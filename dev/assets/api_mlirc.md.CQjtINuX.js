import{_ as r,C as o,c as p,o as d,j as t,a as i,al as n,G as a,w as l}from"./chunks/framework.CIfFXi7v.js";const SR=JSON.parse('{"title":"Higher level API","description":"","frontmatter":{},"headers":[],"relativePath":"api/mlirc.md","filePath":"api/mlirc.md","lastUpdated":null}'),u={name:"api/mlirc.md"},b={class:"jldocstring custom-block"},c={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},A={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},_={class:"jldocstring custom-block"},M={class:"jldocstring custom-block"},E={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},C={class:"jldocstring custom-block"},v={class:"jldocstring custom-block"},P={class:"jldocstring custom-block"},x={class:"jldocstring custom-block"},S={class:"jldocstring custom-block"},D={class:"jldocstring custom-block"},F={class:"jldocstring custom-block"},V={class:"jldocstring custom-block"},O={class:"jldocstring custom-block"},B={class:"jldocstring custom-block"},N={class:"jldocstring custom-block"},G={class:"jldocstring custom-block"},z={class:"jldocstring custom-block"},w={class:"jldocstring custom-block"},U={class:"jldocstring custom-block"},q={class:"jldocstring custom-block"},Q={class:"jldocstring custom-block"},W={class:"jldocstring custom-block"},Z={class:"jldocstring custom-block"},H={class:"jldocstring custom-block"},J={class:"jldocstring custom-block"},K={class:"jldocstring custom-block"},$={class:"jldocstring custom-block"},X={class:"jldocstring custom-block"},Y={class:"jldocstring custom-block"},ee={class:"jldocstring custom-block"},te={class:"jldocstring custom-block"},se={class:"jldocstring custom-block"},ae={class:"jldocstring custom-block"},ie={class:"jldocstring custom-block"},le={class:"jldocstring custom-block"},ne={class:"jldocstring custom-block"},re={class:"jldocstring custom-block"},oe={class:"jldocstring custom-block"},pe={class:"jldocstring custom-block"},de={class:"jldocstring custom-block"},ue={class:"jldocstring custom-block"},be={class:"jldocstring custom-block"},ce={class:"jldocstring custom-block"},he={class:"jldocstring custom-block"},ye={class:"jldocstring custom-block"},ge={class:"jldocstring custom-block"},me={class:"jldocstring custom-block"},ke={class:"jldocstring custom-block"},Re={class:"jldocstring custom-block"},fe={class:"jldocstring custom-block"},Ie={class:"jldocstring custom-block"},Te={class:"jldocstring custom-block"},Ae={class:"jldocstring custom-block"},je={class:"jldocstring custom-block"},_e={class:"jldocstring custom-block"},Me={class:"jldocstring custom-block"},Ee={class:"jldocstring custom-block"},Le={class:"jldocstring custom-block"},Ce={class:"jldocstring custom-block"},ve={class:"jldocstring custom-block"},Pe={class:"jldocstring custom-block"},xe={class:"jldocstring custom-block"},Se={class:"jldocstring custom-block"},De={class:"jldocstring custom-block"},Fe={class:"jldocstring custom-block"},Ve={class:"jldocstring custom-block"},Oe={class:"jldocstring custom-block"},Be={class:"jldocstring custom-block"},Ne={class:"jldocstring custom-block"},Ge={class:"jldocstring custom-block"},ze={class:"jldocstring custom-block"},we={class:"jldocstring custom-block"},Ue={class:"jldocstring custom-block"},qe={class:"jldocstring custom-block"},Qe={class:"jldocstring custom-block"},We={class:"jldocstring custom-block"},Ze={class:"jldocstring custom-block"},He={class:"jldocstring custom-block"},Je={class:"jldocstring custom-block"},Ke={class:"jldocstring custom-block"},$e={class:"jldocstring custom-block"},Xe={class:"jldocstring custom-block"},Ye={class:"jldocstring custom-block"},et={class:"jldocstring custom-block"},tt={class:"jldocstring custom-block"},st={class:"jldocstring custom-block"},at={class:"jldocstring custom-block"},it={class:"jldocstring custom-block"},lt={class:"jldocstring custom-block"},nt={class:"jldocstring custom-block"},rt={class:"jldocstring custom-block"},ot={class:"jldocstring custom-block"},pt={class:"jldocstring custom-block"},dt={class:"jldocstring custom-block"},ut={class:"jldocstring custom-block"},bt={class:"jldocstring custom-block"},ct={class:"jldocstring custom-block"},ht={class:"jldocstring custom-block"},yt={class:"jldocstring custom-block"},gt={class:"jldocstring custom-block"},mt={class:"jldocstring custom-block"},kt={class:"jldocstring custom-block"},Rt={class:"jldocstring custom-block"},ft={class:"jldocstring custom-block"},It={class:"jldocstring custom-block"},Tt={class:"jldocstring custom-block"},At={class:"jldocstring custom-block"},jt={class:"jldocstring custom-block"},_t={class:"jldocstring custom-block"},Mt={class:"jldocstring custom-block"},Et={class:"jldocstring custom-block"},Lt={class:"jldocstring custom-block"},Ct={class:"jldocstring custom-block"},vt={class:"jldocstring custom-block"},Pt={class:"jldocstring custom-block"},xt={class:"jldocstring custom-block"},St={class:"jldocstring custom-block"},Dt={class:"jldocstring custom-block"},Ft={class:"jldocstring custom-block"},Vt={class:"jldocstring custom-block"},Ot={class:"jldocstring custom-block"},Bt={class:"jldocstring custom-block"},Nt={class:"jldocstring custom-block"},Gt={class:"jldocstring custom-block"},zt={class:"jldocstring custom-block"},wt={class:"jldocstring custom-block"},Ut={class:"jldocstring custom-block"},qt={class:"jldocstring custom-block"},Qt={class:"jldocstring custom-block"},Wt={class:"jldocstring custom-block"},Zt={class:"jldocstring custom-block"},Ht={class:"jldocstring custom-block"},Jt={class:"jldocstring custom-block"},Kt={class:"jldocstring custom-block"},$t={class:"jldocstring custom-block"},Xt={class:"jldocstring custom-block"},Yt={class:"jldocstring custom-block"},es={class:"jldocstring custom-block"},ts={class:"jldocstring custom-block"},ss={class:"jldocstring custom-block"},as={class:"jldocstring custom-block"},is={class:"jldocstring custom-block"},ls={class:"jldocstring custom-block"},ns={class:"jldocstring custom-block"},rs={class:"jldocstring custom-block"},os={class:"jldocstring custom-block"},ps={class:"jldocstring custom-block"},ds={class:"jldocstring custom-block"},us={class:"jldocstring custom-block"},bs={class:"jldocstring custom-block"},cs={class:"jldocstring custom-block"},hs={class:"jldocstring custom-block"},ys={class:"jldocstring custom-block"},gs={class:"jldocstring custom-block"},ms={class:"jldocstring custom-block"},ks={class:"jldocstring custom-block"},Rs={class:"jldocstring custom-block"},fs={class:"jldocstring custom-block"},Is={class:"jldocstring custom-block"},Ts={class:"jldocstring custom-block"},As={class:"jldocstring custom-block"},js={class:"jldocstring custom-block"},_s={class:"jldocstring custom-block"},Ms={class:"jldocstring custom-block"},Es={class:"jldocstring custom-block"},Ls={class:"jldocstring custom-block"},Cs={class:"jldocstring custom-block"},vs={class:"jldocstring custom-block"},Ps={class:"jldocstring custom-block"},xs={class:"jldocstring custom-block"},Ss={class:"jldocstring custom-block"},Ds={class:"jldocstring custom-block"},Fs={class:"jldocstring custom-block"},Vs={class:"jldocstring custom-block"},Os={class:"jldocstring custom-block"},Bs={class:"jldocstring custom-block"},Ns={class:"jldocstring custom-block"},Gs={class:"jldocstring custom-block"},zs={class:"jldocstring custom-block"},ws={class:"jldocstring custom-block"},Us={class:"jldocstring custom-block"},qs={class:"jldocstring custom-block"},Qs={class:"jldocstring custom-block"},Ws={class:"jldocstring custom-block"},Zs={class:"jldocstring custom-block"},Hs={class:"jldocstring custom-block"},Js={class:"jldocstring custom-block"},Ks={class:"jldocstring custom-block"},$s={class:"jldocstring custom-block"},Xs={class:"jldocstring custom-block"},Ys={class:"jldocstring custom-block"},ea={class:"jldocstring custom-block"},ta={class:"jldocstring custom-block"},sa={class:"jldocstring custom-block"},aa={class:"jldocstring custom-block"},ia={class:"jldocstring custom-block"},la={class:"jldocstring custom-block"},na={class:"jldocstring custom-block"},ra={class:"jldocstring custom-block"},oa={class:"jldocstring custom-block"},pa={class:"jldocstring custom-block"},da={class:"jldocstring custom-block"},ua={class:"jldocstring custom-block"},ba={class:"jldocstring custom-block"},ca={class:"jldocstring custom-block"},ha={class:"jldocstring custom-block"},ya={class:"jldocstring custom-block"},ga={class:"jldocstring custom-block"},ma={class:"jldocstring custom-block"},ka={class:"jldocstring custom-block"},Ra={class:"jldocstring custom-block"},fa={class:"jldocstring custom-block"},Ia={class:"jldocstring custom-block"},Ta={class:"jldocstring custom-block"},Aa={class:"jldocstring custom-block"},ja={class:"jldocstring custom-block"},_a={class:"jldocstring custom-block"},Ma={class:"jldocstring custom-block"},Ea={class:"jldocstring custom-block"},La={class:"jldocstring custom-block"},Ca={class:"jldocstring custom-block"},va={class:"jldocstring custom-block"},Pa={class:"jldocstring custom-block"},xa={class:"jldocstring custom-block"},Sa={class:"jldocstring custom-block"},Da={class:"jldocstring custom-block"},Fa={class:"jldocstring custom-block"},Va={class:"jldocstring custom-block"},Oa={class:"jldocstring custom-block"},Ba={class:"jldocstring custom-block"},Na={class:"jldocstring custom-block"},Ga={class:"jldocstring custom-block"},za={class:"jldocstring custom-block"},wa={class:"jldocstring custom-block"},Ua={class:"jldocstring custom-block"},qa={class:"jldocstring custom-block"},Qa={class:"jldocstring custom-block"},Wa={class:"jldocstring custom-block"},Za={class:"jldocstring custom-block"},Ha={class:"jldocstring custom-block"},Ja={class:"jldocstring custom-block"},Ka={class:"jldocstring custom-block"},$a={class:"jldocstring custom-block"},Xa={class:"jldocstring custom-block"},Ya={class:"jldocstring custom-block"},ei={class:"jldocstring custom-block"},ti={class:"jldocstring custom-block"},si={class:"jldocstring custom-block"},ai={class:"jldocstring custom-block"},ii={class:"jldocstring custom-block"},li={class:"jldocstring custom-block"},ni={class:"jldocstring custom-block"},ri={class:"jldocstring custom-block"},oi={class:"jldocstring custom-block"},pi={class:"jldocstring custom-block"},di={class:"jldocstring custom-block"},ui={class:"jldocstring custom-block"},bi={class:"jldocstring custom-block"},ci={class:"jldocstring custom-block"},hi={class:"jldocstring custom-block"},yi={class:"jldocstring custom-block"},gi={class:"jldocstring custom-block"},mi={class:"jldocstring custom-block"},ki={class:"jldocstring custom-block"},Ri={class:"jldocstring custom-block"},fi={class:"jldocstring custom-block"},Ii={class:"jldocstring custom-block"},Ti={class:"jldocstring custom-block"},Ai={class:"jldocstring custom-block"},ji={class:"jldocstring custom-block"},_i={class:"jldocstring custom-block"},Mi={class:"jldocstring custom-block"},Ei={class:"jldocstring custom-block"},Li={class:"jldocstring custom-block"},Ci={class:"jldocstring custom-block"},vi={class:"jldocstring custom-block"},Pi={class:"jldocstring custom-block"},xi={class:"jldocstring custom-block"},Si={class:"jldocstring custom-block"},Di={class:"jldocstring custom-block"},Fi={class:"jldocstring custom-block"},Vi={class:"jldocstring custom-block"},Oi={class:"jldocstring custom-block"},Bi={class:"jldocstring custom-block"},Ni={class:"jldocstring custom-block"},Gi={class:"jldocstring custom-block"},zi={class:"jldocstring custom-block"},wi={class:"jldocstring custom-block"},Ui={class:"jldocstring custom-block"},qi={class:"jldocstring custom-block"},Qi={class:"jldocstring custom-block"},Wi={class:"jldocstring custom-block"},Zi={class:"jldocstring custom-block"},Hi={class:"jldocstring custom-block"},Ji={class:"jldocstring custom-block"},Ki={class:"jldocstring custom-block"},$i={class:"jldocstring custom-block"},Xi={class:"jldocstring custom-block"},Yi={class:"jldocstring custom-block"},el={class:"jldocstring custom-block"},tl={class:"jldocstring custom-block"},sl={class:"jldocstring custom-block"},al={class:"jldocstring custom-block"},il={class:"jldocstring custom-block"},ll={class:"jldocstring custom-block"},nl={class:"jldocstring custom-block"},rl={class:"jldocstring custom-block"},ol={class:"jldocstring custom-block"},pl={class:"jldocstring custom-block"},dl={class:"jldocstring custom-block"},ul={class:"jldocstring custom-block"},bl={class:"jldocstring custom-block"},cl={class:"jldocstring custom-block"},hl={class:"jldocstring custom-block"},yl={class:"jldocstring custom-block"},gl={class:"jldocstring custom-block"},ml={class:"jldocstring custom-block"},kl={class:"jldocstring custom-block"},Rl={class:"jldocstring custom-block"},fl={class:"jldocstring custom-block"},Il={class:"jldocstring custom-block"},Tl={class:"jldocstring custom-block"},Al={class:"jldocstring custom-block"},jl={class:"jldocstring custom-block"},_l={class:"jldocstring custom-block"},Ml={class:"jldocstring custom-block"},El={class:"jldocstring custom-block"},Ll={class:"jldocstring custom-block"},Cl={class:"jldocstring custom-block"},vl={class:"jldocstring custom-block"},Pl={class:"jldocstring custom-block"},xl={class:"jldocstring custom-block"},Sl={class:"jldocstring custom-block"},Dl={class:"jldocstring custom-block"},Fl={class:"jldocstring custom-block"},Vl={class:"jldocstring custom-block"},Ol={class:"jldocstring custom-block"},Bl={class:"jldocstring custom-block"},Nl={class:"jldocstring custom-block"},Gl={class:"jldocstring custom-block"},zl={class:"jldocstring custom-block"},wl={class:"jldocstring custom-block"},Ul={class:"jldocstring custom-block"},ql={class:"jldocstring custom-block"},Ql={class:"jldocstring custom-block"},Wl={class:"jldocstring custom-block"},Zl={class:"jldocstring custom-block"},Hl={class:"jldocstring custom-block"},Jl={class:"jldocstring custom-block"},Kl={class:"jldocstring custom-block"},$l={class:"jldocstring custom-block"},Xl={class:"jldocstring custom-block"},Yl={class:"jldocstring custom-block"},en={class:"jldocstring custom-block"},tn={class:"jldocstring custom-block"},sn={class:"jldocstring custom-block"},an={class:"jldocstring custom-block"},ln={class:"jldocstring custom-block"},nn={class:"jldocstring custom-block"},rn={class:"jldocstring custom-block"},on={class:"jldocstring custom-block"},pn={class:"jldocstring custom-block"},dn={class:"jldocstring custom-block"},un={class:"jldocstring custom-block"},bn={class:"jldocstring custom-block"},cn={class:"jldocstring custom-block"},hn={class:"jldocstring custom-block"},yn={class:"jldocstring custom-block"},gn={class:"jldocstring custom-block"},mn={class:"jldocstring custom-block"},kn={class:"jldocstring custom-block"},Rn={class:"jldocstring custom-block"},fn={class:"jldocstring custom-block"},In={class:"jldocstring custom-block"},Tn={class:"jldocstring custom-block"},An={class:"jldocstring custom-block"},jn={class:"jldocstring custom-block"},_n={class:"jldocstring custom-block"},Mn={class:"jldocstring custom-block"},En={class:"jldocstring custom-block"},Ln={class:"jldocstring custom-block"},Cn={class:"jldocstring custom-block"},vn={class:"jldocstring custom-block"},Pn={class:"jldocstring custom-block"},xn={class:"jldocstring custom-block"},Sn={class:"jldocstring custom-block"},Dn={class:"jldocstring custom-block"},Fn={class:"jldocstring custom-block"},Vn={class:"jldocstring custom-block"},On={class:"jldocstring custom-block"},Bn={class:"jldocstring custom-block"},Nn={class:"jldocstring custom-block"},Gn={class:"jldocstring custom-block"},zn={class:"jldocstring custom-block"},wn={class:"jldocstring custom-block"},Un={class:"jldocstring custom-block"},qn={class:"jldocstring custom-block"},Qn={class:"jldocstring custom-block"},Wn={class:"jldocstring custom-block"},Zn={class:"jldocstring custom-block"},Hn={class:"jldocstring custom-block"},Jn={class:"jldocstring custom-block"},Kn={class:"jldocstring custom-block"},$n={class:"jldocstring custom-block"},Xn={class:"jldocstring custom-block"},Yn={class:"jldocstring custom-block"},er={class:"jldocstring custom-block"},tr={class:"jldocstring custom-block"},sr={class:"jldocstring custom-block"},ar={class:"jldocstring custom-block"},ir={class:"jldocstring custom-block"},lr={class:"jldocstring custom-block"},nr={class:"jldocstring custom-block"},rr={class:"jldocstring custom-block"},or={class:"jldocstring custom-block"},pr={class:"jldocstring custom-block"},dr={class:"jldocstring custom-block"},ur={class:"jldocstring custom-block"},br={class:"jldocstring custom-block"},cr={class:"jldocstring custom-block"},hr={class:"jldocstring custom-block"},yr={class:"jldocstring custom-block"},gr={class:"jldocstring custom-block"},mr={class:"jldocstring custom-block"},kr={class:"jldocstring custom-block"},Rr={class:"jldocstring custom-block"},fr={class:"jldocstring custom-block"},Ir={class:"jldocstring custom-block"},Tr={class:"jldocstring custom-block"},Ar={class:"jldocstring custom-block"},jr={class:"jldocstring custom-block"},_r={class:"jldocstring custom-block"},Mr={class:"jldocstring custom-block"},Er={class:"jldocstring custom-block"},Lr={class:"jldocstring custom-block"},Cr={class:"jldocstring custom-block"},vr={class:"jldocstring custom-block"},Pr={class:"jldocstring custom-block"},xr={class:"jldocstring custom-block"},Sr={class:"jldocstring custom-block"},Dr={class:"jldocstring custom-block"},Fr={class:"jldocstring custom-block"},Vr={class:"jldocstring custom-block"},Or={class:"jldocstring custom-block"},Br={class:"jldocstring custom-block"},Nr={class:"jldocstring custom-block"},Gr={class:"jldocstring custom-block"},zr={class:"jldocstring custom-block"},wr={class:"jldocstring custom-block"},Ur={class:"jldocstring custom-block"},qr={class:"jldocstring custom-block"},Qr={class:"jldocstring custom-block"},Wr={class:"jldocstring custom-block"},Zr={class:"jldocstring custom-block"},Hr={class:"jldocstring custom-block"},Jr={class:"jldocstring custom-block"},Kr={class:"jldocstring custom-block"},$r={class:"jldocstring custom-block"},Xr={class:"jldocstring custom-block"},Yr={class:"jldocstring custom-block"},eo={class:"jldocstring custom-block"},to={class:"jldocstring custom-block"},so={class:"jldocstring custom-block"},ao={class:"jldocstring custom-block"},io={class:"jldocstring custom-block"},lo={class:"jldocstring custom-block"},no={class:"jldocstring custom-block"},ro={class:"jldocstring custom-block"},oo={class:"jldocstring custom-block"},po={class:"jldocstring custom-block"},uo={class:"jldocstring custom-block"},bo={class:"jldocstring custom-block"},co={class:"jldocstring custom-block"},ho={class:"jldocstring custom-block"},yo={class:"jldocstring custom-block"},go={class:"jldocstring custom-block"},mo={class:"jldocstring custom-block"},ko={class:"jldocstring custom-block"},Ro={class:"jldocstring custom-block"},fo={class:"jldocstring custom-block"},Io={class:"jldocstring custom-block"},To={class:"jldocstring custom-block"},Ao={class:"jldocstring custom-block"},jo={class:"jldocstring custom-block"},_o={class:"jldocstring custom-block"},Mo={class:"jldocstring custom-block"},Eo={class:"jldocstring custom-block"},Lo={class:"jldocstring custom-block"},Co={class:"jldocstring custom-block"},vo={class:"jldocstring custom-block"},Po={class:"jldocstring custom-block"},xo={class:"jldocstring custom-block"},So={class:"jldocstring custom-block"},Do={class:"jldocstring custom-block"},Fo={class:"jldocstring custom-block"},Vo={class:"jldocstring custom-block"},Oo={class:"jldocstring custom-block"},Bo={class:"jldocstring custom-block"},No={class:"jldocstring custom-block"},Go={class:"jldocstring custom-block"},zo={class:"jldocstring custom-block"},wo={class:"jldocstring custom-block"},Uo={class:"jldocstring custom-block"},qo={class:"jldocstring custom-block"},Qo={class:"jldocstring custom-block"},Wo={class:"jldocstring custom-block"},Zo={class:"jldocstring custom-block"},Ho={class:"jldocstring custom-block"},Jo={class:"jldocstring custom-block"},Ko={class:"jldocstring custom-block"},$o={class:"jldocstring custom-block"},Xo={class:"jldocstring custom-block"},Yo={class:"jldocstring custom-block"},ep={class:"jldocstring custom-block"},tp={class:"jldocstring custom-block"},sp={class:"jldocstring custom-block"},ap={class:"jldocstring custom-block"},ip={class:"jldocstring custom-block"},lp={class:"jldocstring custom-block"},np={class:"jldocstring custom-block"},rp={class:"jldocstring custom-block"},op={class:"jldocstring custom-block"},pp={class:"jldocstring custom-block"},dp={class:"jldocstring custom-block"},up={class:"jldocstring custom-block"},bp={class:"jldocstring custom-block"},cp={class:"jldocstring custom-block"},hp={class:"jldocstring custom-block"},yp={class:"jldocstring custom-block"},gp={class:"jldocstring custom-block"},mp={class:"jldocstring custom-block"},kp={class:"jldocstring custom-block"},Rp={class:"jldocstring custom-block"},fp={class:"jldocstring custom-block"},Ip={class:"jldocstring custom-block"},Tp={class:"jldocstring custom-block"},Ap={class:"jldocstring custom-block"},jp={class:"jldocstring custom-block"},_p={class:"jldocstring custom-block"},Mp={class:"jldocstring custom-block"},Ep={class:"jldocstring custom-block"},Lp={class:"jldocstring custom-block"},Cp={class:"jldocstring custom-block"},vp={class:"jldocstring custom-block"},Pp={class:"jldocstring custom-block"},xp={class:"jldocstring custom-block"},Sp={class:"jldocstring custom-block"},Dp={class:"jldocstring custom-block"},Fp={class:"jldocstring custom-block"},Vp={class:"jldocstring custom-block"},Op={class:"jldocstring custom-block"},Bp={class:"jldocstring custom-block"},Np={class:"jldocstring custom-block"},Gp={class:"jldocstring custom-block"},zp={class:"jldocstring custom-block"},wp={class:"jldocstring custom-block"},Up={class:"jldocstring custom-block"},qp={class:"jldocstring custom-block"},Qp={class:"jldocstring custom-block"},Wp={class:"jldocstring custom-block"},Zp={class:"jldocstring custom-block"},Hp={class:"jldocstring custom-block"},Jp={class:"jldocstring custom-block"},Kp={class:"jldocstring custom-block"},$p={class:"jldocstring custom-block"},Xp={class:"jldocstring custom-block"},Yp={class:"jldocstring custom-block"},ed={class:"jldocstring custom-block"},td={class:"jldocstring custom-block"},sd={class:"jldocstring custom-block"},ad={class:"jldocstring custom-block"},id={class:"jldocstring custom-block"},ld={class:"jldocstring custom-block"},nd={class:"jldocstring custom-block"},rd={class:"jldocstring custom-block"},od={class:"jldocstring custom-block"},pd={class:"jldocstring custom-block"},dd={class:"jldocstring custom-block"},ud={class:"jldocstring custom-block"},bd={class:"jldocstring custom-block"},cd={class:"jldocstring custom-block"},hd={class:"jldocstring custom-block"},yd={class:"jldocstring custom-block"},gd={class:"jldocstring custom-block"},md={class:"jldocstring custom-block"},kd={class:"jldocstring custom-block"},Rd={class:"jldocstring custom-block"},fd={class:"jldocstring custom-block"},Id={class:"jldocstring custom-block"},Td={class:"jldocstring custom-block"},Ad={class:"jldocstring custom-block"},jd={class:"jldocstring custom-block"},_d={class:"jldocstring custom-block"},Md={class:"jldocstring custom-block"},Ed={class:"jldocstring custom-block"},Ld={class:"jldocstring custom-block"},Cd={class:"jldocstring custom-block"},vd={class:"jldocstring custom-block"},Pd={class:"jldocstring custom-block"},xd={class:"jldocstring custom-block"},Sd={class:"jldocstring custom-block"},Dd={class:"jldocstring custom-block"},Fd={class:"jldocstring custom-block"},Vd={class:"jldocstring custom-block"},Od={class:"jldocstring custom-block"},Bd={class:"jldocstring custom-block"},Nd={class:"jldocstring custom-block"},Gd={class:"jldocstring custom-block"},zd={class:"jldocstring custom-block"},wd={class:"jldocstring custom-block"},Ud={class:"jldocstring custom-block"},qd={class:"jldocstring custom-block"},Qd={class:"jldocstring custom-block"},Wd={class:"jldocstring custom-block"},Zd={class:"jldocstring custom-block"},Hd={class:"jldocstring custom-block"},Jd={class:"jldocstring custom-block"},Kd={class:"jldocstring custom-block"},$d={class:"jldocstring custom-block"},Xd={class:"jldocstring custom-block"},Yd={class:"jldocstring custom-block"},eu={class:"jldocstring custom-block"},tu={class:"jldocstring custom-block"},su={class:"jldocstring custom-block"},au={class:"jldocstring custom-block"},iu={class:"jldocstring custom-block"},lu={class:"jldocstring custom-block"},nu={class:"jldocstring custom-block"},ru={class:"jldocstring custom-block"},ou={class:"jldocstring custom-block"},pu={class:"jldocstring custom-block"},du={class:"jldocstring custom-block"},uu={class:"jldocstring custom-block"},bu={class:"jldocstring custom-block"},cu={class:"jldocstring custom-block"},hu={class:"jldocstring custom-block"},yu={class:"jldocstring custom-block"},gu={class:"jldocstring custom-block"},mu={class:"jldocstring custom-block"},ku={class:"jldocstring custom-block"},Ru={class:"jldocstring custom-block"},fu={class:"jldocstring custom-block"},Iu={class:"jldocstring custom-block"},Tu={class:"jldocstring custom-block"},Au={class:"jldocstring custom-block"},ju={class:"jldocstring custom-block"},_u={class:"jldocstring custom-block"},Mu={class:"jldocstring custom-block"},Eu={class:"jldocstring custom-block"},Lu={class:"jldocstring custom-block"},Cu={class:"jldocstring custom-block"},vu={class:"jldocstring custom-block"},Pu={class:"jldocstring custom-block"},xu={class:"jldocstring custom-block"},Su={class:"jldocstring custom-block"},Du={class:"jldocstring custom-block"},Fu={class:"jldocstring custom-block"},Vu={class:"jldocstring custom-block"},Ou={class:"jldocstring custom-block"},Bu={class:"jldocstring custom-block"},Nu={class:"jldocstring custom-block"},Gu={class:"jldocstring custom-block"},zu={class:"jldocstring custom-block"},wu={class:"jldocstring custom-block"},Uu={class:"jldocstring custom-block"},qu={class:"jldocstring custom-block"},Qu={class:"jldocstring custom-block"},Wu={class:"jldocstring custom-block"},Zu={class:"jldocstring custom-block"},Hu={class:"jldocstring custom-block"},Ju={class:"jldocstring custom-block"},Ku={class:"jldocstring custom-block"},$u={class:"jldocstring custom-block"},Xu={class:"jldocstring custom-block"},Yu={class:"jldocstring custom-block"},eb={class:"jldocstring custom-block"},tb={class:"jldocstring custom-block"},sb={class:"jldocstring custom-block"},ab={class:"jldocstring custom-block"},ib={class:"jldocstring custom-block"},lb={class:"jldocstring custom-block"},nb={class:"jldocstring custom-block"},rb={class:"jldocstring custom-block"},ob={class:"jldocstring custom-block"},pb={class:"jldocstring custom-block"},db={class:"jldocstring custom-block"},ub={class:"jldocstring custom-block"},bb={class:"jldocstring custom-block"},cb={class:"jldocstring custom-block"},hb={class:"jldocstring custom-block"},yb={class:"jldocstring custom-block"},gb={class:"jldocstring custom-block"},mb={class:"jldocstring custom-block"},kb={class:"jldocstring custom-block"},Rb={class:"jldocstring custom-block"},fb={class:"jldocstring custom-block"},Ib={class:"jldocstring custom-block"},Tb={class:"jldocstring custom-block"},Ab={class:"jldocstring custom-block"},jb={class:"jldocstring custom-block"},_b={class:"jldocstring custom-block"},Mb={class:"jldocstring custom-block"},Eb={class:"jldocstring custom-block"},Lb={class:"jldocstring custom-block"},Cb={class:"jldocstring custom-block"},vb={class:"jldocstring custom-block"},Pb={class:"jldocstring custom-block"},xb={class:"jldocstring custom-block"},Sb={class:"jldocstring custom-block"},Db={class:"jldocstring custom-block"},Fb={class:"jldocstring custom-block"},Vb={class:"jldocstring custom-block"},Ob={class:"jldocstring custom-block"},Bb={class:"jldocstring custom-block"},Nb={class:"jldocstring custom-block"},Gb={class:"jldocstring custom-block"},zb={class:"jldocstring custom-block"},wb={class:"jldocstring custom-block"},Ub={class:"jldocstring custom-block"},qb={class:"jldocstring custom-block"},Qb={class:"jldocstring custom-block"},Wb={class:"jldocstring custom-block"},Zb={class:"jldocstring custom-block"},Hb={class:"jldocstring custom-block"},Jb={class:"jldocstring custom-block"},Kb={class:"jldocstring custom-block"},$b={class:"jldocstring custom-block"},Xb={class:"jldocstring custom-block"},Yb={class:"jldocstring custom-block"},ec={class:"jldocstring custom-block"},tc={class:"jldocstring custom-block"},sc={class:"jldocstring custom-block"},ac={class:"jldocstring custom-block"},ic={class:"jldocstring custom-block"},lc={class:"jldocstring custom-block"},nc={class:"jldocstring custom-block"},rc={class:"jldocstring custom-block"},oc={class:"jldocstring custom-block"},pc={class:"jldocstring custom-block"},dc={class:"jldocstring custom-block"},uc={class:"jldocstring custom-block"},bc={class:"jldocstring custom-block"},cc={class:"jldocstring custom-block"},hc={class:"jldocstring custom-block"},yc={class:"jldocstring custom-block"},gc={class:"jldocstring custom-block"},mc={class:"jldocstring custom-block"},kc={class:"jldocstring custom-block"},Rc={class:"jldocstring custom-block"},fc={class:"jldocstring custom-block"},Ic={class:"jldocstring custom-block"},Tc={class:"jldocstring custom-block"},Ac={class:"jldocstring custom-block"},jc={class:"jldocstring custom-block"},_c={class:"jldocstring custom-block"},Mc={class:"jldocstring custom-block"},Ec={class:"jldocstring custom-block"},Lc={class:"jldocstring custom-block"},Cc={class:"jldocstring custom-block"},vc={class:"jldocstring custom-block"},Pc={class:"jldocstring custom-block"},xc={class:"jldocstring custom-block"},Sc={class:"jldocstring custom-block"},Dc={class:"jldocstring custom-block"},Fc={class:"jldocstring custom-block"},Vc={class:"jldocstring custom-block"},Oc={class:"jldocstring custom-block"},Bc={class:"jldocstring custom-block"},Nc={class:"jldocstring custom-block"},Gc={class:"jldocstring custom-block"},zc={class:"jldocstring custom-block"},wc={class:"jldocstring custom-block"},Uc={class:"jldocstring custom-block"},qc={class:"jldocstring custom-block"},Qc={class:"jldocstring custom-block"},Wc={class:"jldocstring custom-block"},Zc={class:"jldocstring custom-block"},Hc={class:"jldocstring custom-block"},Jc={class:"jldocstring custom-block"},Kc={class:"jldocstring custom-block"},$c={class:"jldocstring custom-block"},Xc={class:"jldocstring custom-block"},Yc={class:"jldocstring custom-block"},eh={class:"jldocstring custom-block"},th={class:"jldocstring custom-block"},sh={class:"jldocstring custom-block"},ah={class:"jldocstring custom-block"},ih={class:"jldocstring custom-block"},lh={class:"jldocstring custom-block"},nh={class:"jldocstring custom-block"},rh={class:"jldocstring custom-block"},oh={class:"jldocstring custom-block"},ph={class:"jldocstring custom-block"},dh={class:"jldocstring custom-block"},uh={class:"jldocstring custom-block"},bh={class:"jldocstring custom-block"},ch={class:"jldocstring custom-block"},hh={class:"jldocstring custom-block"},yh={class:"jldocstring custom-block"},gh={class:"jldocstring custom-block"},mh={class:"jldocstring custom-block"},kh={class:"jldocstring custom-block"},Rh={class:"jldocstring custom-block"},fh={class:"jldocstring custom-block"},Ih={class:"jldocstring custom-block"},Th={class:"jldocstring custom-block"},Ah={class:"jldocstring custom-block"},jh={class:"jldocstring custom-block"},_h={class:"jldocstring custom-block"},Mh={class:"jldocstring custom-block"},Eh={class:"jldocstring custom-block"},Lh={class:"jldocstring custom-block"},Ch={class:"jldocstring custom-block"},vh={class:"jldocstring custom-block"},Ph={class:"jldocstring custom-block"},xh={class:"jldocstring custom-block"},Sh={class:"jldocstring custom-block"},Dh={class:"jldocstring custom-block"},Fh={class:"jldocstring custom-block"},Vh={class:"jldocstring custom-block"},Oh={class:"jldocstring custom-block"},Bh={class:"jldocstring custom-block"},Nh={class:"jldocstring custom-block"},Gh={class:"jldocstring custom-block"},zh={class:"jldocstring custom-block"},wh={class:"jldocstring custom-block"},Uh={class:"jldocstring custom-block"},qh={class:"jldocstring custom-block"},Qh={class:"jldocstring custom-block"},Wh={class:"jldocstring custom-block"},Zh={class:"jldocstring custom-block"},Hh={class:"jldocstring custom-block"},Jh={class:"jldocstring custom-block"},Kh={class:"jldocstring custom-block"},$h={class:"jldocstring custom-block"},Xh={class:"jldocstring custom-block"},Yh={class:"jldocstring custom-block"},ey={class:"jldocstring custom-block"},ty={class:"jldocstring custom-block"},sy={class:"jldocstring custom-block"},ay={class:"jldocstring custom-block"},iy={class:"jldocstring custom-block"},ly={class:"jldocstring custom-block"},ny={class:"jldocstring custom-block"},ry={class:"jldocstring custom-block"},oy={class:"jldocstring custom-block"},py={class:"jldocstring custom-block"},dy={class:"jldocstring custom-block"},uy={class:"jldocstring custom-block"},by={class:"jldocstring custom-block"},cy={class:"jldocstring custom-block"},hy={class:"jldocstring custom-block"},yy={class:"jldocstring custom-block"},gy={class:"jldocstring custom-block"},my={class:"jldocstring custom-block"},ky={class:"jldocstring custom-block"},Ry={class:"jldocstring custom-block"},fy={class:"jldocstring custom-block"},Iy={class:"jldocstring custom-block"},Ty={class:"jldocstring custom-block"},Ay={class:"jldocstring custom-block"},jy={class:"jldocstring custom-block"},_y={class:"jldocstring custom-block"},My={class:"jldocstring custom-block"},Ey={class:"jldocstring custom-block"},Ly={class:"jldocstring custom-block"},Cy={class:"jldocstring custom-block"},vy={class:"jldocstring custom-block"},Py={class:"jldocstring custom-block"},xy={class:"jldocstring custom-block"},Sy={class:"jldocstring custom-block"},Dy={class:"jldocstring custom-block"},Fy={class:"jldocstring custom-block"},Vy={class:"jldocstring custom-block"},Oy={class:"jldocstring custom-block"},By={class:"jldocstring custom-block"},Ny={class:"jldocstring custom-block"},Gy={class:"jldocstring custom-block"},zy={class:"jldocstring custom-block"},wy={class:"jldocstring custom-block"},Uy={class:"jldocstring custom-block"},qy={class:"jldocstring custom-block"},Qy={class:"jldocstring custom-block"},Wy={class:"jldocstring custom-block"},Zy={class:"jldocstring custom-block"},Hy={class:"jldocstring custom-block"},Jy={class:"jldocstring custom-block"},Ky={class:"jldocstring custom-block"},$y={class:"jldocstring custom-block"},Xy={class:"jldocstring custom-block"},Yy={class:"jldocstring custom-block"},eg={class:"jldocstring custom-block"},tg={class:"jldocstring custom-block"},sg={class:"jldocstring custom-block"},ag={class:"jldocstring custom-block"},ig={class:"jldocstring custom-block"},lg={class:"jldocstring custom-block"},ng={class:"jldocstring custom-block"},rg={class:"jldocstring custom-block"},og={class:"jldocstring custom-block"},pg={class:"jldocstring custom-block"},dg={class:"jldocstring custom-block"},ug={class:"jldocstring custom-block"},bg={class:"jldocstring custom-block"},cg={class:"jldocstring custom-block"},hg={class:"jldocstring custom-block"},yg={class:"jldocstring custom-block"},gg={class:"jldocstring custom-block"},mg={class:"jldocstring custom-block"},kg={class:"jldocstring custom-block"},Rg={class:"jldocstring custom-block"},fg={class:"jldocstring custom-block"},Ig={class:"jldocstring custom-block"},Tg={class:"jldocstring custom-block"},Ag={class:"jldocstring custom-block"},jg={class:"jldocstring custom-block"},_g={class:"jldocstring custom-block"},Mg={class:"jldocstring custom-block"},Eg={class:"jldocstring custom-block"},Lg={class:"jldocstring custom-block"},Cg={class:"jldocstring custom-block"},vg={class:"jldocstring custom-block"},Pg={class:"jldocstring custom-block"},xg={class:"jldocstring custom-block"},Sg={class:"jldocstring custom-block"},Dg={class:"jldocstring custom-block"},Fg={class:"jldocstring custom-block"},Vg={class:"jldocstring custom-block"},Og={class:"jldocstring custom-block"},Bg={class:"jldocstring custom-block"},Ng={class:"jldocstring custom-block"},Gg={class:"jldocstring custom-block"},zg={class:"jldocstring custom-block"},wg={class:"jldocstring custom-block"},Ug={class:"jldocstring custom-block"},qg={class:"jldocstring custom-block"},Qg={class:"jldocstring custom-block"},Wg={class:"jldocstring custom-block"},Zg={class:"jldocstring custom-block"},Hg={class:"jldocstring custom-block"},Jg={class:"jldocstring custom-block"},Kg={class:"jldocstring custom-block"},$g={class:"jldocstring custom-block"},Xg={class:"jldocstring custom-block"},Yg={class:"jldocstring custom-block"},em={class:"jldocstring custom-block"},tm={class:"jldocstring custom-block"},sm={class:"jldocstring custom-block"},am={class:"jldocstring custom-block"},im={class:"jldocstring custom-block"},lm={class:"jldocstring custom-block"},nm={class:"jldocstring custom-block"},rm={class:"jldocstring custom-block"},om={class:"jldocstring custom-block"},pm={class:"jldocstring custom-block"},dm={class:"jldocstring custom-block"},um={class:"jldocstring custom-block"},bm={class:"jldocstring custom-block"},cm={class:"jldocstring custom-block"},hm={class:"jldocstring custom-block"},ym={class:"jldocstring custom-block"},gm={class:"jldocstring custom-block"},mm={class:"jldocstring custom-block"},km={class:"jldocstring custom-block"},Rm={class:"jldocstring custom-block"},fm={class:"jldocstring custom-block"},Im={class:"jldocstring custom-block"},Tm={class:"jldocstring custom-block"},Am={class:"jldocstring custom-block"},jm={class:"jldocstring custom-block"},_m={class:"jldocstring custom-block"},Mm={class:"jldocstring custom-block"},Em={class:"jldocstring custom-block"},Lm={class:"jldocstring custom-block"},Cm={class:"jldocstring custom-block"},vm={class:"jldocstring custom-block"},Pm={class:"jldocstring custom-block"},xm={class:"jldocstring custom-block"},Sm={class:"jldocstring custom-block"},Dm={class:"jldocstring custom-block"},Fm={class:"jldocstring custom-block"},Vm={class:"jldocstring custom-block"},Om={class:"jldocstring custom-block"},Bm={class:"jldocstring custom-block"},Nm={class:"jldocstring custom-block"},Gm={class:"jldocstring custom-block"},zm={class:"jldocstring custom-block"},wm={class:"jldocstring custom-block"},Um={class:"jldocstring custom-block"},qm={class:"jldocstring custom-block"},Qm={class:"jldocstring custom-block"},Wm={class:"jldocstring custom-block"},Zm={class:"jldocstring custom-block"},Hm={class:"jldocstring custom-block"},Jm={class:"jldocstring custom-block"},Km={class:"jldocstring custom-block"},$m={class:"jldocstring custom-block"},Xm={class:"jldocstring custom-block"},Ym={class:"jldocstring custom-block"},ek={class:"jldocstring custom-block"},tk={class:"jldocstring custom-block"},sk={class:"jldocstring custom-block"},ak={class:"jldocstring custom-block"},ik={class:"jldocstring custom-block"},lk={class:"jldocstring custom-block"},nk={class:"jldocstring custom-block"},rk={class:"jldocstring custom-block"},ok={class:"jldocstring custom-block"},pk={class:"jldocstring custom-block"},dk={class:"jldocstring custom-block"},uk={class:"jldocstring custom-block"},bk={class:"jldocstring custom-block"},ck={class:"jldocstring custom-block"},hk={class:"jldocstring custom-block"},yk={class:"jldocstring custom-block"},gk={class:"jldocstring custom-block"},mk={class:"jldocstring custom-block"},kk={class:"jldocstring custom-block"},Rk={class:"jldocstring custom-block"},fk={class:"jldocstring custom-block"},Ik={class:"jldocstring custom-block"},Tk={class:"jldocstring custom-block"},Ak={class:"jldocstring custom-block"},jk={class:"jldocstring custom-block"},_k={class:"jldocstring custom-block"},Mk={class:"jldocstring custom-block"},Ek={class:"jldocstring custom-block"},Lk={class:"jldocstring custom-block"},Ck={class:"jldocstring custom-block"},vk={class:"jldocstring custom-block"},Pk={class:"jldocstring custom-block"},xk={class:"jldocstring custom-block"},Sk={class:"jldocstring custom-block"},Dk={class:"jldocstring custom-block"},Fk={class:"jldocstring custom-block"},Vk={class:"jldocstring custom-block"},Ok={class:"jldocstring custom-block"},Bk={class:"jldocstring custom-block"},Nk={class:"jldocstring custom-block"},Gk={class:"jldocstring custom-block"},zk={class:"jldocstring custom-block"},wk={class:"jldocstring custom-block"},Uk={class:"jldocstring custom-block"},qk={class:"jldocstring custom-block"},Qk={class:"jldocstring custom-block"},Wk={class:"jldocstring custom-block"},Zk={class:"jldocstring custom-block"},Hk={class:"jldocstring custom-block"},Jk={class:"jldocstring custom-block"},Kk={class:"jldocstring custom-block"},$k={class:"jldocstring custom-block"},Xk={class:"jldocstring custom-block"},Yk={class:"jldocstring custom-block"},e2={class:"jldocstring custom-block"},t2={class:"jldocstring custom-block"},s2={class:"jldocstring custom-block"},a2={class:"jldocstring custom-block"},i2={class:"jldocstring custom-block"},l2={class:"jldocstring custom-block"},n2={class:"jldocstring custom-block"},r2={class:"jldocstring custom-block"},o2={class:"jldocstring custom-block"},p2={class:"jldocstring custom-block"},d2={class:"jldocstring custom-block"},u2={class:"jldocstring custom-block"},b2={class:"jldocstring custom-block"},c2={class:"jldocstring custom-block"},h2={class:"jldocstring custom-block"},y2={class:"jldocstring custom-block"},g2={class:"jldocstring custom-block"},m2={class:"jldocstring custom-block"},k2={class:"jldocstring custom-block"},R2={class:"jldocstring custom-block"},f2={class:"jldocstring custom-block"},I2={class:"jldocstring custom-block"},T2={class:"jldocstring custom-block"},A2={class:"jldocstring custom-block"},j2={class:"jldocstring custom-block"},_2={class:"jldocstring custom-block"},M2={class:"jldocstring custom-block"},E2={class:"jldocstring custom-block"},L2={class:"jldocstring custom-block"},C2={class:"jldocstring custom-block"},v2={class:"jldocstring custom-block"},P2={class:"jldocstring custom-block"},x2={class:"jldocstring custom-block"},S2={class:"jldocstring custom-block"},D2={class:"jldocstring custom-block"},F2={class:"jldocstring custom-block"},V2={class:"jldocstring custom-block"},O2={class:"jldocstring custom-block"},B2={class:"jldocstring custom-block"},N2={class:"jldocstring custom-block"},G2={class:"jldocstring custom-block"},z2={class:"jldocstring custom-block"},w2={class:"jldocstring custom-block"},U2={class:"jldocstring custom-block"},q2={class:"jldocstring custom-block"},Q2={class:"jldocstring custom-block"},W2={class:"jldocstring custom-block"},Z2={class:"jldocstring custom-block"},H2={class:"jldocstring custom-block"},J2={class:"jldocstring custom-block"},K2={class:"jldocstring custom-block"},$2={class:"jldocstring custom-block"},X2={class:"jldocstring custom-block"},Y2={class:"jldocstring custom-block"},eR={class:"jldocstring custom-block"},tR={class:"jldocstring custom-block"},sR={class:"jldocstring custom-block"},aR={class:"jldocstring custom-block"},iR={class:"jldocstring custom-block"},lR={class:"jldocstring custom-block"},nR={class:"jldocstring custom-block"},rR={class:"jldocstring custom-block"},oR={class:"jldocstring custom-block"},pR={class:"jldocstring custom-block"},dR={class:"jldocstring custom-block"},uR={class:"jldocstring custom-block"},bR={class:"jldocstring custom-block"},cR={class:"jldocstring custom-block"},hR={class:"jldocstring custom-block"},yR={class:"jldocstring custom-block"},gR={class:"jldocstring custom-block"},mR={class:"jldocstring custom-block"},kR={class:"jldocstring custom-block"},RR={class:"jldocstring custom-block"},fR={class:"jldocstring custom-block"},IR={class:"jldocstring custom-block"},TR={class:"jldocstring custom-block"},AR={class:"jldocstring custom-block"},jR={class:"jldocstring custom-block"},_R={class:"jldocstring custom-block"};function MR(ER,e,LR,CR,vR,PR){const s=o("Badge");return d(),p("div",null,[e[4613]||(e[4613]=t("h1",{id:"Higher-level-API",tabindex:"-1"},[i("Higher level API "),t("a",{class:"header-anchor",href:"#Higher-level-API","aria-label":'Permalink to "Higher level API {#Higher-level-API}"'},"​")],-1)),t("details",b,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Core.Bool-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Core.Bool-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Core.Bool")],-1)),e[1]||(e[1]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given bool attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L210-L214",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",c,[t("summary",null,[e[4]||(e[4]=t("a",{id:"Core.Float64-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Core.Float64-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Core.Float64")],-1)),e[5]||(e[5]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[7]||(e[7]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given floating point attribute, interpreting the value as double.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[6]||(e[6]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L126-L130",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",h,[t("summary",null,[e[8]||(e[8]=t("a",{id:"Core.Int64-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Core.Int64-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Core.Int64")],-1)),e[9]||(e[9]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[11]||(e[11]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given integer attribute, assuming the value is of signed type and fits into a signed 64-bit integer.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[10]||(e[10]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L174-L178",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y,[t("summary",null,[e[12]||(e[12]=t("a",{id:"Core.String-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Core.String-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Core.String")],-1)),e[13]||(e[13]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[15]||(e[15]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the attribute values as a string reference. The data remains live as long as the context in which the attribute lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[14]||(e[14]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L287-L291",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[16]||(e[16]=t("a",{id:"Core.String-Tuple{Reactant.MLIR.IR.Identifier}",href:"#Core.String-Tuple{Reactant.MLIR.IR.Identifier}"},[t("span",{class:"jlbinding"},"Core.String")],-1)),e[17]||(e[17]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[19]||(e[19]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ident)</span></span></code></pre></div><p>Gets the string value of the identifier.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[18]||(e[18]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Identifier.jl#L29-L33",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",m,[t("summary",null,[e[20]||(e[20]=t("a",{id:"Core.UInt64-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Core.UInt64-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Core.UInt64")],-1)),e[21]||(e[21]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[23]||(e[23]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given integer attribute, assuming the value is of unsigned type and fits into an unsigned 64-bit integer.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[22]||(e[22]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L186-L190",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",k,[t("summary",null,[e[24]||(e[24]=t("a",{id:"Reactant.MLIR.IR.AffineMap-Tuple{Any, Any, Vector{Reactant.MLIR.IR.AffineExpr}}",href:"#Reactant.MLIR.IR.AffineMap-Tuple{Any, Any, Vector{Reactant.MLIR.IR.AffineExpr}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.AffineMap")],-1)),e[25]||(e[25]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[27]||(e[27]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ndims, nsymbols, affineExprs; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an affine map with results defined by the given list of affine expressions. The map resulting map also has the requested number of input dimensions and symbols, regardless of them being used in the results.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[26]||(e[26]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L50-L55",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",R,[t("summary",null,[e[28]||(e[28]=t("a",{id:"Reactant.MLIR.IR.AffineMap-Tuple{Any, Any}",href:"#Reactant.MLIR.IR.AffineMap-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.AffineMap")],-1)),e[29]||(e[29]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[31]||(e[31]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ndims, nsymbols; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a zero result affine map of the given dimensions and symbols in the context. The affine map is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[30]||(e[30]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L41-L46",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[32]||(e[32]=t("a",{id:"Reactant.MLIR.IR.AffineMap-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.AffineMap-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.AffineMap")],-1)),e[33]||(e[33]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[35]||(e[35]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the affine map wrapped in the given affine map attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[34]||(e[34]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L64-L68",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I,[t("summary",null,[e[36]||(e[36]=t("a",{id:"Reactant.MLIR.IR.AffineMap-Tuple{}",href:"#Reactant.MLIR.IR.AffineMap-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.AffineMap")],-1)),e[37]||(e[37]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[39]||(e[39]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a zero result affine map with no dimensions or symbols in the context. The affine map is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[38]||(e[38]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L10-L15",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",T,[t("summary",null,[e[40]||(e[40]=t("a",{id:"Reactant.MLIR.IR.Attribute-Tuple{AbstractString}",href:"#Reactant.MLIR.IR.Attribute-Tuple{AbstractString}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Attribute")],-1)),e[41]||(e[41]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[43]||(e[43]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a string attribute in the given context containing the given string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[42]||(e[42]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L270-L274",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",A,[t("summary",null,[e[44]||(e[44]=t("a",{id:"Reactant.MLIR.IR.Attribute-Tuple{Bool}",href:"#Reactant.MLIR.IR.Attribute-Tuple{Bool}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Attribute")],-1)),e[45]||(e[45]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[47]||(e[47]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a bool attribute in the given context with the given value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[46]||(e[46]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L203-L207",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",j,[t("summary",null,[e[48]||(e[48]=t("a",{id:"Reactant.MLIR.IR.Attribute-Tuple{Dict}",href:"#Reactant.MLIR.IR.Attribute-Tuple{Dict}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Attribute")],-1)),e[49]||(e[49]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[51]||(e[51]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a dictionary attribute containing the given list of elements in the provided context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[50]||(e[50]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L93-L97",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_,[t("summary",null,[e[52]||(e[52]=t("a",{id:"Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Attribute")],-1)),e[53]||(e[53]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[55]||(e[55]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Creates an affine map attribute wrapping the given map. The attribute belongs to the same context as the affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[54]||(e[54]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L57-L61",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",M,[t("summary",null,[e[56]||(e[56]=t("a",{id:"Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.Type, AbstractString}",href:"#Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.Type, AbstractString}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Attribute")],-1)),e[57]||(e[57]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[59]||(e[59]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, str)</span></span></code></pre></div><p>Creates a string attribute in the given context containing the given string. Additionally, the attribute has the given type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[58]||(e[58]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L278-L282",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",E,[t("summary",null,[e[60]||(e[60]=t("a",{id:"Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Attribute")],-1)),e[61]||(e[61]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[63]||(e[63]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Creates a type attribute wrapping the given type in the same context as the type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[62]||(e[62]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L376-L380",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",L,[t("summary",null,[e[64]||(e[64]=t("a",{id:"Reactant.MLIR.IR.Attribute-Tuple{T} where T<:AbstractFloat",href:"#Reactant.MLIR.IR.Attribute-Tuple{T} where T<:AbstractFloat"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Attribute")],-1)),e[65]||(e[65]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[67]||(e[67]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(float; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), check</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a floating point attribute in the given context with the given double value and double-precision FP semantics. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[66]||(e[66]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L110-L115",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",C,[t("summary",null,[e[68]||(e[68]=t("a",{id:"Reactant.MLIR.IR.Attribute-Tuple{T} where T<:Complex",href:"#Reactant.MLIR.IR.Attribute-Tuple{T} where T<:Complex"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Attribute")],-1)),e[69]||(e[69]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[71]||(e[71]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(complex; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), check</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a complex attribute in the given context with the given complex value and double-precision FP semantics.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[70]||(e[70]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L136-L140",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",v,[t("summary",null,[e[72]||(e[72]=t("a",{id:"Reactant.MLIR.IR.Attribute-Tuple{Vector{Reactant.MLIR.IR.Attribute}}",href:"#Reactant.MLIR.IR.Attribute-Tuple{Vector{Reactant.MLIR.IR.Attribute}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Attribute")],-1)),e[73]||(e[73]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[75]||(e[75]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an array element containing the given list of elements in the given context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[74]||(e[74]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L78-L82",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",P,[t("summary",null,[e[76]||(e[76]=t("a",{id:"Reactant.MLIR.IR.Attribute-Tuple{}",href:"#Reactant.MLIR.IR.Attribute-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Attribute")],-1)),e[77]||(e[77]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[79]||(e[79]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns an empty attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[78]||(e[78]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L5-L9",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",x,[t("summary",null,[e[80]||(e[80]=t("a",{id:"Reactant.MLIR.IR.Attribute-Union{Tuple{T}, Tuple{T, Any}} where T<:Integer",href:"#Reactant.MLIR.IR.Attribute-Union{Tuple{T}, Tuple{T, Any}} where T<:Integer"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Attribute")],-1)),e[81]||(e[81]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[83]||(e[83]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(int)</span></span></code></pre></div><p>Creates an integer attribute of the given type with the given integer value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[82]||(e[82]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L166-L170",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",S,[t("summary",null,[e[84]||(e[84]=t("a",{id:"Reactant.MLIR.IR.Block-Tuple{Vector{Reactant.MLIR.IR.Type}, Vector{Reactant.MLIR.IR.Location}}",href:"#Reactant.MLIR.IR.Block-Tuple{Vector{Reactant.MLIR.IR.Type}, Vector{Reactant.MLIR.IR.Location}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Block")],-1)),e[85]||(e[85]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[87]||(e[87]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args, locs)</span></span></code></pre></div><p>Creates a new empty block with the given argument types and transfers ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[86]||(e[86]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L17-L21",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",D,[t("summary",null,[e[88]||(e[88]=t("a",{id:"Reactant.MLIR.IR.BlockIterator",href:"#Reactant.MLIR.IR.BlockIterator"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.BlockIterator")],-1)),e[89]||(e[89]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[91]||(e[91]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BlockIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Region</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Iterates over all blocks in the given region.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[90]||(e[90]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Iterators.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",F,[t("summary",null,[e[92]||(e[92]=t("a",{id:"Reactant.MLIR.IR.Context-Tuple{}",href:"#Reactant.MLIR.IR.Context-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Context")],-1)),e[93]||(e[93]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[95]||(e[95]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates an MLIR context and transfers its ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[94]||(e[94]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Context.jl#L10-L14",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",V,[t("summary",null,[e[96]||(e[96]=t("a",{id:"Reactant.MLIR.IR.ExecutionEngine",href:"#Reactant.MLIR.IR.ExecutionEngine"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.ExecutionEngine")],-1)),e[97]||(e[97]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[99]||(e[99]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ExecutionEngine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, optLevel, sharedlibs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [])</span></span></code></pre></div><p>Creates an ExecutionEngine for the provided ModuleOp. The ModuleOp is expected to be &quot;translatable&quot; to LLVM IR (only contains operations in dialects that implement the <code>LLVMTranslationDialectInterface</code>). The module ownership stays with the client and can be destroyed as soon as the call returns. <code>optLevel</code> is the optimization level to be used for transformation and code generation. LLVM passes at <code>optLevel</code> are run before code generation. The number and array of paths corresponding to shared libraries that will be loaded are specified via <code>numPaths</code> and <code>sharedLibPaths</code> respectively. TODO: figure out other options.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[98]||(e[98]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/ExecutionEngine.jl#L10-L20",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",O,[t("summary",null,[e[100]||(e[100]=t("a",{id:"Reactant.MLIR.IR.Identifier-Tuple{String}",href:"#Reactant.MLIR.IR.Identifier-Tuple{String}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Identifier")],-1)),e[101]||(e[101]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[103]||(e[103]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Identifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, str)</span></span></code></pre></div><p>Gets an identifier with the given string value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[102]||(e[102]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Identifier.jl#L5-L9",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",B,[t("summary",null,[e[104]||(e[104]=t("a",{id:"Reactant.MLIR.IR.IntegerSet-NTuple{4, Any}",href:"#Reactant.MLIR.IR.IntegerSet-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.IntegerSet")],-1)),e[105]||(e[105]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[107]||(e[107]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IntegerSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ndims, nsymbols, constraints, eqflags; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Gets or creates a new integer set in the given context. The set is defined by a list of affine constraints, with the given number of input dimensions and symbols, which are treated as either equalities (eqflags is 1) or inequalities (eqflags is 0). Both <code>constraints</code> and <code>eqflags</code> need to be arrays of the same length.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[106]||(e[106]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L18-L24",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",N,[t("summary",null,[e[108]||(e[108]=t("a",{id:"Reactant.MLIR.IR.IntegerSet-Tuple{Any, Any}",href:"#Reactant.MLIR.IR.IntegerSet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.IntegerSet")],-1)),e[109]||(e[109]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[111]||(e[111]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integerset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ndims, nsymbols; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Gets or creates a new canonically empty integer set with the give number of dimensions and symbols in the given context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[110]||(e[110]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L10-L14",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",G,[t("summary",null,[e[112]||(e[112]=t("a",{id:"Reactant.MLIR.IR.LogicalResult",href:"#Reactant.MLIR.IR.LogicalResult"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.LogicalResult")],-1)),e[113]||(e[113]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[115]||(e[115]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LogicalResult</span></span></code></pre></div><p>A logical result value, essentially a boolean with named states. LLVM convention for using boolean values to designate success or failure of an operation is a moving target, so MLIR opted for an explicit class. Instances of <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.IR.LogicalResult"><code>LogicalResult</code></a> must only be inspected using the associated functions.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[114]||(e[114]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/LogicalResult.jl#L1-L7",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",z,[t("summary",null,[e[116]||(e[116]=t("a",{id:"Reactant.MLIR.IR.Module",href:"#Reactant.MLIR.IR.Module"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Module")],-1)),e[117]||(e[117]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[119]||(e[119]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a new, empty module and transfers ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[118]||(e[118]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Module.jl#L10-L14",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",w,[t("summary",null,[e[120]||(e[120]=t("a",{id:"Reactant.MLIR.IR.NamedAttribute-Tuple{Any, Any}",href:"#Reactant.MLIR.IR.NamedAttribute-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.NamedAttribute")],-1)),e[121]||(e[121]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[123]||(e[123]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name, attr)</span></span></code></pre></div><p>Associates an attribute with the name. Takes ownership of neither.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[122]||(e[122]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L858-L862",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",U,[t("summary",null,[e[124]||(e[124]=t("a",{id:"Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.OpPassManager, Any}",href:"#Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.OpPassManager, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.OpPassManager")],-1)),e[125]||(e[125]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[127]||(e[127]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpPassManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opPassManager, operationName)</span></span></code></pre></div><p>Nest an <code>OpPassManager</code> under the provided <code>OpPassManager</code>, the nested passmanager will only run on operations matching the provided name. The returned <code>OpPassManager</code> will be destroyed when the parent is destroyed.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[126]||(e[126]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L195-L199",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",q,[t("summary",null,[e[128]||(e[128]=t("a",{id:"Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.PassManager, Any}",href:"#Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.PassManager, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.OpPassManager")],-1)),e[129]||(e[129]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[131]||(e[131]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpPassManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, operationName)</span></span></code></pre></div><p>Nest an <code>OpPassManager</code> under the top-level PassManager, the nested passmanager will only run on operations matching the provided name. The returned <code>OpPassManager</code> will be destroyed when the parent is destroyed. To further nest more <code>OpPassManager</code> under the newly returned one, see <code>mlirOpPassManagerNest</code> below.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[130]||(e[130]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L186-L191",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Q,[t("summary",null,[e[132]||(e[132]=t("a",{id:"Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.PassManager}",href:"#Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.PassManager}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.OpPassManager")],-1)),e[133]||(e[133]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[135]||(e[135]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpPassManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager)</span></span></code></pre></div><p>Cast a top-level <code>PassManager</code> to a generic <code>OpPassManager</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[134]||(e[134]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L178-L182",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",W,[t("summary",null,[e[136]||(e[136]=t("a",{id:"Reactant.MLIR.IR.Operation-Tuple{Reactant.MLIR.IR.Module}",href:"#Reactant.MLIR.IR.Operation-Tuple{Reactant.MLIR.IR.Module}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Operation")],-1)),e[137]||(e[137]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[139]||(e[139]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Views the module as a generic operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[138]||(e[138]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Module.jl#L50-L54",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Z,[t("summary",null,[e[140]||(e[140]=t("a",{id:"Reactant.MLIR.IR.OperationIterator",href:"#Reactant.MLIR.IR.OperationIterator"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.OperationIterator")],-1)),e[141]||(e[141]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[143]||(e[143]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OperationIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Iterates over all operations for the given block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[142]||(e[142]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Iterators.jl#L66-L70",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",H,[t("summary",null,[e[144]||(e[144]=t("a",{id:"Reactant.MLIR.IR.PassManager-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.PassManager-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.PassManager")],-1)),e[145]||(e[145]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[147]||(e[147]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PassManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(anchorOp; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Create a new top-level PassManager anchored on <code>anchorOp</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[146]||(e[146]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L28-L32",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",J,[t("summary",null,[e[148]||(e[148]=t("a",{id:"Reactant.MLIR.IR.PassManager-Tuple{}",href:"#Reactant.MLIR.IR.PassManager-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.PassManager")],-1)),e[149]||(e[149]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[151]||(e[151]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PassManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Create a new top-level PassManager.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[150]||(e[150]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",K,[t("summary",null,[e[152]||(e[152]=t("a",{id:"Reactant.MLIR.IR.Region-Tuple{}",href:"#Reactant.MLIR.IR.Region-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Region")],-1)),e[153]||(e[153]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[155]||(e[155]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Region</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a new empty region and transfers ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[154]||(e[154]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Region.jl#L15-L19",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$,[t("summary",null,[e[156]||(e[156]=t("a",{id:"Reactant.MLIR.IR.RegionIterator",href:"#Reactant.MLIR.IR.RegionIterator"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.RegionIterator")],-1)),e[157]||(e[157]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[159]||(e[159]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegionIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Iterates over all sub-regions for the given operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[158]||(e[158]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Iterators.jl#L34-L38",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",X,[t("summary",null,[e[160]||(e[160]=t("a",{id:"Reactant.MLIR.IR.SymbolTable-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.SymbolTable-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.SymbolTable")],-1)),e[161]||(e[161]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[163]||(e[163]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(operation)</span></span></code></pre></div><p>Creates a symbol table for the given operation. If the operation does not have the SymbolTable trait, returns a null symbol table.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[162]||(e[162]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/SymbolTable.jl#L10-L14",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Y,[t("summary",null,[e[164]||(e[164]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.Type-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[165]||(e[165]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[167]||(e[167]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the type stored in the given type attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[166]||(e[166]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L383-L387",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ee,[t("summary",null,[e[168]||(e[168]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{<:Integer}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{<:Integer}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[169]||(e[169]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[171]||(e[171]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{&lt;:Integer}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a signless integer type of the given bitwidth in the context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[170]||(e[170]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L80-L84",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",te,[t("summary",null,[e[172]||(e[172]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{<:Reactant.F8E4M3B11FNUZ}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{<:Reactant.F8E4M3B11FNUZ}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[173]||(e[173]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[175]||(e[175]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Reactant.F8E4M3B11FNUZ}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a f8e4m3b11fnuz type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[174]||(e[174]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L212-L216",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",se,[t("summary",null,[e[176]||(e[176]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{<:Reactant.F8E4M3FNUZ}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{<:Reactant.F8E4M3FNUZ}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[177]||(e[177]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[179]||(e[179]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Reactant.F8E4M3FNUZ}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a f8e4m3fnuz type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[178]||(e[178]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L230-L234",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ae,[t("summary",null,[e[180]||(e[180]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{<:Reactant.F8E4M3FN}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{<:Reactant.F8E4M3FN}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[181]||(e[181]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[183]||(e[183]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Reactant.F8E4M3FN}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a f8e4m3fn type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[182]||(e[182]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L203-L207",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ie,[t("summary",null,[e[184]||(e[184]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{<:Reactant.F8E5M2FNUZ}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{<:Reactant.F8E5M2FNUZ}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[185]||(e[185]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[187]||(e[187]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Reactant.F8E5M2FNUZ}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a f8e5m2fnuz type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[186]||(e[186]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L221-L225",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",le,[t("summary",null,[e[188]||(e[188]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{<:Reactant.F8E5M2}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{<:Reactant.F8E5M2}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[189]||(e[189]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[191]||(e[191]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Reactant.F8E5M2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a f8e5m2 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[190]||(e[190]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L194-L198",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ne,[t("summary",null,[e[192]||(e[192]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{<:Reactant.TF32}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{<:Reactant.TF32}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[193]||(e[193]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[195]||(e[195]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Reactant.TF32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a tf32 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[194]||(e[194]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L239-L243",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",re,[t("summary",null,[e[196]||(e[196]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{<:Signed}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{<:Signed}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[197]||(e[197]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[199]||(e[199]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{&lt;:Signed}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a signed integer type of the given bitwidth in the context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[198]||(e[198]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L88-L92",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",oe,[t("summary",null,[e[200]||(e[200]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{<:Unsigned}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{<:Unsigned}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[201]||(e[201]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[203]||(e[203]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{&lt;:Unsigned}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates an unsigned integer type of the given bitwidth in the context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[202]||(e[202]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L96-L100",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pe,[t("summary",null,[e[204]||(e[204]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{Bool}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{Bool}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[205]||(e[205]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[207]||(e[207]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Bool}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a 1-bit signless integer type in the context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[206]||(e[206]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L71-L75",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",de,[t("summary",null,[e[208]||(e[208]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{Float16}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{Float16}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[209]||(e[209]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[211]||(e[211]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Float16}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an f16 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[210]||(e[210]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L164-L168",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ue,[t("summary",null,[e[212]||(e[212]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{Float32}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{Float32}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[213]||(e[213]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[215]||(e[215]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Core</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Type{Float32}; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an f32 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[214]||(e[214]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L180-L184",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",be,[t("summary",null,[e[216]||(e[216]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{Float64}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{Float64}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[217]||(e[217]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[219]||(e[219]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Core</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Type{Float64}; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a f64 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[218]||(e[218]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L187-L191",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ce,[t("summary",null,[e[220]||(e[220]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Type{Nothing}}",href:"#Reactant.MLIR.IR.Type-Tuple{Type{Nothing}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[221]||(e[221]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[223]||(e[223]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a None type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[222]||(e[222]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L42-L46",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",he,[t("summary",null,[e[224]||(e[224]=t("a",{id:"Reactant.MLIR.IR.Type-Tuple{Vector{Reactant.MLIR.IR.Type}}",href:"#Reactant.MLIR.IR.Type-Tuple{Vector{Reactant.MLIR.IR.Type}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[225]||(e[225]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[227]||(e[227]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{&lt;:Tuple{T...}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a tuple type that consists of the given list of elemental types. The type is owned by the context.</p>`,2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[226]||(e[226]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L642-L647",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ye,[t("summary",null,[e[228]||(e[228]=t("a",{id:"Reactant.MLIR.IR.Type-Union{Tuple{Type{Complex{T}}}, Tuple{T}} where T",href:"#Reactant.MLIR.IR.Type-Union{Tuple{Type{Complex{T}}}, Tuple{T}} where T"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Type")],-1)),e[229]||(e[229]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[231]||(e[231]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Complex{T}) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T}</span></span></code></pre></div><p>Creates a complex type with the given element type in the same context as the element type. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[230]||(e[230]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L319-L323",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ge,[t("summary",null,[e[232]||(e[232]=t("a",{id:"Base.:-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}",href:"#Base.:-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Base.:*")],-1)),e[233]||(e[233]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[235]||(e[235]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine mul expression with &#39;lhs&#39; and &#39;rhs&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[234]||(e[234]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L157-L161",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",me,[t("summary",null,[e[236]||(e[236]=t("a",{id:"Base.:+-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}",href:"#Base.:+-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Base.:+")],-1)),e[237]||(e[237]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[239]||(e[239]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine add expression with &#39;lhs&#39; and &#39;rhs&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[238]||(e[238]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L143-L147",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ke,[t("summary",null,[e[240]||(e[240]=t("a",{id:"Base.:==-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}",href:"#Base.:==-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Base.:==")],-1)),e[241]||(e[241]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[243]||(e[243]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b)</span></span></code></pre></div><p>Returns <code>true</code> if the two affine expressions are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[242]||(e[242]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L12-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Re,[t("summary",null,[e[244]||(e[244]=t("a",{id:"Base.:==-Tuple{Reactant.MLIR.IR.AffineMap, Reactant.MLIR.IR.AffineMap}",href:"#Base.:==-Tuple{Reactant.MLIR.IR.AffineMap, Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Base.:==")],-1)),e[245]||(e[245]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[247]||(e[247]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b)</span></span></code></pre></div><p>Checks if two affine maps are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[246]||(e[246]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L20-L24",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fe,[t("summary",null,[e[248]||(e[248]=t("a",{id:"Base.:==-Tuple{Reactant.MLIR.IR.Attribute, Reactant.MLIR.IR.Attribute}",href:"#Base.:==-Tuple{Reactant.MLIR.IR.Attribute, Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Base.:==")],-1)),e[249]||(e[249]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[251]||(e[251]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a1, a2)</span></span></code></pre></div><p>Checks if two attributes are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[250]||(e[250]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L22-L26",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ie,[t("summary",null,[e[252]||(e[252]=t("a",{id:"Base.:==-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}",href:"#Base.:==-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}"},[t("span",{class:"jlbinding"},"Base.:==")],-1)),e[253]||(e[253]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[255]||(e[255]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, other)</span></span></code></pre></div><p>Checks whether two blocks handles point to the same block. This does not perform deep comparison.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[254]||(e[254]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L27-L31",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Te,[t("summary",null,[e[256]||(e[256]=t("a",{id:"Base.:==-Tuple{Reactant.MLIR.IR.Identifier, Reactant.MLIR.IR.Identifier}",href:"#Base.:==-Tuple{Reactant.MLIR.IR.Identifier, Reactant.MLIR.IR.Identifier}"},[t("span",{class:"jlbinding"},"Base.:==")],-1)),e[257]||(e[257]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[259]||(e[259]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ident, other)</span></span></code></pre></div><p>Checks whether two identifiers are the same.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[258]||(e[258]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Identifier.jl#L15-L19",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ae,[t("summary",null,[e[260]||(e[260]=t("a",{id:"Base.:==-Tuple{Reactant.MLIR.IR.IntegerSet, Reactant.MLIR.IR.IntegerSet}",href:"#Base.:==-Tuple{Reactant.MLIR.IR.IntegerSet, Reactant.MLIR.IR.IntegerSet}"},[t("span",{class:"jlbinding"},"Base.:==")],-1)),e[261]||(e[261]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[263]||(e[263]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s1, s2)</span></span></code></pre></div><p>Checks if two integer set objects are equal. This is a &quot;shallow&quot; comparison of two objects. Only the sets with some small number of constraints are uniqued and compare equal here. Set objects that represent the same integer set with different constraints may be considered non-equal by this check. Set difference followed by an (expensive) emptiness check should be used to check equivalence of the underlying integer sets.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[262]||(e[262]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L50-L57",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",je,[t("summary",null,[e[264]||(e[264]=t("a",{id:"Base.:==-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Region}",href:"#Base.:==-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Region}"},[t("span",{class:"jlbinding"},"Base.:==")],-1)),e[265]||(e[265]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[267]||(e[267]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, other)</span></span></code></pre></div><p>Checks whether two region handles point to the same region. This does not perform deep comparison.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[266]||(e[266]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Region.jl#L25-L29",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_e,[t("summary",null,[e[268]||(e[268]=t("a",{id:"Base.:==-Tuple{Reactant.MLIR.IR.Type, Reactant.MLIR.IR.Type}",href:"#Base.:==-Tuple{Reactant.MLIR.IR.Type, Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Base.:==")],-1)),e[269]||(e[269]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[271]||(e[271]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t1, t2)</span></span></code></pre></div><p>Checks if two types are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[270]||(e[270]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L20-L24",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Me,[t("summary",null,[e[272]||(e[272]=t("a",{id:"Base.:==-Tuple{Reactant.MLIR.IR.TypeID, Reactant.MLIR.IR.TypeID}",href:"#Base.:==-Tuple{Reactant.MLIR.IR.TypeID, Reactant.MLIR.IR.TypeID}"},[t("span",{class:"jlbinding"},"Base.:==")],-1)),e[273]||(e[273]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[275]||(e[275]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(typeID1, typeID2)</span></span></code></pre></div><p>Checks if two type ids are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[274]||(e[274]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/TypeID.jl#L23-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ee,[t("summary",null,[e[276]||(e[276]=t("a",{id:"Base.:==-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Base.:==-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Base.:==")],-1)),e[277]||(e[277]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[279]||(e[279]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value1, value2)</span></span></code></pre></div><p>Returns 1 if two values are equal, 0 otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[278]||(e[278]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Value.jl#L14-L18",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Le,[t("summary",null,[e[280]||(e[280]=t("a",{id:"Base.cld-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}",href:"#Base.cld-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Base.cld")],-1)),e[281]||(e[281]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[283]||(e[283]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine ceildiv expression with &#39;lhs&#39; and &#39;rhs&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[282]||(e[282]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L203-L207",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ce,[t("summary",null,[e[284]||(e[284]=t("a",{id:"Base.copy-Tuple{Reactant.MLIR.IR.Operation}",href:"#Base.copy-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Base.copy")],-1)),e[285]||(e[285]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[287]||(e[287]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">copy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Creates a deep copy of an operation. The operation is not inserted and ownership is transferred to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[286]||(e[286]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ve,[t("summary",null,[e[288]||(e[288]=t("a",{id:"Base.div-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}",href:"#Base.div-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Base.div")],-1)),e[289]||(e[289]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[291]||(e[291]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">÷</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine floordiv expression with &#39;lhs&#39; and &#39;rhs&#39;.</p>`,2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[290]||(e[290]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L185-L191",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pe,[t("summary",null,[e[292]||(e[292]=t("a",{id:"Base.fill-Tuple{Reactant.MLIR.IR.Attribute, Reactant.MLIR.IR.Type}",href:"#Base.fill-Tuple{Reactant.MLIR.IR.Attribute, Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Base.fill")],-1)),e[293]||(e[293]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[295]||(e[295]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, shapedType)</span></span></code></pre></div><p>Creates a dense elements attribute with the given Shaped type containing a single replicated element (splat).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[294]||(e[294]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L435-L439",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xe,[t("summary",null,[e[296]||(e[296]=t("a",{id:"Base.gcd-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Base.gcd-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Base.gcd")],-1)),e[297]||(e[297]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[299]||(e[299]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gcd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the greatest known integral divisor of this affine expression. The result is always positive.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[298]||(e[298]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L40-L44",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Se,[t("summary",null,[e[300]||(e[300]=t("a",{id:"Base.hash-Tuple{Reactant.MLIR.IR.TypeID}",href:"#Base.hash-Tuple{Reactant.MLIR.IR.TypeID}"},[t("span",{class:"jlbinding"},"Base.hash")],-1)),e[301]||(e[301]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[303]||(e[303]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(typeID)</span></span></code></pre></div><p>Returns the hash value of the type id.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[302]||(e[302]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/TypeID.jl#L14-L18",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",De,[t("summary",null,[e[304]||(e[304]=t("a",{id:"Base.insert!-Tuple{Reactant.MLIR.IR.Block, Any, Reactant.MLIR.IR.Operation}",href:"#Base.insert!-Tuple{Reactant.MLIR.IR.Block, Any, Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Base.insert!")],-1)),e[305]||(e[305]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[307]||(e[307]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, index, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and inserts it as <code>index</code> to the block. This is an expensive operation that scans the block linearly, prefer insertBefore/After instead.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[306]||(e[306]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L134-L139",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fe,[t("summary",null,[e[308]||(e[308]=t("a",{id:"Base.insert!-Tuple{Reactant.MLIR.IR.Region, Any, Reactant.MLIR.IR.Block}",href:"#Base.insert!-Tuple{Reactant.MLIR.IR.Region, Any, Reactant.MLIR.IR.Block}"},[t("span",{class:"jlbinding"},"Base.insert!")],-1)),e[309]||(e[309]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[311]||(e[311]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, index, block)</span></span></code></pre></div><p>Takes a block owned by the caller and inserts it at <code>index</code> to the given region. This is an expensive operation that linearly scans the region, prefer insertAfter/Before instead.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[310]||(e[310]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Region.jl#L42-L46",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ve,[t("summary",null,[e[312]||(e[312]=t("a",{id:"Base.isempty-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Base.isempty-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Base.isempty")],-1)),e[313]||(e[313]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[315]||(e[315]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isempty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is an empty affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[314]||(e[314]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L114-L118",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Oe,[t("summary",null,[e[316]||(e[316]=t("a",{id:"Base.isempty-Tuple{Reactant.MLIR.IR.IntegerSet}",href:"#Base.isempty-Tuple{Reactant.MLIR.IR.IntegerSet}"},[t("span",{class:"jlbinding"},"Base.isempty")],-1)),e[317]||(e[317]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[319]||(e[319]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isempty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Checks whether the given set is a canonical empty set, e.g., the set returned by <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirIntegerSetEmptyGet-Tuple{Any, Any, Any}"><code>Reactant.MLIR.API.mlirIntegerSetEmptyGet</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[318]||(e[318]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L67-L71",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Be,[t("summary",null,[e[320]||(e[320]=t("a",{id:"Base.isperm-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Base.isperm-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Base.isperm")],-1)),e[321]||(e[321]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[323]||(e[323]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isperm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map represents a symbol-less permutation map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[322]||(e[322]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L180-L184",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ne,[t("summary",null,[e[324]||(e[324]=t("a",{id:"Base.mod-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}",href:"#Base.mod-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Base.mod")],-1)),e[325]||(e[325]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[327]||(e[327]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine mod expression with &#39;lhs&#39; and &#39;rhs&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[326]||(e[326]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L171-L175",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ge,[t("summary",null,[e[328]||(e[328]=t("a",{id:"Base.ndims-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Base.ndims-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Base.ndims")],-1)),e[329]||(e[329]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[331]||(e[331]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ndims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of dimensions of the given affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[330]||(e[330]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L138-L142",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ze,[t("summary",null,[e[332]||(e[332]=t("a",{id:"Base.ndims-Tuple{Reactant.MLIR.IR.IntegerSet}",href:"#Base.ndims-Tuple{Reactant.MLIR.IR.IntegerSet}"},[t("span",{class:"jlbinding"},"Base.ndims")],-1)),e[333]||(e[333]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[335]||(e[335]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ndims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of dimensions in the given set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[334]||(e[334]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L74-L78",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",we,[t("summary",null,[e[336]||(e[336]=t("a",{id:"Base.ndims-Tuple{Reactant.MLIR.IR.Type}",href:"#Base.ndims-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Base.ndims")],-1)),e[337]||(e[337]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[339]||(e[339]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ndims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the rank of the given ranked shaped type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[338]||(e[338]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L348-L352",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ue,[t("summary",null,[e[340]||(e[340]=t("a",{id:"Base.parse-Tuple{Reactant.MLIR.IR.OpPassManager, String}",href:"#Base.parse-Tuple{Reactant.MLIR.IR.OpPassManager, String}"},[t("span",{class:"jlbinding"},"Base.parse")],-1)),e[341]||(e[341]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[343]||(e[343]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opPassManager, pipeline)</span></span></code></pre></div><p>Parse a textual MLIR pass pipeline and add it to the provided <code>OpPassManager</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[342]||(e[342]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L259-L263",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qe,[t("summary",null,[e[344]||(e[344]=t("a",{id:"Base.parse-Tuple{Type{Reactant.MLIR.IR.Attribute}, Any}",href:"#Base.parse-Tuple{Type{Reactant.MLIR.IR.Attribute}, Any}"},[t("span",{class:"jlbinding"},"Base.parse")],-1)),e[345]||(e[345]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[347]||(e[347]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Attribute}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, str; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Parses an attribute. The attribute is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[346]||(e[346]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L14-L18",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qe,[t("summary",null,[e[348]||(e[348]=t("a",{id:"Base.parse-Tuple{Type{Reactant.MLIR.IR.Module}, Any}",href:"#Base.parse-Tuple{Type{Reactant.MLIR.IR.Module}, Any}"},[t("span",{class:"jlbinding"},"Base.parse")],-1)),e[349]||(e[349]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[351]||(e[351]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{Module}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Parses a module from the string and transfers ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[350]||(e[350]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Module.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",We,[t("summary",null,[e[352]||(e[352]=t("a",{id:"Base.parse-Tuple{Type{Reactant.MLIR.IR.Operation}, Any}",href:"#Base.parse-Tuple{Type{Reactant.MLIR.IR.Operation}, Any}"},[t("span",{class:"jlbinding"},"Base.parse")],-1)),e[353]||(e[353]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[355]||(e[355]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{Operation}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, code; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Parses an operation from the string and transfers ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[354]||(e[354]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L245-L249",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ze,[t("summary",null,[e[356]||(e[356]=t("a",{id:"Base.parse-Tuple{Type{Reactant.MLIR.IR.Type}, Any}",href:"#Base.parse-Tuple{Type{Reactant.MLIR.IR.Type}, Any}"},[t("span",{class:"jlbinding"},"Base.parse")],-1)),e[357]||(e[357]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[359]||(e[359]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Parses a type. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[358]||(e[358]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L12-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",He,[t("summary",null,[e[360]||(e[360]=t("a",{id:"Base.push!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation}",href:"#Base.push!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Base.push!")],-1)),e[361]||(e[361]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[363]||(e[363]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">push!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and appends it to the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[362]||(e[362]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L124-L128",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Je,[t("summary",null,[e[364]||(e[364]=t("a",{id:"Base.push!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block}",href:"#Base.push!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block}"},[t("span",{class:"jlbinding"},"Base.push!")],-1)),e[365]||(e[365]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[367]||(e[367]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">push!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, block)</span></span></code></pre></div><p>Takes a block owned by the caller and appends it to the given region.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[366]||(e[366]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Region.jl#L32-L36",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ke,[t("summary",null,[e[368]||(e[368]=t("a",{id:"Base.push!-Tuple{Reactant.MLIR.IR.SymbolTable, Reactant.MLIR.IR.Operation}",href:"#Base.push!-Tuple{Reactant.MLIR.IR.SymbolTable, Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Base.push!")],-1)),e[369]||(e[369]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[371]||(e[371]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">push!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symboltable, operation)</span></span></code></pre></div><p>Inserts the given operation into the given symbol table. The operation must have the symbol trait. If the symbol table already has a symbol with the same name, renames the symbol being inserted to ensure name uniqueness. Note that this does not move the operation itself into the block of the symbol table operation, this should be done separately. Returns the name of the symbol after insertion.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[370]||(e[370]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/SymbolTable.jl#L40-L47",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$e,[t("summary",null,[e[372]||(e[372]=t("a",{id:"Base.replace-Tuple{Reactant.MLIR.IR.AffineMap, Pair{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}, Any, Any}",href:"#Base.replace-Tuple{Reactant.MLIR.IR.AffineMap, Pair{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}, Any, Any}"},[t("span",{class:"jlbinding"},"Base.replace")],-1)),e[373]||(e[373]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[375]||(e[375]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapReplace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, expression </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> replacement, numResultDims, numResultSyms)</span></span></code></pre></div><p>Apply <code>AffineExpr::replace(map)</code> to each of the results and return a new new AffineMap with the new results and the specified number of dims and symbols.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[374]||(e[374]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L214-L218",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xe,[t("summary",null,[e[376]||(e[376]=t("a",{id:"Base.replace-Tuple{Reactant.MLIR.IR.IntegerSet, Any, Any}",href:"#Base.replace-Tuple{Reactant.MLIR.IR.IntegerSet, Any, Any}"},[t("span",{class:"jlbinding"},"Base.replace")],-1)),e[377]||(e[377]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[379]||(e[379]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetReplaceGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, dimReplacements, symbolReplacements, numResultDims, numResultSymbols)</span></span></code></pre></div><p>Gets or creates a new integer set in which the values and dimensions of the given set are replaced with the given affine expressions. <code>dimReplacements</code> and <code>symbolReplacements</code> are expected to point to at least as many consecutive expressions as the given set has dimensions and symbols, respectively. The new set will have <code>numResultDims</code> and <code>numResultSymbols</code> dimensions and symbols, respectively.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[378]||(e[378]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L31-L37",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ye,[t("summary",null,[e[380]||(e[380]=t("a",{id:"Base.reshape-Tuple{Reactant.MLIR.IR.Attribute, Vector{Int64}}",href:"#Base.reshape-Tuple{Reactant.MLIR.IR.Attribute, Vector{Int64}}"},[t("span",{class:"jlbinding"},"Base.reshape")],-1)),e[381]||(e[381]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[383]||(e[383]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reshape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, shapedType)</span></span></code></pre></div><p>Creates a dense elements attribute that has the same data as the given dense elements attribute and a different shaped type. The new type must have the same total number of elements.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[382]||(e[382]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L635-L639",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",et,[t("summary",null,[e[384]||(e[384]=t("a",{id:"Base.size-Tuple{Reactant.MLIR.IR.Type, Int64}",href:"#Base.size-Tuple{Reactant.MLIR.IR.Type, Int64}"},[t("span",{class:"jlbinding"},"Base.size")],-1)),e[385]||(e[385]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[387]||(e[387]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, i)</span></span></code></pre></div><p>Returns the <code>i</code>-th dimension of the given ranked shaped type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[386]||(e[386]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L372-L376",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",tt,[t("summary",null,[e[388]||(e[388]=t("a",{id:"Base.write-Tuple{String, Reactant.MLIR.IR.ExecutionEngine}",href:"#Base.write-Tuple{String, Reactant.MLIR.IR.ExecutionEngine}"},[t("span",{class:"jlbinding"},"Base.write")],-1)),e[389]||(e[389]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[391]||(e[391]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fileName, jit)</span></span></code></pre></div><p>Dump as an object in <code>fileName</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[390]||(e[390]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/ExecutionEngine.jl#L54-L58",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",st,[t("summary",null,[e[392]||(e[392]=t("a",{id:"Reactant.MLIR.IR.AffineDimensionExpr-Tuple{Any}",href:"#Reactant.MLIR.IR.AffineDimensionExpr-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.AffineDimensionExpr")],-1)),e[393]||(e[393]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[395]||(e[395]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AffineDimensionExpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(position; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context)</span></span></code></pre></div><p>Creates an affine dimension expression with &#39;position&#39; in the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[394]||(e[394]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L69-L73",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",at,[t("summary",null,[e[396]||(e[396]=t("a",{id:"Reactant.MLIR.IR.BFloat16Type-Tuple{}",href:"#Reactant.MLIR.IR.BFloat16Type-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.BFloat16Type")],-1)),e[397]||(e[397]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[399]||(e[399]=t("p",null,"BFloat16Type(; context=context())",-1)),e[400]||(e[400]=t("p",null,"Creates a bf16 type in the given context. The type is owned by the context.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[398]||(e[398]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L157-L161",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",it,[t("summary",null,[e[401]||(e[401]=t("a",{id:"Reactant.MLIR.IR.ConstantAffineMap-Tuple{Any}",href:"#Reactant.MLIR.IR.ConstantAffineMap-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.ConstantAffineMap")],-1)),e[402]||(e[402]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[404]||(e[404]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConstantAffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a single constant result affine map in the context. The affine map is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[403]||(e[403]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L59-L63",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",lt,[t("summary",null,[e[405]||(e[405]=t("a",{id:"Reactant.MLIR.IR.ConstantExpr-Tuple{Any}",href:"#Reactant.MLIR.IR.ConstantExpr-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.ConstantExpr")],-1)),e[406]||(e[406]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[408]||(e[408]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConstantExpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(constant</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an affine constant expression with &#39;constant&#39; in the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[407]||(e[407]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L118-L122",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",nt,[t("summary",null,[e[409]||(e[409]=t("a",{id:"Reactant.MLIR.IR.DenseElementsAttribute-Tuple{AbstractArray{Bool}}",href:"#Reactant.MLIR.IR.DenseElementsAttribute-Tuple{AbstractArray{Bool}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.DenseElementsAttribute")],-1)),e[410]||(e[410]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[412]||(e[412]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DenseElementsAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a dense elements attribute with the given shaped type from elements of a specific type. Expects the element type of the shaped type to match the data element type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[411]||(e[411]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L499-L503",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rt,[t("summary",null,[e[413]||(e[413]=t("a",{id:"Reactant.MLIR.IR.DenseElementsAttribute-Tuple{AbstractArray{String}}",href:"#Reactant.MLIR.IR.DenseElementsAttribute-Tuple{AbstractArray{String}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.DenseElementsAttribute")],-1)),e[414]||(e[414]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[416]||(e[416]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DenseElementsAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{String}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a dense elements attribute with the given shaped type from string elements.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[415]||(e[415]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L620-L624",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ot,[t("summary",null,[e[417]||(e[417]=t("a",{id:"Reactant.MLIR.IR.DenseElementsAttribute-Tuple{Reactant.MLIR.IR.Type, AbstractArray}",href:"#Reactant.MLIR.IR.DenseElementsAttribute-Tuple{Reactant.MLIR.IR.Type, AbstractArray}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.DenseElementsAttribute")],-1)),e[418]||(e[418]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[420]||(e[420]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DenseElementsAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, elements)</span></span></code></pre></div><p>Creates a dense elements attribute with the given Shaped type and elements in the same context as the type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[419]||(e[419]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L423-L427",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pt,[t("summary",null,[e[421]||(e[421]=t("a",{id:"Reactant.MLIR.IR.FlatSymbolRefAttribute-Tuple{String}",href:"#Reactant.MLIR.IR.FlatSymbolRefAttribute-Tuple{String}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.FlatSymbolRefAttribute")],-1)),e[422]||(e[422]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[424]||(e[424]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FlatSymbolRefAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, symbol)</span></span></code></pre></div><p>Creates a flat symbol reference attribute in the given context referencing a symbol identified by the given string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[423]||(e[423]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L351-L355",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dt,[t("summary",null,[e[425]||(e[425]=t("a",{id:"Reactant.MLIR.IR.Float8E4M3FN-Tuple{}",href:"#Reactant.MLIR.IR.Float8E4M3FN-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Float8E4M3FN")],-1)),e[426]||(e[426]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[428]||(e[428]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float8E4M3FN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an f8E4M3FN type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[427]||(e[427]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L150-L154",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ut,[t("summary",null,[e[429]||(e[429]=t("a",{id:"Reactant.MLIR.IR.Float8E5M2-Tuple{}",href:"#Reactant.MLIR.IR.Float8E5M2-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.Float8E5M2")],-1)),e[430]||(e[430]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[432]||(e[432]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float8E5M2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an f8E5M2 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[431]||(e[431]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L143-L147",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bt,[t("summary",null,[e[433]||(e[433]=t("a",{id:"Reactant.MLIR.IR.FunctionType-Tuple{Any, Any}",href:"#Reactant.MLIR.IR.FunctionType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.FunctionType")],-1)),e[434]||(e[434]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[436]||(e[436]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FunctionType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inputs, results; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a function type, mapping a list of input types to result types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[435]||(e[435]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L672-L676",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ct,[t("summary",null,[e[437]||(e[437]=t("a",{id:"Reactant.MLIR.IR.IdentityAffineMap-Tuple{Any}",href:"#Reactant.MLIR.IR.IdentityAffineMap-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.IdentityAffineMap")],-1)),e[438]||(e[438]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[440]||(e[440]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IdentityAffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ndims; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an affine map with &#39;ndims&#39; identity in the context. The affine map is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[439]||(e[439]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L67-L71",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ht,[t("summary",null,[e[441]||(e[441]=t("a",{id:"Reactant.MLIR.IR.IndexType-Tuple{}",href:"#Reactant.MLIR.IR.IndexType-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.IndexType")],-1)),e[442]||(e[442]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[444]||(e[444]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IndexType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an index type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[443]||(e[443]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L57-L61",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yt,[t("summary",null,[e[445]||(e[445]=t("a",{id:"Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any, Any, Any}",href:"#Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.MemRefType")],-1)),e[446]||(e[446]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[448]||(e[448]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MemRefType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, rank, shape, layout, memorySpace; location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), check</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a MemRef type with the given rank and shape, a potentially empty list of affine layout maps, the given memory space and element type, in the same context as element type. The type is owned by the context. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[447]||(e[447]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L529-L534",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gt,[t("summary",null,[e[449]||(e[449]=t("a",{id:"Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any, Any}",href:"#Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.MemRefType")],-1)),e[450]||(e[450]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[452]||(e[452]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MemRefType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, rank, shape, memorySpace; location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), check</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a MemRef type with the given rank, shape, memory space and element type in the same context as the element type. The type has no affine maps, i.e. represents a default row-major contiguous memref. The type is owned by the context. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[451]||(e[451]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L554-L560",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mt,[t("summary",null,[e[453]||(e[453]=t("a",{id:"Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any}",href:"#Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.MemRefType")],-1)),e[454]||(e[454]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[456]||(e[456]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MemRefType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, memorySpace)</span></span></code></pre></div><p>Creates an Unranked MemRef type with the given element type and in the given memory space. The type is owned by the context of element type. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[455]||(e[455]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L575-L580",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",kt,[t("summary",null,[e[457]||(e[457]=t("a",{id:"Reactant.MLIR.IR.MinorIdentityAffineMap-Tuple{Any, Any}",href:"#Reactant.MLIR.IR.MinorIdentityAffineMap-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.MinorIdentityAffineMap")],-1)),e[458]||(e[458]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[460]||(e[460]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MinorIdentityAffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ndims, nresults; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an identity affine map on the most minor dimensions in the context. The affine map is owned by the context. The function asserts that the number of dimensions is greater or equal to the number of results.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[459]||(e[459]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L75-L80",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rt,[t("summary",null,[e[461]||(e[461]=t("a",{id:"Reactant.MLIR.IR.OpaqueAttribute-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.IR.OpaqueAttribute-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.OpaqueAttribute")],-1)),e[462]||(e[462]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[464]||(e[464]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpaqueAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dialectNamespace, dataLength, data, type; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an opaque attribute in the given context associated with the dialect identified by its namespace. The attribute contains opaque byte data of the specified length (data need not be null-terminated).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[463]||(e[463]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L234-L239",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ft,[t("summary",null,[e[465]||(e[465]=t("a",{id:"Reactant.MLIR.IR.OpaqueType-Tuple{Any, Any}",href:"#Reactant.MLIR.IR.OpaqueType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.OpaqueType")],-1)),e[466]||(e[466]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[468]||(e[468]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpaqueType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dialectNamespace, typeData; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an opaque type in the given context associated with the dialect identified by its namespace. The type contains opaque byte data of the specified length (data need not be null-terminated).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[467]||(e[467]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L729-L733",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",It,[t("summary",null,[e[469]||(e[469]=t("a",{id:"Reactant.MLIR.IR.PermutationAffineMap-Tuple{Any}",href:"#Reactant.MLIR.IR.PermutationAffineMap-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.PermutationAffineMap")],-1)),e[470]||(e[470]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[472]||(e[472]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PermutationAffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(permutation; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an affine map with a permutation expression and its size in the context. The permutation expression is a non-empty vector of integers. The elements of the permutation vector must be continuous from 0 and cannot be repeated (i.e. <code>[1,2,0]</code> is a valid permutation. <code>[2,0]</code> or <code>[1,1,2]</code> is an invalid invalid permutation). The affine map is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[471]||(e[471]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L86-L93",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Tt,[t("summary",null,[e[473]||(e[473]=t("a",{id:"Reactant.MLIR.IR.SymbolExpr-Tuple{Any}",href:"#Reactant.MLIR.IR.SymbolExpr-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.SymbolExpr")],-1)),e[474]||(e[474]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[476]||(e[476]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SymbolExpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(position; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an affine symbol expression with &#39;position&#39; in the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[475]||(e[475]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L84-L88",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",At,[t("summary",null,[e[477]||(e[477]=t("a",{id:"Reactant.MLIR.IR.SymbolRefAttribute-Tuple{String, Vector{Reactant.MLIR.IR.Attribute}}",href:"#Reactant.MLIR.IR.SymbolRefAttribute-Tuple{String, Vector{Reactant.MLIR.IR.Attribute}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.SymbolRefAttribute")],-1)),e[478]||(e[478]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[480]||(e[480]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SymbolRefAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbol, references; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a symbol reference attribute in the given context referencing a symbol identified by the given string inside a list of nested references. Each of the references in the list must not be nested.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[479]||(e[479]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L304-L309",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jt,[t("summary",null,[e[481]||(e[481]=t("a",{id:"Reactant.MLIR.IR.TensorType",href:"#Reactant.MLIR.IR.TensorType"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.TensorType")],-1)),e[482]||(e[482]=i()),a(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[484]||(e[484]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TensorType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shape, elementType, encoding</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), check</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a tensor type of a fixed rank with the given shape, element type, and optional encoding in the same context as the element type. The type is owned by the context. Tensor types without any specific encoding field should assign <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirAttributeGetNull-Tuple{}"><code>Reactant.MLIR.API.mlirAttributeGetNull</code></a> to this parameter. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[483]||(e[483]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L439-L445",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_t,[t("summary",null,[e[485]||(e[485]=t("a",{id:"Reactant.MLIR.IR.TensorType-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.TensorType-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.TensorType")],-1)),e[486]||(e[486]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[488]||(e[488]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TensorType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType)</span></span></code></pre></div><p>Creates an unranked tensor type with the given element type in the same context as the element type. The type is owned by the context. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[487]||(e[487]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L463-L468",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mt,[t("summary",null,[e[489]||(e[489]=t("a",{id:"Reactant.MLIR.IR.UnitAttribute-Tuple{}",href:"#Reactant.MLIR.IR.UnitAttribute-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.UnitAttribute")],-1)),e[490]||(e[490]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[492]||(e[492]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnitAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a unit attribute in the given context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[491]||(e[491]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L397-L401",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Et,[t("summary",null,[e[493]||(e[493]=t("a",{id:"Reactant.MLIR.IR.VectorType-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.IR.VectorType-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.VectorType")],-1)),e[494]||(e[494]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[496]||(e[496]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VectorType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rank, shape, elementType; location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), check</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a vector type of the shape identified by its rank and dimensions, with the given element type in the same context as the element type. The type is owned by the context. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[495]||(e[495]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L413-L418",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Lt,[t("summary",null,[e[497]||(e[497]=t("a",{id:"Reactant.MLIR.IR.add_owned_pass!-Tuple{Reactant.MLIR.IR.OpPassManager, Any}",href:"#Reactant.MLIR.IR.add_owned_pass!-Tuple{Reactant.MLIR.IR.OpPassManager, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.add_owned_pass!")],-1)),e[498]||(e[498]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[500]||(e[500]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_owned_pass!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opPassManager, pass)</span></span></code></pre></div><p>Add a pass and transfer ownership to the provided <code>OpPassManager</code>. If the pass is not a generic operation pass or matching the type of the provided <code>OpPassManager</code>, a new <code>OpPassManager</code> is implicitly nested under the provided <code>OpPassManager</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[499]||(e[499]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L249-L253",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ct,[t("summary",null,[e[501]||(e[501]=t("a",{id:"Reactant.MLIR.IR.add_owned_pass!-Tuple{Reactant.MLIR.IR.PassManager, Any}",href:"#Reactant.MLIR.IR.add_owned_pass!-Tuple{Reactant.MLIR.IR.PassManager, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.add_owned_pass!")],-1)),e[502]||(e[502]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[504]||(e[504]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_owned_pass!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, pass)</span></span></code></pre></div><p>Add a pass and transfer ownership to the provided top-level <code>PassManager</code>. If the pass is not a generic operation pass or a <code>ModulePass</code>, a new <code>OpPassManager</code> is implicitly nested under the provided PassManager.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[503]||(e[503]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L239-L243",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vt,[t("summary",null,[e[505]||(e[505]=t("a",{id:"Reactant.MLIR.IR.add_pipeline!-Tuple{Reactant.MLIR.IR.OpPassManager, Any}",href:"#Reactant.MLIR.IR.add_pipeline!-Tuple{Reactant.MLIR.IR.OpPassManager, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.add_pipeline!")],-1)),e[506]||(e[506]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[508]||(e[508]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_pipeline!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opPassManager, pipeline)</span></span></code></pre></div><p>Parse a sequence of textual MLIR pass pipeline elements and add them to the provided OpPassManager. If parsing fails an error message is reported using the provided callback.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[507]||(e[507]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L277-L281",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pt,[t("summary",null,[e[509]||(e[509]=t("a",{id:"Reactant.MLIR.IR.affinemap-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.affinemap-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.affinemap")],-1)),e[510]||(e[510]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[512]||(e[512]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">affinemap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the affine map of the given MemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[511]||(e[511]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L617-L621",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xt,[t("summary",null,[e[513]||(e[513]=t("a",{id:"Reactant.MLIR.IR.argument-Tuple{Reactant.MLIR.IR.Block, Any}",href:"#Reactant.MLIR.IR.argument-Tuple{Reactant.MLIR.IR.Block, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.argument")],-1)),e[514]||(e[514]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[516]||(e[516]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">argument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, i)</span></span></code></pre></div><p>Returns <code>i</code>-th argument of the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[515]||(e[515]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L70-L74",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",St,[t("summary",null,[e[517]||(e[517]=t("a",{id:"Reactant.MLIR.IR.attr!-Tuple{Reactant.MLIR.IR.Operation, Any, Any}",href:"#Reactant.MLIR.IR.attr!-Tuple{Reactant.MLIR.IR.Operation, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.attr!")],-1)),e[518]||(e[518]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[520]||(e[520]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">attr!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name, attr)</span></span></code></pre></div><p>Sets an attribute by name, replacing the existing if it exists or adding a new one otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[519]||(e[519]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L202-L206",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Dt,[t("summary",null,[e[521]||(e[521]=t("a",{id:"Reactant.MLIR.IR.attr-Tuple{Reactant.MLIR.IR.Operation, AbstractString}",href:"#Reactant.MLIR.IR.attr-Tuple{Reactant.MLIR.IR.Operation, AbstractString}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.attr")],-1)),e[522]||(e[522]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[524]||(e[524]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">attr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Returns an attribute attached to the operation given its name.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[523]||(e[523]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L189-L193",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ft,[t("summary",null,[e[525]||(e[525]=t("a",{id:"Reactant.MLIR.IR.attr-Tuple{Reactant.MLIR.IR.Operation, Any}",href:"#Reactant.MLIR.IR.attr-Tuple{Reactant.MLIR.IR.Operation, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.attr")],-1)),e[526]||(e[526]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[528]||(e[528]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">attr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, i)</span></span></code></pre></div><p>Return <code>i</code>-th attribute of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[527]||(e[527]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L179-L183",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vt,[t("summary",null,[e[529]||(e[529]=t("a",{id:"Reactant.MLIR.IR.bitwidth-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.bitwidth-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.bitwidth")],-1)),e[530]||(e[530]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[532]||(e[532]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bitwidth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the bitwidth of an integer type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[531]||(e[531]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L132-L136",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ot,[t("summary",null,[e[533]||(e[533]=t("a",{id:"Reactant.MLIR.IR.block-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.block-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.block")],-1)),e[534]||(e[534]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[536]||(e[536]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the block that owns this operation, returning null if the operation is not owned.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[535]||(e[535]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L56-L60",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bt,[t("summary",null,[e[537]||(e[537]=t("a",{id:"Reactant.MLIR.IR.block_arg_num-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.IR.block_arg_num-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.block_arg_num")],-1)),e[538]||(e[538]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[540]||(e[540]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">block_arg_num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the position of the value in the argument list of its block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[539]||(e[539]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Value.jl#L69-L73",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Nt,[t("summary",null,[e[541]||(e[541]=t("a",{id:"Reactant.MLIR.IR.block_owner-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.IR.block_owner-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.block_owner")],-1)),e[542]||(e[542]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[544]||(e[544]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">block_owner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the block in which this value is defined as an argument. Asserts if the value is not a block argument.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[543]||(e[543]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Value.jl#L35-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gt,[t("summary",null,[e[545]||(e[545]=t("a",{id:"Reactant.MLIR.IR.body-Tuple{Any}",href:"#Reactant.MLIR.IR.body-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.body")],-1)),e[546]||(e[546]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[548]||(e[548]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Gets the body of the module, i.e. the only block it contains.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[547]||(e[547]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Module.jl#L43-L47",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zt,[t("summary",null,[e[549]||(e[549]=t("a",{id:"Reactant.MLIR.IR.compose-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineMap}",href:"#Reactant.MLIR.IR.compose-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.compose")],-1)),e[550]||(e[550]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[552]||(e[552]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, affineMap)</span></span></code></pre></div><p>Composes the given map with the given expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[551]||(e[551]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L27-L31",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wt,[t("summary",null,[e[553]||(e[553]=t("a",{id:"Reactant.MLIR.IR.constraint-Tuple{Reactant.MLIR.IR.IntegerSet, Any}",href:"#Reactant.MLIR.IR.constraint-Tuple{Reactant.MLIR.IR.IntegerSet, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.constraint")],-1)),e[554]||(e[554]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[556]||(e[556]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetConstraint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, i)</span></span></code></pre></div><p>Returns <code>i</code>-th constraint of the set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[555]||(e[555]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L116-L120",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ut,[t("summary",null,[e[557]||(e[557]=t("a",{id:"Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.context")],-1)),e[558]||(e[558]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[560]||(e[560]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Gets the context that owns the affine expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[559]||(e[559]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L19-L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qt,[t("summary",null,[e[561]||(e[561]=t("a",{id:"Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.context")],-1)),e[562]||(e[562]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[564]||(e[564]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Gets the context that the given affine map was created with.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[563]||(e[563]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L34-L38",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qt,[t("summary",null,[e[565]||(e[565]=t("a",{id:"Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.context")],-1)),e[566]||(e[566]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[568]||(e[568]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the context that an attribute was created with.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[567]||(e[567]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L29-L33",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wt,[t("summary",null,[e[569]||(e[569]=t("a",{id:"Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Identifier}",href:"#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Identifier}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.context")],-1)),e[570]||(e[570]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[572]||(e[572]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ident)</span></span></code></pre></div><p>Returns the context associated with this identifier</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[571]||(e[571]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Identifier.jl#L22-L26",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zt,[t("summary",null,[e[573]||(e[573]=t("a",{id:"Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.IntegerSet}",href:"#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.IntegerSet}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.context")],-1)),e[574]||(e[574]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[576]||(e[576]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Gets the context in which the given integer set lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[575]||(e[575]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L60-L64",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ht,[t("summary",null,[e[577]||(e[577]=t("a",{id:"Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Module}",href:"#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Module}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.context")],-1)),e[578]||(e[578]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[580]||(e[580]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Gets the context that a module was created with.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[579]||(e[579]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Module.jl#L36-L40",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jt,[t("summary",null,[e[581]||(e[581]=t("a",{id:"Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.context")],-1)),e[582]||(e[582]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[584]||(e[584]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the context this operation is associated with.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[583]||(e[583]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L28-L32",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Kt,[t("summary",null,[e[585]||(e[585]=t("a",{id:"Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.context")],-1)),e[586]||(e[586]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[588]||(e[588]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the context that a type was created with.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[587]||(e[587]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L27-L31",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$t,[t("summary",null,[e[589]||(e[589]=t("a",{id:"Reactant.MLIR.IR.data-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.data-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.data")],-1)),e[590]||(e[590]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[592]||(e[592]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the raw data as a string reference. The data remains live as long as the context in which the attribute lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[591]||(e[591]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L253-L257",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xt,[t("summary",null,[e[593]||(e[593]=t("a",{id:"Reactant.MLIR.IR.data-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.data-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.data")],-1)),e[594]||(e[594]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[596]||(e[596]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueTypeGetData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the raw data as a string reference. The data remains live as long as the context in which the type lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[595]||(e[595]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L751-L755",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yt,[t("summary",null,[e[597]||(e[597]=t("a",{id:"Reactant.MLIR.IR.delete!-Tuple{Reactant.MLIR.IR.SymbolTable, Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.delete!-Tuple{Reactant.MLIR.IR.SymbolTable, Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.delete!")],-1)),e[598]||(e[598]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[600]||(e[600]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">delete!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symboltable, operation)</span></span></code></pre></div><p>Removes the given operation from the symbol table and erases it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[599]||(e[599]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/SymbolTable.jl#L50-L54",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",es,[t("summary",null,[e[601]||(e[601]=t("a",{id:"Reactant.MLIR.IR.dynsize-Tuple{}",href:"#Reactant.MLIR.IR.dynsize-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.dynsize")],-1)),e[602]||(e[602]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[604]||(e[604]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dynsize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the value indicating a dynamic size in a shaped type. Prefer <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.IR.isdynsize-Tuple{Any}"><code>isdynsize</code></a> to direct comparisons with this value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[603]||(e[603]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L391-L395",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ts,[t("summary",null,[e[605]||(e[605]=t("a",{id:"Reactant.MLIR.IR.dynstrideoroffset-Tuple{}",href:"#Reactant.MLIR.IR.dynstrideoroffset-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.dynstrideoroffset")],-1)),e[606]||(e[606]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[608]||(e[608]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeGetDynamicStrideOrOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the value indicating a dynamic stride or offset in a shaped type. Prefer <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.IR.isdynstrideoroffset-Tuple{Any}"><code>isdynstrideoroffset</code></a> to direct comparisons with this value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[607]||(e[607]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L405-L409",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ss,[t("summary",null,[e[609]||(e[609]=t("a",{id:"Reactant.MLIR.IR.enable_ir_printing!-Tuple{Any}",href:"#Reactant.MLIR.IR.enable_ir_printing!-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.enable_ir_printing!")],-1)),e[610]||(e[610]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[612]||(e[612]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enable_ir_printing!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager)</span></span></code></pre></div><p>Enable mlir-print-ir-after-all.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[611]||(e[611]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L38-L42",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",as,[t("summary",null,[e[613]||(e[613]=t("a",{id:"Reactant.MLIR.IR.enable_verifier!",href:"#Reactant.MLIR.IR.enable_verifier!"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.enable_verifier!")],-1)),e[614]||(e[614]=i()),a(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[616]||(e[616]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enable_verifier!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, enable)</span></span></code></pre></div><p>Enable / disable verify-each.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[615]||(e[615]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L57-L61",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",is,[t("summary",null,[e[617]||(e[617]=t("a",{id:"Reactant.MLIR.IR.encoding-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.encoding-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.encoding")],-1)),e[618]||(e[618]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[620]||(e[620]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">encoding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the &#39;encoding&#39; attribute from the ranked tensor type, returning a <code>nothing</code> if none.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[619]||(e[619]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L517-L521",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ls,[t("summary",null,[e[621]||(e[621]=t("a",{id:"Reactant.MLIR.IR.erase_argument!-Tuple{Any, Any}",href:"#Reactant.MLIR.IR.erase_argument!-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.erase_argument!")],-1)),e[622]||(e[622]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[624]||(e[624]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">erase_argument!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, i)</span></span></code></pre></div><p>Erase argument <code>i</code> of the block. Returns the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[623]||(e[623]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L88-L92",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ns,[t("summary",null,[e[625]||(e[625]=t("a",{id:"Reactant.MLIR.IR.failure-Tuple{}",href:"#Reactant.MLIR.IR.failure-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.failure")],-1)),e[626]||(e[626]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[628]||(e[628]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">failure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a logical result representing a failure.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[627]||(e[627]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/LogicalResult.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rs,[t("summary",null,[e[629]||(e[629]=t("a",{id:"Reactant.MLIR.IR.first_block-Tuple{Reactant.MLIR.IR.Region}",href:"#Reactant.MLIR.IR.first_block-Tuple{Reactant.MLIR.IR.Region}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.first_block")],-1)),e[630]||(e[630]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[632]||(e[632]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">first_block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region)</span></span></code></pre></div><p>Gets the first block in the region.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[631]||(e[631]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Region.jl#L73-L77",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",os,[t("summary",null,[e[633]||(e[633]=t("a",{id:"Reactant.MLIR.IR.first_op-Tuple{Reactant.MLIR.IR.Block}",href:"#Reactant.MLIR.IR.first_op-Tuple{Reactant.MLIR.IR.Block}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.first_op")],-1)),e[634]||(e[634]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[636]||(e[636]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">first_op</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the first operation in the block or <code>nothing</code> if empty.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[635]||(e[635]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L101-L105",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ps,[t("summary",null,[e[637]||(e[637]=t("a",{id:"Reactant.MLIR.IR.first_use-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.IR.first_use-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.first_use")],-1)),e[638]||(e[638]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[640]||(e[640]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">first_use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns an <code>OpOperand</code> representing the first use of the value, or a <code>nothing</code> if there are no uses.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[639]||(e[639]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/OpOperand.jl#L12-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ds,[t("summary",null,[e[641]||(e[641]=t("a",{id:"Reactant.MLIR.IR.flatsymbol-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.flatsymbol-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.flatsymbol")],-1)),e[642]||(e[642]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[644]||(e[644]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flatsymbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the referenced symbol as a string reference. The data remains live as long as the context in which the attribute lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[643]||(e[643]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L359-L363",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",us,[t("summary",null,[e[645]||(e[645]=t("a",{id:"Reactant.MLIR.IR.hasrank-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.hasrank-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.hasrank")],-1)),e[646]||(e[646]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[648]||(e[648]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hasrank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given shaped type is ranked.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[647]||(e[647]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L341-L345",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bs,[t("summary",null,[e[649]||(e[649]=t("a",{id:"Reactant.MLIR.IR.hasstaticshape-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.hasstaticshape-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.hasstaticshape")],-1)),e[650]||(e[650]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[652]||(e[652]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hasstaticshape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given shaped type has a static shape.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[651]||(e[651]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L358-L362",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cs,[t("summary",null,[e[653]||(e[653]=t("a",{id:"Reactant.MLIR.IR.input-Tuple{Reactant.MLIR.IR.Type, Any}",href:"#Reactant.MLIR.IR.input-Tuple{Reactant.MLIR.IR.Type, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.input")],-1)),e[654]||(e[654]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[656]||(e[656]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, i)</span></span></code></pre></div><p>Returns the <code>i</code>-th input type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[655]||(e[655]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L708-L712",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hs,[t("summary",null,[e[657]||(e[657]=t("a",{id:"Reactant.MLIR.IR.insert_after!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.insert_after!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.insert_after!")],-1)),e[658]||(e[658]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[660]||(e[660]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert_after!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, reference, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and inserts it after the (non-owned) reference operation in the given block. If the reference is null, prepends the operation. Otherwise, the reference must belong to the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[659]||(e[659]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L150-L154",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ys,[t("summary",null,[e[661]||(e[661]=t("a",{id:"Reactant.MLIR.IR.insert_after!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}",href:"#Reactant.MLIR.IR.insert_after!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.insert_after!")],-1)),e[662]||(e[662]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[664]||(e[664]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert_after!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, reference, block)</span></span></code></pre></div><p>Takes a block owned by the caller and inserts it after the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, prepends the block to the region.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[663]||(e[663]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Region.jl#L57-L61",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gs,[t("summary",null,[e[665]||(e[665]=t("a",{id:"Reactant.MLIR.IR.insert_before!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.insert_before!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.insert_before!")],-1)),e[666]||(e[666]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[668]||(e[668]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert_before!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, reference, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and inserts it before the (non-owned) reference operation in the given block. If the reference is null, appends the operation. Otherwise, the reference must belong to the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[667]||(e[667]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L160-L164",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ms,[t("summary",null,[e[669]||(e[669]=t("a",{id:"Reactant.MLIR.IR.insert_before!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}",href:"#Reactant.MLIR.IR.insert_before!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.insert_before!")],-1)),e[670]||(e[670]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[672]||(e[672]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert_before!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, reference, block)</span></span></code></pre></div><p>Takes a block owned by the caller and inserts it before the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, appends the block to the region.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[671]||(e[671]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Region.jl#L65-L69",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ks,[t("summary",null,[e[673]||(e[673]=t("a",{id:"Reactant.MLIR.IR.is_block_arg-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.IR.is_block_arg-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.is_block_arg")],-1)),e[674]||(e[674]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[676]||(e[676]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_block_arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns 1 if the value is a block argument, 0 otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[675]||(e[675]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Value.jl#L21-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rs,[t("summary",null,[e[677]||(e[677]=t("a",{id:"Reactant.MLIR.IR.is_op_res-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.IR.is_op_res-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.is_op_res")],-1)),e[678]||(e[678]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[680]||(e[680]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_op_res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns 1 if the value is an operation result, 0 otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[679]||(e[679]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Value.jl#L28-L32",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fs,[t("summary",null,[e[681]||(e[681]=t("a",{id:"Reactant.MLIR.IR.is_pure_affine-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.is_pure_affine-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.is_pure_affine")],-1)),e[682]||(e[682]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[684]||(e[684]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_pure_affine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a pure affine expression, i.e. mul, floordiv, ceildic, and mod is only allowed w.r.t constants.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[683]||(e[683]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L33-L37",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Is,[t("summary",null,[e[685]||(e[685]=t("a",{id:"Reactant.MLIR.IR.is_registered-Tuple{Any}",href:"#Reactant.MLIR.IR.is_registered-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.is_registered")],-1)),e[686]||(e[686]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[688]||(e[688]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_registered</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Returns whether the given fully-qualified operation (i.e. &#39;dialect.operation&#39;) is registered with the context. This will return true if the dialect is loaded and the operation is registered within the dialect.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[687]||(e[687]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L299-L304",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ts,[t("summary",null,[e[689]||(e[689]=t("a",{id:"Reactant.MLIR.IR.is_symbolic_or_constant-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.is_symbolic_or_constant-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.is_symbolic_or_constant")],-1)),e[690]||(e[690]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[692]||(e[692]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_symbolic_or_constant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is made out of only symbols and constants.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[691]||(e[691]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L26-L30",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",As,[t("summary",null,[e[693]||(e[693]=t("a",{id:"Reactant.MLIR.IR.isadd-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.isadd-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isadd")],-1)),e[694]||(e[694]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[696]||(e[696]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isadd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an add expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[695]||(e[695]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L136-L140",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",js,[t("summary",null,[e[697]||(e[697]=t("a",{id:"Reactant.MLIR.IR.isaffinemap-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.isaffinemap-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isaffinemap")],-1)),e[698]||(e[698]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[700]||(e[700]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isaffinemap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an affine map attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[699]||(e[699]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L50-L54",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_s,[t("summary",null,[e[701]||(e[701]=t("a",{id:"Reactant.MLIR.IR.isarray-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.isarray-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isarray")],-1)),e[702]||(e[702]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[704]||(e[704]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isarray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an array attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[703]||(e[703]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L71-L75",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ms,[t("summary",null,[e[705]||(e[705]=t("a",{id:"Reactant.MLIR.IR.isbf16-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isbf16-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isbf16")],-1)),e[706]||(e[706]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[708]||(e[708]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isbf16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a bf16 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[707]||(e[707]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L283-L287",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Es,[t("summary",null,[e[709]||(e[709]=t("a",{id:"Reactant.MLIR.IR.isbinary-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.isbinary-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isbinary")],-1)),e[710]||(e[710]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[712]||(e[712]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isbinary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is binary.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[711]||(e[711]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L211-L215",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ls,[t("summary",null,[e[713]||(e[713]=t("a",{id:"Reactant.MLIR.IR.isbool-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.isbool-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isbool")],-1)),e[714]||(e[714]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[716]||(e[716]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isbool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a bool attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[715]||(e[715]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L196-L200",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Cs,[t("summary",null,[e[717]||(e[717]=t("a",{id:"Reactant.MLIR.IR.isceildiv-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.isceildiv-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isceildiv")],-1)),e[718]||(e[718]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[720]||(e[720]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isceildiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an ceildiv expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[719]||(e[719]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L196-L200",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vs,[t("summary",null,[e[721]||(e[721]=t("a",{id:"Reactant.MLIR.IR.iscomplex-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.iscomplex-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.iscomplex")],-1)),e[722]||(e[722]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[724]||(e[724]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">iscomplex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Complex type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[723]||(e[723]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L326-L330",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ps,[t("summary",null,[e[725]||(e[725]=t("a",{id:"Reactant.MLIR.IR.isconstantexpr-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.isconstantexpr-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isconstantexpr")],-1)),e[726]||(e[726]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[728]||(e[728]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isconstantexpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a constant expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[727]||(e[727]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L111-L115",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xs,[t("summary",null,[e[729]||(e[729]=t("a",{id:"Reactant.MLIR.IR.isconstrainteq-Tuple{Reactant.MLIR.IR.IntegerSet, Any}",href:"#Reactant.MLIR.IR.isconstrainteq-Tuple{Reactant.MLIR.IR.IntegerSet, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isconstrainteq")],-1)),e[730]||(e[730]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[732]||(e[732]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetIsConstraintEq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, i)</span></span></code></pre></div><p>Returns <code>true</code> of the <code>i</code>-th constraint of the set is an equality constraint, <code>false</code> otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[731]||(e[731]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L123-L127",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ss,[t("summary",null,[e[733]||(e[733]=t("a",{id:"Reactant.MLIR.IR.isdenseelements-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.isdenseelements-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isdenseelements")],-1)),e[734]||(e[734]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[736]||(e[736]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isdenseelements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a dense elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[735]||(e[735]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L414-L418",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ds,[t("summary",null,[e[737]||(e[737]=t("a",{id:"Reactant.MLIR.IR.isdict-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.isdict-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isdict")],-1)),e[738]||(e[738]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[740]||(e[740]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isdict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a dictionary attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[739]||(e[739]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L86-L90",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fs,[t("summary",null,[e[741]||(e[741]=t("a",{id:"Reactant.MLIR.IR.isdimexpr-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.isdimexpr-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isdimexpr")],-1)),e[742]||(e[742]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[744]||(e[744]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isdimexpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a dimension expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[743]||(e[743]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L62-L66",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vs,[t("summary",null,[e[745]||(e[745]=t("a",{id:"Reactant.MLIR.IR.isdyndim-Tuple{Reactant.MLIR.IR.Type, Int64}",href:"#Reactant.MLIR.IR.isdyndim-Tuple{Reactant.MLIR.IR.Type, Int64}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isdyndim")],-1)),e[746]||(e[746]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[748]||(e[748]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isdyndim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, i)</span></span></code></pre></div><p>Checks wither the <code>i</code>-th dimension of the given shaped type is dynamic.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[747]||(e[747]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L365-L369",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Os,[t("summary",null,[e[749]||(e[749]=t("a",{id:"Reactant.MLIR.IR.isdynsize-Tuple{Any}",href:"#Reactant.MLIR.IR.isdynsize-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isdynsize")],-1)),e[750]||(e[750]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[752]||(e[752]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isdynsize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size)</span></span></code></pre></div><p>Checks whether the given value is used as a placeholder for dynamic sizes in shaped types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[751]||(e[751]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L384-L388",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bs,[t("summary",null,[e[753]||(e[753]=t("a",{id:"Reactant.MLIR.IR.isdynstrideoroffset-Tuple{Any}",href:"#Reactant.MLIR.IR.isdynstrideoroffset-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isdynstrideoroffset")],-1)),e[754]||(e[754]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[756]||(e[756]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeIsDynamicStrideOrOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val)</span></span></code></pre></div><p>Checks whether the given value is used as a placeholder for dynamic strides and offsets in shaped types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[755]||(e[755]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L398-L402",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ns,[t("summary",null,[e[757]||(e[757]=t("a",{id:"Reactant.MLIR.IR.iselements-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.iselements-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.iselements")],-1)),e[758]||(e[758]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[760]||(e[760]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">iselements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[759]||(e[759]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L404-L408",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gs,[t("summary",null,[e[761]||(e[761]=t("a",{id:"Reactant.MLIR.IR.isf16-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isf16-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isf16")],-1)),e[762]||(e[762]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[764]||(e[764]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f16 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[763]||(e[763]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L290-L294",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zs,[t("summary",null,[e[765]||(e[765]=t("a",{id:"Reactant.MLIR.IR.isf32-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isf32-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isf32")],-1)),e[766]||(e[766]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[768]||(e[768]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f32 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[767]||(e[767]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L297-L301",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ws,[t("summary",null,[e[769]||(e[769]=t("a",{id:"Reactant.MLIR.IR.isf64-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isf64-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isf64")],-1)),e[770]||(e[770]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[772]||(e[772]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f64 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[771]||(e[771]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L304-L308",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Us,[t("summary",null,[e[773]||(e[773]=t("a",{id:"Reactant.MLIR.IR.isf8e4m3b11fnuz-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isf8e4m3b11fnuz-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isf8e4m3b11fnuz")],-1)),e[774]||(e[774]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[776]||(e[776]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf8e4m3b11fnuz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3B11FNUZ type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[775]||(e[775]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L262-L266",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qs,[t("summary",null,[e[777]||(e[777]=t("a",{id:"Reactant.MLIR.IR.isf8e4m3fn-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isf8e4m3fn-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isf8e4m3fn")],-1)),e[778]||(e[778]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[780]||(e[780]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf8e4m3fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3FN type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[779]||(e[779]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L255-L259",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qs,[t("summary",null,[e[781]||(e[781]=t("a",{id:"Reactant.MLIR.IR.isf8e4m3fnuz-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isf8e4m3fnuz-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isf8e4m3fnuz")],-1)),e[782]||(e[782]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[784]||(e[784]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf8e4m3fnuz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3FNUZ type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[783]||(e[783]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L276-L280",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ws,[t("summary",null,[e[785]||(e[785]=t("a",{id:"Reactant.MLIR.IR.isf8e5m2-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isf8e5m2-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isf8e5m2")],-1)),e[786]||(e[786]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[788]||(e[788]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf8e5m2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E5M2 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[787]||(e[787]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L248-L252",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zs,[t("summary",null,[e[789]||(e[789]=t("a",{id:"Reactant.MLIR.IR.isf8e5m2fnuz-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isf8e5m2fnuz-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isf8e5m2fnuz")],-1)),e[790]||(e[790]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[792]||(e[792]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf8e5m2fnuz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E5M2FNUZ type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[791]||(e[791]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L269-L273",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hs,[t("summary",null,[e[793]||(e[793]=t("a",{id:"Reactant.MLIR.IR.isfailure-Tuple{Reactant.MLIR.IR.LogicalResult}",href:"#Reactant.MLIR.IR.isfailure-Tuple{Reactant.MLIR.IR.LogicalResult}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isfailure")],-1)),e[794]||(e[794]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[796]||(e[796]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isfailure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res)</span></span></code></pre></div><p>Checks if the given logical result represents a failure.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[795]||(e[795]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/LogicalResult.jl#L35-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Js,[t("summary",null,[e[797]||(e[797]=t("a",{id:"Reactant.MLIR.IR.isflatsymbolref-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.isflatsymbolref-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isflatsymbolref")],-1)),e[798]||(e[798]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[800]||(e[800]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isflatsymbolref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a flat symbol reference attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[799]||(e[799]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L344-L348",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ks,[t("summary",null,[e[801]||(e[801]=t("a",{id:"Reactant.MLIR.IR.isfloat-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.isfloat-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isfloat")],-1)),e[802]||(e[802]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[804]||(e[804]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isfloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a floating point attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[803]||(e[803]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L103-L107",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$s,[t("summary",null,[e[805]||(e[805]=t("a",{id:"Reactant.MLIR.IR.isfloordiv-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.isfloordiv-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isfloordiv")],-1)),e[806]||(e[806]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[808]||(e[808]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isfloordiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an floordiv expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[807]||(e[807]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L178-L182",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xs,[t("summary",null,[e[809]||(e[809]=t("a",{id:"Reactant.MLIR.IR.isfunction-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isfunction-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isfunction")],-1)),e[810]||(e[810]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[812]||(e[812]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isfunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a function type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[811]||(e[811]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L665-L669",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ys,[t("summary",null,[e[813]||(e[813]=t("a",{id:"Reactant.MLIR.IR.isfunctionofdimexpr-Tuple{Reactant.MLIR.IR.AffineExpr, Any}",href:"#Reactant.MLIR.IR.isfunctionofdimexpr-Tuple{Reactant.MLIR.IR.AffineExpr, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isfunctionofdimexpr")],-1)),e[814]||(e[814]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[816]||(e[816]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isfunctionofdimexpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, position)</span></span></code></pre></div><p>Checks whether the given affine expression involves AffineDimExpr &#39;position&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[815]||(e[815]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L54-L58",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ea,[t("summary",null,[e[817]||(e[817]=t("a",{id:"Reactant.MLIR.IR.isidentity-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Reactant.MLIR.IR.isidentity-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isidentity")],-1)),e[818]||(e[818]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[820]||(e[820]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isidentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is an identity affine map. The function asserts that the number of dimensions is greater or equal to the number of results.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[819]||(e[819]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L100-L104",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ta,[t("summary",null,[e[821]||(e[821]=t("a",{id:"Reactant.MLIR.IR.isindex-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isindex-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isindex")],-1)),e[822]||(e[822]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[824]||(e[824]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isindex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an index type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[823]||(e[823]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L64-L68",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sa,[t("summary",null,[e[825]||(e[825]=t("a",{id:"Reactant.MLIR.IR.isinteger-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.isinteger-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isinteger")],-1)),e[826]||(e[826]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[828]||(e[828]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isinteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an integer attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[827]||(e[827]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L159-L163",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",aa,[t("summary",null,[e[829]||(e[829]=t("a",{id:"Reactant.MLIR.IR.isinteger-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isinteger-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isinteger")],-1)),e[830]||(e[830]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[832]||(e[832]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isinteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an integer type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[831]||(e[831]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L104-L108",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ia,[t("summary",null,[e[833]||(e[833]=t("a",{id:"Reactant.MLIR.IR.isintegerset-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.isintegerset-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isintegerset")],-1)),e[834]||(e[834]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[836]||(e[836]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isintegerset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an integer set attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[835]||(e[835]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L220-L224",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",la,[t("summary",null,[e[837]||(e[837]=t("a",{id:"Reactant.MLIR.IR.ismemref-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.ismemref-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.ismemref")],-1)),e[838]||(e[838]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[840]||(e[840]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ismemref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a MemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[839]||(e[839]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L593-L597",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",na,[t("summary",null,[e[841]||(e[841]=t("a",{id:"Reactant.MLIR.IR.isminoridentity-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Reactant.MLIR.IR.isminoridentity-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isminoridentity")],-1)),e[842]||(e[842]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[844]||(e[844]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isminoridentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is a minor identity affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[843]||(e[843]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L107-L111",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ra,[t("summary",null,[e[845]||(e[845]=t("a",{id:"Reactant.MLIR.IR.ismod-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.ismod-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.ismod")],-1)),e[846]||(e[846]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[848]||(e[848]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ismod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an mod expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[847]||(e[847]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L164-L168",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",oa,[t("summary",null,[e[849]||(e[849]=t("a",{id:"Reactant.MLIR.IR.ismul-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.ismul-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.ismul")],-1)),e[850]||(e[850]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[852]||(e[852]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ismul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an mul expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[851]||(e[851]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L150-L154",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pa,[t("summary",null,[e[853]||(e[853]=t("a",{id:"Reactant.MLIR.IR.ismultipleof-Tuple{Reactant.MLIR.IR.AffineExpr, Any}",href:"#Reactant.MLIR.IR.ismultipleof-Tuple{Reactant.MLIR.IR.AffineExpr, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.ismultipleof")],-1)),e[854]||(e[854]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[856]||(e[856]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ismultipleof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, factor)</span></span></code></pre></div><p>Checks whether the given affine expression is a multiple of &#39;factor&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[855]||(e[855]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L47-L51",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",da,[t("summary",null,[e[857]||(e[857]=t("a",{id:"Reactant.MLIR.IR.isnone-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isnone-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isnone")],-1)),e[858]||(e[858]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[860]||(e[860]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsANone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a None type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[859]||(e[859]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L49-L53",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ua,[t("summary",null,[e[861]||(e[861]=t("a",{id:"Reactant.MLIR.IR.isopaque-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.isopaque-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isopaque")],-1)),e[862]||(e[862]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[864]||(e[864]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isopaque</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an opaque attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[863]||(e[863]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L227-L231",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ba,[t("summary",null,[e[865]||(e[865]=t("a",{id:"Reactant.MLIR.IR.isopaque-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isopaque-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isopaque")],-1)),e[866]||(e[866]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[868]||(e[868]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isopaque</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an opaque type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[867]||(e[867]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L737-L741",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ca,[t("summary",null,[e[869]||(e[869]=t("a",{id:"Reactant.MLIR.IR.isprojperm-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Reactant.MLIR.IR.isprojperm-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isprojperm")],-1)),e[870]||(e[870]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[872]||(e[872]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isprojperm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map represents a subset of a symbol-less permutation map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[871]||(e[871]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L173-L177",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ha,[t("summary",null,[e[873]||(e[873]=t("a",{id:"Reactant.MLIR.IR.isrankedtensor-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isrankedtensor-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isrankedtensor")],-1)),e[874]||(e[874]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[876]||(e[876]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isrankedtensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a ranked tensor type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[875]||(e[875]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L503-L507",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ya,[t("summary",null,[e[877]||(e[877]=t("a",{id:"Reactant.MLIR.IR.isshaped-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isshaped-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isshaped")],-1)),e[878]||(e[878]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[880]||(e[880]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isshaped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Shaped type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[879]||(e[879]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L334-L338",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ga,[t("summary",null,[e[881]||(e[881]=t("a",{id:"Reactant.MLIR.IR.issigned-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.issigned-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.issigned")],-1)),e[882]||(e[882]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[884]||(e[884]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given integer type is signed.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[883]||(e[883]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L111-L115",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ma,[t("summary",null,[e[885]||(e[885]=t("a",{id:"Reactant.MLIR.IR.issignless-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.issignless-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.issignless")],-1)),e[886]||(e[886]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[888]||(e[888]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issignless</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given integer type is signless.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[887]||(e[887]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L118-L122",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ka,[t("summary",null,[e[889]||(e[889]=t("a",{id:"Reactant.MLIR.IR.issingleconstant-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Reactant.MLIR.IR.issingleconstant-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.issingleconstant")],-1)),e[890]||(e[890]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[892]||(e[892]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issingleconstant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is a single result constant affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[891]||(e[891]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L121-L125",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ra,[t("summary",null,[e[893]||(e[893]=t("a",{id:"Reactant.MLIR.IR.issparseelements-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.issparseelements-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.issparseelements")],-1)),e[894]||(e[894]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[896]||(e[896]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issparseelements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a sparse elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[895]||(e[895]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L660-L664",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fa,[t("summary",null,[e[897]||(e[897]=t("a",{id:"Reactant.MLIR.IR.issplat-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.issplat-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.issplat")],-1)),e[898]||(e[898]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[900]||(e[900]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issplat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given dense elements attribute contains a single replicated value (splat).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[899]||(e[899]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L648-L652",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ia,[t("summary",null,[e[901]||(e[901]=t("a",{id:"Reactant.MLIR.IR.isstring-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.isstring-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isstring")],-1)),e[902]||(e[902]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[904]||(e[904]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isstring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a string attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[903]||(e[903]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L263-L267",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ta,[t("summary",null,[e[905]||(e[905]=t("a",{id:"Reactant.MLIR.IR.issuccess-Tuple{Reactant.MLIR.IR.LogicalResult}",href:"#Reactant.MLIR.IR.issuccess-Tuple{Reactant.MLIR.IR.LogicalResult}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.issuccess")],-1)),e[906]||(e[906]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[908]||(e[908]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issuccess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res)</span></span></code></pre></div><p>Checks if the given logical result represents a success.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[907]||(e[907]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/LogicalResult.jl#L28-L32",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Aa,[t("summary",null,[e[909]||(e[909]=t("a",{id:"Reactant.MLIR.IR.issymbolexpr-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.issymbolexpr-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.issymbolexpr")],-1)),e[910]||(e[910]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[912]||(e[912]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issymbolexpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a symbol expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[911]||(e[911]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L77-L81",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ja,[t("summary",null,[e[913]||(e[913]=t("a",{id:"Reactant.MLIR.IR.issymbolref-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.issymbolref-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.issymbolref")],-1)),e[914]||(e[914]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[916]||(e[916]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issymbolref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a symbol reference attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[915]||(e[915]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L297-L301",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_a,[t("summary",null,[e[917]||(e[917]=t("a",{id:"Reactant.MLIR.IR.istensor-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.istensor-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.istensor")],-1)),e[918]||(e[918]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[920]||(e[920]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">istensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Tensor type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[919]||(e[919]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L496-L500",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ma,[t("summary",null,[e[921]||(e[921]=t("a",{id:"Reactant.MLIR.IR.istf32-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.istf32-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.istf32")],-1)),e[922]||(e[922]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[924]||(e[924]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">istf32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an tf32 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[923]||(e[923]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L311-L315",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ea,[t("summary",null,[e[925]||(e[925]=t("a",{id:"Reactant.MLIR.IR.istuple-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.istuple-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.istuple")],-1)),e[926]||(e[926]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[928]||(e[928]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">istuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a tuple type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[927]||(e[927]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L657-L661",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",La,[t("summary",null,[e[929]||(e[929]=t("a",{id:"Reactant.MLIR.IR.istype-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.istype-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.istype")],-1)),e[930]||(e[930]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[932]||(e[932]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">istype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a type attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[931]||(e[931]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L369-L373",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ca,[t("summary",null,[e[933]||(e[933]=t("a",{id:"Reactant.MLIR.IR.isunit-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.isunit-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isunit")],-1)),e[934]||(e[934]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[936]||(e[936]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isunit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a unit attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[935]||(e[935]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L390-L394",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",va,[t("summary",null,[e[937]||(e[937]=t("a",{id:"Reactant.MLIR.IR.isunrankedmemref-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isunrankedmemref-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isunrankedmemref")],-1)),e[938]||(e[938]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[940]||(e[940]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAUnrankedMemRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an UnrankedMemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[939]||(e[939]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L600-L604",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pa,[t("summary",null,[e[941]||(e[941]=t("a",{id:"Reactant.MLIR.IR.isunrankedtensor-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isunrankedtensor-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isunrankedtensor")],-1)),e[942]||(e[942]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[944]||(e[944]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isunrankedtensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an unranked tensor type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[943]||(e[943]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L510-L514",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xa,[t("summary",null,[e[945]||(e[945]=t("a",{id:"Reactant.MLIR.IR.isunsigned-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isunsigned-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isunsigned")],-1)),e[946]||(e[946]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[948]||(e[948]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isunsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given integer type is unsigned.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[947]||(e[947]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L125-L129",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sa,[t("summary",null,[e[949]||(e[949]=t("a",{id:"Reactant.MLIR.IR.isvector-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.isvector-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.isvector")],-1)),e[950]||(e[950]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[952]||(e[952]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isvector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Vector type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[951]||(e[951]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L431-L435",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Da,[t("summary",null,[e[953]||(e[953]=t("a",{id:"Reactant.MLIR.IR.layout-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.layout-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.layout")],-1)),e[954]||(e[954]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[956]||(e[956]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">layout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the layout of the given MemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[955]||(e[955]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L607-L611",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fa,[t("summary",null,[e[957]||(e[957]=t("a",{id:"Reactant.MLIR.IR.leafref-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.leafref-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.leafref")],-1)),e[958]||(e[958]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[960]||(e[960]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">leafref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the string reference to the leaf referenced symbol. The data remains live as long as the context in which the attribute lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[959]||(e[959]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L324-L328",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Va,[t("summary",null,[e[961]||(e[961]=t("a",{id:"Reactant.MLIR.IR.lhs-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.lhs-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.lhs")],-1)),e[962]||(e[962]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[964]||(e[964]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the left hand side affine expression of the given affine binary operation expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[963]||(e[963]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L218-L222",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Oa,[t("summary",null,[e[965]||(e[965]=t("a",{id:"Reactant.MLIR.IR.location-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.location-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.location")],-1)),e[966]||(e[966]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[968]||(e[968]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the location of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[967]||(e[967]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L35-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ba,[t("summary",null,[e[969]||(e[969]=t("a",{id:"Reactant.MLIR.IR.lookup-Tuple{Reactant.MLIR.IR.ExecutionEngine, String}",href:"#Reactant.MLIR.IR.lookup-Tuple{Reactant.MLIR.IR.ExecutionEngine, String}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.lookup")],-1)),e[970]||(e[970]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[972]||(e[972]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lookup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit, name)</span></span></code></pre></div><p>Lookup a native function in the execution engine by name, returns nullptr if the name can&#39;t be looked-up.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[971]||(e[971]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/ExecutionEngine.jl#L38-L42",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Na,[t("summary",null,[e[973]||(e[973]=t("a",{id:"Reactant.MLIR.IR.lookup-Tuple{Reactant.MLIR.IR.SymbolTable, AbstractString}",href:"#Reactant.MLIR.IR.lookup-Tuple{Reactant.MLIR.IR.SymbolTable, AbstractString}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.lookup")],-1)),e[974]||(e[974]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[976]||(e[976]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lookup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symboltable, name)</span></span></code></pre></div><p>Looks up a symbol with the given name in the given symbol table and returns the operation that corresponds to the symbol. If the symbol cannot be found, returns a null operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[975]||(e[975]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/SymbolTable.jl#L22-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ga,[t("summary",null,[e[977]||(e[977]=t("a",{id:"Reactant.MLIR.IR.majorsubmap-Tuple{Reactant.MLIR.IR.AffineMap, Any}",href:"#Reactant.MLIR.IR.majorsubmap-Tuple{Reactant.MLIR.IR.AffineMap, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.majorsubmap")],-1)),e[978]||(e[978]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[980]||(e[980]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">majorsubmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, nresults)</span></span></code></pre></div><p>Returns the affine map consisting of the most major <code>nresults</code> results. Returns the null AffineMap if the <code>nresults</code> is equal to zero. Returns the <code>affineMap</code> if <code>nresults</code> is greater or equals to number of results of the given affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[979]||(e[979]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L195-L201",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",za,[t("summary",null,[e[981]||(e[981]=t("a",{id:"Reactant.MLIR.IR.memspace-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.memspace-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.memspace")],-1)),e[982]||(e[982]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[984]||(e[984]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetMemorySpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the memory space of the given MemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[983]||(e[983]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L627-L631",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wa,[t("summary",null,[e[985]||(e[985]=t("a",{id:"Reactant.MLIR.IR.minorsubmap-Tuple{Reactant.MLIR.IR.AffineMap, Any}",href:"#Reactant.MLIR.IR.minorsubmap-Tuple{Reactant.MLIR.IR.AffineMap, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.minorsubmap")],-1)),e[986]||(e[986]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[988]||(e[988]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">minorsubmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, nresults)</span></span></code></pre></div><p>Returns the affine map consisting of the most minor <code>nresults</code> results. Returns the null AffineMap if the <code>nresults</code> is equal to zero. Returns the <code>affineMap</code> if <code>nresults</code> is greater or equals to number of results of the given affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[987]||(e[987]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L205-L210",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ua,[t("summary",null,[e[989]||(e[989]=t("a",{id:"Reactant.MLIR.IR.move_after!-Tuple{Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.move_after!-Tuple{Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.move_after!")],-1)),e[990]||(e[990]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[992]||(e[992]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">move_after!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, other)</span></span></code></pre></div><p>Moves the given operation immediately after the other operation in its parent block. The given operation may be owned by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[991]||(e[991]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L276-L280",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qa,[t("summary",null,[e[993]||(e[993]=t("a",{id:"Reactant.MLIR.IR.move_before!-Tuple{Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.move_before!-Tuple{Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.move_before!")],-1)),e[994]||(e[994]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[996]||(e[996]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">move_before!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, other)</span></span></code></pre></div><p>Moves the given operation immediately before the other operation in its parent block. The given operation may be owner by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[995]||(e[995]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L286-L293",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qa,[t("summary",null,[e[997]||(e[997]=t("a",{id:"Reactant.MLIR.IR.name-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.name-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.name")],-1)),e[998]||(e[998]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1e3]||(e[1e3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the name of the operation as an identifier.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[999]||(e[999]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L49-L53",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wa,[t("summary",null,[e[1001]||(e[1001]=t("a",{id:"Reactant.MLIR.IR.namespace-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.namespace-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.namespace")],-1)),e[1002]||(e[1002]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1004]||(e[1004]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueAttrGetDialectNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the namespace of the dialect with which the given opaque attribute is associated. The namespace string is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1003]||(e[1003]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L243-L247",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Za,[t("summary",null,[e[1005]||(e[1005]=t("a",{id:"Reactant.MLIR.IR.namespace-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.namespace-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.namespace")],-1)),e[1006]||(e[1006]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1008]||(e[1008]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueTypeGetDialectNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the namespace of the dialect with which the given opaque type is associated. The namespace string is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1007]||(e[1007]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L744-L748",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ha,[t("summary",null,[e[1009]||(e[1009]=t("a",{id:"Reactant.MLIR.IR.nargs-Tuple{Reactant.MLIR.IR.Block}",href:"#Reactant.MLIR.IR.nargs-Tuple{Reactant.MLIR.IR.Block}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.nargs")],-1)),e[1010]||(e[1010]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1012]||(e[1012]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nargs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the number of arguments of the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1011]||(e[1011]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L63-L67",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ja,[t("summary",null,[e[1013]||(e[1013]=t("a",{id:"Reactant.MLIR.IR.nattrs-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.nattrs-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.nattrs")],-1)),e[1014]||(e[1014]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1016]||(e[1016]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nattrs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of attributes attached to the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1015]||(e[1015]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L172-L176",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ka,[t("summary",null,[e[1017]||(e[1017]=t("a",{id:"Reactant.MLIR.IR.nconstraints-Tuple{Reactant.MLIR.IR.IntegerSet}",href:"#Reactant.MLIR.IR.nconstraints-Tuple{Reactant.MLIR.IR.IntegerSet}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.nconstraints")],-1)),e[1018]||(e[1018]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1020]||(e[1020]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nconstraints</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of constraints (equalities + inequalities) in the given set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1019]||(e[1019]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L95-L99",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$a,[t("summary",null,[e[1021]||(e[1021]=t("a",{id:"Reactant.MLIR.IR.nequalities-Tuple{Reactant.MLIR.IR.IntegerSet}",href:"#Reactant.MLIR.IR.nequalities-Tuple{Reactant.MLIR.IR.IntegerSet}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.nequalities")],-1)),e[1022]||(e[1022]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1024]||(e[1024]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nequalities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of equalities in the given set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1023]||(e[1023]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L102-L106",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xa,[t("summary",null,[e[1025]||(e[1025]=t("a",{id:"Reactant.MLIR.IR.next-Tuple{Reactant.MLIR.IR.Block}",href:"#Reactant.MLIR.IR.next-Tuple{Reactant.MLIR.IR.Block}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.next")],-1)),e[1026]||(e[1026]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1028]||(e[1028]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the block immediately following the given block in its parent region or <code>nothing</code> if last.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1027]||(e[1027]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L52-L56",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ya,[t("summary",null,[e[1029]||(e[1029]=t("a",{id:"Reactant.MLIR.IR.next-Tuple{Reactant.MLIR.IR.OpOperand}",href:"#Reactant.MLIR.IR.next-Tuple{Reactant.MLIR.IR.OpOperand}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.next")],-1)),e[1030]||(e[1030]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1032]||(e[1032]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns an op operand representing the next use of the value, or <code>nothing</code> if there is no next use.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1031]||(e[1031]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/OpOperand.jl#L37-L41",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ei,[t("summary",null,[e[1033]||(e[1033]=t("a",{id:"Reactant.MLIR.IR.ninequalities-Tuple{Reactant.MLIR.IR.IntegerSet}",href:"#Reactant.MLIR.IR.ninequalities-Tuple{Reactant.MLIR.IR.IntegerSet}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.ninequalities")],-1)),e[1034]||(e[1034]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1036]||(e[1036]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ninequalities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of inequalities in the given set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1035]||(e[1035]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L109-L113",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ti,[t("summary",null,[e[1037]||(e[1037]=t("a",{id:"Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.ninputs")],-1)),e[1038]||(e[1038]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1040]||(e[1040]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ninputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of inputs (dimensions + symbols) of the given affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1039]||(e[1039]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L166-L170",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",si,[t("summary",null,[e[1041]||(e[1041]=t("a",{id:"Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.IntegerSet}",href:"#Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.IntegerSet}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.ninputs")],-1)),e[1042]||(e[1042]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1044]||(e[1044]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ninputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of inputs (dimensions + symbols) in the given set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1043]||(e[1043]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L88-L92",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ai,[t("summary",null,[e[1045]||(e[1045]=t("a",{id:"Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.ninputs")],-1)),e[1046]||(e[1046]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1048]||(e[1048]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ninputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of input types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1047]||(e[1047]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L688-L692",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ii,[t("summary",null,[e[1049]||(e[1049]=t("a",{id:"Reactant.MLIR.IR.nnestedrefs-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.nnestedrefs-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.nnestedrefs")],-1)),e[1050]||(e[1050]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1052]||(e[1052]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nnestedrefs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the number of references nested in the given symbol reference attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1051]||(e[1051]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L334-L338",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",li,[t("summary",null,[e[1053]||(e[1053]=t("a",{id:"Reactant.MLIR.IR.noperands-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.noperands-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.noperands")],-1)),e[1054]||(e[1054]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1056]||(e[1056]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">noperands</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of operands of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1055]||(e[1055]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L120-L124",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ni,[t("summary",null,[e[1057]||(e[1057]=t("a",{id:"Reactant.MLIR.IR.nregions-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.nregions-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.nregions")],-1)),e[1058]||(e[1058]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1060]||(e[1060]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nregions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of regions attached to the given operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1059]||(e[1059]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L85-L89",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ri,[t("summary",null,[e[1061]||(e[1061]=t("a",{id:"Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.nresults")],-1)),e[1062]||(e[1062]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1064]||(e[1064]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nresults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of results of the given affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1063]||(e[1063]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L152-L156",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",oi,[t("summary",null,[e[1065]||(e[1065]=t("a",{id:"Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.nresults")],-1)),e[1066]||(e[1066]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1068]||(e[1068]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nresults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of results of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1067]||(e[1067]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L102-L106",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pi,[t("summary",null,[e[1069]||(e[1069]=t("a",{id:"Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.nresults")],-1)),e[1070]||(e[1070]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1072]||(e[1072]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nresults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of result types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1071]||(e[1071]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L698-L702",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",di,[t("summary",null,[e[1073]||(e[1073]=t("a",{id:"Reactant.MLIR.IR.nsuccessors-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.nsuccessors-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.nsuccessors")],-1)),e[1074]||(e[1074]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1076]||(e[1076]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nsuccessors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of successor blocks of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1075]||(e[1075]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L155-L159",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ui,[t("summary",null,[e[1077]||(e[1077]=t("a",{id:"Reactant.MLIR.IR.nsymbols-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Reactant.MLIR.IR.nsymbols-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.nsymbols")],-1)),e[1078]||(e[1078]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1080]||(e[1080]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nsymbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of symbols of the given affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1079]||(e[1079]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L145-L149",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bi,[t("summary",null,[e[1081]||(e[1081]=t("a",{id:"Reactant.MLIR.IR.nsymbols-Tuple{Reactant.MLIR.IR.IntegerSet}",href:"#Reactant.MLIR.IR.nsymbols-Tuple{Reactant.MLIR.IR.IntegerSet}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.nsymbols")],-1)),e[1082]||(e[1082]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1084]||(e[1084]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nsymbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of symbols in the given set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1083]||(e[1083]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IntegerSet.jl#L81-L85",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ci,[t("summary",null,[e[1085]||(e[1085]=t("a",{id:"Reactant.MLIR.IR.op_owner-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.IR.op_owner-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.op_owner")],-1)),e[1086]||(e[1086]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1088]||(e[1088]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">op_owner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns an operation that produced this value as its result. Asserts if the value is not an op result.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1087]||(e[1087]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Value.jl#L45-L49",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hi,[t("summary",null,[e[1089]||(e[1089]=t("a",{id:"Reactant.MLIR.IR.op_res_num-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.IR.op_res_num-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.op_res_num")],-1)),e[1090]||(e[1090]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1092]||(e[1092]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">op_res_num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the position of the value in the list of results of the operation that produced it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1091]||(e[1091]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Value.jl#L79-L83",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yi,[t("summary",null,[e[1093]||(e[1093]=t("a",{id:"Reactant.MLIR.IR.operand",href:"#Reactant.MLIR.IR.operand"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.operand")],-1)),e[1094]||(e[1094]=i()),a(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[1096]||(e[1096]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">operand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, i)</span></span></code></pre></div><p>Returns <code>i</code>-th operand of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1095]||(e[1095]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L127-L131",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gi,[t("summary",null,[e[1097]||(e[1097]=t("a",{id:"Reactant.MLIR.IR.operand!-Tuple{Reactant.MLIR.IR.Operation, Any, Any}",href:"#Reactant.MLIR.IR.operand!-Tuple{Reactant.MLIR.IR.Operation, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.operand!")],-1)),e[1098]||(e[1098]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1100]||(e[1100]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">operand!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, i, value)</span></span></code></pre></div><p>Sets the <code>i</code>-th operand of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1099]||(e[1099]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L144-L148",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mi,[t("summary",null,[e[1101]||(e[1101]=t("a",{id:"Reactant.MLIR.IR.operandindex-Tuple{Reactant.MLIR.IR.OpOperand}",href:"#Reactant.MLIR.IR.operandindex-Tuple{Reactant.MLIR.IR.OpOperand}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.operandindex")],-1)),e[1102]||(e[1102]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1104]||(e[1104]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">operandindex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns the operand number of an op operand.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1103]||(e[1103]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/OpOperand.jl#L30-L34",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ki,[t("summary",null,[e[1105]||(e[1105]=t("a",{id:"Reactant.MLIR.IR.operands-Tuple{Any}",href:"#Reactant.MLIR.IR.operands-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.operands")],-1)),e[1106]||(e[1106]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1108]||(e[1108]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">operands</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Return an array of all operands of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1107]||(e[1107]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L137-L141",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ri,[t("summary",null,[e[1109]||(e[1109]=t("a",{id:"Reactant.MLIR.IR.owner-Tuple{Reactant.MLIR.IR.OpOperand}",href:"#Reactant.MLIR.IR.owner-Tuple{Reactant.MLIR.IR.OpOperand}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.owner")],-1)),e[1110]||(e[1110]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1112]||(e[1112]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">owner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns the owner operation of an op operand.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1111]||(e[1111]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/OpOperand.jl#L23-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fi,[t("summary",null,[e[1113]||(e[1113]=t("a",{id:"Reactant.MLIR.IR.parent_op-Tuple{Reactant.MLIR.IR.Block}",href:"#Reactant.MLIR.IR.parent_op-Tuple{Reactant.MLIR.IR.Block}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.parent_op")],-1)),e[1114]||(e[1114]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1116]||(e[1116]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parent_op</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the closest surrounding operation that contains this block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1115]||(e[1115]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L36-L40",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ii,[t("summary",null,[e[1117]||(e[1117]=t("a",{id:"Reactant.MLIR.IR.parent_op-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.parent_op-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.parent_op")],-1)),e[1118]||(e[1118]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1120]||(e[1120]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parent_op</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the operation that owns this operation, returning null if the operation is not owned.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1119]||(e[1119]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L63-L67",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ti,[t("summary",null,[e[1121]||(e[1121]=t("a",{id:"Reactant.MLIR.IR.parent_region-Tuple{Reactant.MLIR.IR.Block}",href:"#Reactant.MLIR.IR.parent_region-Tuple{Reactant.MLIR.IR.Block}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.parent_region")],-1)),e[1122]||(e[1122]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1124]||(e[1124]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parent_region</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the region that contains this block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1123]||(e[1123]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L43-L47",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ai,[t("summary",null,[e[1125]||(e[1125]=t("a",{id:"Reactant.MLIR.IR.pass_pipeline-Tuple{Reactant.MLIR.IR.OpPassManager}",href:"#Reactant.MLIR.IR.pass_pipeline-Tuple{Reactant.MLIR.IR.OpPassManager}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.pass_pipeline")],-1)),e[1126]||(e[1126]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1128]||(e[1128]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pass_pipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opPassManager) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span></span></code></pre></div><p>Returns the pass pipeline.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1127]||(e[1127]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L205-L209",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ji,[t("summary",null,[e[1129]||(e[1129]=t("a",{id:"Reactant.MLIR.IR.position-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.position-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.position")],-1)),e[1130]||(e[1130]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1132]||(e[1132]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">position</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the position of the given affine dimension expression, affine symbol expression or ...</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1131]||(e[1131]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L92-L96",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_i,[t("summary",null,[e[1133]||(e[1133]=t("a",{id:"Reactant.MLIR.IR.print_pass_pipeline-Tuple{IO, Reactant.MLIR.IR.OpPassManager}",href:"#Reactant.MLIR.IR.print_pass_pipeline-Tuple{IO, Reactant.MLIR.IR.OpPassManager}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.print_pass_pipeline")],-1)),e[1134]||(e[1134]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1136]||(e[1136]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print_pass_pipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(io</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, opPassManager)</span></span></code></pre></div><p>Prints the pass pipeline to the IO.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1135]||(e[1135]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L212-L216",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mi,[t("summary",null,[e[1137]||(e[1137]=t("a",{id:"Reactant.MLIR.IR.push_argument!-Tuple{Reactant.MLIR.IR.Block, Any}",href:"#Reactant.MLIR.IR.push_argument!-Tuple{Reactant.MLIR.IR.Block, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.push_argument!")],-1)),e[1138]||(e[1138]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1140]||(e[1140]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">push_argument!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, type; location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Appends an argument of the specified type to the block. Returns the newly added argument.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1139]||(e[1139]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L80-L84",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ei,[t("summary",null,[e[1141]||(e[1141]=t("a",{id:"Reactant.MLIR.IR.region-Tuple{Reactant.MLIR.IR.Operation, Any}",href:"#Reactant.MLIR.IR.region-Tuple{Reactant.MLIR.IR.Operation, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.region")],-1)),e[1142]||(e[1142]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1144]||(e[1144]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">region</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, i)</span></span></code></pre></div><p>Returns <code>i</code>-th region attached to the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1143]||(e[1143]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L92-L96",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Li,[t("summary",null,[e[1145]||(e[1145]=t("a",{id:"Reactant.MLIR.IR.result",href:"#Reactant.MLIR.IR.result"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.result")],-1)),e[1146]||(e[1146]=i()),a(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[1148]||(e[1148]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, i)</span></span></code></pre></div><p>Returns the <code>i</code>-th result type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1147]||(e[1147]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L718-L722",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ci,[t("summary",null,[e[1149]||(e[1149]=t("a",{id:"Reactant.MLIR.IR.result-2",href:"#Reactant.MLIR.IR.result-2"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.result")],-1)),e[1150]||(e[1150]=i()),a(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[1152]||(e[1152]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, i)</span></span></code></pre></div><p>Returns <code>i</code>-th result of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1151]||(e[1151]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L109-L113",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vi,[t("summary",null,[e[1153]||(e[1153]=t("a",{id:"Reactant.MLIR.IR.result-Tuple{Reactant.MLIR.IR.AffineMap, Any}",href:"#Reactant.MLIR.IR.result-Tuple{Reactant.MLIR.IR.AffineMap, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.result")],-1)),e[1154]||(e[1154]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1156]||(e[1156]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, pos)</span></span></code></pre></div><p>Returns the result at the given position.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1155]||(e[1155]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L159-L163",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pi,[t("summary",null,[e[1157]||(e[1157]=t("a",{id:"Reactant.MLIR.IR.result-Tuple{Reactant.MLIR.IR.AffineMap}",href:"#Reactant.MLIR.IR.result-Tuple{Reactant.MLIR.IR.AffineMap}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.result")],-1)),e[1158]||(e[1158]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1160]||(e[1160]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the constant result of the given affine map. The function asserts that the map has a single constant result.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1159]||(e[1159]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L128-L132",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xi,[t("summary",null,[e[1161]||(e[1161]=t("a",{id:"Reactant.MLIR.IR.rhs-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.rhs-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.rhs")],-1)),e[1162]||(e[1162]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1164]||(e[1164]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the right hand side affine expression of the given affine binary operation expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1163]||(e[1163]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L225-L229",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Si,[t("summary",null,[e[1165]||(e[1165]=t("a",{id:"Reactant.MLIR.IR.rmattr!-Tuple{Reactant.MLIR.IR.Operation, Any}",href:"#Reactant.MLIR.IR.rmattr!-Tuple{Reactant.MLIR.IR.Operation, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.rmattr!")],-1)),e[1166]||(e[1166]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1168]||(e[1168]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rmattr!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Removes an attribute by name. Returns false if the attribute was not found and true if removed.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1167]||(e[1167]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L212-L216",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Di,[t("summary",null,[e[1169]||(e[1169]=t("a",{id:"Reactant.MLIR.IR.rmfromparent!-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.rmfromparent!-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.rmfromparent!")],-1)),e[1170]||(e[1170]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1172]||(e[1172]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rmfromparent!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Removes the given operation from its parent block. The operation is not destroyed. The ownership of the operation is transferred to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1171]||(e[1171]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L71-L76",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fi,[t("summary",null,[e[1173]||(e[1173]=t("a",{id:"Reactant.MLIR.IR.rootref-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.rootref-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.rootref")],-1)),e[1174]||(e[1174]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1176]||(e[1176]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rootref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the string reference to the root referenced symbol. The data remains live as long as the context in which the attribute lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1175]||(e[1175]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L314-L318",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vi,[t("summary",null,[e[1177]||(e[1177]=t("a",{id:"Reactant.MLIR.IR.run!",href:"#Reactant.MLIR.IR.run!"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.run!")],-1)),e[1178]||(e[1178]=i()),a(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[1180]||(e[1180]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">run!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Run the provided <code>passManager</code> on the given <code>module</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1179]||(e[1179]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Pass.jl#L145-L149",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Oi,[t("summary",null,[e[1181]||(e[1181]=t("a",{id:"Reactant.MLIR.IR.submap-Tuple{Reactant.MLIR.IR.AffineMap, Vector{Int64}}",href:"#Reactant.MLIR.IR.submap-Tuple{Reactant.MLIR.IR.AffineMap, Vector{Int64}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.submap")],-1)),e[1182]||(e[1182]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1184]||(e[1184]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">submap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, positions)</span></span></code></pre></div><p>Returns the affine map consisting of the <code>positions</code> subset.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1183]||(e[1183]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L187-L191",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bi,[t("summary",null,[e[1185]||(e[1185]=t("a",{id:"Reactant.MLIR.IR.success-Tuple{}",href:"#Reactant.MLIR.IR.success-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.success")],-1)),e[1186]||(e[1186]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1188]||(e[1188]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">success</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a logical result representing a success.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1187]||(e[1187]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/LogicalResult.jl#L14-L18",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ni,[t("summary",null,[e[1189]||(e[1189]=t("a",{id:"Reactant.MLIR.IR.successor-Tuple{Reactant.MLIR.IR.Operation, Any}",href:"#Reactant.MLIR.IR.successor-Tuple{Reactant.MLIR.IR.Operation, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.successor")],-1)),e[1190]||(e[1190]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1192]||(e[1192]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">successor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, i)</span></span></code></pre></div><p>Returns <code>i</code>-th successor of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1191]||(e[1191]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L162-L166",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gi,[t("summary",null,[e[1193]||(e[1193]=t("a",{id:"Reactant.MLIR.IR.terminator-Tuple{Reactant.MLIR.IR.Block}",href:"#Reactant.MLIR.IR.terminator-Tuple{Reactant.MLIR.IR.Block}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.terminator")],-1)),e[1194]||(e[1194]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1196]||(e[1196]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">terminator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the terminator operation in the block or <code>nothing</code> if no terminator.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1195]||(e[1195]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Block.jl#L113-L117",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zi,[t("summary",null,[e[1197]||(e[1197]=t("a",{id:"Reactant.MLIR.IR.type!-Tuple{Any, Any}",href:"#Reactant.MLIR.IR.type!-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.type!")],-1)),e[1198]||(e[1198]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1200]||(e[1200]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_type!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, type)</span></span></code></pre></div><p>Sets the type of the block argument to the given type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1199]||(e[1199]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Value.jl#L106-L110",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wi,[t("summary",null,[e[1201]||(e[1201]=t("a",{id:"Reactant.MLIR.IR.type-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.type-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.type")],-1)),e[1202]||(e[1202]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1204]||(e[1204]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the type of this attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1203]||(e[1203]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L36-L40",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ui,[t("summary",null,[e[1205]||(e[1205]=t("a",{id:"Reactant.MLIR.IR.type-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.IR.type-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.type")],-1)),e[1206]||(e[1206]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1208]||(e[1208]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the type of the value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1207]||(e[1207]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Value.jl#L99-L103",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qi,[t("summary",null,[e[1209]||(e[1209]=t("a",{id:"Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Attribute}",href:"#Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Attribute}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.typeid")],-1)),e[1210]||(e[1210]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1212]||(e[1212]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">typeid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the type id of the attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1211]||(e[1211]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Attribute.jl#L43-L47",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qi,[t("summary",null,[e[1213]||(e[1213]=t("a",{id:"Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.typeid")],-1)),e[1214]||(e[1214]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1216]||(e[1216]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">typeid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the type id of the operation. Returns null if the operation does not have a registered operation description.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1215]||(e[1215]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L42-L46",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wi,[t("summary",null,[e[1217]||(e[1217]=t("a",{id:"Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Type}",href:"#Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Type}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.typeid")],-1)),e[1218]||(e[1218]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1220]||(e[1220]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">typeid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the type ID of the type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1219]||(e[1219]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Type.jl#L34-L38",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zi,[t("summary",null,[e[1221]||(e[1221]=t("a",{id:"Reactant.MLIR.IR.value-Tuple{Reactant.MLIR.IR.AffineExpr}",href:"#Reactant.MLIR.IR.value-Tuple{Reactant.MLIR.IR.AffineExpr}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.value")],-1)),e[1222]||(e[1222]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1224]||(e[1224]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the value of the given affine constant expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1223]||(e[1223]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineExpr.jl#L126-L130",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hi,[t("summary",null,[e[1225]||(e[1225]=t("a",{id:"Reactant.MLIR.IR.verify-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.verify-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.verify")],-1)),e[1226]||(e[1226]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1228]||(e[1228]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">verify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Verify the operation and return true if it passes, false if it fails.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1227]||(e[1227]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/Operation.jl#L269-L273",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ji,[t("summary",null,[e[1229]||(e[1229]=t("a",{id:"Reactant.MLIR.IR.verifyall-Tuple{Reactant.MLIR.IR.Operation}",href:"#Reactant.MLIR.IR.verifyall-Tuple{Reactant.MLIR.IR.Operation}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.verifyall")],-1)),e[1230]||(e[1230]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1232]||(e[1232]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">verifyall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(operation; debug</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Prints the operations which could not be verified.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1231]||(e[1231]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/IR.jl#L117-L121",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ki,[t("summary",null,[e[1233]||(e[1233]=t("a",{id:"Reactant.MLIR.IR.@affinemap-Tuple{Any}",href:"#Reactant.MLIR.IR.@affinemap-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.IR.@affinemap")],-1)),e[1234]||(e[1234]=i()),a(s,{type:"info",class:"jlObjectType jlMacro",text:"Macro"})]),e[1236]||(e[1236]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@affinemap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (d1, d2, d3, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[s1, s2, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (d0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d1, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Returns an affine map from the provided Julia expression. On the right hand side are allowed the following function calls:</p><ul><li>+, *, ÷, %, fld, cld</li></ul><p>The rhs can only contains dimensions and symbols present on the left hand side or integer literals.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Reactant</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MLIR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> IR</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> IR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(IR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           IR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@affinemap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (d1, d2)[s0] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (d1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s0, d2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       end</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MLIR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">IR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#= (d0, d1)[s0] -&gt; (d0 + s0, d1 mod 10) =#</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1235]||(e[1235]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/IR/AffineMap.jl#L249-L267",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[4614]||(e[4614]=t("h1",{id:"MLIR-C-API",tabindex:"-1"},[i("MLIR C API "),t("a",{class:"header-anchor",href:"#MLIR-C-API","aria-label":'Permalink to "MLIR C API {#MLIR-C-API}"'},"​")],-1)),t("details",$i,[t("summary",null,[e[1237]||(e[1237]=t("a",{id:"Reactant.MLIR.API.LLVMAttributeRef",href:"#Reactant.MLIR.API.LLVMAttributeRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMAttributeRef")],-1)),e[1238]||(e[1238]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1240]||(e[1240]=t("p",null,"Used to represent an attributes.",-1)),e[1241]||(e[1241]=t("p",null,[t("strong",null,"See also")],-1)),e[1242]||(e[1242]=t("p",null,"llvm::Attribute",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1239]||(e[1239]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9926-L9931",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xi,[t("summary",null,[e[1243]||(e[1243]=t("a",{id:"Reactant.MLIR.API.LLVMBasicBlockRef",href:"#Reactant.MLIR.API.LLVMBasicBlockRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMBasicBlockRef")],-1)),e[1244]||(e[1244]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1246]||(e[1246]=t("p",null,"Represents a basic block of instructions in LLVM IR.",-1)),e[1247]||(e[1247]=t("p",null,"This models llvm::BasicBlock.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1245]||(e[1245]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9839-L9843",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yi,[t("summary",null,[e[1248]||(e[1248]=t("a",{id:"Reactant.MLIR.API.LLVMBinaryRef",href:"#Reactant.MLIR.API.LLVMBinaryRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMBinaryRef")],-1)),e[1249]||(e[1249]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1251]||(e[1251]=t("p",null,[t("strong",null,"See also")],-1)),e[1252]||(e[1252]=t("p",null,"llvm::object::Binary",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1250]||(e[1250]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9968-L9971",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",el,[t("summary",null,[e[1253]||(e[1253]=t("a",{id:"Reactant.MLIR.API.LLVMBool",href:"#Reactant.MLIR.API.LLVMBool"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMBool")],-1)),e[1254]||(e[1254]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1256]||(e[1256]=t("p",null,[t("code",null,"LLVMCSupportTypes Types and Enumerations")],-1)),e[1257]||(e[1257]=t("p",null,"@{",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1255]||(e[1255]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9784-L9788",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",tl,[t("summary",null,[e[1258]||(e[1258]=t("a",{id:"Reactant.MLIR.API.LLVMBuilderRef",href:"#Reactant.MLIR.API.LLVMBuilderRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMBuilderRef")],-1)),e[1259]||(e[1259]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1261]||(e[1261]=t("p",null,"Represents an LLVM basic block builder.",-1)),e[1262]||(e[1262]=t("p",null,"This models llvm::IRBuilder.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1260]||(e[1260]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9875-L9879",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sl,[t("summary",null,[e[1263]||(e[1263]=t("a",{id:"Reactant.MLIR.API.LLVMComdatRef",href:"#Reactant.MLIR.API.LLVMComdatRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMComdatRef")],-1)),e[1264]||(e[1264]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1266]||(e[1266]=t("p",null,[t("strong",null,"See also")],-1)),e[1267]||(e[1267]=t("p",null,"llvm::Comdat",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1265]||(e[1265]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9944-L9947",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",al,[t("summary",null,[e[1268]||(e[1268]=t("a",{id:"Reactant.MLIR.API.LLVMContextRef",href:"#Reactant.MLIR.API.LLVMContextRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMContextRef")],-1)),e[1269]||(e[1269]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1271]||(e[1271]=t("p",null,"The top-level container for all LLVM global data. See the LLVMContext class.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1270]||(e[1270]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9803-L9805",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",il,[t("summary",null,[e[1272]||(e[1272]=t("a",{id:"Reactant.MLIR.API.LLVMDIBuilderRef",href:"#Reactant.MLIR.API.LLVMDIBuilderRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMDIBuilderRef")],-1)),e[1273]||(e[1273]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1275]||(e[1275]=t("p",null,"Represents an LLVM debug info builder.",-1)),e[1276]||(e[1276]=t("p",null,"This models llvm::DIBuilder.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1274]||(e[1274]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9884-L9888",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ll,[t("summary",null,[e[1277]||(e[1277]=t("a",{id:"Reactant.MLIR.API.LLVMDbgRecordRef",href:"#Reactant.MLIR.API.LLVMDbgRecordRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMDbgRecordRef")],-1)),e[1278]||(e[1278]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1280]||(e[1280]=t("p",null,[t("strong",null,"See also")],-1)),e[1281]||(e[1281]=t("p",null,"llvm::DbgRecord",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1279]||(e[1279]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9976-L9979",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",nl,[t("summary",null,[e[1282]||(e[1282]=t("a",{id:"Reactant.MLIR.API.LLVMDiagnosticInfoRef",href:"#Reactant.MLIR.API.LLVMDiagnosticInfoRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMDiagnosticInfoRef")],-1)),e[1283]||(e[1283]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1285]||(e[1285]=t("p",null,[t("strong",null,"See also")],-1)),e[1286]||(e[1286]=t("p",null,"llvm::DiagnosticInfo",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1284]||(e[1284]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9936-L9939",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rl,[t("summary",null,[e[1287]||(e[1287]=t("a",{id:"Reactant.MLIR.API.LLVMJITEventListenerRef",href:"#Reactant.MLIR.API.LLVMJITEventListenerRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMJITEventListenerRef")],-1)),e[1288]||(e[1288]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1290]||(e[1290]=t("p",null,[t("strong",null,"See also")],-1)),e[1291]||(e[1291]=t("p",null,"llvm::JITEventListener",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1289]||(e[1289]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9960-L9963",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ol,[t("summary",null,[e[1292]||(e[1292]=t("a",{id:"Reactant.MLIR.API.LLVMMemoryBufferRef",href:"#Reactant.MLIR.API.LLVMMemoryBufferRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMMemoryBufferRef")],-1)),e[1293]||(e[1293]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1295]||(e[1295]=t("p",null,"Used to pass regions of memory through LLVM interfaces.",-1)),e[1296]||(e[1296]=t("p",null,[t("strong",null,"See also")],-1)),e[1297]||(e[1297]=t("p",null,"llvm::MemoryBuffer",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1294]||(e[1294]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9793-L9798",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pl,[t("summary",null,[e[1298]||(e[1298]=t("a",{id:"Reactant.MLIR.API.LLVMMetadataRef",href:"#Reactant.MLIR.API.LLVMMetadataRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMMetadataRef")],-1)),e[1299]||(e[1299]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1301]||(e[1301]=t("p",null,"Represents an LLVM Metadata.",-1)),e[1302]||(e[1302]=t("p",null,"This models llvm::Metadata.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1300]||(e[1300]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9848-L9852",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dl,[t("summary",null,[e[1303]||(e[1303]=t("a",{id:"Reactant.MLIR.API.LLVMModuleFlagEntry",href:"#Reactant.MLIR.API.LLVMModuleFlagEntry"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMModuleFlagEntry")],-1)),e[1304]||(e[1304]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1306]||(e[1306]=t("p",null,[t("strong",null,"See also")],-1)),e[1307]||(e[1307]=t("p",null,"llvm::Module::ModuleFlagEntry",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1305]||(e[1305]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9952-L9955",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ul,[t("summary",null,[e[1308]||(e[1308]=t("a",{id:"Reactant.MLIR.API.LLVMModuleProviderRef",href:"#Reactant.MLIR.API.LLVMModuleProviderRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMModuleProviderRef")],-1)),e[1309]||(e[1309]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1311]||(e[1311]=t("p",null,"Interface used to provide a module to JIT or interpreter. This is now just a synonym for llvm::Module, but we have to keep using the different type to keep binary compatibility.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1310]||(e[1310]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9893-L9895",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bl,[t("summary",null,[e[1312]||(e[1312]=t("a",{id:"Reactant.MLIR.API.LLVMModuleRef",href:"#Reactant.MLIR.API.LLVMModuleRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMModuleRef")],-1)),e[1313]||(e[1313]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1315]||(e[1315]=t("p",null,"The top-level container for all other LLVM Intermediate Representation (IR) objects.",-1)),e[1316]||(e[1316]=t("p",null,[t("strong",null,"See also")],-1)),e[1317]||(e[1317]=t("p",null,"llvm::Module",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1314]||(e[1314]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9810-L9815",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cl,[t("summary",null,[e[1318]||(e[1318]=t("a",{id:"Reactant.MLIR.API.LLVMNamedMDNodeRef",href:"#Reactant.MLIR.API.LLVMNamedMDNodeRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMNamedMDNodeRef")],-1)),e[1319]||(e[1319]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1321]||(e[1321]=t("p",null,"Represents an LLVM Named Metadata Node.",-1)),e[1322]||(e[1322]=t("p",null,"This models llvm::NamedMDNode.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1320]||(e[1320]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9857-L9861",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hl,[t("summary",null,[e[1323]||(e[1323]=t("a",{id:"Reactant.MLIR.API.LLVMOperandBundleRef",href:"#Reactant.MLIR.API.LLVMOperandBundleRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMOperandBundleRef")],-1)),e[1324]||(e[1324]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1326]||(e[1326]=t("p",null,[t("strong",null,"See also")],-1)),e[1327]||(e[1327]=t("p",null,"llvm::OperandBundleDef",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1325]||(e[1325]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9918-L9921",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yl,[t("summary",null,[e[1328]||(e[1328]=t("a",{id:"Reactant.MLIR.API.LLVMPassManagerRef",href:"#Reactant.MLIR.API.LLVMPassManagerRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMPassManagerRef")],-1)),e[1329]||(e[1329]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1331]||(e[1331]=t("p",null,[t("strong",null,"See also")],-1)),e[1332]||(e[1332]=t("p",null,"llvm::PassManagerBase",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1330]||(e[1330]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9900-L9903",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gl,[t("summary",null,[e[1333]||(e[1333]=t("a",{id:"Reactant.MLIR.API.LLVMTypeRef",href:"#Reactant.MLIR.API.LLVMTypeRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMTypeRef")],-1)),e[1334]||(e[1334]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1336]||(e[1336]=t("p",null,[i("Each value in the LLVM IR has a type, an "),t("a",{href:"/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.LLVMTypeRef"},[t("code",null,"LLVMTypeRef")]),i(".")],-1)),e[1337]||(e[1337]=t("p",null,[t("strong",null,"See also")],-1)),e[1338]||(e[1338]=t("p",null,"llvm::Type",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1335]||(e[1335]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9820-L9825",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ml,[t("summary",null,[e[1339]||(e[1339]=t("a",{id:"Reactant.MLIR.API.LLVMUseRef",href:"#Reactant.MLIR.API.LLVMUseRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMUseRef")],-1)),e[1340]||(e[1340]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1342]||(e[1342]=t("p",null,"Used to get the users and usees of a Value.",-1)),e[1343]||(e[1343]=t("p",null,[t("strong",null,"See also")],-1)),e[1344]||(e[1344]=t("p",null,"llvm::Use",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1341]||(e[1341]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9908-L9913",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",kl,[t("summary",null,[e[1345]||(e[1345]=t("a",{id:"Reactant.MLIR.API.LLVMValueMetadataEntry",href:"#Reactant.MLIR.API.LLVMValueMetadataEntry"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMValueMetadataEntry")],-1)),e[1346]||(e[1346]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1348]||(e[1348]=t("p",null,"Represents an entry in a Global Object's metadata attachments.",-1)),e[1349]||(e[1349]=t("p",null,"This models std::pair<unsigned, MDNode *>",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1347]||(e[1347]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9866-L9870",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rl,[t("summary",null,[e[1350]||(e[1350]=t("a",{id:"Reactant.MLIR.API.LLVMValueRef",href:"#Reactant.MLIR.API.LLVMValueRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.LLVMValueRef")],-1)),e[1351]||(e[1351]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1353]||(e[1353]=t("p",null,"Represents an individual value in LLVM IR.",-1)),e[1354]||(e[1354]=t("p",null,"This models llvm::Value.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1352]||(e[1352]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9830-L9834",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fl,[t("summary",null,[e[1355]||(e[1355]=t("a",{id:"Reactant.MLIR.API.MlirDiagnostic",href:"#Reactant.MLIR.API.MlirDiagnostic"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirDiagnostic")],-1)),e[1356]||(e[1356]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1358]||(e[1358]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirDiagnostic</span></span></code></pre></div><p>An opaque reference to a diagnostic, always owned by the diagnostics engine (context). Must not be stored outside of the diagnostic handler.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1357]||(e[1357]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6257-L6261",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Il,[t("summary",null,[e[1359]||(e[1359]=t("a",{id:"Reactant.MLIR.API.MlirDiagnosticHandler",href:"#Reactant.MLIR.API.MlirDiagnosticHandler"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirDiagnosticHandler")],-1)),e[1360]||(e[1360]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1362]||(e[1362]=t("p",null,[i("Diagnostic handler type. Accepts a reference to a diagnostic, which is only guaranteed to be live during the call. The handler is passed the "),t("code",null,"userData"),i(" that was provided when the handler was attached to a context. If the handler processed the diagnostic completely, it is expected to return success. Otherwise, it is expected to return failure to indicate that other handlers should attempt to process the diagnostic.")],-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1361]||(e[1361]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6284-L6286",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Tl,[t("summary",null,[e[1363]||(e[1363]=t("a",{id:"Reactant.MLIR.API.MlirDiagnosticHandlerID",href:"#Reactant.MLIR.API.MlirDiagnosticHandlerID"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirDiagnosticHandlerID")],-1)),e[1364]||(e[1364]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1366]||(e[1366]=t("p",null,"Opaque identifier of a diagnostic handler, useful to detach a handler.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1365]||(e[1365]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6278-L6280",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Al,[t("summary",null,[e[1367]||(e[1367]=t("a",{id:"Reactant.MLIR.API.MlirDiagnosticSeverity",href:"#Reactant.MLIR.API.MlirDiagnosticSeverity"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirDiagnosticSeverity")],-1)),e[1368]||(e[1368]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1370]||(e[1370]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirDiagnosticSeverity</span></span></code></pre></div><p>Severity of a diagnostic.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1369]||(e[1369]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6266-L6270",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jl,[t("summary",null,[e[1371]||(e[1371]=t("a",{id:"Reactant.MLIR.API.MlirExternalPassCallbacks",href:"#Reactant.MLIR.API.MlirExternalPassCallbacks"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirExternalPassCallbacks")],-1)),e[1372]||(e[1372]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1374]||(e[1374]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirExternalPassCallbacks</span></span></code></pre></div><p>Structure of external <a href="./@ref"><code>MlirPass</code></a> callbacks. All callbacks are required to be set unless otherwise specified.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Field</th><th style="text-align:left;">Note</th></tr></thead><tbody><tr><td style="text-align:left;">construct</td><td style="text-align:left;">This callback is called from the pass is created. This is analogous to a C++ pass constructor.</td></tr><tr><td style="text-align:left;">destruct</td><td style="text-align:left;">This callback is called when the pass is destroyed This is analogous to a C++ pass destructor.</td></tr><tr><td style="text-align:left;">initialize</td><td style="text-align:left;">This callback is optional. The callback is called before the pass is run, allowing a chance to initialize any complex state necessary for running the pass. See Pass::initialize(MLIRContext *).</td></tr><tr><td style="text-align:left;">clone</td><td style="text-align:left;">This callback is called when the pass is cloned. See Pass::clonePass().</td></tr><tr><td style="text-align:left;">run</td><td style="text-align:left;">This callback is called when the pass is run. See Pass::runOnOperation().</td></tr></tbody></table>',3)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1373]||(e[1373]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9107-L9119",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_l,[t("summary",null,[e[1375]||(e[1375]=t("a",{id:"Reactant.MLIR.API.MlirLlvmThreadPool",href:"#Reactant.MLIR.API.MlirLlvmThreadPool"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirLlvmThreadPool")],-1)),e[1376]||(e[1376]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1378]||(e[1378]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirLlvmThreadPool</span></span></code></pre></div><p>Re-export llvm::ThreadPool so as to avoid including the LLVM C API directly.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1377]||(e[1377]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L46-L50",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ml,[t("summary",null,[e[1379]||(e[1379]=t("a",{id:"Reactant.MLIR.API.MlirLogicalResult",href:"#Reactant.MLIR.API.MlirLogicalResult"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirLogicalResult")],-1)),e[1380]||(e[1380]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1382]||(e[1382]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirLogicalResult</span></span></code></pre></div><p>A logical result value, essentially a boolean with named states. LLVM convention for using boolean values to designate success or failure of an operation is a moving target, so MLIR opted for an explicit class. Instances of <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.MlirLogicalResult"><code>MlirLogicalResult</code></a> must only be inspected using the associated functions.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1381]||(e[1381]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L113-L117",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",El,[t("summary",null,[e[1383]||(e[1383]=t("a",{id:"Reactant.MLIR.API.MlirNamedAttribute",href:"#Reactant.MLIR.API.MlirNamedAttribute"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirNamedAttribute")],-1)),e[1384]||(e[1384]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1386]||(e[1386]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirNamedAttribute</span></span></code></pre></div><p>Named MLIR attribute.</p><p>A named attribute is essentially a (name, attribute) pair where the name is a string.</p>',3)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1385]||(e[1385]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L309-L315",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ll,[t("summary",null,[e[1387]||(e[1387]=t("a",{id:"Reactant.MLIR.API.MlirOperationState",href:"#Reactant.MLIR.API.MlirOperationState"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirOperationState")],-1)),e[1388]||(e[1388]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1390]||(e[1390]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirOperationState</span></span></code></pre></div><p>An auxiliary class for constructing operations.</p><p>This class contains all the information necessary to construct the operation. It owns the MlirRegions it has pointers to and does not own anything else. By default, the state can be constructed from a name and location, the latter being also used to access the context, and has no other components. These components can be added progressively until the operation is constructed. Users are not expected to rely on the internals of this class and should use mlirOperationState* functions instead.</p>',3)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1389]||(e[1389]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1017-L1023",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Cl,[t("summary",null,[e[1391]||(e[1391]=t("a",{id:"Reactant.MLIR.API.MlirOperationWalkCallback",href:"#Reactant.MLIR.API.MlirOperationWalkCallback"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirOperationWalkCallback")],-1)),e[1392]||(e[1392]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1394]||(e[1394]=t("p",null,[i("Operation walker type. The handler is passed an (opaque) reference to an operation and a pointer to a "),t("code",null,"userData"),i(".")],-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1393]||(e[1393]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1780-L1782",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vl,[t("summary",null,[e[1395]||(e[1395]=t("a",{id:"Reactant.MLIR.API.MlirPassDisplayMode",href:"#Reactant.MLIR.API.MlirPassDisplayMode"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirPassDisplayMode")],-1)),e[1396]||(e[1396]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1398]||(e[1398]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirPassDisplayMode</span></span></code></pre></div><p>Enumerated type of pass display modes. Mainly used in <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirPassManagerEnableStatistics-Tuple{Any, Any}"><code>mlirPassManagerEnableStatistics</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1397]||(e[1397]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9003-L9007",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pl,[t("summary",null,[e[1399]||(e[1399]=t("a",{id:"Reactant.MLIR.API.MlirRewritePatternCallbacks",href:"#Reactant.MLIR.API.MlirRewritePatternCallbacks"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirRewritePatternCallbacks")],-1)),e[1400]||(e[1400]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1402]||(e[1402]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirRewritePatternCallbacks</span></span></code></pre></div><p>Callbacks to construct a rewrite pattern.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Field</th><th style="text-align:left;">Note</th></tr></thead><tbody><tr><td style="text-align:left;">construct</td><td style="text-align:left;">Optional constructor for the user data. Set to nullptr to disable it.</td></tr><tr><td style="text-align:left;">destruct</td><td style="text-align:left;">Optional destructor for the user data. Set to nullptr to disable it.</td></tr><tr><td style="text-align:left;">matchAndRewrite</td><td style="text-align:left;">The callback function to match against code rooted at the specified operation, and perform the rewrite if the match is successful, corresponding to RewritePattern::matchAndRewrite.</td></tr></tbody></table>',3)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1401]||(e[1401]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9690-L9700",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xl,[t("summary",null,[e[1403]||(e[1403]=t("a",{id:"Reactant.MLIR.API.MlirShapedTypeComponentsCallback",href:"#Reactant.MLIR.API.MlirShapedTypeComponentsCallback"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirShapedTypeComponentsCallback")],-1)),e[1404]||(e[1404]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1406]||(e[1406]=t("p",null,"These callbacks are used to return multiple shaped type components from functions while transferring ownership to the caller. The first argument is the has rank boolean followed by the the rank and a pointer to the shape (if applicable). The next argument is the element type, then the attribute. The last argument is an opaque pointer forwarded to the callback by the caller. This callback will be called potentially multiple times for each shaped type components.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1405]||(e[1405]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8842-L8844",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sl,[t("summary",null,[e[1407]||(e[1407]=t("a",{id:"Reactant.MLIR.API.MlirSparseTensorLevelType",href:"#Reactant.MLIR.API.MlirSparseTensorLevelType"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirSparseTensorLevelType")],-1)),e[1408]||(e[1408]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1410]||(e[1410]=t("p",null,"Dimension level types (and properties) that define sparse tensors. See the documentation in SparseTensorAttrDefs.td for their meaning.",-1)),e[1411]||(e[1411]=t("p",null,"These correspond to SparseTensorEncodingAttr::LevelType in the C++ API. If updating, keep them in sync and update the static_assert in the impl file.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1409]||(e[1409]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8317-L8321",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Dl,[t("summary",null,[e[1412]||(e[1412]=t("a",{id:"Reactant.MLIR.API.MlirStringCallback",href:"#Reactant.MLIR.API.MlirStringCallback"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirStringCallback")],-1)),e[1413]||(e[1413]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1415]||(e[1415]=t("p",null,"A callback for returning string references.",-1)),e[1416]||(e[1416]=t("p",null,[i("This function is called back by the functions that need to return a reference to the portion of the string with the following arguments: - an "),t("a",{href:"/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.MlirStringRef"},[t("code",null,"MlirStringRef")]),i(" representing the current portion of the string - a pointer to user data forwarded from the printing call.")],-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1414]||(e[1414]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L106-L110",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fl,[t("summary",null,[e[1417]||(e[1417]=t("a",{id:"Reactant.MLIR.API.MlirStringRef",href:"#Reactant.MLIR.API.MlirStringRef"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirStringRef")],-1)),e[1418]||(e[1418]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1420]||(e[1420]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirStringRef</span></span></code></pre></div><p>A pointer to a sized fragment of a string, not necessarily null-terminated. Does not own the underlying string. This is equivalent to llvm::StringRef.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Field</th><th style="text-align:left;">Note</th></tr></thead><tbody><tr><td style="text-align:left;">data</td><td style="text-align:left;">Pointer to the first symbol.</td></tr><tr><td style="text-align:left;">length</td><td style="text-align:left;">Length of the fragment.</td></tr></tbody></table>',3)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1419]||(e[1419]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L63-L72",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vl,[t("summary",null,[e[1421]||(e[1421]=t("a",{id:"Reactant.MLIR.API.MlirTypesCallback",href:"#Reactant.MLIR.API.MlirTypesCallback"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirTypesCallback")],-1)),e[1422]||(e[1422]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1424]||(e[1424]=t("p",null,"These callbacks are used to return multiple types from functions while transferring ownership to the caller. The first argument is the number of consecutive elements pointed to by the second argument. The third argument is an opaque pointer forwarded to the callback by the caller.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1423]||(e[1423]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8794-L8796",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ol,[t("summary",null,[e[1425]||(e[1425]=t("a",{id:"Reactant.MLIR.API.MlirWalkOrder",href:"#Reactant.MLIR.API.MlirWalkOrder"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirWalkOrder")],-1)),e[1426]||(e[1426]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1428]||(e[1428]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirWalkOrder</span></span></code></pre></div><p>Traversal order for operation walk.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1427]||(e[1427]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1769-L1773",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bl,[t("summary",null,[e[1429]||(e[1429]=t("a",{id:"Reactant.MLIR.API.MlirWalkResult",href:"#Reactant.MLIR.API.MlirWalkResult"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.MlirWalkResult")],-1)),e[1430]||(e[1430]=i()),a(s,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[1432]||(e[1432]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirWalkResult</span></span></code></pre></div><p>Operation walk result.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1431]||(e[1431]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1758-L1762",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Nl,[t("summary",null,[e[1433]||(e[1433]=t("a",{id:"Reactant.MLIR.API.mlirAffineAddExprGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineAddExprGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineAddExprGet")],-1)),e[1434]||(e[1434]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1436]||(e[1436]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineAddExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine add expression with &#39;lhs&#39; and &#39;rhs&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1435]||(e[1435]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2930-L2934",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gl,[t("summary",null,[e[1437]||(e[1437]=t("a",{id:"Reactant.MLIR.API.mlirAffineBinaryOpExprGetLHS-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineBinaryOpExprGetLHS-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineBinaryOpExprGetLHS")],-1)),e[1438]||(e[1438]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1440]||(e[1440]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineBinaryOpExprGetLHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the left hand side affine expression of the given affine binary operation expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1439]||(e[1439]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3030-L3034",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zl,[t("summary",null,[e[1441]||(e[1441]=t("a",{id:"Reactant.MLIR.API.mlirAffineBinaryOpExprGetRHS-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineBinaryOpExprGetRHS-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineBinaryOpExprGetRHS")],-1)),e[1442]||(e[1442]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1444]||(e[1444]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineBinaryOpExprGetRHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the right hand side affine expression of the given affine binary operation expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1443]||(e[1443]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3039-L3043",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wl,[t("summary",null,[e[1445]||(e[1445]=t("a",{id:"Reactant.MLIR.API.mlirAffineCeilDivExprGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineCeilDivExprGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineCeilDivExprGet")],-1)),e[1446]||(e[1446]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1448]||(e[1448]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineCeilDivExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine ceildiv expression with &#39;lhs&#39; and &#39;rhs&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1447]||(e[1447]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3010-L3014",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ul,[t("summary",null,[e[1449]||(e[1449]=t("a",{id:"Reactant.MLIR.API.mlirAffineConstantExprGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineConstantExprGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineConstantExprGet")],-1)),e[1450]||(e[1450]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1452]||(e[1452]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineConstantExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, constant)</span></span></code></pre></div><p>Creates an affine constant expression with &#39;constant&#39; in the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1451]||(e[1451]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2901-L2905",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ql,[t("summary",null,[e[1453]||(e[1453]=t("a",{id:"Reactant.MLIR.API.mlirAffineConstantExprGetValue-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineConstantExprGetValue-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineConstantExprGetValue")],-1)),e[1454]||(e[1454]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1456]||(e[1456]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineConstantExprGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the value of the given affine constant expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1455]||(e[1455]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2912-L2916",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ql,[t("summary",null,[e[1457]||(e[1457]=t("a",{id:"Reactant.MLIR.API.mlirAffineDimExprGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineDimExprGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineDimExprGet")],-1)),e[1458]||(e[1458]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1460]||(e[1460]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineDimExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, position)</span></span></code></pre></div><p>Creates an affine dimension expression with &#39;position&#39; in the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1459]||(e[1459]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2843-L2847",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wl,[t("summary",null,[e[1461]||(e[1461]=t("a",{id:"Reactant.MLIR.API.mlirAffineDimExprGetPosition-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineDimExprGetPosition-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineDimExprGetPosition")],-1)),e[1462]||(e[1462]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1464]||(e[1464]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineDimExprGetPosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the position of the given affine dimension expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1463]||(e[1463]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2854-L2858",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zl,[t("summary",null,[e[1465]||(e[1465]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprCompose-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineExprCompose-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprCompose")],-1)),e[1466]||(e[1466]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1468]||(e[1468]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprCompose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, affineMap)</span></span></code></pre></div><p>Composes the given map with the given expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1467]||(e[1467]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2790-L2794",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hl,[t("summary",null,[e[1469]||(e[1469]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprDump-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprDump-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprDump")],-1)),e[1470]||(e[1470]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1472]||(e[1472]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Prints the affine expression to the standard error stream.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1471]||(e[1471]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2728-L2732",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jl,[t("summary",null,[e[1473]||(e[1473]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineExprEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprEqual")],-1)),e[1474]||(e[1474]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1476]||(e[1476]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Returns <code>true</code> if the two affine expressions are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1475]||(e[1475]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2699-L2703",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Kl,[t("summary",null,[e[1477]||(e[1477]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprGetContext-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprGetContext-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprGetContext")],-1)),e[1478]||(e[1478]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1480]||(e[1480]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Gets the context that owns the affine expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1479]||(e[1479]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2690-L2694",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$l,[t("summary",null,[e[1481]||(e[1481]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprGetLargestKnownDivisor-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprGetLargestKnownDivisor-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprGetLargestKnownDivisor")],-1)),e[1482]||(e[1482]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1484]||(e[1484]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprGetLargestKnownDivisor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the greatest known integral divisor of this affine expression. The result is always positive.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1483]||(e[1483]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2755-L2759",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xl,[t("summary",null,[e[1485]||(e[1485]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsAAdd-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsAAdd-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsAAdd")],-1)),e[1486]||(e[1486]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1488]||(e[1488]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsAAdd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an add expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1487]||(e[1487]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2921-L2925",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yl,[t("summary",null,[e[1489]||(e[1489]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsABinary-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsABinary-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsABinary")],-1)),e[1490]||(e[1490]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1492]||(e[1492]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsABinary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is binary.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1491]||(e[1491]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3021-L3025",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",en,[t("summary",null,[e[1493]||(e[1493]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsACeilDiv-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsACeilDiv-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsACeilDiv")],-1)),e[1494]||(e[1494]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1496]||(e[1496]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsACeilDiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an ceildiv expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1495]||(e[1495]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3001-L3005",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",tn,[t("summary",null,[e[1497]||(e[1497]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsAConstant-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsAConstant-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsAConstant")],-1)),e[1498]||(e[1498]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1500]||(e[1500]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsAConstant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a constant expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1499]||(e[1499]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2892-L2896",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sn,[t("summary",null,[e[1501]||(e[1501]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsADim-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsADim-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsADim")],-1)),e[1502]||(e[1502]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1504]||(e[1504]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsADim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a dimension expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1503]||(e[1503]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2834-L2838",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",an,[t("summary",null,[e[1505]||(e[1505]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsAFloorDiv-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsAFloorDiv-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsAFloorDiv")],-1)),e[1506]||(e[1506]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1508]||(e[1508]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsAFloorDiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an floordiv expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1507]||(e[1507]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2981-L2985",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ln,[t("summary",null,[e[1509]||(e[1509]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsAMod-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsAMod-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsAMod")],-1)),e[1510]||(e[1510]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1512]||(e[1512]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsAMod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an mod expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1511]||(e[1511]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2961-L2965",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",nn,[t("summary",null,[e[1513]||(e[1513]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsAMul-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsAMul-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsAMul")],-1)),e[1514]||(e[1514]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1516]||(e[1516]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsAMul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an mul expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1515]||(e[1515]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2941-L2945",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rn,[t("summary",null,[e[1517]||(e[1517]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsASymbol-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsASymbol-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsASymbol")],-1)),e[1518]||(e[1518]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1520]||(e[1520]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsASymbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a symbol expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1519]||(e[1519]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2863-L2867",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",on,[t("summary",null,[e[1521]||(e[1521]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsFunctionOfDim-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsFunctionOfDim-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsFunctionOfDim")],-1)),e[1522]||(e[1522]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1524]||(e[1524]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsFunctionOfDim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, position)</span></span></code></pre></div><p>Checks whether the given affine expression involves AffineDimExpr &#39;position&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1523]||(e[1523]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2775-L2779",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pn,[t("summary",null,[e[1525]||(e[1525]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsMultipleOf-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsMultipleOf-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsMultipleOf")],-1)),e[1526]||(e[1526]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1528]||(e[1528]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsMultipleOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, factor)</span></span></code></pre></div><p>Checks whether the given affine expression is a multiple of &#39;factor&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1527]||(e[1527]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2764-L2768",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dn,[t("summary",null,[e[1529]||(e[1529]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsNull")],-1)),e[1530]||(e[1530]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1532]||(e[1532]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns <code>true</code> if the given affine expression is a null expression. Note constant zero is not a null expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1531]||(e[1531]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2708-L2712",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",un,[t("summary",null,[e[1533]||(e[1533]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsPureAffine-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsPureAffine-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsPureAffine")],-1)),e[1534]||(e[1534]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1536]||(e[1536]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsPureAffine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a pure affine expression, i.e. mul, floordiv, ceildic, and mod is only allowed w.r.t constants.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1535]||(e[1535]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2746-L2750",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bn,[t("summary",null,[e[1537]||(e[1537]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprIsSymbolicOrConstant-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineExprIsSymbolicOrConstant-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprIsSymbolicOrConstant")],-1)),e[1538]||(e[1538]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1540]||(e[1540]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsSymbolicOrConstant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is made out of only symbols and constants.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1539]||(e[1539]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2737-L2741",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cn,[t("summary",null,[e[1541]||(e[1541]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprPrint-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirAffineExprPrint-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprPrint")],-1)),e[1542]||(e[1542]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1544]||(e[1544]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, callback, userData)</span></span></code></pre></div><p>Prints an affine expression by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1543]||(e[1543]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2717-L2721",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hn,[t("summary",null,[e[1545]||(e[1545]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprShiftDims-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirAffineExprShiftDims-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprShiftDims")],-1)),e[1546]||(e[1546]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1548]||(e[1548]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprShiftDims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, numDims, shift, offset)</span></span></code></pre></div><p>Replace dims[offset ... numDims) by dims[offset + shift ... shift + numDims).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1547]||(e[1547]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2801-L2805",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yn,[t("summary",null,[e[1549]||(e[1549]=t("a",{id:"Reactant.MLIR.API.mlirAffineExprShiftSymbols-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirAffineExprShiftSymbols-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineExprShiftSymbols")],-1)),e[1550]||(e[1550]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1552]||(e[1552]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprShiftSymbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, numSymbols, shift, offset)</span></span></code></pre></div><p>Replace symbols[offset ... numSymbols) by symbols[offset + shift ... shift + numSymbols).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1551]||(e[1551]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2812-L2816",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gn,[t("summary",null,[e[1553]||(e[1553]=t("a",{id:"Reactant.MLIR.API.mlirAffineFloorDivExprGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineFloorDivExprGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineFloorDivExprGet")],-1)),e[1554]||(e[1554]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1556]||(e[1556]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineFloorDivExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine floordiv expression with &#39;lhs&#39; and &#39;rhs&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1555]||(e[1555]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2990-L2994",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mn,[t("summary",null,[e[1557]||(e[1557]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapAttrGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapAttrGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapAttrGet")],-1)),e[1558]||(e[1558]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1560]||(e[1560]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(map)</span></span></code></pre></div><p>Creates an affine map attribute wrapping the given map. The attribute belongs to the same context as the affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1559]||(e[1559]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3548-L3552",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",kn,[t("summary",null,[e[1561]||(e[1561]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirAffineMapAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapAttrGetTypeID")],-1)),e[1562]||(e[1562]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1564]||(e[1564]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an AffineMap attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1563]||(e[1563]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3566-L3570",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rn,[t("summary",null,[e[1565]||(e[1565]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapAttrGetValue-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapAttrGetValue-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapAttrGetValue")],-1)),e[1566]||(e[1566]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1568]||(e[1568]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the affine map wrapped in the given affine map attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1567]||(e[1567]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3557-L3561",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fn,[t("summary",null,[e[1569]||(e[1569]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapCompressUnusedSymbols-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirAffineMapCompressUnusedSymbols-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapCompressUnusedSymbols")],-1)),e[1570]||(e[1570]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1572]||(e[1572]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapCompressUnusedSymbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMaps, size, result, populateResult)</span></span></code></pre></div><p>Returns the simplified affine map resulting from dropping the symbols that do not appear in any of the individual maps in <code>affineMaps</code>. Asserts that all maps in <code>affineMaps</code> are normalized to the same number of dims and symbols. Takes a callback <code>populateResult</code> to fill the <code>res</code> container with value <code>m</code> at entry <code>idx</code>. This allows returning without worrying about ownership considerations.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1571]||(e[1571]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3332-L3336",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",In,[t("summary",null,[e[1573]||(e[1573]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapConstantGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineMapConstantGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapConstantGet")],-1)),e[1574]||(e[1574]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1576]||(e[1576]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapConstantGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, val)</span></span></code></pre></div><p>Creates a single constant result affine map in the context. The affine map is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1575]||(e[1575]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3130-L3134",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Tn,[t("summary",null,[e[1577]||(e[1577]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapDump-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapDump-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapDump")],-1)),e[1578]||(e[1578]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1580]||(e[1580]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Prints the affine map to the standard error stream.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1579]||(e[1579]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3086-L3090",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",An,[t("summary",null,[e[1581]||(e[1581]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapEmptyGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapEmptyGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapEmptyGet")],-1)),e[1582]||(e[1582]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1584]||(e[1584]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapEmptyGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a zero result affine map with no dimensions or symbols in the context. The affine map is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1583]||(e[1583]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3095-L3099",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jn,[t("summary",null,[e[1585]||(e[1585]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineMapEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapEqual")],-1)),e[1586]||(e[1586]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1588]||(e[1588]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a1, a2)</span></span></code></pre></div><p>Checks if two affine maps are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1587]||(e[1587]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3066-L3070",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_n,[t("summary",null,[e[1589]||(e[1589]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapGet-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirAffineMapGet-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapGet")],-1)),e[1590]||(e[1590]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1592]||(e[1592]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, dimCount, symbolCount, nAffineExprs, affineExprs)</span></span></code></pre></div><p>Creates an affine map with results defined by the given list of affine expressions. The map resulting map also has the requested number of input dimensions and symbols, regardless of them being used in the results.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1591]||(e[1591]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3115-L3119",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mn,[t("summary",null,[e[1593]||(e[1593]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapGetContext-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapGetContext-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapGetContext")],-1)),e[1594]||(e[1594]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1596]||(e[1596]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Gets the context that the given affine map was created with</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1595]||(e[1595]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3048-L3052",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",En,[t("summary",null,[e[1597]||(e[1597]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapGetMajorSubMap-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineMapGetMajorSubMap-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapGetMajorSubMap")],-1)),e[1598]||(e[1598]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1600]||(e[1600]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetMajorSubMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, numResults)</span></span></code></pre></div><p>Returns the affine map consisting of the most major <code>numResults</code> results. Returns the null AffineMap if the <code>numResults</code> is equal to zero. Returns the <code>affineMap</code> if <code>numResults</code> is greater or equals to number of results of the given affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1599]||(e[1599]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3293-L3297",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ln,[t("summary",null,[e[1601]||(e[1601]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapGetMinorSubMap-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineMapGetMinorSubMap-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapGetMinorSubMap")],-1)),e[1602]||(e[1602]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1604]||(e[1604]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetMinorSubMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, numResults)</span></span></code></pre></div><p>Returns the affine map consisting of the most minor <code>numResults</code> results. Returns the null AffineMap if the <code>numResults</code> is equal to zero. Returns the <code>affineMap</code> if <code>numResults</code> is greater or equals to number of results of the given affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1603]||(e[1603]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3304-L3308",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Cn,[t("summary",null,[e[1605]||(e[1605]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapGetNumDims-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapGetNumDims-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapGetNumDims")],-1)),e[1606]||(e[1606]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1608]||(e[1608]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetNumDims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of dimensions of the given affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1607]||(e[1607]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3217-L3221",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vn,[t("summary",null,[e[1609]||(e[1609]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapGetNumInputs-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapGetNumInputs-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapGetNumInputs")],-1)),e[1610]||(e[1610]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1612]||(e[1612]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetNumInputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of inputs (dimensions + symbols) of the given affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1611]||(e[1611]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3255-L3259",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pn,[t("summary",null,[e[1613]||(e[1613]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapGetNumResults-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapGetNumResults-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapGetNumResults")],-1)),e[1614]||(e[1614]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1616]||(e[1616]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetNumResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of results of the given affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1615]||(e[1615]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3235-L3239",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xn,[t("summary",null,[e[1617]||(e[1617]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapGetNumSymbols-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapGetNumSymbols-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapGetNumSymbols")],-1)),e[1618]||(e[1618]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1620]||(e[1620]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetNumSymbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of symbols of the given affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1619]||(e[1619]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3226-L3230",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sn,[t("summary",null,[e[1621]||(e[1621]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapGetResult-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineMapGetResult-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapGetResult")],-1)),e[1622]||(e[1622]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1624]||(e[1624]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, pos)</span></span></code></pre></div><p>Returns the result at the given position.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1623]||(e[1623]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3244-L3248",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Dn,[t("summary",null,[e[1625]||(e[1625]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapGetSingleConstantResult-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapGetSingleConstantResult-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapGetSingleConstantResult")],-1)),e[1626]||(e[1626]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1628]||(e[1628]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetSingleConstantResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the constant result of the given affine map. The function asserts that the map has a single constant result.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1627]||(e[1627]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3208-L3212",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fn,[t("summary",null,[e[1629]||(e[1629]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapGetSubMap-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirAffineMapGetSubMap-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapGetSubMap")],-1)),e[1630]||(e[1630]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1632]||(e[1632]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetSubMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, size, resultPos)</span></span></code></pre></div><p>Returns the affine map consisting of the <code>resultPos</code> subset.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1631]||(e[1631]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3282-L3286",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vn,[t("summary",null,[e[1633]||(e[1633]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapIsEmpty-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapIsEmpty-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapIsEmpty")],-1)),e[1634]||(e[1634]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1636]||(e[1636]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is an empty affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1635]||(e[1635]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3190-L3194",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",On,[t("summary",null,[e[1637]||(e[1637]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapIsIdentity-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapIsIdentity-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapIsIdentity")],-1)),e[1638]||(e[1638]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1640]||(e[1640]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsIdentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is an identity affine map. The function asserts that the number of dimensions is greater or equal to the number of results.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1639]||(e[1639]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3172-L3176",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bn,[t("summary",null,[e[1641]||(e[1641]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapIsMinorIdentity-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapIsMinorIdentity-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapIsMinorIdentity")],-1)),e[1642]||(e[1642]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1644]||(e[1644]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsMinorIdentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is a minor identity affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1643]||(e[1643]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3181-L3185",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Nn,[t("summary",null,[e[1645]||(e[1645]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapIsNull")],-1)),e[1646]||(e[1646]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1648]||(e[1648]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether an affine map is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1647]||(e[1647]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3057-L3061",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gn,[t("summary",null,[e[1649]||(e[1649]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapIsPermutation-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapIsPermutation-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapIsPermutation")],-1)),e[1650]||(e[1650]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1652]||(e[1652]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsPermutation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map represents a symbol-less permutation map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1651]||(e[1651]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3273-L3277",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zn,[t("summary",null,[e[1653]||(e[1653]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapIsProjectedPermutation-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapIsProjectedPermutation-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapIsProjectedPermutation")],-1)),e[1654]||(e[1654]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1656]||(e[1656]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsProjectedPermutation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map represents a subset of a symbol-less permutation map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1655]||(e[1655]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3264-L3268",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wn,[t("summary",null,[e[1657]||(e[1657]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapIsSingleConstant-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineMapIsSingleConstant-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapIsSingleConstant")],-1)),e[1658]||(e[1658]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1660]||(e[1660]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsSingleConstant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is a single result constant affine map.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1659]||(e[1659]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3199-L3203",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Un,[t("summary",null,[e[1661]||(e[1661]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapMinorIdentityGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirAffineMapMinorIdentityGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapMinorIdentityGet")],-1)),e[1662]||(e[1662]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1664]||(e[1664]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapMinorIdentityGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, dims, results)</span></span></code></pre></div><p>Creates an identity affine map on the most minor dimensions in the context. The affine map is owned by the context. The function asserts that the number of dimensions is greater or equal to the number of results.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1663]||(e[1663]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3150-L3154",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qn,[t("summary",null,[e[1665]||(e[1665]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapMultiDimIdentityGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineMapMultiDimIdentityGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapMultiDimIdentityGet")],-1)),e[1666]||(e[1666]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1668]||(e[1668]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapMultiDimIdentityGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, numDims)</span></span></code></pre></div><p>Creates an affine map with &#39;numDims&#39; identity in the context. The affine map is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1667]||(e[1667]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3139-L3143",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qn,[t("summary",null,[e[1669]||(e[1669]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapPermutationGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirAffineMapPermutationGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapPermutationGet")],-1)),e[1670]||(e[1670]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1672]||(e[1672]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapPermutationGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, size, permutation)</span></span></code></pre></div><p>Creates an affine map with a permutation expression and its size in the context. The permutation expression is a non-empty vector of integers. The elements of the permutation vector must be continuous from 0 and cannot be repeated (i.e. <code>[1,2,0]</code> is a valid permutation. <code>[2,0]</code> or <code>[1,1,2]</code> is an invalid permutation.) The affine map is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1671]||(e[1671]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3161-L3165",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wn,[t("summary",null,[e[1673]||(e[1673]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapPrint-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirAffineMapPrint-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapPrint")],-1)),e[1674]||(e[1674]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1676]||(e[1676]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, callback, userData)</span></span></code></pre></div><p>Prints an affine map by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1675]||(e[1675]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3075-L3079",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zn,[t("summary",null,[e[1677]||(e[1677]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapReplace-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirAffineMapReplace-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapReplace")],-1)),e[1678]||(e[1678]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1680]||(e[1680]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapReplace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, expression, replacement, numResultDims, numResultSyms)</span></span></code></pre></div><p>Apply AffineExpr::replace(<code>map</code>) to each of the results and return a new new AffineMap with the new results and the specified number of dims and symbols.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1679]||(e[1679]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3315-L3319",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hn,[t("summary",null,[e[1681]||(e[1681]=t("a",{id:"Reactant.MLIR.API.mlirAffineMapZeroResultGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirAffineMapZeroResultGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMapZeroResultGet")],-1)),e[1682]||(e[1682]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1684]||(e[1684]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapZeroResultGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, dimCount, symbolCount)</span></span></code></pre></div><p>Creates a zero result affine map of the given dimensions and symbols in the context. The affine map is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1683]||(e[1683]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3104-L3108",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jn,[t("summary",null,[e[1685]||(e[1685]=t("a",{id:"Reactant.MLIR.API.mlirAffineModExprGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineModExprGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineModExprGet")],-1)),e[1686]||(e[1686]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1688]||(e[1688]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineModExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine mod expression with &#39;lhs&#39; and &#39;rhs&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1687]||(e[1687]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2970-L2974",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Kn,[t("summary",null,[e[1689]||(e[1689]=t("a",{id:"Reactant.MLIR.API.mlirAffineMulExprGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineMulExprGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineMulExprGet")],-1)),e[1690]||(e[1690]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1692]||(e[1692]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMulExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine mul expression with &#39;lhs&#39; and &#39;rhs&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1691]||(e[1691]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2950-L2954",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$n,[t("summary",null,[e[1693]||(e[1693]=t("a",{id:"Reactant.MLIR.API.mlirAffineSymbolExprGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAffineSymbolExprGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineSymbolExprGet")],-1)),e[1694]||(e[1694]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1696]||(e[1696]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineSymbolExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, position)</span></span></code></pre></div><p>Creates an affine symbol expression with &#39;position&#39; in the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1695]||(e[1695]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2872-L2876",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xn,[t("summary",null,[e[1697]||(e[1697]=t("a",{id:"Reactant.MLIR.API.mlirAffineSymbolExprGetPosition-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAffineSymbolExprGetPosition-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAffineSymbolExprGetPosition")],-1)),e[1698]||(e[1698]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1700]||(e[1700]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineSymbolExprGetPosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the position of the given affine symbol expression.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1699]||(e[1699]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2883-L2887",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yn,[t("summary",null,[e[1701]||(e[1701]=t("a",{id:"Reactant.MLIR.API.mlirAnyQuantizedTypeGet-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirAnyQuantizedTypeGet-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAnyQuantizedTypeGet")],-1)),e[1702]||(e[1702]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1704]||(e[1704]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAnyQuantizedTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, storageType, expressedType, storageTypeMin, storageTypeMax)</span></span></code></pre></div><p>Creates an instance of AnyQuantizedType with the given parameters in the same context as <code>storageType</code> and returns it. The instance is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1703]||(e[1703]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7801-L7805",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",er,[t("summary",null,[e[1705]||(e[1705]=t("a",{id:"Reactant.MLIR.API.mlirArrayAttrGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirArrayAttrGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirArrayAttrGet")],-1)),e[1706]||(e[1706]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1708]||(e[1708]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirArrayAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, numElements, elements)</span></span></code></pre></div><p>Creates an array element containing the given list of elements in the given context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1707]||(e[1707]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3584-L3588",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",tr,[t("summary",null,[e[1709]||(e[1709]=t("a",{id:"Reactant.MLIR.API.mlirArrayAttrGetElement-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirArrayAttrGetElement-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirArrayAttrGetElement")],-1)),e[1710]||(e[1710]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1712]||(e[1712]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirArrayAttrGetElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, pos)</span></span></code></pre></div><p>Returns pos-th element stored in the given array attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1711]||(e[1711]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3604-L3608",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sr,[t("summary",null,[e[1713]||(e[1713]=t("a",{id:"Reactant.MLIR.API.mlirArrayAttrGetNumElements-Tuple{Any}",href:"#Reactant.MLIR.API.mlirArrayAttrGetNumElements-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirArrayAttrGetNumElements")],-1)),e[1714]||(e[1714]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1716]||(e[1716]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirArrayAttrGetNumElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the number of elements stored in the given array attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1715]||(e[1715]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3595-L3599",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ar,[t("summary",null,[e[1717]||(e[1717]=t("a",{id:"Reactant.MLIR.API.mlirArrayAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirArrayAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirArrayAttrGetTypeID")],-1)),e[1718]||(e[1718]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1720]||(e[1720]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirArrayAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Array attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1719]||(e[1719]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3615-L3619",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ir,[t("summary",null,[e[1721]||(e[1721]=t("a",{id:"Reactant.MLIR.API.mlirAsmStateCreateForOperation-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAsmStateCreateForOperation-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAsmStateCreateForOperation")],-1)),e[1722]||(e[1722]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1724]||(e[1724]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAsmStateCreateForOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, flags)</span></span></code></pre></div><p>Creates new AsmState, as with AsmState the IR should not be mutated in-between using this state. Must be freed with a call to <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirAsmStateDestroy-Tuple{Any}"><code>mlirAsmStateDestroy</code></a>().</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1723]||(e[1723]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1097-L1101",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",lr,[t("summary",null,[e[1725]||(e[1725]=t("a",{id:"Reactant.MLIR.API.mlirAsmStateCreateForValue-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAsmStateCreateForValue-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAsmStateCreateForValue")],-1)),e[1726]||(e[1726]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1728]||(e[1728]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAsmStateCreateForValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, flags)</span></span></code></pre></div><p>Creates new AsmState from value. Must be freed with a call to <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirAsmStateDestroy-Tuple{Any}"><code>mlirAsmStateDestroy</code></a>().</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1727]||(e[1727]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1108-L1112",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",nr,[t("summary",null,[e[1729]||(e[1729]=t("a",{id:"Reactant.MLIR.API.mlirAsmStateDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAsmStateDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAsmStateDestroy")],-1)),e[1730]||(e[1730]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1732]||(e[1732]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAsmStateDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state)</span></span></code></pre></div><p>Destroys printing flags created with mlirAsmStateCreate.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1731]||(e[1731]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1119-L1123",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rr,[t("summary",null,[e[1733]||(e[1733]=t("a",{id:"Reactant.MLIR.API.mlirAttributeDump-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeDump-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeDump")],-1)),e[1734]||(e[1734]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1736]||(e[1736]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Prints the attribute to the standard error stream.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1735]||(e[1735]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2525-L2529",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",or,[t("summary",null,[e[1737]||(e[1737]=t("a",{id:"Reactant.MLIR.API.mlirAttributeEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAttributeEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeEqual")],-1)),e[1738]||(e[1738]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1740]||(e[1740]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a1, a2)</span></span></code></pre></div><p>Checks if two attributes are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1739]||(e[1739]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2505-L2509",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pr,[t("summary",null,[e[1741]||(e[1741]=t("a",{id:"Reactant.MLIR.API.mlirAttributeGetContext-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeGetContext-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeGetContext")],-1)),e[1742]||(e[1742]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1744]||(e[1744]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the context that an attribute was created with.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1743]||(e[1743]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2460-L2464",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dr,[t("summary",null,[e[1745]||(e[1745]=t("a",{id:"Reactant.MLIR.API.mlirAttributeGetDialect-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeGetDialect-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeGetDialect")],-1)),e[1746]||(e[1746]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1748]||(e[1748]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeGetDialect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the dialect of the attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1747]||(e[1747]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2487-L2491",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ur,[t("summary",null,[e[1749]||(e[1749]=t("a",{id:"Reactant.MLIR.API.mlirAttributeGetNull-Tuple{}",href:"#Reactant.MLIR.API.mlirAttributeGetNull-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeGetNull")],-1)),e[1750]||(e[1750]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1752]||(e[1752]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeGetNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns an empty attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1751]||(e[1751]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3526-L3530",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",br,[t("summary",null,[e[1753]||(e[1753]=t("a",{id:"Reactant.MLIR.API.mlirAttributeGetType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeGetType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeGetType")],-1)),e[1754]||(e[1754]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1756]||(e[1756]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeGetType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the type of this attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1755]||(e[1755]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2469-L2473",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cr,[t("summary",null,[e[1757]||(e[1757]=t("a",{id:"Reactant.MLIR.API.mlirAttributeGetTypeID-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeGetTypeID-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeGetTypeID")],-1)),e[1758]||(e[1758]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1760]||(e[1760]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the type id of the attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1759]||(e[1759]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2478-L2482",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hr,[t("summary",null,[e[1761]||(e[1761]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsAAffineMap-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsAAffineMap-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsAAffineMap")],-1)),e[1762]||(e[1762]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1764]||(e[1764]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAAffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an affine map attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1763]||(e[1763]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3539-L3543",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yr,[t("summary",null,[e[1765]||(e[1765]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsAArray-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsAArray-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsAArray")],-1)),e[1766]||(e[1766]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1768]||(e[1768]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an array attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1767]||(e[1767]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3575-L3579",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gr,[t("summary",null,[e[1769]||(e[1769]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsABool-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsABool-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsABool")],-1)),e[1770]||(e[1770]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1772]||(e[1772]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsABool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a bool attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1771]||(e[1771]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3787-L3791",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mr,[t("summary",null,[e[1773]||(e[1773]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsADenseBoolArray-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsADenseBoolArray-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsADenseBoolArray")],-1)),e[1774]||(e[1774]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1776]||(e[1776]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsADenseBoolArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a dense array attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1775]||(e[1775]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4161-L4165",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",kr,[t("summary",null,[e[1777]||(e[1777]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsADenseElements-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsADenseElements-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsADenseElements")],-1)),e[1778]||(e[1778]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1780]||(e[1780]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsADenseElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a dense elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1779]||(e[1779]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4283-L4287",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rr,[t("summary",null,[e[1781]||(e[1781]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsADictionary-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsADictionary-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsADictionary")],-1)),e[1782]||(e[1782]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1784]||(e[1784]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsADictionary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a dictionary attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1783]||(e[1783]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3624-L3628",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fr,[t("summary",null,[e[1785]||(e[1785]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsAElements-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsAElements-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsAElements")],-1)),e[1786]||(e[1786]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1788]||(e[1788]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1787]||(e[1787]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4117-L4121",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ir,[t("summary",null,[e[1789]||(e[1789]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsAFlatSymbolRef-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsAFlatSymbolRef-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsAFlatSymbolRef")],-1)),e[1790]||(e[1790]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1792]||(e[1792]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAFlatSymbolRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a flat symbol reference attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1791]||(e[1791]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4025-L4029",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Tr,[t("summary",null,[e[1793]||(e[1793]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsAFloat-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsAFloat-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsAFloat")],-1)),e[1794]||(e[1794]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1796]||(e[1796]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a floating point attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1795]||(e[1795]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3684-L3688",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ar,[t("summary",null,[e[1797]||(e[1797]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsAInteger-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsAInteger-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsAInteger")],-1)),e[1798]||(e[1798]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1800]||(e[1800]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an integer attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1799]||(e[1799]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3733-L3737",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jr,[t("summary",null,[e[1801]||(e[1801]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsAIntegerSet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsAIntegerSet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsAIntegerSet")],-1)),e[1802]||(e[1802]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1804]||(e[1804]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAIntegerSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an integer set attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1803]||(e[1803]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3814-L3818",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_r,[t("summary",null,[e[1805]||(e[1805]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsAOpaque-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsAOpaque-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsAOpaque")],-1)),e[1806]||(e[1806]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1808]||(e[1808]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAOpaque</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an opaque attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1807]||(e[1807]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3850-L3854",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mr,[t("summary",null,[e[1809]||(e[1809]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsASparseElements-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsASparseElements-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsASparseElements")],-1)),e[1810]||(e[1810]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1812]||(e[1812]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsASparseElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a sparse elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1811]||(e[1811]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4873-L4877",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Er,[t("summary",null,[e[1813]||(e[1813]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsASparseTensorEncodingAttr-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsASparseTensorEncodingAttr-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsASparseTensorEncodingAttr")],-1)),e[1814]||(e[1814]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1816]||(e[1816]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsASparseTensorEncodingAttr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a <code>sparse\\_tensor.encoding</code> attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1815]||(e[1815]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8339-L8343",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Lr,[t("summary",null,[e[1817]||(e[1817]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsAString-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsAString-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsAString")],-1)),e[1818]||(e[1818]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1820]||(e[1820]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a string attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1819]||(e[1819]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3901-L3905",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Cr,[t("summary",null,[e[1821]||(e[1821]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsASymbolRef-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsASymbolRef-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsASymbolRef")],-1)),e[1822]||(e[1822]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1824]||(e[1824]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsASymbolRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a symbol reference attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1823]||(e[1823]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3946-L3950",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vr,[t("summary",null,[e[1825]||(e[1825]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsAType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsAType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsAType")],-1)),e[1826]||(e[1826]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1828]||(e[1828]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a type attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1827]||(e[1827]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4054-L4058",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pr,[t("summary",null,[e[1829]||(e[1829]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsAUnit-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsAUnit-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsAUnit")],-1)),e[1830]||(e[1830]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1832]||(e[1832]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a unit attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1831]||(e[1831]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4090-L4094",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xr,[t("summary",null,[e[1833]||(e[1833]=t("a",{id:"Reactant.MLIR.API.mlirAttributeIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirAttributeIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeIsNull")],-1)),e[1834]||(e[1834]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1836]||(e[1836]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether an attribute is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1835]||(e[1835]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2496-L2500",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sr,[t("summary",null,[e[1837]||(e[1837]=t("a",{id:"Reactant.MLIR.API.mlirAttributeParseGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirAttributeParseGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributeParseGet")],-1)),e[1838]||(e[1838]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1840]||(e[1840]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeParseGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, attr)</span></span></code></pre></div><p>Parses an attribute. The attribute is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1839]||(e[1839]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2449-L2453",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Dr,[t("summary",null,[e[1841]||(e[1841]=t("a",{id:"Reactant.MLIR.API.mlirAttributePrint-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirAttributePrint-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirAttributePrint")],-1)),e[1842]||(e[1842]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1844]||(e[1844]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributePrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, callback, userData)</span></span></code></pre></div><p>Prints an attribute by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1843]||(e[1843]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2514-L2518",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fr,[t("summary",null,[e[1845]||(e[1845]=t("a",{id:"Reactant.MLIR.API.mlirBF16TypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBF16TypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBF16TypeGet")],-1)),e[1846]||(e[1846]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1848]||(e[1848]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBF16TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a bf16 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1847]||(e[1847]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5394-L5398",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vr,[t("summary",null,[e[1849]||(e[1849]=t("a",{id:"Reactant.MLIR.API.mlirBFloat16TypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirBFloat16TypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBFloat16TypeGetTypeID")],-1)),e[1850]||(e[1850]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1852]||(e[1852]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBFloat16TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an BFloat16 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1851]||(e[1851]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5376-L5380",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Or,[t("summary",null,[e[1853]||(e[1853]=t("a",{id:"Reactant.MLIR.API.mlirBlockAddArgument-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirBlockAddArgument-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockAddArgument")],-1)),e[1854]||(e[1854]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1856]||(e[1856]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockAddArgument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, type, loc)</span></span></code></pre></div><p>Appends an argument of the specified type to the block. Returns the newly added argument.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1855]||(e[1855]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2058-L2062",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Br,[t("summary",null,[e[1857]||(e[1857]=t("a",{id:"Reactant.MLIR.API.mlirBlockAppendOwnedOperation-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirBlockAppendOwnedOperation-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockAppendOwnedOperation")],-1)),e[1858]||(e[1858]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1860]||(e[1860]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockAppendOwnedOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and appends it to the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1859]||(e[1859]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2005-L2009",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Nr,[t("summary",null,[e[1861]||(e[1861]=t("a",{id:"Reactant.MLIR.API.mlirBlockArgumentGetArgNumber-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockArgumentGetArgNumber-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockArgumentGetArgNumber")],-1)),e[1862]||(e[1862]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1864]||(e[1864]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockArgumentGetArgNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the position of the value in the argument list of its block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1863]||(e[1863]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2192-L2196",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gr,[t("summary",null,[e[1865]||(e[1865]=t("a",{id:"Reactant.MLIR.API.mlirBlockArgumentGetOwner-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockArgumentGetOwner-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockArgumentGetOwner")],-1)),e[1866]||(e[1866]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1868]||(e[1868]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockArgumentGetOwner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the block in which this value is defined as an argument. Asserts if the value is not a block argument.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1867]||(e[1867]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2183-L2187",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zr,[t("summary",null,[e[1869]||(e[1869]=t("a",{id:"Reactant.MLIR.API.mlirBlockArgumentSetType-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirBlockArgumentSetType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockArgumentSetType")],-1)),e[1870]||(e[1870]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1872]||(e[1872]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockArgumentSetType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, type)</span></span></code></pre></div><p>Sets the type of the block argument to the given type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1871]||(e[1871]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2201-L2205",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wr,[t("summary",null,[e[1873]||(e[1873]=t("a",{id:"Reactant.MLIR.API.mlirBlockCreate-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirBlockCreate-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockCreate")],-1)),e[1874]||(e[1874]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1876]||(e[1876]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nArgs, args, locs)</span></span></code></pre></div><p>Creates a new empty block with the given argument types and transfers ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1875]||(e[1875]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1913-L1917",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ur,[t("summary",null,[e[1877]||(e[1877]=t("a",{id:"Reactant.MLIR.API.mlirBlockDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockDestroy")],-1)),e[1878]||(e[1878]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1880]||(e[1880]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Takes a block owned by the caller and destroys it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1879]||(e[1879]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1924-L1928",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qr,[t("summary",null,[e[1881]||(e[1881]=t("a",{id:"Reactant.MLIR.API.mlirBlockDetach-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockDetach-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockDetach")],-1)),e[1882]||(e[1882]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1884]||(e[1884]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockDetach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Detach a block from the owning region and assume ownership.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1883]||(e[1883]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1933-L1937",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qr,[t("summary",null,[e[1885]||(e[1885]=t("a",{id:"Reactant.MLIR.API.mlirBlockEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirBlockEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockEqual")],-1)),e[1886]||(e[1886]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1888]||(e[1888]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, other)</span></span></code></pre></div><p>Checks whether two blocks handles point to the same block. This does not perform deep comparison.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1887]||(e[1887]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1951-L1955",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wr,[t("summary",null,[e[1889]||(e[1889]=t("a",{id:"Reactant.MLIR.API.mlirBlockEraseArgument-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirBlockEraseArgument-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockEraseArgument")],-1)),e[1890]||(e[1890]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1892]||(e[1892]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockEraseArgument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, index)</span></span></code></pre></div><p>Erase the argument at &#39;index&#39; and remove it from the argument list.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1891]||(e[1891]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2069-L2073",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zr,[t("summary",null,[e[1893]||(e[1893]=t("a",{id:"Reactant.MLIR.API.mlirBlockGetArgument-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirBlockGetArgument-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockGetArgument")],-1)),e[1894]||(e[1894]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1896]||(e[1896]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetArgument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th argument of the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1895]||(e[1895]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2089-L2093",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hr,[t("summary",null,[e[1897]||(e[1897]=t("a",{id:"Reactant.MLIR.API.mlirBlockGetFirstOperation-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockGetFirstOperation-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockGetFirstOperation")],-1)),e[1898]||(e[1898]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1900]||(e[1900]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetFirstOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the first operation in the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1899]||(e[1899]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1987-L1991",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jr,[t("summary",null,[e[1901]||(e[1901]=t("a",{id:"Reactant.MLIR.API.mlirBlockGetNextInRegion-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockGetNextInRegion-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockGetNextInRegion")],-1)),e[1902]||(e[1902]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1904]||(e[1904]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetNextInRegion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the block immediately following the given block in its parent region.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1903]||(e[1903]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1978-L1982",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Kr,[t("summary",null,[e[1905]||(e[1905]=t("a",{id:"Reactant.MLIR.API.mlirBlockGetNumArguments-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockGetNumArguments-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockGetNumArguments")],-1)),e[1906]||(e[1906]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1908]||(e[1908]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetNumArguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the number of arguments of the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1907]||(e[1907]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2049-L2053",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$r,[t("summary",null,[e[1909]||(e[1909]=t("a",{id:"Reactant.MLIR.API.mlirBlockGetNumPredecessors-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockGetNumPredecessors-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockGetNumPredecessors")],-1)),e[1910]||(e[1910]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1912]||(e[1912]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetNumPredecessors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the number of predecessor blocks of the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1911]||(e[1911]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2127-L2131",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xr,[t("summary",null,[e[1913]||(e[1913]=t("a",{id:"Reactant.MLIR.API.mlirBlockGetNumSuccessors-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockGetNumSuccessors-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockGetNumSuccessors")],-1)),e[1914]||(e[1914]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1916]||(e[1916]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetNumSuccessors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the number of successor blocks of the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1915]||(e[1915]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2109-L2113",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yr,[t("summary",null,[e[1917]||(e[1917]=t("a",{id:"Reactant.MLIR.API.mlirBlockGetParentOperation-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockGetParentOperation-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockGetParentOperation")],-1)),e[1918]||(e[1918]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1920]||(e[1920]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetParentOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1)</span></span></code></pre></div><p>Returns the closest surrounding operation that contains this block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1919]||(e[1919]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1960-L1964",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",eo,[t("summary",null,[e[1921]||(e[1921]=t("a",{id:"Reactant.MLIR.API.mlirBlockGetParentRegion-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockGetParentRegion-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockGetParentRegion")],-1)),e[1922]||(e[1922]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1924]||(e[1924]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetParentRegion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the region that contains this block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1923]||(e[1923]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1969-L1973",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",to,[t("summary",null,[e[1925]||(e[1925]=t("a",{id:"Reactant.MLIR.API.mlirBlockGetPredecessor-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirBlockGetPredecessor-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockGetPredecessor")],-1)),e[1926]||(e[1926]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1928]||(e[1928]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetPredecessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th predecessor of the block.</p><p>WARNING: This getter is more expensive than the others here because the impl actually iterates the use-def chain (of block operands) anew for each indexed access.</p>',3)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1927]||(e[1927]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2136-L2142",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",so,[t("summary",null,[e[1929]||(e[1929]=t("a",{id:"Reactant.MLIR.API.mlirBlockGetSuccessor-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirBlockGetSuccessor-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockGetSuccessor")],-1)),e[1930]||(e[1930]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1932]||(e[1932]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetSuccessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th successor of the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1931]||(e[1931]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2118-L2122",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ao,[t("summary",null,[e[1933]||(e[1933]=t("a",{id:"Reactant.MLIR.API.mlirBlockGetTerminator-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockGetTerminator-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockGetTerminator")],-1)),e[1934]||(e[1934]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1936]||(e[1936]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetTerminator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the terminator operation in the block or null if no terminator.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1935]||(e[1935]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1996-L2000",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",io,[t("summary",null,[e[1937]||(e[1937]=t("a",{id:"Reactant.MLIR.API.mlirBlockInsertArgument-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirBlockInsertArgument-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockInsertArgument")],-1)),e[1938]||(e[1938]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1940]||(e[1940]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockInsertArgument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, pos, type, loc)</span></span></code></pre></div><p>Inserts an argument of the specified type at a specified index to the block. Returns the newly added argument.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1939]||(e[1939]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2078-L2082",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",lo,[t("summary",null,[e[1941]||(e[1941]=t("a",{id:"Reactant.MLIR.API.mlirBlockInsertOwnedOperation-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirBlockInsertOwnedOperation-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockInsertOwnedOperation")],-1)),e[1942]||(e[1942]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1944]||(e[1944]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockInsertOwnedOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, pos, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and inserts it as <code>pos</code> to the block. This is an expensive operation that scans the block linearly, prefer insertBefore/After instead.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1943]||(e[1943]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2016-L2020",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",no,[t("summary",null,[e[1945]||(e[1945]=t("a",{id:"Reactant.MLIR.API.mlirBlockInsertOwnedOperationAfter-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirBlockInsertOwnedOperationAfter-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockInsertOwnedOperationAfter")],-1)),e[1946]||(e[1946]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1948]||(e[1948]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockInsertOwnedOperationAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, reference, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and inserts it after the (non-owned) reference operation in the given block. If the reference is null, prepends the operation. Otherwise, the reference must belong to the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1947]||(e[1947]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2027-L2031",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ro,[t("summary",null,[e[1949]||(e[1949]=t("a",{id:"Reactant.MLIR.API.mlirBlockInsertOwnedOperationBefore-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirBlockInsertOwnedOperationBefore-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockInsertOwnedOperationBefore")],-1)),e[1950]||(e[1950]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1952]||(e[1952]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockInsertOwnedOperationBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, reference, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and inserts it before the (non-owned) reference operation in the given block. If the reference is null, appends the operation. Otherwise, the reference must belong to the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1951]||(e[1951]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2038-L2042",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",oo,[t("summary",null,[e[1953]||(e[1953]=t("a",{id:"Reactant.MLIR.API.mlirBlockIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBlockIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockIsNull")],-1)),e[1954]||(e[1954]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1956]||(e[1956]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Checks whether a block is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1955]||(e[1955]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1942-L1946",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",po,[t("summary",null,[e[1957]||(e[1957]=t("a",{id:"Reactant.MLIR.API.mlirBlockPrint-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirBlockPrint-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBlockPrint")],-1)),e[1958]||(e[1958]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1960]||(e[1960]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, callback, userData)</span></span></code></pre></div><p>Prints a block by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1959]||(e[1959]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2098-L2102",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",uo,[t("summary",null,[e[1961]||(e[1961]=t("a",{id:"Reactant.MLIR.API.mlirBoolAttrGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirBoolAttrGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBoolAttrGet")],-1)),e[1962]||(e[1962]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1964]||(e[1964]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBoolAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, value)</span></span></code></pre></div><p>Creates a bool attribute in the given context with the given value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1963]||(e[1963]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3796-L3800",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bo,[t("summary",null,[e[1965]||(e[1965]=t("a",{id:"Reactant.MLIR.API.mlirBoolAttrGetValue-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBoolAttrGetValue-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBoolAttrGetValue")],-1)),e[1966]||(e[1966]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1968]||(e[1968]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBoolAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given bool attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1967]||(e[1967]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3805-L3809",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",co,[t("summary",null,[e[1969]||(e[1969]=t("a",{id:"Reactant.MLIR.API.mlirBytecodeWriterConfigCreate-Tuple{}",href:"#Reactant.MLIR.API.mlirBytecodeWriterConfigCreate-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBytecodeWriterConfigCreate")],-1)),e[1970]||(e[1970]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1972]||(e[1972]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBytecodeWriterConfigCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates new printing flags with defaults, intended for customization. Must be freed with a call to <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirBytecodeWriterConfigDestroy-Tuple{Any}"><code>mlirBytecodeWriterConfigDestroy</code></a>().</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1971]||(e[1971]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1224-L1228",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ho,[t("summary",null,[e[1973]||(e[1973]=t("a",{id:"Reactant.MLIR.API.mlirBytecodeWriterConfigDesiredEmitVersion-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirBytecodeWriterConfigDesiredEmitVersion-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBytecodeWriterConfigDesiredEmitVersion")],-1)),e[1974]||(e[1974]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1976]||(e[1976]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBytecodeWriterConfigDesiredEmitVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, version)</span></span></code></pre></div><p>Sets the version to emit in the writer config.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1975]||(e[1975]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1242-L1246",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yo,[t("summary",null,[e[1977]||(e[1977]=t("a",{id:"Reactant.MLIR.API.mlirBytecodeWriterConfigDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirBytecodeWriterConfigDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirBytecodeWriterConfigDestroy")],-1)),e[1978]||(e[1978]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1980]||(e[1980]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBytecodeWriterConfigDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(config)</span></span></code></pre></div><p>Destroys printing flags created with <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirBytecodeWriterConfigCreate-Tuple{}"><code>mlirBytecodeWriterConfigCreate</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1979]||(e[1979]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1233-L1237",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",go,[t("summary",null,[e[1981]||(e[1981]=t("a",{id:"Reactant.MLIR.API.mlirCalibratedQuantizedTypeGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirCalibratedQuantizedTypeGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirCalibratedQuantizedTypeGet")],-1)),e[1982]||(e[1982]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1984]||(e[1984]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirCalibratedQuantizedTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(expressedType, min, max)</span></span></code></pre></div><p>Creates an instance of CalibratedQuantizedType with the given parameters in the same context as <code>expressedType</code> and returns it. The instance is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1983]||(e[1983]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8066-L8070",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mo,[t("summary",null,[e[1985]||(e[1985]=t("a",{id:"Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMax-Tuple{Any}",href:"#Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMax-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMax")],-1)),e[1986]||(e[1986]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1988]||(e[1988]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirCalibratedQuantizedTypeGetMax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the max value of the given calibrated quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1987]||(e[1987]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8086-L8090",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ko,[t("summary",null,[e[1989]||(e[1989]=t("a",{id:"Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMin-Tuple{Any}",href:"#Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMin-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMin")],-1)),e[1990]||(e[1990]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1992]||(e[1992]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirCalibratedQuantizedTypeGetMin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the min value of the given calibrated quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1991]||(e[1991]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8077-L8081",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ro,[t("summary",null,[e[1993]||(e[1993]=t("a",{id:"Reactant.MLIR.API.mlirComplexTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirComplexTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirComplexTypeGet")],-1)),e[1994]||(e[1994]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[1996]||(e[1996]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirComplexTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType)</span></span></code></pre></div><p>Creates a complex type with the given element type in the same context as the element type. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1995]||(e[1995]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5556-L5560",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fo,[t("summary",null,[e[1997]||(e[1997]=t("a",{id:"Reactant.MLIR.API.mlirComplexTypeGetElementType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirComplexTypeGetElementType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirComplexTypeGetElementType")],-1)),e[1998]||(e[1998]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2e3]||(e[2e3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirComplexTypeGetElementType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the element type of the given complex type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[1999]||(e[1999]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5565-L5569",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Io,[t("summary",null,[e[2001]||(e[2001]=t("a",{id:"Reactant.MLIR.API.mlirComplexTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirComplexTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirComplexTypeGetTypeID")],-1)),e[2002]||(e[2002]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2004]||(e[2004]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirComplexTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Complex type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2003]||(e[2003]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5538-L5542",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",To,[t("summary",null,[e[2005]||(e[2005]=t("a",{id:"Reactant.MLIR.API.mlirContextAppendDialectRegistry-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirContextAppendDialectRegistry-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextAppendDialectRegistry")],-1)),e[2006]||(e[2006]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2008]||(e[2008]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextAppendDialectRegistry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, registry)</span></span></code></pre></div><p>Append the contents of the given dialect registry to the registry associated with the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2007]||(e[2007]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L406-L410",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ao,[t("summary",null,[e[2009]||(e[2009]=t("a",{id:"Reactant.MLIR.API.mlirContextAttachDiagnosticHandler-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirContextAttachDiagnosticHandler-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextAttachDiagnosticHandler")],-1)),e[2010]||(e[2010]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2012]||(e[2012]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextAttachDiagnosticHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, handler, userData, deleteUserData)</span></span></code></pre></div><p>Attaches the diagnostic handler to the context. Handlers are invoked in the reverse order of attachment until one of them processes the diagnostic completely. When a handler is invoked it is passed the <code>userData</code> that was provided when it was attached. If non-NULL, <code>deleteUserData</code> is called once the system no longer needs to call the handler (for instance after the handler is detached or the context is destroyed). Returns an identifier that can be used to detach the handler.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2011]||(e[2011]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6340-L6344",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jo,[t("summary",null,[e[2013]||(e[2013]=t("a",{id:"Reactant.MLIR.API.mlirContextCreate-Tuple{}",href:"#Reactant.MLIR.API.mlirContextCreate-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextCreate")],-1)),e[2014]||(e[2014]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2016]||(e[2016]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates an MLIR context and transfers its ownership to the caller. This sets the default multithreading option (enabled).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2015]||(e[2015]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L321-L325",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_o,[t("summary",null,[e[2017]||(e[2017]=t("a",{id:"Reactant.MLIR.API.mlirContextCreateWithRegistry-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirContextCreateWithRegistry-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextCreateWithRegistry")],-1)),e[2018]||(e[2018]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2020]||(e[2020]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextCreateWithRegistry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(registry, threadingEnabled)</span></span></code></pre></div><p>Creates an MLIR context, setting the multithreading setting explicitly and pre-loading the dialects from the provided DialectRegistry.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2019]||(e[2019]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L339-L343",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mo,[t("summary",null,[e[2021]||(e[2021]=t("a",{id:"Reactant.MLIR.API.mlirContextCreateWithThreading-Tuple{Any}",href:"#Reactant.MLIR.API.mlirContextCreateWithThreading-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextCreateWithThreading")],-1)),e[2022]||(e[2022]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2024]||(e[2024]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextCreateWithThreading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(threadingEnabled)</span></span></code></pre></div><p>Creates an MLIR context with an explicit setting of the multithreading setting and transfers its ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2023]||(e[2023]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L330-L334",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Eo,[t("summary",null,[e[2025]||(e[2025]=t("a",{id:"Reactant.MLIR.API.mlirContextDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirContextDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextDestroy")],-1)),e[2026]||(e[2026]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2028]||(e[2028]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Takes an MLIR context owned by the caller and destroys it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2027]||(e[2027]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L368-L372",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Lo,[t("summary",null,[e[2029]||(e[2029]=t("a",{id:"Reactant.MLIR.API.mlirContextDetachDiagnosticHandler-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirContextDetachDiagnosticHandler-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextDetachDiagnosticHandler")],-1)),e[2030]||(e[2030]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2032]||(e[2032]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextDetachDiagnosticHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, id)</span></span></code></pre></div><p>Detaches an attached diagnostic handler from the context given its identifier.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2031]||(e[2031]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6354-L6358",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Co,[t("summary",null,[e[2033]||(e[2033]=t("a",{id:"Reactant.MLIR.API.mlirContextEnableMultithreading-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirContextEnableMultithreading-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextEnableMultithreading")],-1)),e[2034]||(e[2034]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2036]||(e[2036]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextEnableMultithreading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, enable)</span></span></code></pre></div><p>Set threading mode (must be set to false to mlir-print-ir-after-all).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2035]||(e[2035]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L437-L441",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vo,[t("summary",null,[e[2037]||(e[2037]=t("a",{id:"Reactant.MLIR.API.mlirContextEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirContextEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextEqual")],-1)),e[2038]||(e[2038]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2040]||(e[2040]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx1, ctx2)</span></span></code></pre></div><p>Checks if two contexts are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2039]||(e[2039]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L350-L354",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Po,[t("summary",null,[e[2041]||(e[2041]=t("a",{id:"Reactant.MLIR.API.mlirContextGetAllowUnregisteredDialects-Tuple{Any}",href:"#Reactant.MLIR.API.mlirContextGetAllowUnregisteredDialects-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextGetAllowUnregisteredDialects")],-1)),e[2042]||(e[2042]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2044]||(e[2044]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextGetAllowUnregisteredDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Returns whether the context allows unregistered dialects.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2043]||(e[2043]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L388-L392",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xo,[t("summary",null,[e[2045]||(e[2045]=t("a",{id:"Reactant.MLIR.API.mlirContextGetNumLoadedDialects-Tuple{Any}",href:"#Reactant.MLIR.API.mlirContextGetNumLoadedDialects-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextGetNumLoadedDialects")],-1)),e[2046]||(e[2046]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2048]||(e[2048]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextGetNumLoadedDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Returns the number of dialects loaded by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2047]||(e[2047]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L417-L421",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",So,[t("summary",null,[e[2049]||(e[2049]=t("a",{id:"Reactant.MLIR.API.mlirContextGetNumRegisteredDialects-Tuple{Any}",href:"#Reactant.MLIR.API.mlirContextGetNumRegisteredDialects-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextGetNumRegisteredDialects")],-1)),e[2050]||(e[2050]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2052]||(e[2052]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextGetNumRegisteredDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Returns the number of dialects registered with the given context. A registered dialect will be loaded if needed by the parser.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2051]||(e[2051]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L397-L401",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Do,[t("summary",null,[e[2053]||(e[2053]=t("a",{id:"Reactant.MLIR.API.mlirContextGetNumThreads-Tuple{Any}",href:"#Reactant.MLIR.API.mlirContextGetNumThreads-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextGetNumThreads")],-1)),e[2054]||(e[2054]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2056]||(e[2056]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextGetNumThreads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Gets the number of threads of the thread pool of the context when multithreading is enabled. Returns 1 if no multithreading.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2055]||(e[2055]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L477-L481",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fo,[t("summary",null,[e[2057]||(e[2057]=t("a",{id:"Reactant.MLIR.API.mlirContextGetOrLoadDialect-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirContextGetOrLoadDialect-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextGetOrLoadDialect")],-1)),e[2058]||(e[2058]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2060]||(e[2060]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextGetOrLoadDialect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, name)</span></span></code></pre></div><p>Gets the dialect instance owned by the given context using the dialect namespace to identify it, loads (i.e., constructs the instance of) the dialect if necessary. If the dialect is not registered with the context, returns null. Use mlirContextLoad&lt;Name&gt;Dialect to load an unregistered dialect.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2059]||(e[2059]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L426-L430",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vo,[t("summary",null,[e[2061]||(e[2061]=t("a",{id:"Reactant.MLIR.API.mlirContextGetThreadPool-Tuple{Any}",href:"#Reactant.MLIR.API.mlirContextGetThreadPool-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextGetThreadPool")],-1)),e[2062]||(e[2062]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2064]||(e[2064]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextGetThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Gets the thread pool of the context when enabled multithreading, otherwise an assertion is raised.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2063]||(e[2063]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L486-L490",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Oo,[t("summary",null,[e[2065]||(e[2065]=t("a",{id:"Reactant.MLIR.API.mlirContextIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirContextIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextIsNull")],-1)),e[2066]||(e[2066]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2068]||(e[2068]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Checks whether a context is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2067]||(e[2067]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L359-L363",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bo,[t("summary",null,[e[2069]||(e[2069]=t("a",{id:"Reactant.MLIR.API.mlirContextIsRegisteredOperation-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirContextIsRegisteredOperation-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextIsRegisteredOperation")],-1)),e[2070]||(e[2070]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2072]||(e[2072]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextIsRegisteredOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, name)</span></span></code></pre></div><p>Returns whether the given fully-qualified operation (i.e. &#39;dialect.operation&#39;) is registered with the context. This will return true if the dialect is loaded and the operation is registered within the dialect.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2071]||(e[2071]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L455-L459",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",No,[t("summary",null,[e[2073]||(e[2073]=t("a",{id:"Reactant.MLIR.API.mlirContextLoadAllAvailableDialects-Tuple{Any}",href:"#Reactant.MLIR.API.mlirContextLoadAllAvailableDialects-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextLoadAllAvailableDialects")],-1)),e[2074]||(e[2074]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2076]||(e[2076]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextLoadAllAvailableDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Eagerly loads all available dialects registered with a context, making them available for use for IR construction.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2075]||(e[2075]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L446-L450",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Go,[t("summary",null,[e[2077]||(e[2077]=t("a",{id:"Reactant.MLIR.API.mlirContextSetAllowUnregisteredDialects-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirContextSetAllowUnregisteredDialects-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextSetAllowUnregisteredDialects")],-1)),e[2078]||(e[2078]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2080]||(e[2080]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextSetAllowUnregisteredDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, allow)</span></span></code></pre></div><p>Sets whether unregistered dialects are allowed in this context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2079]||(e[2079]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L377-L381",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zo,[t("summary",null,[e[2081]||(e[2081]=t("a",{id:"Reactant.MLIR.API.mlirContextSetThreadPool-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirContextSetThreadPool-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirContextSetThreadPool")],-1)),e[2082]||(e[2082]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2084]||(e[2084]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextSetThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, threadPool)</span></span></code></pre></div><p>Sets the thread pool of the context explicitly, enabling multithreading in the process. This API should be used to avoid re-creating thread pools in long-running applications that perform multiple compilations, see the C++ documentation for MLIRContext for details.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2083]||(e[2083]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L466-L470",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wo,[t("summary",null,[e[2085]||(e[2085]=t("a",{id:"Reactant.MLIR.API.mlirCreateExternalPass-NTuple{9, Any}",href:"#Reactant.MLIR.API.mlirCreateExternalPass-NTuple{9, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirCreateExternalPass")],-1)),e[2086]||(e[2086]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2088]||(e[2088]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirCreateExternalPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passID, name, argument, description, opName, nDependentDialects, dependentDialects, callbacks, userData)</span></span></code></pre></div><p>Creates an external <a href="./@ref"><code>MlirPass</code></a> that calls the supplied <code>callbacks</code> using the supplied <code>userData</code>. If <code>opName</code> is empty, the pass is a generic operation pass. Otherwise it is an operation pass specific to the specified pass name.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2087]||(e[2087]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9128-L9132",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Uo,[t("summary",null,[e[2089]||(e[2089]=t("a",{id:"Reactant.MLIR.API.mlirDenseArrayGetNumElements-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDenseArrayGetNumElements-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseArrayGetNumElements")],-1)),e[2090]||(e[2090]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2092]||(e[2092]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseArrayGetNumElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Get the size of a dense array.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2091]||(e[2091]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4241-L4245",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qo,[t("summary",null,[e[2093]||(e[2093]=t("a",{id:"Reactant.MLIR.API.mlirDenseBoolArrayGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirDenseBoolArrayGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseBoolArrayGet")],-1)),e[2094]||(e[2094]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2096]||(e[2096]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseBoolArrayGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, size, values)</span></span></code></pre></div><p>Create a dense array attribute with the given elements.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2095]||(e[2095]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4194-L4198",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qo,[t("summary",null,[e[2097]||(e[2097]=t("a",{id:"Reactant.MLIR.API.mlirDenseBoolArrayGetElement-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirDenseBoolArrayGetElement-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseBoolArrayGetElement")],-1)),e[2098]||(e[2098]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2100]||(e[2100]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseBoolArrayGetElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, pos)</span></span></code></pre></div><p>Get an element of a dense array.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2099]||(e[2099]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4250-L4254",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wo,[t("summary",null,[e[2101]||(e[2101]=t("a",{id:"Reactant.MLIR.API.mlirDenseBoolResourceElementsAttrGetValue-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirDenseBoolResourceElementsAttrGetValue-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseBoolResourceElementsAttrGetValue")],-1)),e[2102]||(e[2102]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2104]||(e[2104]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseBoolResourceElementsAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, pos)</span></span></code></pre></div><p>Returns the pos-th value (flat contiguous indexing) of a specific type contained by the given dense resource elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2103]||(e[2103]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4802-L4806",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zo,[t("summary",null,[e[2105]||(e[2105]=t("a",{id:"Reactant.MLIR.API.mlirDenseElementsAttrBoolGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirDenseElementsAttrBoolGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseElementsAttrBoolGet")],-1)),e[2106]||(e[2106]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2108]||(e[2108]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrBoolGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, numElements, elements)</span></span></code></pre></div><p>Creates a dense elements attribute with the given shaped type from elements of a specific type. Expects the element type of the shaped type to match the data element type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2107]||(e[2107]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4400-L4404",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ho,[t("summary",null,[e[2109]||(e[2109]=t("a",{id:"Reactant.MLIR.API.mlirDenseElementsAttrGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirDenseElementsAttrGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseElementsAttrGet")],-1)),e[2110]||(e[2110]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2112]||(e[2112]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, numElements, elements)</span></span></code></pre></div><p>Creates a dense elements attribute with the given Shaped type and elements in the same context as the type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2111]||(e[2111]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4309-L4313",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jo,[t("summary",null,[e[2113]||(e[2113]=t("a",{id:"Reactant.MLIR.API.mlirDenseElementsAttrGetBoolValue-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirDenseElementsAttrGetBoolValue-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseElementsAttrGetBoolValue")],-1)),e[2114]||(e[2114]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2116]||(e[2116]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrGetBoolValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, pos)</span></span></code></pre></div><p>Returns the pos-th value (flat contiguous indexing) of a specific type contained by the given dense elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2115]||(e[2115]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4565-L4569",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ko,[t("summary",null,[e[2117]||(e[2117]=t("a",{id:"Reactant.MLIR.API.mlirDenseElementsAttrGetRawData-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDenseElementsAttrGetRawData-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseElementsAttrGetRawData")],-1)),e[2118]||(e[2118]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2120]||(e[2120]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrGetRawData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the raw data of the given dense elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2119]||(e[2119]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4648-L4652",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$o,[t("summary",null,[e[2121]||(e[2121]=t("a",{id:"Reactant.MLIR.API.mlirDenseElementsAttrGetSplatValue-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDenseElementsAttrGetSplatValue-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseElementsAttrGetSplatValue")],-1)),e[2122]||(e[2122]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2124]||(e[2124]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrGetSplatValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the single replicated value (splat) of a specific type contained by the given dense elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2123]||(e[2123]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4514-L4518",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xo,[t("summary",null,[e[2125]||(e[2125]=t("a",{id:"Reactant.MLIR.API.mlirDenseElementsAttrIsSplat-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDenseElementsAttrIsSplat-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseElementsAttrIsSplat")],-1)),e[2126]||(e[2126]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2128]||(e[2128]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrIsSplat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given dense elements attribute contains a single replicated value (splat).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2127]||(e[2127]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4505-L4509",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yo,[t("summary",null,[e[2129]||(e[2129]=t("a",{id:"Reactant.MLIR.API.mlirDenseElementsAttrRawBufferGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirDenseElementsAttrRawBufferGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseElementsAttrRawBufferGet")],-1)),e[2130]||(e[2130]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2132]||(e[2132]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrRawBufferGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, rawBufferSize, rawBuffer)</span></span></code></pre></div><p>Creates a dense elements attribute with the given Shaped type and elements populated from a packed, row-major opaque buffer of contents.</p><p>The format of the raw buffer is a densely packed array of values that can be bitcast to the storage format of the element type specified. Types that are not byte aligned will be: - For bitwidth &gt; 1: Rounded up to the next byte. - For bitwidth = 1: Packed into 8bit bytes with bits corresponding to the linear order of the shape type from MSB to LSB, padded to on the right.</p><p>A raw buffer of a single element (or for 1-bit, a byte of value 0 or 255) will be interpreted as a splat. User code should be prepared for additional, conformant patterns to be identified as splats in the future.</p>',4)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2131]||(e[2131]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4320-L4328",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ep,[t("summary",null,[e[2133]||(e[2133]=t("a",{id:"Reactant.MLIR.API.mlirDenseElementsAttrReshapeGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirDenseElementsAttrReshapeGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseElementsAttrReshapeGet")],-1)),e[2134]||(e[2134]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2136]||(e[2136]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrReshapeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, shapedType)</span></span></code></pre></div><p>Creates a dense elements attribute that has the same data as the given dense elements attribute and a different shaped type. The new type must have the same total number of elements.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2135]||(e[2135]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4494-L4498",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",tp,[t("summary",null,[e[2137]||(e[2137]=t("a",{id:"Reactant.MLIR.API.mlirDenseElementsAttrSplatGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirDenseElementsAttrSplatGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseElementsAttrSplatGet")],-1)),e[2138]||(e[2138]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2140]||(e[2140]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrSplatGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, element)</span></span></code></pre></div><p>Creates a dense elements attribute with the given Shaped type containing a single replicated element (splat).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2139]||(e[2139]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4335-L4339",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sp,[t("summary",null,[e[2141]||(e[2141]=t("a",{id:"Reactant.MLIR.API.mlirDenseElementsAttrStringGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirDenseElementsAttrStringGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseElementsAttrStringGet")],-1)),e[2142]||(e[2142]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2144]||(e[2144]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrStringGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, numElements, strs)</span></span></code></pre></div><p>Creates a dense elements attribute with the given shaped type from string elements.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2143]||(e[2143]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4483-L4487",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ap,[t("summary",null,[e[2145]||(e[2145]=t("a",{id:"Reactant.MLIR.API.mlirDenseIntOrFPElementsAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirDenseIntOrFPElementsAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDenseIntOrFPElementsAttrGetTypeID")],-1)),e[2146]||(e[2146]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2148]||(e[2148]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseIntOrFPElementsAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an DenseIntOrFPElements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2147]||(e[2147]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4300-L4304",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ip,[t("summary",null,[e[2149]||(e[2149]=t("a",{id:"Reactant.MLIR.API.mlirDiagnosticGetLocation-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDiagnosticGetLocation-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDiagnosticGetLocation")],-1)),e[2150]||(e[2150]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2152]||(e[2152]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDiagnosticGetLocation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diagnostic)</span></span></code></pre></div><p>Returns the location at which the diagnostic is reported.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2151]||(e[2151]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6300-L6304",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",lp,[t("summary",null,[e[2153]||(e[2153]=t("a",{id:"Reactant.MLIR.API.mlirDiagnosticGetNote-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirDiagnosticGetNote-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDiagnosticGetNote")],-1)),e[2154]||(e[2154]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2156]||(e[2156]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDiagnosticGetNote</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diagnostic, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th note attached to the diagnostic. Expects <code>pos</code> to be a valid zero-based index into the list of notes.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2155]||(e[2155]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6329-L6333",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",np,[t("summary",null,[e[2157]||(e[2157]=t("a",{id:"Reactant.MLIR.API.mlirDiagnosticGetNumNotes-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDiagnosticGetNumNotes-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDiagnosticGetNumNotes")],-1)),e[2158]||(e[2158]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2160]||(e[2160]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDiagnosticGetNumNotes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diagnostic)</span></span></code></pre></div><p>Returns the number of notes attached to the diagnostic.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2159]||(e[2159]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6320-L6324",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rp,[t("summary",null,[e[2161]||(e[2161]=t("a",{id:"Reactant.MLIR.API.mlirDiagnosticGetSeverity-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDiagnosticGetSeverity-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDiagnosticGetSeverity")],-1)),e[2162]||(e[2162]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2164]||(e[2164]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDiagnosticGetSeverity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diagnostic)</span></span></code></pre></div><p>Returns the severity of the diagnostic.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2163]||(e[2163]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6309-L6313",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",op,[t("summary",null,[e[2165]||(e[2165]=t("a",{id:"Reactant.MLIR.API.mlirDiagnosticPrint-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirDiagnosticPrint-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDiagnosticPrint")],-1)),e[2166]||(e[2166]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2168]||(e[2168]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDiagnosticPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diagnostic, callback, userData)</span></span></code></pre></div><p>Prints a diagnostic using the provided callback.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2167]||(e[2167]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6289-L6293",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pp,[t("summary",null,[e[2169]||(e[2169]=t("a",{id:"Reactant.MLIR.API.mlirDialectEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirDialectEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDialectEqual")],-1)),e[2170]||(e[2170]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2172]||(e[2172]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dialect1, dialect2)</span></span></code></pre></div><p>Checks if two dialects that belong to the same context are equal. Dialects from different contexts will not compare equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2171]||(e[2171]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L513-L517",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dp,[t("summary",null,[e[2173]||(e[2173]=t("a",{id:"Reactant.MLIR.API.mlirDialectGetContext-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDialectGetContext-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDialectGetContext")],-1)),e[2174]||(e[2174]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2176]||(e[2176]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dialect)</span></span></code></pre></div><p>Returns the context that owns the dialect.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2175]||(e[2175]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L495-L499",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",up,[t("summary",null,[e[2177]||(e[2177]=t("a",{id:"Reactant.MLIR.API.mlirDialectGetNamespace-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDialectGetNamespace-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDialectGetNamespace")],-1)),e[2178]||(e[2178]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2180]||(e[2180]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectGetNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dialect)</span></span></code></pre></div><p>Returns the namespace of the given dialect.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2179]||(e[2179]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L522-L526",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bp,[t("summary",null,[e[2181]||(e[2181]=t("a",{id:"Reactant.MLIR.API.mlirDialectHandleGetNamespace-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDialectHandleGetNamespace-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDialectHandleGetNamespace")],-1)),e[2182]||(e[2182]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2184]||(e[2184]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectHandleGetNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1)</span></span></code></pre></div><p>Returns the namespace associated with the provided dialect handle.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2183]||(e[2183]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L531-L535",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cp,[t("summary",null,[e[2185]||(e[2185]=t("a",{id:"Reactant.MLIR.API.mlirDialectHandleInsertDialect-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirDialectHandleInsertDialect-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDialectHandleInsertDialect")],-1)),e[2186]||(e[2186]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2188]||(e[2188]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectHandleInsertDialect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1, arg2)</span></span></code></pre></div><p>Inserts the dialect associated with the provided dialect handle into the provided dialect registry</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2187]||(e[2187]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L540-L544",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hp,[t("summary",null,[e[2189]||(e[2189]=t("a",{id:"Reactant.MLIR.API.mlirDialectHandleLoadDialect-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirDialectHandleLoadDialect-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDialectHandleLoadDialect")],-1)),e[2190]||(e[2190]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2192]||(e[2192]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectHandleLoadDialect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1, arg2)</span></span></code></pre></div><p>Loads the dialect associated with the provided dialect handle.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2191]||(e[2191]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L562-L566",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yp,[t("summary",null,[e[2193]||(e[2193]=t("a",{id:"Reactant.MLIR.API.mlirDialectHandleRegisterDialect-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirDialectHandleRegisterDialect-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDialectHandleRegisterDialect")],-1)),e[2194]||(e[2194]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2196]||(e[2196]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectHandleRegisterDialect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1, arg2)</span></span></code></pre></div><p>Registers the dialect associated with the provided dialect handle.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2195]||(e[2195]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L551-L555",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gp,[t("summary",null,[e[2197]||(e[2197]=t("a",{id:"Reactant.MLIR.API.mlirDialectIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDialectIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDialectIsNull")],-1)),e[2198]||(e[2198]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2200]||(e[2200]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dialect)</span></span></code></pre></div><p>Checks if the dialect is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2199]||(e[2199]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L504-L508",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mp,[t("summary",null,[e[2201]||(e[2201]=t("a",{id:"Reactant.MLIR.API.mlirDialectRegistryCreate-Tuple{}",href:"#Reactant.MLIR.API.mlirDialectRegistryCreate-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDialectRegistryCreate")],-1)),e[2202]||(e[2202]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2204]||(e[2204]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectRegistryCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a dialect registry and transfers its ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2203]||(e[2203]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L573-L577",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",kp,[t("summary",null,[e[2205]||(e[2205]=t("a",{id:"Reactant.MLIR.API.mlirDialectRegistryDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDialectRegistryDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDialectRegistryDestroy")],-1)),e[2206]||(e[2206]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2208]||(e[2208]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectRegistryDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(registry)</span></span></code></pre></div><p>Takes a dialect registry owned by the caller and destroys it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2207]||(e[2207]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L591-L595",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rp,[t("summary",null,[e[2209]||(e[2209]=t("a",{id:"Reactant.MLIR.API.mlirDialectRegistryIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDialectRegistryIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDialectRegistryIsNull")],-1)),e[2210]||(e[2210]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2212]||(e[2212]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectRegistryIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(registry)</span></span></code></pre></div><p>Checks if the dialect registry is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2211]||(e[2211]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L582-L586",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fp,[t("summary",null,[e[2213]||(e[2213]=t("a",{id:"Reactant.MLIR.API.mlirDictionaryAttrGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirDictionaryAttrGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDictionaryAttrGet")],-1)),e[2214]||(e[2214]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2216]||(e[2216]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDictionaryAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, numElements, elements)</span></span></code></pre></div><p>Creates a dictionary attribute containing the given list of elements in the provided context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2215]||(e[2215]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3633-L3637",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ip,[t("summary",null,[e[2217]||(e[2217]=t("a",{id:"Reactant.MLIR.API.mlirDictionaryAttrGetElement-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirDictionaryAttrGetElement-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDictionaryAttrGetElement")],-1)),e[2218]||(e[2218]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2220]||(e[2220]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDictionaryAttrGetElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, pos)</span></span></code></pre></div><p>Returns pos-th element of the given dictionary attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2219]||(e[2219]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3653-L3657",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Tp,[t("summary",null,[e[2221]||(e[2221]=t("a",{id:"Reactant.MLIR.API.mlirDictionaryAttrGetElementByName-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirDictionaryAttrGetElementByName-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDictionaryAttrGetElementByName")],-1)),e[2222]||(e[2222]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2224]||(e[2224]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDictionaryAttrGetElementByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, name)</span></span></code></pre></div><p>Returns the dictionary attribute element with the given name or NULL if the given name does not exist in the dictionary.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2223]||(e[2223]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3664-L3668",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ap,[t("summary",null,[e[2225]||(e[2225]=t("a",{id:"Reactant.MLIR.API.mlirDictionaryAttrGetNumElements-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDictionaryAttrGetNumElements-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDictionaryAttrGetNumElements")],-1)),e[2226]||(e[2226]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2228]||(e[2228]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDictionaryAttrGetNumElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the number of attributes contained in a dictionary attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2227]||(e[2227]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3644-L3648",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jp,[t("summary",null,[e[2229]||(e[2229]=t("a",{id:"Reactant.MLIR.API.mlirDictionaryAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirDictionaryAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDictionaryAttrGetTypeID")],-1)),e[2230]||(e[2230]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2232]||(e[2232]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDictionaryAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a Dictionary attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2231]||(e[2231]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3675-L3679",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_p,[t("summary",null,[e[2233]||(e[2233]=t("a",{id:"Reactant.MLIR.API.mlirDisctinctAttrCreate-Tuple{Any}",href:"#Reactant.MLIR.API.mlirDisctinctAttrCreate-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirDisctinctAttrCreate")],-1)),e[2234]||(e[2234]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2236]||(e[2236]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDisctinctAttrCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(referencedAttr)</span></span></code></pre></div><p>Creates a DisctinctAttr with the referenced attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2235]||(e[2235]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4016-L4020",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mp,[t("summary",null,[e[2237]||(e[2237]=t("a",{id:"Reactant.MLIR.API.mlirElementsAttrGetNumElements-Tuple{Any}",href:"#Reactant.MLIR.API.mlirElementsAttrGetNumElements-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirElementsAttrGetNumElements")],-1)),e[2238]||(e[2238]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2240]||(e[2240]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirElementsAttrGetNumElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Gets the total number of elements in the given elements attribute. In order to iterate over the attribute, obtain its type, which must be a statically shaped type and use its sizes to build a multi-dimensional index.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2239]||(e[2239]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4148-L4152",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ep,[t("summary",null,[e[2241]||(e[2241]=t("a",{id:"Reactant.MLIR.API.mlirElementsAttrGetValue-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirElementsAttrGetValue-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirElementsAttrGetValue")],-1)),e[2242]||(e[2242]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2244]||(e[2244]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirElementsAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, rank, idxs)</span></span></code></pre></div><p>Returns the element at the given rank-dimensional index.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2243]||(e[2243]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4126-L4130",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Lp,[t("summary",null,[e[2245]||(e[2245]=t("a",{id:"Reactant.MLIR.API.mlirElementsAttrIsValidIndex-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirElementsAttrIsValidIndex-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirElementsAttrIsValidIndex")],-1)),e[2246]||(e[2246]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2248]||(e[2248]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirElementsAttrIsValidIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, rank, idxs)</span></span></code></pre></div><p>Checks whether the given rank-dimensional index is valid in the given elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2247]||(e[2247]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4137-L4141",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Cp,[t("summary",null,[e[2249]||(e[2249]=t("a",{id:"Reactant.MLIR.API.mlirEmitError-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirEmitError-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirEmitError")],-1)),e[2250]||(e[2250]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2252]||(e[2252]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirEmitError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location, message)</span></span></code></pre></div><p>Emits an error at the given location through the diagnostics engine. Used for testing purposes.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2251]||(e[2251]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6365-L6369",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vp,[t("summary",null,[e[2253]||(e[2253]=t("a",{id:"Reactant.MLIR.API.mlirEnableGlobalDebug-Tuple{Any}",href:"#Reactant.MLIR.API.mlirEnableGlobalDebug-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirEnableGlobalDebug")],-1)),e[2254]||(e[2254]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2256]||(e[2256]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirEnableGlobalDebug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(enable)</span></span></code></pre></div><p>Sets the global debugging flag.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2255]||(e[2255]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6212-L6216",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pp,[t("summary",null,[e[2257]||(e[2257]=t("a",{id:"Reactant.MLIR.API.mlirExecutionEngineCreate-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirExecutionEngineCreate-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirExecutionEngineCreate")],-1)),e[2258]||(e[2258]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2260]||(e[2260]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, optLevel, numPaths, sharedLibPaths, enableObjectDump)</span></span></code></pre></div><p>Creates an ExecutionEngine for the provided ModuleOp. The ModuleOp is expected to be &quot;translatable&quot; to LLVM IR (only contains operations in dialects that implement the <code>LLVMTranslationDialectInterface</code>). The module ownership stays with the client and can be destroyed as soon as the call returns. <code>optLevel</code> is the optimization level to be used for transformation and code generation. LLVM passes at <code>optLevel</code> are run before code generation. The number and array of paths corresponding to shared libraries that will be loaded are specified via <code>numPaths</code> and <code>sharedLibPaths</code> respectively. TODO: figure out other options.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2259]||(e[2259]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8665-L8669",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xp,[t("summary",null,[e[2261]||(e[2261]=t("a",{id:"Reactant.MLIR.API.mlirExecutionEngineDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirExecutionEngineDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirExecutionEngineDestroy")],-1)),e[2262]||(e[2262]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2264]||(e[2264]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit)</span></span></code></pre></div><p>Destroy an ExecutionEngine instance.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2263]||(e[2263]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8689-L8693",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sp,[t("summary",null,[e[2265]||(e[2265]=t("a",{id:"Reactant.MLIR.API.mlirExecutionEngineDumpToObjectFile-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirExecutionEngineDumpToObjectFile-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirExecutionEngineDumpToObjectFile")],-1)),e[2266]||(e[2266]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2268]||(e[2268]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineDumpToObjectFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit, fileName)</span></span></code></pre></div><p>Dump as an object in <code>fileName</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2267]||(e[2267]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8751-L8755",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Dp,[t("summary",null,[e[2269]||(e[2269]=t("a",{id:"Reactant.MLIR.API.mlirExecutionEngineInitialize-Tuple{Any}",href:"#Reactant.MLIR.API.mlirExecutionEngineInitialize-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirExecutionEngineInitialize")],-1)),e[2270]||(e[2270]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2272]||(e[2272]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineInitialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit)</span></span></code></pre></div><p>Initialize the ExecutionEngine. Global constructors specified by <code>llvm.mlir.global\\_ctors</code> will be run. One common scenario is that kernel binary compiled from <code>gpu.module</code> gets loaded during initialization. Make sure all symbols are resolvable before initialization by calling <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirExecutionEngineRegisterSymbol-Tuple{Any, Any, Any}"><code>mlirExecutionEngineRegisterSymbol</code></a> or including shared libraries.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2271]||(e[2271]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8680-L8684",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fp,[t("summary",null,[e[2273]||(e[2273]=t("a",{id:"Reactant.MLIR.API.mlirExecutionEngineInvokePacked-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirExecutionEngineInvokePacked-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirExecutionEngineInvokePacked")],-1)),e[2274]||(e[2274]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2276]||(e[2276]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineInvokePacked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit, name, arguments)</span></span></code></pre></div><p>Invoke a native function in the execution engine by name with the arguments and result of the invoked function passed as an array of pointers. The function must have been tagged with the <code>llvm.emit\\_c\\_interface</code> attribute. Returns a failure if the execution fails for any reason (the function name can&#39;t be resolved for instance).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2275]||(e[2275]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8707-L8711",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vp,[t("summary",null,[e[2277]||(e[2277]=t("a",{id:"Reactant.MLIR.API.mlirExecutionEngineIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirExecutionEngineIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirExecutionEngineIsNull")],-1)),e[2278]||(e[2278]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2280]||(e[2280]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit)</span></span></code></pre></div><p>Checks whether an execution engine is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2279]||(e[2279]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8698-L8702",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Op,[t("summary",null,[e[2281]||(e[2281]=t("a",{id:"Reactant.MLIR.API.mlirExecutionEngineLookup-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirExecutionEngineLookup-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirExecutionEngineLookup")],-1)),e[2282]||(e[2282]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2284]||(e[2284]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineLookup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit, name)</span></span></code></pre></div><p>Lookup a native function in the execution engine by name, returns nullptr if the name can&#39;t be looked-up.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2283]||(e[2283]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8729-L8733",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bp,[t("summary",null,[e[2285]||(e[2285]=t("a",{id:"Reactant.MLIR.API.mlirExecutionEngineLookupPacked-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirExecutionEngineLookupPacked-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirExecutionEngineLookupPacked")],-1)),e[2286]||(e[2286]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2288]||(e[2288]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineLookupPacked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit, name)</span></span></code></pre></div><p>Lookup the wrapper of the native function in the execution engine with the given name, returns nullptr if the function can&#39;t be looked-up.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2287]||(e[2287]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8718-L8722",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Np,[t("summary",null,[e[2289]||(e[2289]=t("a",{id:"Reactant.MLIR.API.mlirExecutionEngineRegisterSymbol-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirExecutionEngineRegisterSymbol-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirExecutionEngineRegisterSymbol")],-1)),e[2290]||(e[2290]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2292]||(e[2292]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineRegisterSymbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit, name, sym)</span></span></code></pre></div><p>Register a symbol with the jit: this symbol will be accessible to the jitted code.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2291]||(e[2291]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8740-L8744",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gp,[t("summary",null,[e[2293]||(e[2293]=t("a",{id:"Reactant.MLIR.API.mlirExternalPassSignalFailure-Tuple{Any}",href:"#Reactant.MLIR.API.mlirExternalPassSignalFailure-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirExternalPassSignalFailure")],-1)),e[2294]||(e[2294]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2296]||(e[2296]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExternalPassSignalFailure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pass)</span></span></code></pre></div><p>This signals that the pass has failed. This is only valid to call during the <code>run</code> callback of <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.MlirExternalPassCallbacks"><code>MlirExternalPassCallbacks</code></a>. See Pass::signalPassFailure().</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2295]||(e[2295]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9157-L9161",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zp,[t("summary",null,[e[2297]||(e[2297]=t("a",{id:"Reactant.MLIR.API.mlirF16TypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirF16TypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirF16TypeGet")],-1)),e[2298]||(e[2298]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2300]||(e[2300]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirF16TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f16 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2299]||(e[2299]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5421-L5425",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wp,[t("summary",null,[e[2301]||(e[2301]=t("a",{id:"Reactant.MLIR.API.mlirF32TypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirF32TypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirF32TypeGet")],-1)),e[2302]||(e[2302]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2304]||(e[2304]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirF32TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f32 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2303]||(e[2303]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5448-L5452",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Up,[t("summary",null,[e[2305]||(e[2305]=t("a",{id:"Reactant.MLIR.API.mlirF64TypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirF64TypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirF64TypeGet")],-1)),e[2306]||(e[2306]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2308]||(e[2308]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirF64TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a f64 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2307]||(e[2307]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5475-L5479",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qp,[t("summary",null,[e[2309]||(e[2309]=t("a",{id:"Reactant.MLIR.API.mlirFlatSymbolRefAttrGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirFlatSymbolRefAttrGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFlatSymbolRefAttrGet")],-1)),e[2310]||(e[2310]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2312]||(e[2312]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFlatSymbolRefAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, symbol)</span></span></code></pre></div><p>Creates a flat symbol reference attribute in the given context referencing a symbol identified by the given string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2311]||(e[2311]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4034-L4038",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qp,[t("summary",null,[e[2313]||(e[2313]=t("a",{id:"Reactant.MLIR.API.mlirFlatSymbolRefAttrGetValue-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFlatSymbolRefAttrGetValue-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFlatSymbolRefAttrGetValue")],-1)),e[2314]||(e[2314]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2316]||(e[2316]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFlatSymbolRefAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the referenced symbol as a string reference. The data remains live as long as the context in which the attribute lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2315]||(e[2315]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4045-L4049",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wp,[t("summary",null,[e[2317]||(e[2317]=t("a",{id:"Reactant.MLIR.API.mlirFloat16TypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat16TypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat16TypeGetTypeID")],-1)),e[2318]||(e[2318]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2320]||(e[2320]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat16TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float16 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2319]||(e[2319]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5403-L5407",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zp,[t("summary",null,[e[2321]||(e[2321]=t("a",{id:"Reactant.MLIR.API.mlirFloat32TypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat32TypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat32TypeGetTypeID")],-1)),e[2322]||(e[2322]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2324]||(e[2324]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat32TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float32 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2323]||(e[2323]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5430-L5434",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hp,[t("summary",null,[e[2325]||(e[2325]=t("a",{id:"Reactant.MLIR.API.mlirFloat4E2M1FNTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloat4E2M1FNTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat4E2M1FNTypeGet")],-1)),e[2326]||(e[2326]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2328]||(e[2328]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat4E2M1FNTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f4E2M1FN type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2327]||(e[2327]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5097-L5101",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jp,[t("summary",null,[e[2329]||(e[2329]=t("a",{id:"Reactant.MLIR.API.mlirFloat4E2M1FNTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat4E2M1FNTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat4E2M1FNTypeGetTypeID")],-1)),e[2330]||(e[2330]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2332]||(e[2332]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat4E2M1FNTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float4E2M1FN type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2331]||(e[2331]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5079-L5083",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Kp,[t("summary",null,[e[2333]||(e[2333]=t("a",{id:"Reactant.MLIR.API.mlirFloat64TypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat64TypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat64TypeGetTypeID")],-1)),e[2334]||(e[2334]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2336]||(e[2336]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat64TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float64 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2335]||(e[2335]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5457-L5461",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$p,[t("summary",null,[e[2337]||(e[2337]=t("a",{id:"Reactant.MLIR.API.mlirFloat6E2M3FNTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloat6E2M3FNTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat6E2M3FNTypeGet")],-1)),e[2338]||(e[2338]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2340]||(e[2340]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat6E2M3FNTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f6E2M3FN type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2339]||(e[2339]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5124-L5128",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xp,[t("summary",null,[e[2341]||(e[2341]=t("a",{id:"Reactant.MLIR.API.mlirFloat6E2M3FNTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat6E2M3FNTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat6E2M3FNTypeGetTypeID")],-1)),e[2342]||(e[2342]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2344]||(e[2344]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat6E2M3FNTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float6E2M3FN type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2343]||(e[2343]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5106-L5110",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yp,[t("summary",null,[e[2345]||(e[2345]=t("a",{id:"Reactant.MLIR.API.mlirFloat6E3M2FNTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloat6E3M2FNTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat6E3M2FNTypeGet")],-1)),e[2346]||(e[2346]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2348]||(e[2348]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat6E3M2FNTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f6E3M2FN type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2347]||(e[2347]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5151-L5155",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ed,[t("summary",null,[e[2349]||(e[2349]=t("a",{id:"Reactant.MLIR.API.mlirFloat6E3M2FNTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat6E3M2FNTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat6E3M2FNTypeGetTypeID")],-1)),e[2350]||(e[2350]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2352]||(e[2352]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat6E3M2FNTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float6E3M2FN type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2351]||(e[2351]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5133-L5137",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",td,[t("summary",null,[e[2353]||(e[2353]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E3M4TypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloat8E3M4TypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E3M4TypeGet")],-1)),e[2354]||(e[2354]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2356]||(e[2356]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E3M4TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E3M4 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2355]||(e[2355]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5340-L5344",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sd,[t("summary",null,[e[2357]||(e[2357]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E3M4TypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat8E3M4TypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E3M4TypeGetTypeID")],-1)),e[2358]||(e[2358]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2360]||(e[2360]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E3M4TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E3M4 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2359]||(e[2359]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5322-L5326",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ad,[t("summary",null,[e[2361]||(e[2361]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGet")],-1)),e[2362]||(e[2362]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2364]||(e[2364]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3B11FNUZTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E4M3B11FNUZ type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2363]||(e[2363]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5313-L5317",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",id,[t("summary",null,[e[2365]||(e[2365]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGetTypeID")],-1)),e[2366]||(e[2366]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2368]||(e[2368]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3B11FNUZTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E4M3B11FNUZ type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2367]||(e[2367]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5295-L5299",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ld,[t("summary",null,[e[2369]||(e[2369]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E4M3FNTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloat8E4M3FNTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E4M3FNTypeGet")],-1)),e[2370]||(e[2370]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2372]||(e[2372]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3FNTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E4M3FN type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2371]||(e[2371]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5232-L5236",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",nd,[t("summary",null,[e[2373]||(e[2373]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E4M3FNTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat8E4M3FNTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E4M3FNTypeGetTypeID")],-1)),e[2374]||(e[2374]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2376]||(e[2376]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3FNTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E4M3FN type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2375]||(e[2375]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5214-L5218",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rd,[t("summary",null,[e[2377]||(e[2377]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGet")],-1)),e[2378]||(e[2378]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2380]||(e[2380]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3FNUZTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E4M3FNUZ type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2379]||(e[2379]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5286-L5290",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",od,[t("summary",null,[e[2381]||(e[2381]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGetTypeID")],-1)),e[2382]||(e[2382]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2384]||(e[2384]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3FNUZTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E4M3FNUZ type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2383]||(e[2383]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5268-L5272",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pd,[t("summary",null,[e[2385]||(e[2385]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E4M3TypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloat8E4M3TypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E4M3TypeGet")],-1)),e[2386]||(e[2386]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2388]||(e[2388]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E4M3 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2387]||(e[2387]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5205-L5209",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dd,[t("summary",null,[e[2389]||(e[2389]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E4M3TypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat8E4M3TypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E4M3TypeGetTypeID")],-1)),e[2390]||(e[2390]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2392]||(e[2392]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E4M3 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2391]||(e[2391]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5187-L5191",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ud,[t("summary",null,[e[2393]||(e[2393]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGet")],-1)),e[2394]||(e[2394]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2396]||(e[2396]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E5M2FNUZTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E5M2FNUZ type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2395]||(e[2395]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5259-L5263",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bd,[t("summary",null,[e[2397]||(e[2397]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGetTypeID")],-1)),e[2398]||(e[2398]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2400]||(e[2400]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E5M2FNUZTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E5M2FNUZ type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2399]||(e[2399]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5241-L5245",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cd,[t("summary",null,[e[2401]||(e[2401]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E5M2TypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloat8E5M2TypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E5M2TypeGet")],-1)),e[2402]||(e[2402]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2404]||(e[2404]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E5M2TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E5M2 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2403]||(e[2403]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5178-L5182",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hd,[t("summary",null,[e[2405]||(e[2405]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E5M2TypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat8E5M2TypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E5M2TypeGetTypeID")],-1)),e[2406]||(e[2406]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2408]||(e[2408]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E5M2TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E5M2 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2407]||(e[2407]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5160-L5164",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yd,[t("summary",null,[e[2409]||(e[2409]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E8M0FNUTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloat8E8M0FNUTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E8M0FNUTypeGet")],-1)),e[2410]||(e[2410]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2412]||(e[2412]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E8M0FNUTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E8M0FNU type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2411]||(e[2411]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5367-L5371",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gd,[t("summary",null,[e[2413]||(e[2413]=t("a",{id:"Reactant.MLIR.API.mlirFloat8E8M0FNUTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloat8E8M0FNUTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloat8E8M0FNUTypeGetTypeID")],-1)),e[2414]||(e[2414]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2416]||(e[2416]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E8M0FNUTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E8M0FNU type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2415]||(e[2415]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5349-L5353",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",md,[t("summary",null,[e[2417]||(e[2417]=t("a",{id:"Reactant.MLIR.API.mlirFloatAttrDoubleGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirFloatAttrDoubleGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloatAttrDoubleGet")],-1)),e[2418]||(e[2418]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2420]||(e[2420]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloatAttrDoubleGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, type, value)</span></span></code></pre></div><p>Creates a floating point attribute in the given context with the given double value and double-precision FP semantics.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2419]||(e[2419]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3693-L3697",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",kd,[t("summary",null,[e[2421]||(e[2421]=t("a",{id:"Reactant.MLIR.API.mlirFloatAttrDoubleGetChecked-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirFloatAttrDoubleGetChecked-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloatAttrDoubleGetChecked")],-1)),e[2422]||(e[2422]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2424]||(e[2424]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloatAttrDoubleGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, type, value)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirFloatAttrDoubleGet-Tuple{Any, Any, Any}"><code>mlirFloatAttrDoubleGet</code></a>&quot;, but if the type is not valid for a construction of a FloatAttr, returns a null <a href="./@ref"><code>MlirAttribute</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2423]||(e[2423]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3704-L3708",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rd,[t("summary",null,[e[2425]||(e[2425]=t("a",{id:"Reactant.MLIR.API.mlirFloatAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloatAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloatAttrGetTypeID")],-1)),e[2426]||(e[2426]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2428]||(e[2428]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloatAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a Float attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2427]||(e[2427]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3724-L3728",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fd,[t("summary",null,[e[2429]||(e[2429]=t("a",{id:"Reactant.MLIR.API.mlirFloatAttrGetValueDouble-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloatAttrGetValueDouble-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloatAttrGetValueDouble")],-1)),e[2430]||(e[2430]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2432]||(e[2432]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloatAttrGetValueDouble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given floating point attribute, interpreting the value as double.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2431]||(e[2431]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3715-L3719",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Id,[t("summary",null,[e[2433]||(e[2433]=t("a",{id:"Reactant.MLIR.API.mlirFloatTF32TypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFloatTF32TypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloatTF32TypeGetTypeID")],-1)),e[2434]||(e[2434]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2436]||(e[2436]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloatTF32TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a TF32 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2435]||(e[2435]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5484-L5488",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Td,[t("summary",null,[e[2437]||(e[2437]=t("a",{id:"Reactant.MLIR.API.mlirFloatTypeGetWidth-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFloatTypeGetWidth-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFloatTypeGetWidth")],-1)),e[2438]||(e[2438]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2440]||(e[2440]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloatTypeGetWidth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the bitwidth of a floating-point type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2439]||(e[2439]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5070-L5074",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ad,[t("summary",null,[e[2441]||(e[2441]=t("a",{id:"Reactant.MLIR.API.mlirFreezeRewritePattern-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFreezeRewritePattern-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFreezeRewritePattern")],-1)),e[2442]||(e[2442]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2444]||(e[2444]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFreezeRewritePattern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Freeze the given <a href="./@ref"><code>MlirRewritePatternSet</code></a> to a <a href="./@ref"><code>MlirFrozenRewritePatternSet</code></a>. Note that the ownership of the input set is transferred into the frozen set after this call.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2443]||(e[2443]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9643-L9647",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jd,[t("summary",null,[e[2445]||(e[2445]=t("a",{id:"Reactant.MLIR.API.mlirFrozenRewritePatternSetDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFrozenRewritePatternSetDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFrozenRewritePatternSetDestroy")],-1)),e[2446]||(e[2446]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2448]||(e[2448]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFrozenRewritePatternSetDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Destroy the given <a href="./@ref"><code>MlirFrozenRewritePatternSet</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2447]||(e[2447]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9654-L9658",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_d,[t("summary",null,[e[2449]||(e[2449]=t("a",{id:"Reactant.MLIR.API.mlirFuncSetArgAttr-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirFuncSetArgAttr-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFuncSetArgAttr")],-1)),e[2450]||(e[2450]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2452]||(e[2452]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFuncSetArgAttr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos, name, attr)</span></span></code></pre></div><p>Sets the argument attribute &#39;name&#39; of an argument at index &#39;pos&#39;. Asserts that the operation is a FuncOp.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2451]||(e[2451]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6532-L6536",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Md,[t("summary",null,[e[2453]||(e[2453]=t("a",{id:"Reactant.MLIR.API.mlirFunctionTypeGet-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirFunctionTypeGet-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFunctionTypeGet")],-1)),e[2454]||(e[2454]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2456]||(e[2456]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFunctionTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, numInputs, inputs, numResults, results)</span></span></code></pre></div><p>Creates a function type, mapping a list of input types to result types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2455]||(e[2455]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6114-L6118",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ed,[t("summary",null,[e[2457]||(e[2457]=t("a",{id:"Reactant.MLIR.API.mlirFunctionTypeGetInput-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirFunctionTypeGetInput-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFunctionTypeGetInput")],-1)),e[2458]||(e[2458]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2460]||(e[2460]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFunctionTypeGetInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns the pos-th input type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2459]||(e[2459]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6147-L6151",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ld,[t("summary",null,[e[2461]||(e[2461]=t("a",{id:"Reactant.MLIR.API.mlirFunctionTypeGetNumInputs-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFunctionTypeGetNumInputs-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFunctionTypeGetNumInputs")],-1)),e[2462]||(e[2462]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2464]||(e[2464]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFunctionTypeGetNumInputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of input types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2463]||(e[2463]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6129-L6133",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Cd,[t("summary",null,[e[2465]||(e[2465]=t("a",{id:"Reactant.MLIR.API.mlirFunctionTypeGetNumResults-Tuple{Any}",href:"#Reactant.MLIR.API.mlirFunctionTypeGetNumResults-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFunctionTypeGetNumResults")],-1)),e[2466]||(e[2466]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2468]||(e[2468]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFunctionTypeGetNumResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of result types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2467]||(e[2467]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6138-L6142",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vd,[t("summary",null,[e[2469]||(e[2469]=t("a",{id:"Reactant.MLIR.API.mlirFunctionTypeGetResult-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirFunctionTypeGetResult-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFunctionTypeGetResult")],-1)),e[2470]||(e[2470]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2472]||(e[2472]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFunctionTypeGetResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns the pos-th result type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2471]||(e[2471]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6156-L6160",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pd,[t("summary",null,[e[2473]||(e[2473]=t("a",{id:"Reactant.MLIR.API.mlirFunctionTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirFunctionTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirFunctionTypeGetTypeID")],-1)),e[2474]||(e[2474]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2476]||(e[2476]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFunctionTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Function type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2475]||(e[2475]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6096-L6100",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xd,[t("summary",null,[e[2477]||(e[2477]=t("a",{id:"Reactant.MLIR.API.mlirIRRewriterCreate-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIRRewriterCreate-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIRRewriterCreate")],-1)),e[2478]||(e[2478]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2480]||(e[2480]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIRRewriterCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Create an IRRewriter and transfer ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2479]||(e[2479]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9616-L9620",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sd,[t("summary",null,[e[2481]||(e[2481]=t("a",{id:"Reactant.MLIR.API.mlirIRRewriterCreateFromOp-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIRRewriterCreateFromOp-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIRRewriterCreateFromOp")],-1)),e[2482]||(e[2482]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2484]||(e[2484]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIRRewriterCreateFromOp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Create an IRRewriter and transfer ownership to the caller. Additionally set the insertion point before the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2483]||(e[2483]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9625-L9629",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Dd,[t("summary",null,[e[2485]||(e[2485]=t("a",{id:"Reactant.MLIR.API.mlirIRRewriterDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIRRewriterDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIRRewriterDestroy")],-1)),e[2486]||(e[2486]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2488]||(e[2488]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIRRewriterDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter)</span></span></code></pre></div><p>Takes an IRRewriter owned by the caller and destroys it. It is the responsibility of the user to only pass an IRRewriter class.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2487]||(e[2487]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9634-L9638",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fd,[t("summary",null,[e[2489]||(e[2489]=t("a",{id:"Reactant.MLIR.API.mlirIdentifierEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirIdentifierEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIdentifierEqual")],-1)),e[2490]||(e[2490]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2492]||(e[2492]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIdentifierEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ident, other)</span></span></code></pre></div><p>Checks whether two identifiers are the same.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2491]||(e[2491]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2565-L2569",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vd,[t("summary",null,[e[2493]||(e[2493]=t("a",{id:"Reactant.MLIR.API.mlirIdentifierGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirIdentifierGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIdentifierGet")],-1)),e[2494]||(e[2494]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2496]||(e[2496]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIdentifierGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, str)</span></span></code></pre></div><p>Gets an identifier with the given string value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2495]||(e[2495]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2545-L2549",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Od,[t("summary",null,[e[2497]||(e[2497]=t("a",{id:"Reactant.MLIR.API.mlirIdentifierGetContext-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIdentifierGetContext-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIdentifierGetContext")],-1)),e[2498]||(e[2498]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2500]||(e[2500]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIdentifierGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1)</span></span></code></pre></div><p>Returns the context associated with this identifier</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2499]||(e[2499]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2556-L2560",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bd,[t("summary",null,[e[2501]||(e[2501]=t("a",{id:"Reactant.MLIR.API.mlirIdentifierStr-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIdentifierStr-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIdentifierStr")],-1)),e[2502]||(e[2502]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2504]||(e[2504]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIdentifierStr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ident)</span></span></code></pre></div><p>Gets the string value of the identifier.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2503]||(e[2503]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2574-L2578",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Nd,[t("summary",null,[e[2505]||(e[2505]=t("a",{id:"Reactant.MLIR.API.mlirIndexTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIndexTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIndexTypeGet")],-1)),e[2506]||(e[2506]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2508]||(e[2508]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIndexTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an index type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2507]||(e[2507]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5052-L5056",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gd,[t("summary",null,[e[2509]||(e[2509]=t("a",{id:"Reactant.MLIR.API.mlirIndexTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirIndexTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIndexTypeGetTypeID")],-1)),e[2510]||(e[2510]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2512]||(e[2512]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIndexTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Index type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2511]||(e[2511]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5034-L5038",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zd,[t("summary",null,[e[2513]||(e[2513]=t("a",{id:"Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceInferReturnTypes-NTuple{11, Any}",href:"#Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceInferReturnTypes-NTuple{11, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceInferReturnTypes")],-1)),e[2514]||(e[2514]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2516]||(e[2516]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirInferShapedTypeOpInterfaceInferReturnTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opName, context, location, nOperands, operands, attributes, properties, nRegions, regions, callback, userData)</span></span></code></pre></div><p>Infers the return shaped type components of the operation. Calls <code>callback</code> with the types of inferred arguments on success. Returns failure otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2515]||(e[2515]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8847-L8851",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wd,[t("summary",null,[e[2517]||(e[2517]=t("a",{id:"Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceTypeID")],-1)),e[2518]||(e[2518]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2520]||(e[2520]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirInferShapedTypeOpInterfaceTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the interface TypeID of the InferShapedTypeOpInterface.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2519]||(e[2519]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8832-L8836",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ud,[t("summary",null,[e[2521]||(e[2521]=t("a",{id:"Reactant.MLIR.API.mlirInferTypeOpInterfaceInferReturnTypes-NTuple{11, Any}",href:"#Reactant.MLIR.API.mlirInferTypeOpInterfaceInferReturnTypes-NTuple{11, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirInferTypeOpInterfaceInferReturnTypes")],-1)),e[2522]||(e[2522]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2524]||(e[2524]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirInferTypeOpInterfaceInferReturnTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opName, context, location, nOperands, operands, attributes, properties, nRegions, regions, callback, userData)</span></span></code></pre></div><p>Infers the return types of the operation identified by its canonical given the arguments that will be supplied to its generic builder. Calls <code>callback</code> with the types of inferred arguments, potentially several times, on success. Returns failure otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2523]||(e[2523]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8799-L8803",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qd,[t("summary",null,[e[2525]||(e[2525]=t("a",{id:"Reactant.MLIR.API.mlirInferTypeOpInterfaceTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirInferTypeOpInterfaceTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirInferTypeOpInterfaceTypeID")],-1)),e[2526]||(e[2526]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2528]||(e[2528]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirInferTypeOpInterfaceTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the interface TypeID of the InferTypeOpInterface.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2527]||(e[2527]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8784-L8788",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qd,[t("summary",null,[e[2529]||(e[2529]=t("a",{id:"Reactant.MLIR.API.mlirIntegerAttrGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirIntegerAttrGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerAttrGet")],-1)),e[2530]||(e[2530]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2532]||(e[2532]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, value)</span></span></code></pre></div><p>Creates an integer attribute of the given type with the given integer value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2531]||(e[2531]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3742-L3746",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wd,[t("summary",null,[e[2533]||(e[2533]=t("a",{id:"Reactant.MLIR.API.mlirIntegerAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirIntegerAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerAttrGetTypeID")],-1)),e[2534]||(e[2534]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2536]||(e[2536]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Integer attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2535]||(e[2535]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3778-L3782",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zd,[t("summary",null,[e[2537]||(e[2537]=t("a",{id:"Reactant.MLIR.API.mlirIntegerAttrGetValueInt-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerAttrGetValueInt-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerAttrGetValueInt")],-1)),e[2538]||(e[2538]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2540]||(e[2540]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerAttrGetValueInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given integer attribute, assuming the value is of signless type and fits into a signed 64-bit integer.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2539]||(e[2539]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3751-L3755",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hd,[t("summary",null,[e[2541]||(e[2541]=t("a",{id:"Reactant.MLIR.API.mlirIntegerAttrGetValueSInt-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerAttrGetValueSInt-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerAttrGetValueSInt")],-1)),e[2542]||(e[2542]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2544]||(e[2544]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerAttrGetValueSInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given integer attribute, assuming the value is of signed type and fits into a signed 64-bit integer.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2543]||(e[2543]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3760-L3764",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jd,[t("summary",null,[e[2545]||(e[2545]=t("a",{id:"Reactant.MLIR.API.mlirIntegerAttrGetValueUInt-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerAttrGetValueUInt-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerAttrGetValueUInt")],-1)),e[2546]||(e[2546]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2548]||(e[2548]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerAttrGetValueUInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given integer attribute, assuming the value is of unsigned type and fits into an unsigned 64-bit integer.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2547]||(e[2547]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3769-L3773",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Kd,[t("summary",null,[e[2549]||(e[2549]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetAttrGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerSetAttrGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetAttrGet")],-1)),e[2550]||(e[2550]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2552]||(e[2552]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Creates an integer set attribute wrapping the given set. The attribute belongs to the same context as the integer set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2551]||(e[2551]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3823-L3827",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$d,[t("summary",null,[e[2553]||(e[2553]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirIntegerSetAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetAttrGetTypeID")],-1)),e[2554]||(e[2554]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2556]||(e[2556]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an IntegerSet attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2555]||(e[2555]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3841-L3845",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xd,[t("summary",null,[e[2557]||(e[2557]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetAttrGetValue-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerSetAttrGetValue-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetAttrGetValue")],-1)),e[2558]||(e[2558]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2560]||(e[2560]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the integer set wrapped in the given integer set attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2559]||(e[2559]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3832-L3836",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yd,[t("summary",null,[e[2561]||(e[2561]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetDump-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerSetDump-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetDump")],-1)),e[2562]||(e[2562]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2564]||(e[2564]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Prints an integer set to the standard error stream.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2563]||(e[2563]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3388-L3392",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",eu,[t("summary",null,[e[2565]||(e[2565]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetEmptyGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirIntegerSetEmptyGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetEmptyGet")],-1)),e[2566]||(e[2566]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2568]||(e[2568]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetEmptyGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, numDims, numSymbols)</span></span></code></pre></div><p>Gets or creates a new canonically empty integer set with the give number of dimensions and symbols in the given context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2567]||(e[2567]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3397-L3401",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",tu,[t("summary",null,[e[2569]||(e[2569]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirIntegerSetEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetEqual")],-1)),e[2570]||(e[2570]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2572]||(e[2572]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s1, s2)</span></span></code></pre></div><p>Checks if two integer set objects are equal. This is a &quot;shallow&quot; comparison of two objects. Only the sets with some small number of constraints are uniqued and compare equal here. Set objects that represent the same integer set with different constraints may be considered non-equal by this check. Set difference followed by an (expensive) emptiness check should be used to check equivalence of the underlying integer sets.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2571]||(e[2571]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3368-L3372",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",su,[t("summary",null,[e[2573]||(e[2573]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetGet-NTuple{6, Any}",href:"#Reactant.MLIR.API.mlirIntegerSetGet-NTuple{6, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetGet")],-1)),e[2574]||(e[2574]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2576]||(e[2576]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, numDims, numSymbols, numConstraints, constraints, eqFlags)</span></span></code></pre></div><p>Gets or creates a new integer set in the given context. The set is defined by a list of affine constraints, with the given number of input dimensions and symbols, which are treated as either equalities (eqFlags is 1) or inequalities (eqFlags is 0). Both <code>constraints</code> and <code>eqFlags</code> are expected to point to at least <code>numConstraint</code> consecutive values.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2575]||(e[2575]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3408-L3412",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",au,[t("summary",null,[e[2577]||(e[2577]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetGetConstraint-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirIntegerSetGetConstraint-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetGetConstraint")],-1)),e[2578]||(e[2578]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2580]||(e[2580]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetConstraint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th constraint of the set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2579]||(e[2579]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3506-L3510",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",iu,[t("summary",null,[e[2581]||(e[2581]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetGetContext-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerSetGetContext-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetGetContext")],-1)),e[2582]||(e[2582]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2584]||(e[2584]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Gets the context in which the given integer set lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2583]||(e[2583]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3350-L3354",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",lu,[t("summary",null,[e[2585]||(e[2585]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetGetNumConstraints-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerSetGetNumConstraints-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetGetNumConstraints")],-1)),e[2586]||(e[2586]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2588]||(e[2588]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetNumConstraints</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of constraints (equalities + inequalities) in the given set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2587]||(e[2587]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3479-L3483",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",nu,[t("summary",null,[e[2589]||(e[2589]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetGetNumDims-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerSetGetNumDims-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetGetNumDims")],-1)),e[2590]||(e[2590]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2592]||(e[2592]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetNumDims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of dimensions in the given set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2591]||(e[2591]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3452-L3456",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ru,[t("summary",null,[e[2593]||(e[2593]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetGetNumEqualities-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerSetGetNumEqualities-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetGetNumEqualities")],-1)),e[2594]||(e[2594]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2596]||(e[2596]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetNumEqualities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of equalities in the given set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2595]||(e[2595]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3488-L3492",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ou,[t("summary",null,[e[2597]||(e[2597]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetGetNumInequalities-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerSetGetNumInequalities-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetGetNumInequalities")],-1)),e[2598]||(e[2598]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2600]||(e[2600]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetNumInequalities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of inequalities in the given set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2599]||(e[2599]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3497-L3501",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pu,[t("summary",null,[e[2601]||(e[2601]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetGetNumInputs-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerSetGetNumInputs-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetGetNumInputs")],-1)),e[2602]||(e[2602]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2604]||(e[2604]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetNumInputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of inputs (dimensions + symbols) in the given set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2603]||(e[2603]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3470-L3474",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",du,[t("summary",null,[e[2605]||(e[2605]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetGetNumSymbols-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerSetGetNumSymbols-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetGetNumSymbols")],-1)),e[2606]||(e[2606]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2608]||(e[2608]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetNumSymbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of symbols in the given set.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2607]||(e[2607]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3461-L3465",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",uu,[t("summary",null,[e[2609]||(e[2609]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetIsCanonicalEmpty-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerSetIsCanonicalEmpty-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetIsCanonicalEmpty")],-1)),e[2610]||(e[2610]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2612]||(e[2612]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetIsCanonicalEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Checks whether the given set is a canonical empty set, e.g., the set returned by <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirIntegerSetEmptyGet-Tuple{Any, Any, Any}"><code>mlirIntegerSetEmptyGet</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2611]||(e[2611]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3443-L3447",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bu,[t("summary",null,[e[2613]||(e[2613]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetIsConstraintEq-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirIntegerSetIsConstraintEq-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetIsConstraintEq")],-1)),e[2614]||(e[2614]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2616]||(e[2616]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetIsConstraintEq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, pos)</span></span></code></pre></div><p>Returns <code>true</code> of the <code>pos</code>-th constraint of the set is an equality constraint, <code>false</code> otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2615]||(e[2615]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3517-L3521",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cu,[t("summary",null,[e[2617]||(e[2617]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerSetIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetIsNull")],-1)),e[2618]||(e[2618]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2620]||(e[2620]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Checks whether an integer set is a null object.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2619]||(e[2619]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3359-L3363",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hu,[t("summary",null,[e[2621]||(e[2621]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetPrint-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirIntegerSetPrint-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetPrint")],-1)),e[2622]||(e[2622]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2624]||(e[2624]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, callback, userData)</span></span></code></pre></div><p>Prints an integer set by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2623]||(e[2623]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3377-L3381",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yu,[t("summary",null,[e[2625]||(e[2625]=t("a",{id:"Reactant.MLIR.API.mlirIntegerSetReplaceGet-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirIntegerSetReplaceGet-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerSetReplaceGet")],-1)),e[2626]||(e[2626]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2628]||(e[2628]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetReplaceGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, dimReplacements, symbolReplacements, numResultDims, numResultSymbols)</span></span></code></pre></div><p>Gets or creates a new integer set in which the values and dimensions of the given set are replaced with the given affine expressions. <code>dimReplacements</code> and <code>symbolReplacements</code> are expected to point to at least as many consecutive expressions as the given set has dimensions and symbols, respectively. The new set will have <code>numResultDims</code> and <code>numResultSymbols</code> dimensions and symbols, respectively.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2627]||(e[2627]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3426-L3430",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gu,[t("summary",null,[e[2629]||(e[2629]=t("a",{id:"Reactant.MLIR.API.mlirIntegerTypeGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirIntegerTypeGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerTypeGet")],-1)),e[2630]||(e[2630]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2632]||(e[2632]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, bitwidth)</span></span></code></pre></div><p>Creates a signless integer type of the given bitwidth in the context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2631]||(e[2631]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4971-L4975",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mu,[t("summary",null,[e[2633]||(e[2633]=t("a",{id:"Reactant.MLIR.API.mlirIntegerTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirIntegerTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerTypeGetTypeID")],-1)),e[2634]||(e[2634]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2636]||(e[2636]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Integer type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2635]||(e[2635]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4953-L4957",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ku,[t("summary",null,[e[2637]||(e[2637]=t("a",{id:"Reactant.MLIR.API.mlirIntegerTypeGetWidth-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerTypeGetWidth-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerTypeGetWidth")],-1)),e[2638]||(e[2638]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2640]||(e[2640]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeGetWidth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the bitwidth of an integer type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2639]||(e[2639]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4998-L5002",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ru,[t("summary",null,[e[2641]||(e[2641]=t("a",{id:"Reactant.MLIR.API.mlirIntegerTypeIsSigned-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerTypeIsSigned-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerTypeIsSigned")],-1)),e[2642]||(e[2642]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2644]||(e[2644]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeIsSigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given integer type is signed.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2643]||(e[2643]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5016-L5020",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fu,[t("summary",null,[e[2645]||(e[2645]=t("a",{id:"Reactant.MLIR.API.mlirIntegerTypeIsSignless-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerTypeIsSignless-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerTypeIsSignless")],-1)),e[2646]||(e[2646]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2648]||(e[2648]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeIsSignless</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given integer type is signless.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2647]||(e[2647]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5007-L5011",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Iu,[t("summary",null,[e[2649]||(e[2649]=t("a",{id:"Reactant.MLIR.API.mlirIntegerTypeIsUnsigned-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIntegerTypeIsUnsigned-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerTypeIsUnsigned")],-1)),e[2650]||(e[2650]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2652]||(e[2652]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeIsUnsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given integer type is unsigned.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2651]||(e[2651]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5025-L5029",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Tu,[t("summary",null,[e[2653]||(e[2653]=t("a",{id:"Reactant.MLIR.API.mlirIntegerTypeSignedGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirIntegerTypeSignedGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerTypeSignedGet")],-1)),e[2654]||(e[2654]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2656]||(e[2656]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeSignedGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, bitwidth)</span></span></code></pre></div><p>Creates a signed integer type of the given bitwidth in the context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2655]||(e[2655]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4980-L4984",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Au,[t("summary",null,[e[2657]||(e[2657]=t("a",{id:"Reactant.MLIR.API.mlirIntegerTypeUnsignedGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirIntegerTypeUnsignedGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIntegerTypeUnsignedGet")],-1)),e[2658]||(e[2658]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2660]||(e[2660]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeUnsignedGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, bitwidth)</span></span></code></pre></div><p>Creates an unsigned integer type of the given bitwidth in the context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2659]||(e[2659]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4989-L4993",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ju,[t("summary",null,[e[2661]||(e[2661]=t("a",{id:"Reactant.MLIR.API.mlirIsCurrentDebugType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirIsCurrentDebugType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIsCurrentDebugType")],-1)),e[2662]||(e[2662]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2664]||(e[2664]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIsCurrentDebugType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks if <code>type</code> is set as the current debug type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2663]||(e[2663]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6248-L6252",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_u,[t("summary",null,[e[2665]||(e[2665]=t("a",{id:"Reactant.MLIR.API.mlirIsGlobalDebugEnabled-Tuple{}",href:"#Reactant.MLIR.API.mlirIsGlobalDebugEnabled-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirIsGlobalDebugEnabled")],-1)),e[2666]||(e[2666]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2668]||(e[2668]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIsGlobalDebugEnabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Retuns <code>true</code> if the global debugging flag is set, false otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2667]||(e[2667]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6221-L6225",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mu,[t("summary",null,[e[2669]||(e[2669]=t("a",{id:"Reactant.MLIR.API.mlirLLVMArrayTypeGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirLLVMArrayTypeGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMArrayTypeGet")],-1)),e[2670]||(e[2670]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2672]||(e[2672]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMArrayTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, numElements)</span></span></code></pre></div><p>Creates an llvm.array type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2671]||(e[2671]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6675-L6679",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Eu,[t("summary",null,[e[2673]||(e[2673]=t("a",{id:"Reactant.MLIR.API.mlirLLVMArrayTypeGetElementType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMArrayTypeGetElementType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMArrayTypeGetElementType")],-1)),e[2674]||(e[2674]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2676]||(e[2676]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMArrayTypeGetElementType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the element type of the llvm.array type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2675]||(e[2675]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6684-L6688",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Lu,[t("summary",null,[e[2677]||(e[2677]=t("a",{id:"Reactant.MLIR.API.mlirLLVMCConvAttrGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirLLVMCConvAttrGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMCConvAttrGet")],-1)),e[2678]||(e[2678]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2680]||(e[2680]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMCConvAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, cconv)</span></span></code></pre></div><p>Creates a LLVM CConv attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2679]||(e[2679]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6920-L6924",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Cu,[t("summary",null,[e[2681]||(e[2681]=t("a",{id:"Reactant.MLIR.API.mlirLLVMComdatAttrGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirLLVMComdatAttrGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMComdatAttrGet")],-1)),e[2682]||(e[2682]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2684]||(e[2684]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMComdatAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, comdat)</span></span></code></pre></div><p>Creates a LLVM Comdat attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2683]||(e[2683]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6939-L6943",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vu,[t("summary",null,[e[2685]||(e[2685]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDIAnnotationAttrGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirLLVMDIAnnotationAttrGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDIAnnotationAttrGet")],-1)),e[2686]||(e[2686]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2688]||(e[2688]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIAnnotationAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, name, value)</span></span></code></pre></div><p>Creates a LLVM DIAnnotation attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2687]||(e[2687]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7328-L7332",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pu,[t("summary",null,[e[2689]||(e[2689]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDIBasicTypeAttrGet-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirLLVMDIBasicTypeAttrGet-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDIBasicTypeAttrGet")],-1)),e[2690]||(e[2690]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2692]||(e[2692]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIBasicTypeAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, tag, name, sizeInBits, encoding)</span></span></code></pre></div><p>Creates a LLVM DIBasicType attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2691]||(e[2691]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7029-L7033",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xu,[t("summary",null,[e[2693]||(e[2693]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDICompileUnitAttrGet-NTuple{9, Any}",href:"#Reactant.MLIR.API.mlirLLVMDICompileUnitAttrGet-NTuple{9, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDICompileUnitAttrGet")],-1)),e[2694]||(e[2694]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2696]||(e[2696]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDICompileUnitAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, id, sourceLanguage, file, producer, isOptimized, emissionKind, nameTableKind, splitDebugFilename)</span></span></code></pre></div><p>Creates a LLVM DICompileUnit attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2695]||(e[2695]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7189-L7193",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Su,[t("summary",null,[e[2697]||(e[2697]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGet-NTuple{18, Any}",href:"#Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGet-NTuple{18, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGet")],-1)),e[2698]||(e[2698]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2700]||(e[2700]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDICompositeTypeAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, recId, isRecSelf, tag, name, file, line, scope, baseType, flags, sizeInBits, alignInBits, nElements, elements, dataLocation, rank, allocated, associated)</span></span></code></pre></div><p>Creates a LLVM DICompositeType attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2699]||(e[2699]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7053-L7057",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Du,[t("summary",null,[e[2701]||(e[2701]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGetRecSelf-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGetRecSelf-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGetRecSelf")],-1)),e[2702]||(e[2702]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2704]||(e[2704]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDICompositeTypeAttrGetRecSelf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(recId)</span></span></code></pre></div><p>Creates a self-referencing LLVM DICompositeType attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2703]||(e[2703]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7044-L7048",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fu,[t("summary",null,[e[2705]||(e[2705]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGet-NTuple{9, Any}",href:"#Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGet-NTuple{9, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGet")],-1)),e[2706]||(e[2706]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2708]||(e[2708]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIDerivedTypeAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, tag, name, baseType, sizeInBits, alignInBits, offsetInBits, dwarfAddressSpace, extraData)</span></span></code></pre></div><p>Creates a LLVM DIDerivedType attribute. Note that <code>dwarfAddressSpace</code> is an optional field, where <a href="./@ref"><code>MLIR_CAPI_DWARF_ADDRESS_SPACE_NULL</code></a> indicates null and non-negative values indicate a value present.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2707]||(e[2707]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7100-L7104",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vu,[t("summary",null,[e[2709]||(e[2709]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGetBaseType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGetBaseType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGetBaseType")],-1)),e[2710]||(e[2710]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2712]||(e[2712]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIDerivedTypeAttrGetBaseType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diDerivedType)</span></span></code></pre></div><p>Gets the base type from a LLVM DIDerivedType attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2711]||(e[2711]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7153-L7157",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ou,[t("summary",null,[e[2713]||(e[2713]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDIExpressionAttrGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirLLVMDIExpressionAttrGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDIExpressionAttrGet")],-1)),e[2714]||(e[2714]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2716]||(e[2716]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIExpressionAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, nOperations, operations)</span></span></code></pre></div><p>Creates a LLVM DIExpression attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2715]||(e[2715]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6995-L6999",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bu,[t("summary",null,[e[2717]||(e[2717]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDIExpressionElemAttrGet-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirLLVMDIExpressionElemAttrGet-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDIExpressionElemAttrGet")],-1)),e[2718]||(e[2718]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2720]||(e[2720]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIExpressionElemAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, opcode, nArguments, arguments)</span></span></code></pre></div><p>Creates a LLVM DIExpressionElem attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2719]||(e[2719]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6984-L6988",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Nu,[t("summary",null,[e[2721]||(e[2721]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDIFileAttrGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirLLVMDIFileAttrGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDIFileAttrGet")],-1)),e[2722]||(e[2722]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2724]||(e[2724]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIFileAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, name, directory)</span></span></code></pre></div><p>Creates a LLVM DIFileAttr attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2723]||(e[2723]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7164-L7168",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gu,[t("summary",null,[e[2725]||(e[2725]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDIFlagsAttrGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirLLVMDIFlagsAttrGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDIFlagsAttrGet")],-1)),e[2726]||(e[2726]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2728]||(e[2728]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIFlagsAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, value)</span></span></code></pre></div><p>Creates a LLVM DIFlags attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2727]||(e[2727]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7218-L7222",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zu,[t("summary",null,[e[2729]||(e[2729]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDIImportedEntityAttrGet-NTuple{9, Any}",href:"#Reactant.MLIR.API.mlirLLVMDIImportedEntityAttrGet-NTuple{9, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDIImportedEntityAttrGet")],-1)),e[2730]||(e[2730]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2732]||(e[2732]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIImportedEntityAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, tag, scope, entity, file, line, name, nElements, elements)</span></span></code></pre></div><p>Creates a LLVM DIImportedEntityAttr attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2731]||(e[2731]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7436-L7440",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wu,[t("summary",null,[e[2733]||(e[2733]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDILexicalBlockAttrGet-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirLLVMDILexicalBlockAttrGet-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDILexicalBlockAttrGet")],-1)),e[2734]||(e[2734]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2736]||(e[2736]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDILexicalBlockAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, scope, file, line, column)</span></span></code></pre></div><p>Creates a LLVM DILexicalBlock attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2735]||(e[2735]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7227-L7231",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Uu,[t("summary",null,[e[2737]||(e[2737]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDILexicalBlockFileAttrGet-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirLLVMDILexicalBlockFileAttrGet-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDILexicalBlockFileAttrGet")],-1)),e[2738]||(e[2738]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2740]||(e[2740]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDILexicalBlockFileAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, scope, file, discriminator)</span></span></code></pre></div><p>Creates a LLVM DILexicalBlockFile attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2739]||(e[2739]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7242-L7246",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qu,[t("summary",null,[e[2741]||(e[2741]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDILocalVariableAttrGet-NTuple{9, Any}",href:"#Reactant.MLIR.API.mlirLLVMDILocalVariableAttrGet-NTuple{9, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDILocalVariableAttrGet")],-1)),e[2742]||(e[2742]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2744]||(e[2744]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDILocalVariableAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, scope, name, diFile, line, arg, alignInBits, diType, flags)</span></span></code></pre></div><p>Creates a LLVM DILocalVariableAttr attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2743]||(e[2743]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7253-L7257",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qu,[t("summary",null,[e[2745]||(e[2745]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDIModuleAttrGet-NTuple{9, Any}",href:"#Reactant.MLIR.API.mlirLLVMDIModuleAttrGet-NTuple{9, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDIModuleAttrGet")],-1)),e[2746]||(e[2746]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2748]||(e[2748]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIModuleAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, file, scope, name, configMacros, includePath, apinotes, line, isDecl)</span></span></code></pre></div><p>Creates a LLVM DIModuleAttr attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2747]||(e[2747]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7415-L7419",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wu,[t("summary",null,[e[2749]||(e[2749]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDIModuleAttrGetScope-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMDIModuleAttrGetScope-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDIModuleAttrGetScope")],-1)),e[2750]||(e[2750]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2752]||(e[2752]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIModuleAttrGetScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diModule)</span></span></code></pre></div><p>Gets the scope of this DIModuleAttr.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2751]||(e[2751]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7457-L7461",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zu,[t("summary",null,[e[2753]||(e[2753]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDINullTypeAttrGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMDINullTypeAttrGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDINullTypeAttrGet")],-1)),e[2754]||(e[2754]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2756]||(e[2756]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDINullTypeAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a LLVM DINullType attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2755]||(e[2755]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6975-L6979",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hu,[t("summary",null,[e[2757]||(e[2757]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGet-NTuple{17, Any}",href:"#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGet-NTuple{17, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGet")],-1)),e[2758]||(e[2758]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2760]||(e[2760]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, recId, isRecSelf, id, compileUnit, scope, name, linkageName, file, line, scopeLine, subprogramFlags, type, nRetainedNodes, retainedNodes, nAnnotations, annotations)</span></span></code></pre></div><p>Creates a LLVM DISubprogramAttr attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2759]||(e[2759]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7283-L7287",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ju,[t("summary",null,[e[2761]||(e[2761]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetCompileUnit-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetCompileUnit-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetCompileUnit")],-1)),e[2762]||(e[2762]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2764]||(e[2764]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetCompileUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diSubprogram)</span></span></code></pre></div><p>Gets the compile unit from this DISubprogram.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2763]||(e[2763]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7368-L7372",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ku,[t("summary",null,[e[2765]||(e[2765]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetFile-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetFile-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetFile")],-1)),e[2766]||(e[2766]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2768]||(e[2768]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diSubprogram)</span></span></code></pre></div><p>Gets the file from this DISubprogramAttr.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2767]||(e[2767]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7379-L7383",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$u,[t("summary",null,[e[2769]||(e[2769]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetLine-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetLine-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetLine")],-1)),e[2770]||(e[2770]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2772]||(e[2772]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetLine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diSubprogram)</span></span></code></pre></div><p>Gets the line from this DISubprogramAttr.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2771]||(e[2771]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7350-L7354",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xu,[t("summary",null,[e[2773]||(e[2773]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetRecSelf-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetRecSelf-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetRecSelf")],-1)),e[2774]||(e[2774]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2776]||(e[2776]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetRecSelf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(recId)</span></span></code></pre></div><p>Creates a self-referencing LLVM DISubprogramAttr attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2775]||(e[2775]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7274-L7278",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yu,[t("summary",null,[e[2777]||(e[2777]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScope-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScope-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScope")],-1)),e[2778]||(e[2778]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2780]||(e[2780]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diSubprogram)</span></span></code></pre></div><p>Gets the scope from this DISubprogramAttr.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2779]||(e[2779]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7339-L7343",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",eb,[t("summary",null,[e[2781]||(e[2781]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScopeLine-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScopeLine-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScopeLine")],-1)),e[2782]||(e[2782]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2784]||(e[2784]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetScopeLine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diSubprogram)</span></span></code></pre></div><p>Gets the scope line from this DISubprogram.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2783]||(e[2783]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7359-L7363",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",tb,[t("summary",null,[e[2785]||(e[2785]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetType")],-1)),e[2786]||(e[2786]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2788]||(e[2788]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diSubprogram)</span></span></code></pre></div><p>Gets the type from this DISubprogramAttr.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2787]||(e[2787]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7390-L7394",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sb,[t("summary",null,[e[2789]||(e[2789]=t("a",{id:"Reactant.MLIR.API.mlirLLVMDISubroutineTypeAttrGet-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirLLVMDISubroutineTypeAttrGet-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMDISubroutineTypeAttrGet")],-1)),e[2790]||(e[2790]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2792]||(e[2792]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubroutineTypeAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, callingConvention, nTypes, types)</span></span></code></pre></div><p>Creates a LLVM DISubroutineTypeAttr attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2791]||(e[2791]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7401-L7405",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ab,[t("summary",null,[e[2793]||(e[2793]=t("a",{id:"Reactant.MLIR.API.mlirLLVMFunctionTypeGet-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirLLVMFunctionTypeGet-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMFunctionTypeGet")],-1)),e[2794]||(e[2794]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2796]||(e[2796]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMFunctionTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resultType, nArgumentTypes, argumentTypes, isVarArg)</span></span></code></pre></div><p>Creates an llvm.func type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2795]||(e[2795]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6693-L6697",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ib,[t("summary",null,[e[2797]||(e[2797]=t("a",{id:"Reactant.MLIR.API.mlirLLVMFunctionTypeGetInput-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirLLVMFunctionTypeGetInput-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMFunctionTypeGetInput")],-1)),e[2798]||(e[2798]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2800]||(e[2800]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMFunctionTypeGetInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns the pos-th input type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2799]||(e[2799]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6716-L6720",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",lb,[t("summary",null,[e[2801]||(e[2801]=t("a",{id:"Reactant.MLIR.API.mlirLLVMFunctionTypeGetNumInputs-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMFunctionTypeGetNumInputs-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMFunctionTypeGetNumInputs")],-1)),e[2802]||(e[2802]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2804]||(e[2804]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMFunctionTypeGetNumInputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of input types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2803]||(e[2803]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6707-L6711",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",nb,[t("summary",null,[e[2805]||(e[2805]=t("a",{id:"Reactant.MLIR.API.mlirLLVMFunctionTypeGetReturnType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMFunctionTypeGetReturnType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMFunctionTypeGetReturnType")],-1)),e[2806]||(e[2806]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2808]||(e[2808]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMFunctionTypeGetReturnType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the return type of the function type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2807]||(e[2807]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6725-L6729",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rb,[t("summary",null,[e[2809]||(e[2809]=t("a",{id:"Reactant.MLIR.API.mlirLLVMLinkageAttrGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirLLVMLinkageAttrGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMLinkageAttrGet")],-1)),e[2810]||(e[2810]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2812]||(e[2812]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMLinkageAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, linkage)</span></span></code></pre></div><p>Creates a LLVM Linkage attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2811]||(e[2811]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6964-L6968",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ob,[t("summary",null,[e[2813]||(e[2813]=t("a",{id:"Reactant.MLIR.API.mlirLLVMPointerTypeGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirLLVMPointerTypeGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMPointerTypeGet")],-1)),e[2814]||(e[2814]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2816]||(e[2816]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMPointerTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, addressSpace)</span></span></code></pre></div><p>Creates an llvm.ptr type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2815]||(e[2815]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6639-L6643",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pb,[t("summary",null,[e[2817]||(e[2817]=t("a",{id:"Reactant.MLIR.API.mlirLLVMPointerTypeGetAddressSpace-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMPointerTypeGetAddressSpace-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMPointerTypeGetAddressSpace")],-1)),e[2818]||(e[2818]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2820]||(e[2820]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMPointerTypeGetAddressSpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pointerType)</span></span></code></pre></div><p>Returns address space of llvm.ptr</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2819]||(e[2819]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6657-L6661",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",db,[t("summary",null,[e[2821]||(e[2821]=t("a",{id:"Reactant.MLIR.API.mlirLLVMStructTypeGetElementType-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirLLVMStructTypeGetElementType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMStructTypeGetElementType")],-1)),e[2822]||(e[2822]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2824]||(e[2824]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeGetElementType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, position)</span></span></code></pre></div><p>Returns the <code>positions</code>-th field of the struct. Asserts if the struct is opaque, not yet initialized or if the position is out of range.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2823]||(e[2823]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6761-L6765",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ub,[t("summary",null,[e[2825]||(e[2825]=t("a",{id:"Reactant.MLIR.API.mlirLLVMStructTypeGetIdentifier-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMStructTypeGetIdentifier-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMStructTypeGetIdentifier")],-1)),e[2826]||(e[2826]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2828]||(e[2828]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeGetIdentifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the identifier of the identified struct. Asserts that the struct is identified, i.e., not literal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2827]||(e[2827]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6781-L6785",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bb,[t("summary",null,[e[2829]||(e[2829]=t("a",{id:"Reactant.MLIR.API.mlirLLVMStructTypeGetNumElementTypes-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMStructTypeGetNumElementTypes-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMStructTypeGetNumElementTypes")],-1)),e[2830]||(e[2830]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2832]||(e[2832]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeGetNumElementTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of fields in the struct. Asserts if the struct is opaque or not yet initialized.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2831]||(e[2831]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6752-L6756",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cb,[t("summary",null,[e[2833]||(e[2833]=t("a",{id:"Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedGet")],-1)),e[2834]||(e[2834]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2836]||(e[2836]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeIdentifiedGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, name)</span></span></code></pre></div><p>Creates an LLVM identified struct type with no body. If a struct type with this name already exists in the context, returns that type. Use <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedNewGet-NTuple{5, Any}"><code>mlirLLVMStructTypeIdentifiedNewGet</code></a> to create a fresh struct type, potentially renaming it. The body should be set separatelty by calling <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirLLVMStructTypeSetBody-NTuple{4, Any}"><code>mlirLLVMStructTypeSetBody</code></a>, if it isn&#39;t set already.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2835]||(e[2835]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6824-L6828",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hb,[t("summary",null,[e[2837]||(e[2837]=t("a",{id:"Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedNewGet-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedNewGet-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedNewGet")],-1)),e[2838]||(e[2838]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2840]||(e[2840]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeIdentifiedNewGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, name, nFieldTypes, fieldTypes, isPacked)</span></span></code></pre></div><p>Creates an LLVM identified struct type with no body and a name starting with the given prefix. If a struct with the exact name as the given prefix already exists, appends an unspecified suffix to the name so that the name is unique in context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2839]||(e[2839]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6835-L6839",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yb,[t("summary",null,[e[2841]||(e[2841]=t("a",{id:"Reactant.MLIR.API.mlirLLVMStructTypeIsLiteral-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMStructTypeIsLiteral-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMStructTypeIsLiteral")],-1)),e[2842]||(e[2842]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2844]||(e[2844]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeIsLiteral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the type is a literal (unnamed) LLVM struct type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2843]||(e[2843]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6743-L6747",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gb,[t("summary",null,[e[2845]||(e[2845]=t("a",{id:"Reactant.MLIR.API.mlirLLVMStructTypeIsOpaque-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMStructTypeIsOpaque-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMStructTypeIsOpaque")],-1)),e[2846]||(e[2846]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2848]||(e[2848]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeIsOpaque</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> is the struct is explicitly opaque (will not have a body) or uninitialized (will eventually have a body).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2847]||(e[2847]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6790-L6794",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mb,[t("summary",null,[e[2849]||(e[2849]=t("a",{id:"Reactant.MLIR.API.mlirLLVMStructTypeIsPacked-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMStructTypeIsPacked-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMStructTypeIsPacked")],-1)),e[2850]||(e[2850]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2852]||(e[2852]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeIsPacked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the struct is packed.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2851]||(e[2851]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6772-L6776",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",kb,[t("summary",null,[e[2853]||(e[2853]=t("a",{id:"Reactant.MLIR.API.mlirLLVMStructTypeLiteralGet-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirLLVMStructTypeLiteralGet-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMStructTypeLiteralGet")],-1)),e[2854]||(e[2854]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2856]||(e[2856]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeLiteralGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, nFieldTypes, fieldTypes, isPacked)</span></span></code></pre></div><p>Creates an LLVM literal (unnamed) struct type. This may assert if the fields have types not compatible with the LLVM dialect. For a graceful failure, use the checked version.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2855]||(e[2855]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6799-L6803",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rb,[t("summary",null,[e[2857]||(e[2857]=t("a",{id:"Reactant.MLIR.API.mlirLLVMStructTypeLiteralGetChecked-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirLLVMStructTypeLiteralGetChecked-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMStructTypeLiteralGetChecked")],-1)),e[2858]||(e[2858]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2860]||(e[2860]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeLiteralGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, nFieldTypes, fieldTypes, isPacked)</span></span></code></pre></div><p>Creates an LLVM literal (unnamed) struct type if possible. Emits a diagnostic at the given location and returns null otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2859]||(e[2859]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6810-L6814",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fb,[t("summary",null,[e[2861]||(e[2861]=t("a",{id:"Reactant.MLIR.API.mlirLLVMStructTypeSetBody-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirLLVMStructTypeSetBody-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMStructTypeSetBody")],-1)),e[2862]||(e[2862]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2864]||(e[2864]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeSetBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(structType, nFieldTypes, fieldTypes, isPacked)</span></span></code></pre></div><p>Sets the body of the identified struct if it hasn&#39;t been set yet. Returns whether the operation was successful.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2863]||(e[2863]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6856-L6860",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ib,[t("summary",null,[e[2865]||(e[2865]=t("a",{id:"Reactant.MLIR.API.mlirLLVMVoidTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLLVMVoidTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLLVMVoidTypeGet")],-1)),e[2866]||(e[2866]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2868]||(e[2868]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMVoidTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an llmv.void type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2867]||(e[2867]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6666-L6670",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Tb,[t("summary",null,[e[2869]||(e[2869]=t("a",{id:"Reactant.MLIR.API.mlirLinalgFillBuiltinNamedOpRegion-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLinalgFillBuiltinNamedOpRegion-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLinalgFillBuiltinNamedOpRegion")],-1)),e[2870]||(e[2870]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2872]||(e[2872]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLinalgFillBuiltinNamedOpRegion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mlirOp)</span></span></code></pre></div><p>Apply the special region builder for the builtin named Linalg op. Assert that <code>mlirOp</code> is a builtin named Linalg op.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2871]||(e[2871]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7466-L7470",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ab,[t("summary",null,[e[2873]||(e[2873]=t("a",{id:"Reactant.MLIR.API.mlirLlvmThreadPoolCreate-Tuple{}",href:"#Reactant.MLIR.API.mlirLlvmThreadPoolCreate-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLlvmThreadPoolCreate")],-1)),e[2874]||(e[2874]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2876]||(e[2876]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLlvmThreadPoolCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Create an LLVM thread pool. This is reexported here to avoid directly pulling in the LLVM headers directly.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2875]||(e[2875]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L158-L162",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jb,[t("summary",null,[e[2877]||(e[2877]=t("a",{id:"Reactant.MLIR.API.mlirLlvmThreadPoolDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLlvmThreadPoolDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLlvmThreadPoolDestroy")],-1)),e[2878]||(e[2878]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2880]||(e[2880]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLlvmThreadPoolDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pool)</span></span></code></pre></div><p>Destroy an LLVM thread pool.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2879]||(e[2879]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L167-L171",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_b,[t("summary",null,[e[2881]||(e[2881]=t("a",{id:"Reactant.MLIR.API.mlirLoadIRDLDialects-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLoadIRDLDialects-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLoadIRDLDialects")],-1)),e[2882]||(e[2882]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2884]||(e[2884]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLoadIRDLDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module)</span></span></code></pre></div><p>Loads all IRDL dialects in the provided module, registering the dialects in the module&#39;s associated context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2883]||(e[2883]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6622-L6626",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mb,[t("summary",null,[e[2885]||(e[2885]=t("a",{id:"Reactant.MLIR.API.mlirLocationCallSiteGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirLocationCallSiteGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationCallSiteGet")],-1)),e[2886]||(e[2886]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2888]||(e[2888]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationCallSiteGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callee, caller)</span></span></code></pre></div><p>Creates a call site location with a callee and a caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2887]||(e[2887]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L712-L716",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Eb,[t("summary",null,[e[2889]||(e[2889]=t("a",{id:"Reactant.MLIR.API.mlirLocationCallSiteGetCallee-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationCallSiteGetCallee-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationCallSiteGetCallee")],-1)),e[2890]||(e[2890]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2892]||(e[2892]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationCallSiteGetCallee</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Getter for callee of CallSite.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2891]||(e[2891]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L723-L727",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Lb,[t("summary",null,[e[2893]||(e[2893]=t("a",{id:"Reactant.MLIR.API.mlirLocationCallSiteGetCaller-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationCallSiteGetCaller-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationCallSiteGetCaller")],-1)),e[2894]||(e[2894]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2896]||(e[2896]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationCallSiteGetCaller</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Getter for caller of CallSite.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2895]||(e[2895]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L732-L736",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Cb,[t("summary",null,[e[2897]||(e[2897]=t("a",{id:"Reactant.MLIR.API.mlirLocationCallSiteGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirLocationCallSiteGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationCallSiteGetTypeID")],-1)),e[2898]||(e[2898]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2900]||(e[2900]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationCallSiteGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>TypeID Getter for CallSite.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2899]||(e[2899]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L741-L745",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vb,[t("summary",null,[e[2901]||(e[2901]=t("a",{id:"Reactant.MLIR.API.mlirLocationEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirLocationEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationEqual")],-1)),e[2902]||(e[2902]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2904]||(e[2904]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(l1, l2)</span></span></code></pre></div><p>Checks if two locations are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2903]||(e[2903]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L894-L898",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pb,[t("summary",null,[e[2905]||(e[2905]=t("a",{id:"Reactant.MLIR.API.mlirLocationFileLineColGet-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirLocationFileLineColGet-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFileLineColGet")],-1)),e[2906]||(e[2906]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2908]||(e[2908]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFileLineColGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, filename, line, col)</span></span></code></pre></div><p>Creates an File/Line/Column location owned by the given context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2907]||(e[2907]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L618-L622",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xb,[t("summary",null,[e[2909]||(e[2909]=t("a",{id:"Reactant.MLIR.API.mlirLocationFileLineColRangeGet-NTuple{6, Any}",href:"#Reactant.MLIR.API.mlirLocationFileLineColRangeGet-NTuple{6, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFileLineColRangeGet")],-1)),e[2910]||(e[2910]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2912]||(e[2912]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFileLineColRangeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, filename, start_line, start_col, end_line, end_col)</span></span></code></pre></div><p>Creates an File/Line/Column range location owned by the given context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2911]||(e[2911]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L629-L633",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sb,[t("summary",null,[e[2913]||(e[2913]=t("a",{id:"Reactant.MLIR.API.mlirLocationFileLineColRangeGetEndColumn-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationFileLineColRangeGetEndColumn-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFileLineColRangeGetEndColumn")],-1)),e[2914]||(e[2914]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2916]||(e[2916]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFileLineColRangeGetEndColumn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Getter for end_column of FileLineColRange.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2915]||(e[2915]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L685-L689",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Db,[t("summary",null,[e[2917]||(e[2917]=t("a",{id:"Reactant.MLIR.API.mlirLocationFileLineColRangeGetEndLine-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationFileLineColRangeGetEndLine-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFileLineColRangeGetEndLine")],-1)),e[2918]||(e[2918]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2920]||(e[2920]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFileLineColRangeGetEndLine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Getter for end_line of FileLineColRange.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2919]||(e[2919]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L676-L680",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fb,[t("summary",null,[e[2921]||(e[2921]=t("a",{id:"Reactant.MLIR.API.mlirLocationFileLineColRangeGetFilename-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationFileLineColRangeGetFilename-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFileLineColRangeGetFilename")],-1)),e[2922]||(e[2922]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2924]||(e[2924]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFileLineColRangeGetFilename</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Getter for filename of FileLineColRange.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2923]||(e[2923]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L647-L651",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vb,[t("summary",null,[e[2925]||(e[2925]=t("a",{id:"Reactant.MLIR.API.mlirLocationFileLineColRangeGetStartColumn-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationFileLineColRangeGetStartColumn-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFileLineColRangeGetStartColumn")],-1)),e[2926]||(e[2926]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2928]||(e[2928]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFileLineColRangeGetStartColumn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Getter for start_column of FileLineColRange.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2927]||(e[2927]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L667-L671",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ob,[t("summary",null,[e[2929]||(e[2929]=t("a",{id:"Reactant.MLIR.API.mlirLocationFileLineColRangeGetStartLine-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationFileLineColRangeGetStartLine-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFileLineColRangeGetStartLine")],-1)),e[2930]||(e[2930]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2932]||(e[2932]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFileLineColRangeGetStartLine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Getter for start_line of FileLineColRange.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2931]||(e[2931]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L658-L662",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bb,[t("summary",null,[e[2933]||(e[2933]=t("a",{id:"Reactant.MLIR.API.mlirLocationFileLineColRangeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirLocationFileLineColRangeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFileLineColRangeGetTypeID")],-1)),e[2934]||(e[2934]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2936]||(e[2936]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFileLineColRangeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>TypeID Getter for FileLineColRange.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2935]||(e[2935]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L694-L698",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Nb,[t("summary",null,[e[2937]||(e[2937]=t("a",{id:"Reactant.MLIR.API.mlirLocationFromAttribute-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationFromAttribute-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFromAttribute")],-1)),e[2938]||(e[2938]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2940]||(e[2940]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFromAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Creates a location from a location attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2939]||(e[2939]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L609-L613",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gb,[t("summary",null,[e[2941]||(e[2941]=t("a",{id:"Reactant.MLIR.API.mlirLocationFusedGet-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirLocationFusedGet-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFusedGet")],-1)),e[2942]||(e[2942]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2944]||(e[2944]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFusedGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, nLocations, locations, metadata)</span></span></code></pre></div><p>Creates a fused location with an array of locations and metadata.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2943]||(e[2943]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L759-L763",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zb,[t("summary",null,[e[2945]||(e[2945]=t("a",{id:"Reactant.MLIR.API.mlirLocationFusedGetLocations-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirLocationFusedGetLocations-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFusedGetLocations")],-1)),e[2946]||(e[2946]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2948]||(e[2948]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFusedGetLocations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location, locationsCPtr)</span></span></code></pre></div><p>Getter for locations of Fused. Requires pre-allocated memory of #fusedLocations X sizeof(<a href="./@ref"><code>MlirLocation</code></a>).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2947]||(e[2947]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L782-L786",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wb,[t("summary",null,[e[2949]||(e[2949]=t("a",{id:"Reactant.MLIR.API.mlirLocationFusedGetMetadata-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationFusedGetMetadata-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFusedGetMetadata")],-1)),e[2950]||(e[2950]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2952]||(e[2952]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFusedGetMetadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Getter for metadata of Fused.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2951]||(e[2951]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L793-L797",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ub,[t("summary",null,[e[2953]||(e[2953]=t("a",{id:"Reactant.MLIR.API.mlirLocationFusedGetNumLocations-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationFusedGetNumLocations-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFusedGetNumLocations")],-1)),e[2954]||(e[2954]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2956]||(e[2956]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFusedGetNumLocations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Getter for number of locations fused together.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2955]||(e[2955]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L773-L777",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qb,[t("summary",null,[e[2957]||(e[2957]=t("a",{id:"Reactant.MLIR.API.mlirLocationFusedGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirLocationFusedGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationFusedGetTypeID")],-1)),e[2958]||(e[2958]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2960]||(e[2960]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFusedGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>TypeID Getter for Fused.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2959]||(e[2959]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L802-L806",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qb,[t("summary",null,[e[2961]||(e[2961]=t("a",{id:"Reactant.MLIR.API.mlirLocationGetAttribute-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationGetAttribute-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationGetAttribute")],-1)),e[2962]||(e[2962]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2964]||(e[2964]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationGetAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Returns the underlying location attribute of this location.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2963]||(e[2963]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L600-L604",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wb,[t("summary",null,[e[2965]||(e[2965]=t("a",{id:"Reactant.MLIR.API.mlirLocationGetContext-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationGetContext-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationGetContext")],-1)),e[2966]||(e[2966]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2968]||(e[2968]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Gets the context that a location was created with.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2967]||(e[2967]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L876-L880",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zb,[t("summary",null,[e[2969]||(e[2969]=t("a",{id:"Reactant.MLIR.API.mlirLocationIsACallSite-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationIsACallSite-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationIsACallSite")],-1)),e[2970]||(e[2970]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2972]||(e[2972]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationIsACallSite</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Checks whether the given location is an CallSite.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2971]||(e[2971]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L750-L754",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hb,[t("summary",null,[e[2973]||(e[2973]=t("a",{id:"Reactant.MLIR.API.mlirLocationIsAFileLineColRange-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationIsAFileLineColRange-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationIsAFileLineColRange")],-1)),e[2974]||(e[2974]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2976]||(e[2976]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationIsAFileLineColRange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Checks whether the given location is an FileLineColRange.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2975]||(e[2975]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L703-L707",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jb,[t("summary",null,[e[2977]||(e[2977]=t("a",{id:"Reactant.MLIR.API.mlirLocationIsAFused-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationIsAFused-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationIsAFused")],-1)),e[2978]||(e[2978]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2980]||(e[2980]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationIsAFused</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Checks whether the given location is an Fused.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2979]||(e[2979]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L811-L815",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Kb,[t("summary",null,[e[2981]||(e[2981]=t("a",{id:"Reactant.MLIR.API.mlirLocationIsAName-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationIsAName-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationIsAName")],-1)),e[2982]||(e[2982]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2984]||(e[2984]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationIsAName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Checks whether the given location is an Name.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2983]||(e[2983]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L858-L862",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$b,[t("summary",null,[e[2985]||(e[2985]=t("a",{id:"Reactant.MLIR.API.mlirLocationIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationIsNull")],-1)),e[2986]||(e[2986]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2988]||(e[2988]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Checks if the location is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2987]||(e[2987]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L885-L889",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xb,[t("summary",null,[e[2989]||(e[2989]=t("a",{id:"Reactant.MLIR.API.mlirLocationNameGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirLocationNameGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationNameGet")],-1)),e[2990]||(e[2990]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2992]||(e[2992]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationNameGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, name, childLoc)</span></span></code></pre></div><p>Creates a name location owned by the given context. Providing null location for childLoc is allowed and if childLoc is null location, then the behavior is the same as having unknown child location.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2991]||(e[2991]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L820-L824",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yb,[t("summary",null,[e[2993]||(e[2993]=t("a",{id:"Reactant.MLIR.API.mlirLocationNameGetChildLoc-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationNameGetChildLoc-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationNameGetChildLoc")],-1)),e[2994]||(e[2994]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[2996]||(e[2996]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationNameGetChildLoc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Getter for childLoc of Name.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2995]||(e[2995]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L840-L844",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ec,[t("summary",null,[e[2997]||(e[2997]=t("a",{id:"Reactant.MLIR.API.mlirLocationNameGetName-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationNameGetName-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationNameGetName")],-1)),e[2998]||(e[2998]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3e3]||(e[3e3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationNameGetName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Getter for name of Name.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2999]||(e[2999]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L831-L835",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",tc,[t("summary",null,[e[3001]||(e[3001]=t("a",{id:"Reactant.MLIR.API.mlirLocationNameGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirLocationNameGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationNameGetTypeID")],-1)),e[3002]||(e[3002]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3004]||(e[3004]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationNameGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>TypeID Getter for Name.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3003]||(e[3003]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L849-L853",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sc,[t("summary",null,[e[3005]||(e[3005]=t("a",{id:"Reactant.MLIR.API.mlirLocationPrint-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirLocationPrint-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationPrint")],-1)),e[3006]||(e[3006]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3008]||(e[3008]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location, callback, userData)</span></span></code></pre></div><p>Prints a location by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3007]||(e[3007]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L903-L907",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ac,[t("summary",null,[e[3009]||(e[3009]=t("a",{id:"Reactant.MLIR.API.mlirLocationUnknownGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLocationUnknownGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLocationUnknownGet")],-1)),e[3010]||(e[3010]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3012]||(e[3012]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationUnknownGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Creates a location with unknown position owned by the given context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3011]||(e[3011]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L867-L871",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ic,[t("summary",null,[e[3013]||(e[3013]=t("a",{id:"Reactant.MLIR.API.mlirLogicalResultFailure-Tuple{}",href:"#Reactant.MLIR.API.mlirLogicalResultFailure-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLogicalResultFailure")],-1)),e[3014]||(e[3014]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3016]||(e[3016]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLogicalResultFailure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a logical result representing a failure.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3015]||(e[3015]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L149-L153",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",lc,[t("summary",null,[e[3017]||(e[3017]=t("a",{id:"Reactant.MLIR.API.mlirLogicalResultIsFailure-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLogicalResultIsFailure-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLogicalResultIsFailure")],-1)),e[3018]||(e[3018]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3020]||(e[3020]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLogicalResultIsFailure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res)</span></span></code></pre></div><p>Checks if the given logical result represents a failure.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3019]||(e[3019]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L131-L135",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",nc,[t("summary",null,[e[3021]||(e[3021]=t("a",{id:"Reactant.MLIR.API.mlirLogicalResultIsSuccess-Tuple{Any}",href:"#Reactant.MLIR.API.mlirLogicalResultIsSuccess-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLogicalResultIsSuccess")],-1)),e[3022]||(e[3022]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3024]||(e[3024]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLogicalResultIsSuccess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res)</span></span></code></pre></div><p>Checks if the given logical result represents a success.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3023]||(e[3023]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L122-L126",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rc,[t("summary",null,[e[3025]||(e[3025]=t("a",{id:"Reactant.MLIR.API.mlirLogicalResultSuccess-Tuple{}",href:"#Reactant.MLIR.API.mlirLogicalResultSuccess-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirLogicalResultSuccess")],-1)),e[3026]||(e[3026]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3028]||(e[3028]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLogicalResultSuccess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a logical result representing a success.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3027]||(e[3027]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L140-L144",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",oc,[t("summary",null,[e[3029]||(e[3029]=t("a",{id:"Reactant.MLIR.API.mlirMemRefTypeContiguousGet-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirMemRefTypeContiguousGet-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirMemRefTypeContiguousGet")],-1)),e[3030]||(e[3030]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3032]||(e[3032]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeContiguousGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, rank, shape, memorySpace)</span></span></code></pre></div><p>Creates a MemRef type with the given rank, shape, memory space and element type in the same context as the element type. The type has no affine maps, i.e. represents a default row-major contiguous memref. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3031]||(e[3031]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5951-L5955",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pc,[t("summary",null,[e[3033]||(e[3033]=t("a",{id:"Reactant.MLIR.API.mlirMemRefTypeContiguousGetChecked-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirMemRefTypeContiguousGetChecked-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirMemRefTypeContiguousGetChecked")],-1)),e[3034]||(e[3034]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3036]||(e[3036]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeContiguousGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, elementType, rank, shape, memorySpace)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirMemRefTypeContiguousGet-NTuple{4, Any}"><code>mlirMemRefTypeContiguousGet</code></a>&quot; but returns a nullptr wrapping <a href="./@ref"><code>MlirType</code></a> on illegal arguments, emitting appropriate diagnostics.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3035]||(e[3035]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5965-L5969",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dc,[t("summary",null,[e[3037]||(e[3037]=t("a",{id:"Reactant.MLIR.API.mlirMemRefTypeGet-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirMemRefTypeGet-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirMemRefTypeGet")],-1)),e[3038]||(e[3038]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3040]||(e[3040]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, rank, shape, layout, memorySpace)</span></span></code></pre></div><p>Creates a MemRef type with the given rank and shape, a potentially empty list of affine layout maps, the given memory space and element type, in the same context as element type. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3039]||(e[3039]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5920-L5924",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",uc,[t("summary",null,[e[3041]||(e[3041]=t("a",{id:"Reactant.MLIR.API.mlirMemRefTypeGetAffineMap-Tuple{Any}",href:"#Reactant.MLIR.API.mlirMemRefTypeGetAffineMap-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirMemRefTypeGetAffineMap")],-1)),e[3042]||(e[3042]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3044]||(e[3044]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetAffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the affine map of the given MemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3043]||(e[3043]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6011-L6015",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bc,[t("summary",null,[e[3045]||(e[3045]=t("a",{id:"Reactant.MLIR.API.mlirMemRefTypeGetChecked-NTuple{6, Any}",href:"#Reactant.MLIR.API.mlirMemRefTypeGetChecked-NTuple{6, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirMemRefTypeGetChecked")],-1)),e[3046]||(e[3046]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3048]||(e[3048]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, elementType, rank, shape, layout, memorySpace)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirMemRefTypeGet-NTuple{5, Any}"><code>mlirMemRefTypeGet</code></a>&quot; but returns a nullptr-wrapping <a href="./@ref"><code>MlirType</code></a> o illegal arguments, emitting appropriate diagnostics.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3047]||(e[3047]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5935-L5939",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cc,[t("summary",null,[e[3049]||(e[3049]=t("a",{id:"Reactant.MLIR.API.mlirMemRefTypeGetLayout-Tuple{Any}",href:"#Reactant.MLIR.API.mlirMemRefTypeGetLayout-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirMemRefTypeGetLayout")],-1)),e[3050]||(e[3050]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3052]||(e[3052]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetLayout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the layout of the given MemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3051]||(e[3051]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6002-L6006",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hc,[t("summary",null,[e[3053]||(e[3053]=t("a",{id:"Reactant.MLIR.API.mlirMemRefTypeGetMemorySpace-Tuple{Any}",href:"#Reactant.MLIR.API.mlirMemRefTypeGetMemorySpace-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirMemRefTypeGetMemorySpace")],-1)),e[3054]||(e[3054]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3056]||(e[3056]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetMemorySpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the memory space of the given MemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3055]||(e[3055]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6020-L6024",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yc,[t("summary",null,[e[3057]||(e[3057]=t("a",{id:"Reactant.MLIR.API.mlirMemRefTypeGetStridesAndOffset-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirMemRefTypeGetStridesAndOffset-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirMemRefTypeGetStridesAndOffset")],-1)),e[3058]||(e[3058]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3060]||(e[3060]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetStridesAndOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, strides, offset)</span></span></code></pre></div><p>Returns the strides of the MemRef if the layout map is in strided form. Both strides and offset are out params. strides must point to pre-allocated memory of length equal to the rank of the memref.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3059]||(e[3059]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6029-L6033",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gc,[t("summary",null,[e[3061]||(e[3061]=t("a",{id:"Reactant.MLIR.API.mlirMemRefTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirMemRefTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirMemRefTypeGetTypeID")],-1)),e[3062]||(e[3062]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3064]||(e[3064]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an MemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3063]||(e[3063]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5884-L5888",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mc,[t("summary",null,[e[3065]||(e[3065]=t("a",{id:"Reactant.MLIR.API.mlirMergeSymbolsIntoFromClone-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirMergeSymbolsIntoFromClone-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirMergeSymbolsIntoFromClone")],-1)),e[3066]||(e[3066]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3068]||(e[3068]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMergeSymbolsIntoFromClone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, other)</span></span></code></pre></div><p>Merge the symbols from <code>other</code> into <code>target</code>, potentially renaming them to avoid conflicts. Private symbols may be renamed during the merge, public symbols must have at most one declaration. A name conflict in public symbols is reported as an error before returning a failure.</p><p>Note that this clones the <code>other</code> operation unlike the C++ counterpart that takes ownership.</p>',3)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3067]||(e[3067]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8644-L8650",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",kc,[t("summary",null,[e[3069]||(e[3069]=t("a",{id:"Reactant.MLIR.API.mlirModuleCreateEmpty-Tuple{Any}",href:"#Reactant.MLIR.API.mlirModuleCreateEmpty-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirModuleCreateEmpty")],-1)),e[3070]||(e[3070]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3072]||(e[3072]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleCreateEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Creates a new, empty module and transfers ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3071]||(e[3071]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L914-L918",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rc,[t("summary",null,[e[3073]||(e[3073]=t("a",{id:"Reactant.MLIR.API.mlirModuleCreateParse-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirModuleCreateParse-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirModuleCreateParse")],-1)),e[3074]||(e[3074]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3076]||(e[3076]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleCreateParse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, _module)</span></span></code></pre></div><p>Parses a module from the string and transfers ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3075]||(e[3075]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L923-L927",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fc,[t("summary",null,[e[3077]||(e[3077]=t("a",{id:"Reactant.MLIR.API.mlirModuleCreateParseFromFile-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirModuleCreateParseFromFile-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirModuleCreateParseFromFile")],-1)),e[3078]||(e[3078]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3080]||(e[3080]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleCreateParseFromFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, fileName)</span></span></code></pre></div><p>Parses a module from file and transfers ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3079]||(e[3079]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L934-L938",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ic,[t("summary",null,[e[3081]||(e[3081]=t("a",{id:"Reactant.MLIR.API.mlirModuleDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirModuleDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirModuleDestroy")],-1)),e[3082]||(e[3082]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3084]||(e[3084]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module)</span></span></code></pre></div><p>Takes a module owned by the caller and deletes it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3083]||(e[3083]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L972-L976",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Tc,[t("summary",null,[e[3085]||(e[3085]=t("a",{id:"Reactant.MLIR.API.mlirModuleEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirModuleEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirModuleEqual")],-1)),e[3086]||(e[3086]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3088]||(e[3088]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Checks if two modules are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3087]||(e[3087]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L999-L1003",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ac,[t("summary",null,[e[3089]||(e[3089]=t("a",{id:"Reactant.MLIR.API.mlirModuleFromOperation-Tuple{Any}",href:"#Reactant.MLIR.API.mlirModuleFromOperation-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirModuleFromOperation")],-1)),e[3090]||(e[3090]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3092]||(e[3092]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleFromOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Views the generic operation as a module. The returned module is null when the input operation was not a ModuleOp.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3091]||(e[3091]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L990-L994",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jc,[t("summary",null,[e[3093]||(e[3093]=t("a",{id:"Reactant.MLIR.API.mlirModuleGetBody-Tuple{Any}",href:"#Reactant.MLIR.API.mlirModuleGetBody-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirModuleGetBody")],-1)),e[3094]||(e[3094]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3096]||(e[3096]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleGetBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module)</span></span></code></pre></div><p>Gets the body of the module, i.e. the only block it contains.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3095]||(e[3095]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L954-L958",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_c,[t("summary",null,[e[3097]||(e[3097]=t("a",{id:"Reactant.MLIR.API.mlirModuleGetContext-Tuple{Any}",href:"#Reactant.MLIR.API.mlirModuleGetContext-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirModuleGetContext")],-1)),e[3098]||(e[3098]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3100]||(e[3100]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module)</span></span></code></pre></div><p>Gets the context that a module was created with.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3099]||(e[3099]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L945-L949",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mc,[t("summary",null,[e[3101]||(e[3101]=t("a",{id:"Reactant.MLIR.API.mlirModuleGetOperation-Tuple{Any}",href:"#Reactant.MLIR.API.mlirModuleGetOperation-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirModuleGetOperation")],-1)),e[3102]||(e[3102]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3104]||(e[3104]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleGetOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module)</span></span></code></pre></div><p>Views the module as a generic operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3103]||(e[3103]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L981-L985",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ec,[t("summary",null,[e[3105]||(e[3105]=t("a",{id:"Reactant.MLIR.API.mlirModuleHashValue-Tuple{Any}",href:"#Reactant.MLIR.API.mlirModuleHashValue-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirModuleHashValue")],-1)),e[3106]||(e[3106]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3108]||(e[3108]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleHashValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mod)</span></span></code></pre></div><p>Compute a hash for the given module.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3107]||(e[3107]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1008-L1012",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Lc,[t("summary",null,[e[3109]||(e[3109]=t("a",{id:"Reactant.MLIR.API.mlirModuleIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirModuleIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirModuleIsNull")],-1)),e[3110]||(e[3110]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3112]||(e[3112]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module)</span></span></code></pre></div><p>Checks whether a module is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3111]||(e[3111]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L963-L967",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Cc,[t("summary",null,[e[3113]||(e[3113]=t("a",{id:"Reactant.MLIR.API.mlirNamedAttributeGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirNamedAttributeGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirNamedAttributeGet")],-1)),e[3114]||(e[3114]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3116]||(e[3116]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirNamedAttributeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name, attr)</span></span></code></pre></div><p>Associates an attribute with the name. Takes ownership of neither.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3115]||(e[3115]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2534-L2538",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vc,[t("summary",null,[e[3117]||(e[3117]=t("a",{id:"Reactant.MLIR.API.mlirNoneTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirNoneTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirNoneTypeGet")],-1)),e[3118]||(e[3118]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3120]||(e[3120]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirNoneTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a None type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3119]||(e[3119]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5529-L5533",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pc,[t("summary",null,[e[3121]||(e[3121]=t("a",{id:"Reactant.MLIR.API.mlirNoneTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirNoneTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirNoneTypeGetTypeID")],-1)),e[3122]||(e[3122]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3124]||(e[3124]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirNoneTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an None type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3123]||(e[3123]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5511-L5515",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xc,[t("summary",null,[e[3125]||(e[3125]=t("a",{id:"Reactant.MLIR.API.mlirOpOperandGetNextUse-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpOperandGetNextUse-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpOperandGetNextUse")],-1)),e[3126]||(e[3126]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3128]||(e[3128]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpOperandGetNextUse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns an op operand representing the next use of the value, or a null op operand if there is no next use.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3127]||(e[3127]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2366-L2370",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sc,[t("summary",null,[e[3129]||(e[3129]=t("a",{id:"Reactant.MLIR.API.mlirOpOperandGetOperandNumber-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpOperandGetOperandNumber-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpOperandGetOperandNumber")],-1)),e[3130]||(e[3130]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3132]||(e[3132]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpOperandGetOperandNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns the operand number of an op operand.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3131]||(e[3131]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2357-L2361",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Dc,[t("summary",null,[e[3133]||(e[3133]=t("a",{id:"Reactant.MLIR.API.mlirOpOperandGetOwner-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpOperandGetOwner-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpOperandGetOwner")],-1)),e[3134]||(e[3134]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3136]||(e[3136]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpOperandGetOwner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns the owner operation of an op operand.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3135]||(e[3135]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2348-L2352",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fc,[t("summary",null,[e[3137]||(e[3137]=t("a",{id:"Reactant.MLIR.API.mlirOpOperandGetValue-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpOperandGetValue-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpOperandGetValue")],-1)),e[3138]||(e[3138]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3140]||(e[3140]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpOperandGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns the value of an op operand.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3139]||(e[3139]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2339-L2343",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vc,[t("summary",null,[e[3141]||(e[3141]=t("a",{id:"Reactant.MLIR.API.mlirOpOperandIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpOperandIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpOperandIsNull")],-1)),e[3142]||(e[3142]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3144]||(e[3144]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpOperandIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns whether the op operand is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3143]||(e[3143]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2330-L2334",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Oc,[t("summary",null,[e[3145]||(e[3145]=t("a",{id:"Reactant.MLIR.API.mlirOpPassManagerAddOwnedPass-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOpPassManagerAddOwnedPass-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPassManagerAddOwnedPass")],-1)),e[3146]||(e[3146]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3148]||(e[3148]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPassManagerAddOwnedPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, pass)</span></span></code></pre></div><p>Add a pass and transfer ownership to the provided mlirOpPassManager. If the pass is not a generic operation pass or matching the type of the provided PassManager, a new OpPassManager is implicitly nested under the provided PassManager.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3147]||(e[3147]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9057-L9061",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bc,[t("summary",null,[e[3149]||(e[3149]=t("a",{id:"Reactant.MLIR.API.mlirOpPassManagerAddPipeline-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirOpPassManagerAddPipeline-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPassManagerAddPipeline")],-1)),e[3150]||(e[3150]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3152]||(e[3152]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPassManagerAddPipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, pipelineElements, callback, userData)</span></span></code></pre></div><p>Parse a sequence of textual MLIR pass pipeline elements and add them to the provided OpPassManager. If parsing fails an error message is reported using the provided callback.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3151]||(e[3151]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9068-L9072",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Nc,[t("summary",null,[e[3153]||(e[3153]=t("a",{id:"Reactant.MLIR.API.mlirOpPassManagerGetNestedUnder-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOpPassManagerGetNestedUnder-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPassManagerGetNestedUnder")],-1)),e[3154]||(e[3154]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3156]||(e[3156]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPassManagerGetNestedUnder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, operationName)</span></span></code></pre></div><p>Nest an OpPassManager under the provided OpPassManager, the nested passmanager will only run on operations matching the provided name. The returned OpPassManager will be destroyed when the parent is destroyed.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3155]||(e[3155]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9035-L9039",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gc,[t("summary",null,[e[3157]||(e[3157]=t("a",{id:"Reactant.MLIR.API.mlirOpPrintingFlagsAssumeVerified-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpPrintingFlagsAssumeVerified-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPrintingFlagsAssumeVerified")],-1)),e[3158]||(e[3158]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3160]||(e[3160]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsAssumeVerified</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags)</span></span></code></pre></div><p>Do not verify the operation when using custom operation printers.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3159]||(e[3159]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1206-L1210",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zc,[t("summary",null,[e[3161]||(e[3161]=t("a",{id:"Reactant.MLIR.API.mlirOpPrintingFlagsCreate-Tuple{}",href:"#Reactant.MLIR.API.mlirOpPrintingFlagsCreate-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPrintingFlagsCreate")],-1)),e[3162]||(e[3162]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3164]||(e[3164]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates new printing flags with defaults, intended for customization. Must be freed with a call to <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOpPrintingFlagsDestroy-Tuple{Any}"><code>mlirOpPrintingFlagsDestroy</code></a>().</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3163]||(e[3163]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1128-L1132",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wc,[t("summary",null,[e[3165]||(e[3165]=t("a",{id:"Reactant.MLIR.API.mlirOpPrintingFlagsDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpPrintingFlagsDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPrintingFlagsDestroy")],-1)),e[3166]||(e[3166]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3168]||(e[3168]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags)</span></span></code></pre></div><p>Destroys printing flags created with <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOpPrintingFlagsCreate-Tuple{}"><code>mlirOpPrintingFlagsCreate</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3167]||(e[3167]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1137-L1141",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Uc,[t("summary",null,[e[3169]||(e[3169]=t("a",{id:"Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeElementsAttrs-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeElementsAttrs-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeElementsAttrs")],-1)),e[3170]||(e[3170]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3172]||(e[3172]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsElideLargeElementsAttrs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, largeElementLimit)</span></span></code></pre></div><p>Enables the elision of large elements attributes by printing a lexically valid but otherwise meaningless form instead of the element data. The <code>largeElementLimit</code> is used to configure what is considered to be a &quot;large&quot; ElementsAttr by providing an upper limit to the number of elements.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3171]||(e[3171]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1146-L1150",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qc,[t("summary",null,[e[3173]||(e[3173]=t("a",{id:"Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeResourceString-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeResourceString-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeResourceString")],-1)),e[3174]||(e[3174]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3176]||(e[3176]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsElideLargeResourceString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, largeResourceLimit)</span></span></code></pre></div><p>Enables the elision of large resources strings by omitting them from the <code>dialect_resources</code> section. The <code>largeResourceLimit</code> is used to configure what is considered to be a &quot;large&quot; resource by providing an upper limit to the string size.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3175]||(e[3175]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1157-L1161",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qc,[t("summary",null,[e[3177]||(e[3177]=t("a",{id:"Reactant.MLIR.API.mlirOpPrintingFlagsEnableDebugInfo-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOpPrintingFlagsEnableDebugInfo-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPrintingFlagsEnableDebugInfo")],-1)),e[3178]||(e[3178]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3180]||(e[3180]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsEnableDebugInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, enable, prettyForm)</span></span></code></pre></div><p>Enable or disable printing of debug information (based on <code>enable</code>). If &#39;prettyForm&#39; is set to true, debug information is printed in a more readable &#39;pretty&#39; form. Note: The IR generated with &#39;prettyForm&#39; is not parsable.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3179]||(e[3179]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1168-L1172",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wc,[t("summary",null,[e[3181]||(e[3181]=t("a",{id:"Reactant.MLIR.API.mlirOpPrintingFlagsPrintGenericOpForm-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpPrintingFlagsPrintGenericOpForm-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPrintingFlagsPrintGenericOpForm")],-1)),e[3182]||(e[3182]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3184]||(e[3184]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsPrintGenericOpForm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags)</span></span></code></pre></div><p>Always print operations in the generic form.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3183]||(e[3183]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1179-L1183",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zc,[t("summary",null,[e[3185]||(e[3185]=t("a",{id:"Reactant.MLIR.API.mlirOpPrintingFlagsPrintNameLocAsPrefix-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpPrintingFlagsPrintNameLocAsPrefix-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPrintingFlagsPrintNameLocAsPrefix")],-1)),e[3186]||(e[3186]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3188]||(e[3188]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsPrintNameLocAsPrefix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags)</span></span></code></pre></div><p>Print the name and location, if NamedLoc, as a prefix to the SSA ID.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3187]||(e[3187]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1188-L1192",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hc,[t("summary",null,[e[3189]||(e[3189]=t("a",{id:"Reactant.MLIR.API.mlirOpPrintingFlagsSkipRegions-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpPrintingFlagsSkipRegions-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPrintingFlagsSkipRegions")],-1)),e[3190]||(e[3190]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3192]||(e[3192]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsSkipRegions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags)</span></span></code></pre></div><p>Skip printing regions.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3191]||(e[3191]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1215-L1219",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jc,[t("summary",null,[e[3193]||(e[3193]=t("a",{id:"Reactant.MLIR.API.mlirOpPrintingFlagsUseLocalScope-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpPrintingFlagsUseLocalScope-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpPrintingFlagsUseLocalScope")],-1)),e[3194]||(e[3194]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3196]||(e[3196]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsUseLocalScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags)</span></span></code></pre></div><p>Use local scope when printing the operation. This allows for using the printer in a more localized and thread-safe setting, but may not necessarily be identical to what the IR will look like when dumping the full module.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3195]||(e[3195]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1197-L1201",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Kc,[t("summary",null,[e[3197]||(e[3197]=t("a",{id:"Reactant.MLIR.API.mlirOpResultGetOwner-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpResultGetOwner-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpResultGetOwner")],-1)),e[3198]||(e[3198]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3200]||(e[3200]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpResultGetOwner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns an operation that produced this value as its result. Asserts if the value is not an op result.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3199]||(e[3199]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2210-L2214",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$c,[t("summary",null,[e[3201]||(e[3201]=t("a",{id:"Reactant.MLIR.API.mlirOpResultGetResultNumber-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpResultGetResultNumber-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpResultGetResultNumber")],-1)),e[3202]||(e[3202]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3204]||(e[3204]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpResultGetResultNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the position of the value in the list of results of the operation that produced it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3203]||(e[3203]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2219-L2223",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xc,[t("summary",null,[e[3205]||(e[3205]=t("a",{id:"Reactant.MLIR.API.mlirOpRewritePatternCreate-NTuple{7, Any}",href:"#Reactant.MLIR.API.mlirOpRewritePatternCreate-NTuple{7, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpRewritePatternCreate")],-1)),e[3206]||(e[3206]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3208]||(e[3208]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpRewritePatternCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rootName, benefit, context, callbacks, userData, nGeneratedNames, generatedNames)</span></span></code></pre></div><p>Create a rewrite pattern that matches the operation with the given rootName, corresponding to mlir::OpRewritePattern.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3207]||(e[3207]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9707-L9711",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yc,[t("summary",null,[e[3209]||(e[3209]=t("a",{id:"Reactant.MLIR.API.mlirOpaqueAttrGet-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirOpaqueAttrGet-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpaqueAttrGet")],-1)),e[3210]||(e[3210]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3212]||(e[3212]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, dialectNamespace, dataLength, data, type)</span></span></code></pre></div><p>Creates an opaque attribute in the given context associated with the dialect identified by its namespace. The attribute contains opaque byte data of the specified length (data need not be null-terminated).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3211]||(e[3211]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3859-L3863",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",eh,[t("summary",null,[e[3213]||(e[3213]=t("a",{id:"Reactant.MLIR.API.mlirOpaqueAttrGetData-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpaqueAttrGetData-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpaqueAttrGetData")],-1)),e[3214]||(e[3214]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3216]||(e[3216]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueAttrGetData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the raw data as a string reference. The data remains live as long as the context in which the attribute lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3215]||(e[3215]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3883-L3887",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",th,[t("summary",null,[e[3217]||(e[3217]=t("a",{id:"Reactant.MLIR.API.mlirOpaqueAttrGetDialectNamespace-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpaqueAttrGetDialectNamespace-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpaqueAttrGetDialectNamespace")],-1)),e[3218]||(e[3218]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3220]||(e[3220]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueAttrGetDialectNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the namespace of the dialect with which the given opaque attribute is associated. The namespace string is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3219]||(e[3219]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3874-L3878",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sh,[t("summary",null,[e[3221]||(e[3221]=t("a",{id:"Reactant.MLIR.API.mlirOpaqueAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirOpaqueAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpaqueAttrGetTypeID")],-1)),e[3222]||(e[3222]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3224]||(e[3224]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Opaque attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3223]||(e[3223]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3892-L3896",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ah,[t("summary",null,[e[3225]||(e[3225]=t("a",{id:"Reactant.MLIR.API.mlirOpaqueTypeGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOpaqueTypeGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpaqueTypeGet")],-1)),e[3226]||(e[3226]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3228]||(e[3228]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, dialectNamespace, typeData)</span></span></code></pre></div><p>Creates an opaque type in the given context associated with the dialect identified by its namespace. The type contains opaque byte data of the specified length (data need not be null-terminated).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3227]||(e[3227]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6183-L6187",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ih,[t("summary",null,[e[3229]||(e[3229]=t("a",{id:"Reactant.MLIR.API.mlirOpaqueTypeGetData-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpaqueTypeGetData-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpaqueTypeGetData")],-1)),e[3230]||(e[3230]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3232]||(e[3232]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueTypeGetData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the raw data as a string reference. The data remains live as long as the context in which the type lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3231]||(e[3231]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6203-L6207",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",lh,[t("summary",null,[e[3233]||(e[3233]=t("a",{id:"Reactant.MLIR.API.mlirOpaqueTypeGetDialectNamespace-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOpaqueTypeGetDialectNamespace-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpaqueTypeGetDialectNamespace")],-1)),e[3234]||(e[3234]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3236]||(e[3236]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueTypeGetDialectNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the namespace of the dialect with which the given opaque type is associated. The namespace string is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3235]||(e[3235]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6194-L6198",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",nh,[t("summary",null,[e[3237]||(e[3237]=t("a",{id:"Reactant.MLIR.API.mlirOpaqueTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirOpaqueTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOpaqueTypeGetTypeID")],-1)),e[3238]||(e[3238]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3240]||(e[3240]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Opaque type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3239]||(e[3239]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6165-L6169",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rh,[t("summary",null,[e[3241]||(e[3241]=t("a",{id:"Reactant.MLIR.API.mlirOperationClone-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationClone-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationClone")],-1)),e[3242]||(e[3242]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3244]||(e[3244]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationClone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Creates a deep copy of an operation. The operation is not inserted and ownership is transferred to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3243]||(e[3243]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1277-L1281",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",oh,[t("summary",null,[e[3245]||(e[3245]=t("a",{id:"Reactant.MLIR.API.mlirOperationCreate-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationCreate-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationCreate")],-1)),e[3246]||(e[3246]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3248]||(e[3248]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state)</span></span></code></pre></div><p>Creates an operation and transfers ownership to the caller. Note that caller owned child objects are transferred in this call and must not be further used. Particularly, this applies to any regions added to the state (the implementation may invalidate any such pointers).</p><p>This call can fail under the following conditions, in which case, it will return a null operation and emit diagnostics: - Result type inference is enabled and cannot be performed.</p>',3)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3247]||(e[3247]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1253-L1259",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ph,[t("summary",null,[e[3249]||(e[3249]=t("a",{id:"Reactant.MLIR.API.mlirOperationCreateParse-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOperationCreateParse-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationCreateParse")],-1)),e[3250]||(e[3250]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3252]||(e[3252]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationCreateParse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, sourceStr, sourceName)</span></span></code></pre></div><p>Parses an operation, giving ownership to the caller. If parsing fails a null operation will be returned, and an error diagnostic emitted.</p><p><code>sourceStr</code> may be either the text assembly format, or binary bytecode format. <code>sourceName</code> is used as the file name of the source; any IR without locations will get a <code>FileLineColLoc</code> location with <code>sourceName</code> as the file name.</p>',3)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3251]||(e[3251]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1264-L1270",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dh,[t("summary",null,[e[3253]||(e[3253]=t("a",{id:"Reactant.MLIR.API.mlirOperationDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationDestroy")],-1)),e[3254]||(e[3254]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3256]||(e[3256]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Takes an operation owned by the caller and destroys it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3255]||(e[3255]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1286-L1290",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",uh,[t("summary",null,[e[3257]||(e[3257]=t("a",{id:"Reactant.MLIR.API.mlirOperationDump-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationDump-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationDump")],-1)),e[3258]||(e[3258]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3260]||(e[3260]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Prints an operation to stderr.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3259]||(e[3259]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1711-L1715",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bh,[t("summary",null,[e[3261]||(e[3261]=t("a",{id:"Reactant.MLIR.API.mlirOperationEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationEqual")],-1)),e[3262]||(e[3262]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3264]||(e[3264]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, other)</span></span></code></pre></div><p>Checks whether two operation handles point to the same operation. This does not perform deep comparison.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3263]||(e[3263]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1313-L1317",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ch,[t("summary",null,[e[3265]||(e[3265]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetAttribute-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationGetAttribute-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetAttribute")],-1)),e[3266]||(e[3266]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3268]||(e[3268]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos)</span></span></code></pre></div><p>Return <code>pos</code>-th attribute of the operation. Deprecated, please use <code>mlirOperationGetInherentAttribute</code> or <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationGetDiscardableAttribute-Tuple{Any, Any}"><code>mlirOperationGetDiscardableAttribute</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3267]||(e[3267]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1603-L1607",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hh,[t("summary",null,[e[3269]||(e[3269]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetAttributeByName-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationGetAttributeByName-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetAttributeByName")],-1)),e[3270]||(e[3270]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3272]||(e[3272]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Returns an attribute attached to the operation given its name. Deprecated, please use <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationGetInherentAttributeByName-Tuple{Any, Any}"><code>mlirOperationGetInherentAttributeByName</code></a> or <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationGetDiscardableAttributeByName-Tuple{Any, Any}"><code>mlirOperationGetDiscardableAttributeByName</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3271]||(e[3271]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1614-L1618",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yh,[t("summary",null,[e[3273]||(e[3273]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetBlock-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetBlock-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetBlock")],-1)),e[3274]||(e[3274]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3276]||(e[3276]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the block that owns this operation, returning null if the operation is not owned.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3275]||(e[3275]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1376-L1380",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gh,[t("summary",null,[e[3277]||(e[3277]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetContext-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetContext-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetContext")],-1)),e[3278]||(e[3278]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3280]||(e[3280]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the context this operation is associated with</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3279]||(e[3279]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1331-L1335",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mh,[t("summary",null,[e[3281]||(e[3281]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetDiscardableAttribute-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationGetDiscardableAttribute-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetDiscardableAttribute")],-1)),e[3282]||(e[3282]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3284]||(e[3284]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetDiscardableAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos)</span></span></code></pre></div><p>Return <code>pos</code>-th discardable attribute of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3283]||(e[3283]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1550-L1554",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",kh,[t("summary",null,[e[3285]||(e[3285]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetDiscardableAttributeByName-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationGetDiscardableAttributeByName-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetDiscardableAttributeByName")],-1)),e[3286]||(e[3286]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3288]||(e[3288]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetDiscardableAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Returns a discardable attribute attached to the operation given its name.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3287]||(e[3287]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1561-L1565",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rh,[t("summary",null,[e[3289]||(e[3289]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetFirstRegion-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetFirstRegion-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetFirstRegion")],-1)),e[3290]||(e[3290]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3292]||(e[3292]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetFirstRegion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns first region attached to the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3291]||(e[3291]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1886-L1890",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fh,[t("summary",null,[e[3293]||(e[3293]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetInherentAttributeByName-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationGetInherentAttributeByName-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetInherentAttributeByName")],-1)),e[3294]||(e[3294]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3296]||(e[3296]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetInherentAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Returns an inherent attribute attached to the operation given its name.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3295]||(e[3295]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1519-L1523",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ih,[t("summary",null,[e[3297]||(e[3297]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetLocation-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetLocation-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetLocation")],-1)),e[3298]||(e[3298]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3300]||(e[3300]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetLocation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the location of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3299]||(e[3299]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1340-L1344",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Th,[t("summary",null,[e[3301]||(e[3301]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetName-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetName-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetName")],-1)),e[3302]||(e[3302]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3304]||(e[3304]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the name of the operation as an identifier.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3303]||(e[3303]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1367-L1371",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ah,[t("summary",null,[e[3305]||(e[3305]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetNextInBlock-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetNextInBlock-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetNextInBlock")],-1)),e[3306]||(e[3306]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3308]||(e[3308]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNextInBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns an operation immediately following the given operation it its enclosing block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3307]||(e[3307]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1412-L1416",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jh,[t("summary",null,[e[3309]||(e[3309]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetNumAttributes-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetNumAttributes-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetNumAttributes")],-1)),e[3310]||(e[3310]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3312]||(e[3312]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNumAttributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of attributes attached to the operation. Deprecated, please use <code>mlirOperationGetNumInherentAttributes</code> or <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationGetNumDiscardableAttributes-Tuple{Any}"><code>mlirOperationGetNumDiscardableAttributes</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3311]||(e[3311]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1594-L1598",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_h,[t("summary",null,[e[3313]||(e[3313]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetNumDiscardableAttributes-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetNumDiscardableAttributes-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetNumDiscardableAttributes")],-1)),e[3314]||(e[3314]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3316]||(e[3316]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNumDiscardableAttributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of discardable attributes attached to the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3315]||(e[3315]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1541-L1545",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mh,[t("summary",null,[e[3317]||(e[3317]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetNumOperands-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetNumOperands-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetNumOperands")],-1)),e[3318]||(e[3318]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3320]||(e[3320]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNumOperands</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of operands of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3319]||(e[3319]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1421-L1425",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Eh,[t("summary",null,[e[3321]||(e[3321]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetNumRegions-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetNumRegions-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetNumRegions")],-1)),e[3322]||(e[3322]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3324]||(e[3324]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNumRegions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of regions attached to the given operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3323]||(e[3323]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1394-L1398",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Lh,[t("summary",null,[e[3325]||(e[3325]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetNumResults-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetNumResults-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetNumResults")],-1)),e[3326]||(e[3326]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3328]||(e[3328]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNumResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of results of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3327]||(e[3327]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1461-L1465",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ch,[t("summary",null,[e[3329]||(e[3329]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetNumSuccessors-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetNumSuccessors-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetNumSuccessors")],-1)),e[3330]||(e[3330]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3332]||(e[3332]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNumSuccessors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of successor blocks of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3331]||(e[3331]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1479-L1483",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vh,[t("summary",null,[e[3333]||(e[3333]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetOperand-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationGetOperand-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetOperand")],-1)),e[3334]||(e[3334]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3336]||(e[3336]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetOperand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th operand of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3335]||(e[3335]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1430-L1434",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ph,[t("summary",null,[e[3337]||(e[3337]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetParentOperation-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetParentOperation-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetParentOperation")],-1)),e[3338]||(e[3338]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3340]||(e[3340]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetParentOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the operation that owns this operation, returning null if the operation is not owned.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3339]||(e[3339]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1385-L1389",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xh,[t("summary",null,[e[3341]||(e[3341]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetRegion-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationGetRegion-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetRegion")],-1)),e[3342]||(e[3342]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3344]||(e[3344]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetRegion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th region attached to the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3343]||(e[3343]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1403-L1407",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sh,[t("summary",null,[e[3345]||(e[3345]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetResult-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationGetResult-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetResult")],-1)),e[3346]||(e[3346]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3348]||(e[3348]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th result of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3347]||(e[3347]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1470-L1474",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Dh,[t("summary",null,[e[3349]||(e[3349]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetSuccessor-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationGetSuccessor-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetSuccessor")],-1)),e[3350]||(e[3350]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3352]||(e[3352]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetSuccessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th successor of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3351]||(e[3351]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1488-L1492",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fh,[t("summary",null,[e[3353]||(e[3353]=t("a",{id:"Reactant.MLIR.API.mlirOperationGetTypeID-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationGetTypeID-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationGetTypeID")],-1)),e[3354]||(e[3354]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3356]||(e[3356]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the type id of the operation. Returns null if the operation does not have a registered operation description.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3355]||(e[3355]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1358-L1362",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vh,[t("summary",null,[e[3357]||(e[3357]=t("a",{id:"Reactant.MLIR.API.mlirOperationHasInherentAttributeByName-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationHasInherentAttributeByName-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationHasInherentAttributeByName")],-1)),e[3358]||(e[3358]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3360]||(e[3360]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationHasInherentAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Returns true if this operation defines an inherent attribute with this name. Note: the attribute can be optional, so <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationGetInherentAttributeByName-Tuple{Any, Any}"><code>mlirOperationGetInherentAttributeByName</code></a> can still return a null attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3359]||(e[3359]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1508-L1512",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Oh,[t("summary",null,[e[3361]||(e[3361]=t("a",{id:"Reactant.MLIR.API.mlirOperationHashValue-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationHashValue-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationHashValue")],-1)),e[3362]||(e[3362]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3364]||(e[3364]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationHashValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Compute a hash for the given operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3363]||(e[3363]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1322-L1326",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bh,[t("summary",null,[e[3365]||(e[3365]=t("a",{id:"Reactant.MLIR.API.mlirOperationImplementsInterface-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationImplementsInterface-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationImplementsInterface")],-1)),e[3366]||(e[3366]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3368]||(e[3368]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationImplementsInterface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(operation, interfaceTypeID)</span></span></code></pre></div><p>Returns <code>true</code> if the given operation implements an interface identified by its TypeID.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3367]||(e[3367]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8762-L8766",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Nh,[t("summary",null,[e[3369]||(e[3369]=t("a",{id:"Reactant.MLIR.API.mlirOperationImplementsInterfaceStatic-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOperationImplementsInterfaceStatic-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationImplementsInterfaceStatic")],-1)),e[3370]||(e[3370]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3372]||(e[3372]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationImplementsInterfaceStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(operationName, context, interfaceTypeID)</span></span></code></pre></div><p>Returns <code>true</code> if the operation identified by its canonical string name implements the interface identified by its TypeID in the given context. Note that interfaces may be attached to operations in some contexts and not others.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3371]||(e[3371]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8773-L8777",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gh,[t("summary",null,[e[3373]||(e[3373]=t("a",{id:"Reactant.MLIR.API.mlirOperationIsBeforeInBlock-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationIsBeforeInBlock-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationIsBeforeInBlock")],-1)),e[3374]||(e[3374]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3376]||(e[3376]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationIsBeforeInBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, other)</span></span></code></pre></div><p>Given an operation &#39;other&#39; that is within the same parent block, return whether the current operation is before &#39;other&#39; in the operation list of the parent block. Note: This function has an average complexity of O(1), but worst case may take O(N) where N is the number of operations within the parent block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3375]||(e[3375]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1747-L1751",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zh,[t("summary",null,[e[3377]||(e[3377]=t("a",{id:"Reactant.MLIR.API.mlirOperationIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationIsNull")],-1)),e[3378]||(e[3378]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3380]||(e[3380]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Checks whether the underlying operation is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3379]||(e[3379]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1304-L1308",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wh,[t("summary",null,[e[3381]||(e[3381]=t("a",{id:"Reactant.MLIR.API.mlirOperationMoveAfter-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationMoveAfter-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationMoveAfter")],-1)),e[3382]||(e[3382]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3384]||(e[3384]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationMoveAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, other)</span></span></code></pre></div><p>Moves the given operation immediately after the other operation in its parent block. The given operation may be owned by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3383]||(e[3383]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1729-L1733",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Uh,[t("summary",null,[e[3385]||(e[3385]=t("a",{id:"Reactant.MLIR.API.mlirOperationMoveBefore-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationMoveBefore-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationMoveBefore")],-1)),e[3386]||(e[3386]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3388]||(e[3388]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationMoveBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, other)</span></span></code></pre></div><p>Moves the given operation immediately before the other operation in its parent block. The given operation may be owner by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3387]||(e[3387]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1738-L1742",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qh,[t("summary",null,[e[3389]||(e[3389]=t("a",{id:"Reactant.MLIR.API.mlirOperationPrint-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOperationPrint-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationPrint")],-1)),e[3390]||(e[3390]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3392]||(e[3392]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, callback, userData)</span></span></code></pre></div><p>Prints an operation by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3391]||(e[3391]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1647-L1651",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qh,[t("summary",null,[e[3393]||(e[3393]=t("a",{id:"Reactant.MLIR.API.mlirOperationPrintWithFlags-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirOperationPrintWithFlags-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationPrintWithFlags")],-1)),e[3394]||(e[3394]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3396]||(e[3396]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationPrintWithFlags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, flags, callback, userData)</span></span></code></pre></div><p>Same as <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationPrint-Tuple{Any, Any, Any}"><code>mlirOperationPrint</code></a> but accepts flags controlling the printing behavior.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3395]||(e[3395]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1658-L1662",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wh,[t("summary",null,[e[3397]||(e[3397]=t("a",{id:"Reactant.MLIR.API.mlirOperationPrintWithState-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirOperationPrintWithState-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationPrintWithState")],-1)),e[3398]||(e[3398]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3400]||(e[3400]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationPrintWithState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, state, callback, userData)</span></span></code></pre></div><p>Same as <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationPrint-Tuple{Any, Any, Any}"><code>mlirOperationPrint</code></a> but accepts AsmState controlling the printing behavior as well as caching computed names.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3399]||(e[3399]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1672-L1676",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zh,[t("summary",null,[e[3401]||(e[3401]=t("a",{id:"Reactant.MLIR.API.mlirOperationRemoveAttributeByName-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationRemoveAttributeByName-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationRemoveAttributeByName")],-1)),e[3402]||(e[3402]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3404]||(e[3404]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationRemoveAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Removes an attribute by name. Returns false if the attribute was not found and true if removed. Deprecated, please use <code>mlirOperationRemoveInherentAttributeByName</code> or <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationRemoveDiscardableAttributeByName-Tuple{Any, Any}"><code>mlirOperationRemoveDiscardableAttributeByName</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3403]||(e[3403]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1636-L1640",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hh,[t("summary",null,[e[3405]||(e[3405]=t("a",{id:"Reactant.MLIR.API.mlirOperationRemoveDiscardableAttributeByName-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationRemoveDiscardableAttributeByName-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationRemoveDiscardableAttributeByName")],-1)),e[3406]||(e[3406]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3408]||(e[3408]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationRemoveDiscardableAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Removes a discardable attribute by name. Returns false if the attribute was not found and true if removed.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3407]||(e[3407]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1583-L1587",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jh,[t("summary",null,[e[3409]||(e[3409]=t("a",{id:"Reactant.MLIR.API.mlirOperationRemoveFromParent-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationRemoveFromParent-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationRemoveFromParent")],-1)),e[3410]||(e[3410]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3412]||(e[3412]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationRemoveFromParent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Removes the given operation from its parent block. The operation is not destroyed. The ownership of the operation is transferred to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3411]||(e[3411]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1295-L1299",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Kh,[t("summary",null,[e[3413]||(e[3413]=t("a",{id:"Reactant.MLIR.API.mlirOperationSetAttributeByName-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOperationSetAttributeByName-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationSetAttributeByName")],-1)),e[3414]||(e[3414]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3416]||(e[3416]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name, attr)</span></span></code></pre></div><p>Sets an attribute by name, replacing the existing if it exists or adding a new one otherwise. Deprecated, please use <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationSetInherentAttributeByName-Tuple{Any, Any, Any}"><code>mlirOperationSetInherentAttributeByName</code></a> or <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationSetDiscardableAttributeByName-Tuple{Any, Any, Any}"><code>mlirOperationSetDiscardableAttributeByName</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3415]||(e[3415]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1625-L1629",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$h,[t("summary",null,[e[3417]||(e[3417]=t("a",{id:"Reactant.MLIR.API.mlirOperationSetDiscardableAttributeByName-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOperationSetDiscardableAttributeByName-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationSetDiscardableAttributeByName")],-1)),e[3418]||(e[3418]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3420]||(e[3420]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetDiscardableAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name, attr)</span></span></code></pre></div><p>Sets a discardable attribute by name, replacing the existing if it exists or adding a new one otherwise. The new <code>attr</code> Attribute is not allowed to be null, use <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationRemoveDiscardableAttributeByName-Tuple{Any, Any}"><code>mlirOperationRemoveDiscardableAttributeByName</code></a> to remove an Attribute instead.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3419]||(e[3419]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1572-L1576",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xh,[t("summary",null,[e[3421]||(e[3421]=t("a",{id:"Reactant.MLIR.API.mlirOperationSetInherentAttributeByName-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOperationSetInherentAttributeByName-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationSetInherentAttributeByName")],-1)),e[3422]||(e[3422]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3424]||(e[3424]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetInherentAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name, attr)</span></span></code></pre></div><p>Sets an inherent attribute by name, replacing the existing if it exists. This has no effect if &quot;name&quot; does not match an inherent attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3423]||(e[3423]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1530-L1534",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yh,[t("summary",null,[e[3425]||(e[3425]=t("a",{id:"Reactant.MLIR.API.mlirOperationSetLocation-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationSetLocation-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationSetLocation")],-1)),e[3426]||(e[3426]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3428]||(e[3428]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetLocation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, loc)</span></span></code></pre></div><p>Sets the location of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3427]||(e[3427]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1349-L1353",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ey,[t("summary",null,[e[3429]||(e[3429]=t("a",{id:"Reactant.MLIR.API.mlirOperationSetOperand-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOperationSetOperand-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationSetOperand")],-1)),e[3430]||(e[3430]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3432]||(e[3432]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetOperand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos, newValue)</span></span></code></pre></div><p>Sets the <code>pos</code>-th operand of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3431]||(e[3431]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1439-L1443",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ty,[t("summary",null,[e[3433]||(e[3433]=t("a",{id:"Reactant.MLIR.API.mlirOperationSetOperands-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOperationSetOperands-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationSetOperands")],-1)),e[3434]||(e[3434]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3436]||(e[3436]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetOperands</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, nOperands, operands)</span></span></code></pre></div><p>Replaces the operands of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3435]||(e[3435]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1450-L1454",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sy,[t("summary",null,[e[3437]||(e[3437]=t("a",{id:"Reactant.MLIR.API.mlirOperationSetSuccessor-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOperationSetSuccessor-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationSetSuccessor")],-1)),e[3438]||(e[3438]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3440]||(e[3440]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetSuccessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos, block)</span></span></code></pre></div><p>Set <code>pos</code>-th successor of the operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3439]||(e[3439]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1497-L1501",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ay,[t("summary",null,[e[3441]||(e[3441]=t("a",{id:"Reactant.MLIR.API.mlirOperationStateAddResults-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOperationStateAddResults-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationStateAddResults")],-1)),e[3442]||(e[3442]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3444]||(e[3444]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationStateAddResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state, n, results)</span></span></code></pre></div><p>Adds a list of components to the operation state.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3443]||(e[3443]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1051-L1055",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",iy,[t("summary",null,[e[3445]||(e[3445]=t("a",{id:"Reactant.MLIR.API.mlirOperationStateEnableResultTypeInference-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationStateEnableResultTypeInference-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationStateEnableResultTypeInference")],-1)),e[3446]||(e[3446]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3448]||(e[3448]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationStateEnableResultTypeInference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state)</span></span></code></pre></div><p>Enables result type inference for the operation under construction. If enabled, then the caller must not have called <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationStateAddResults-Tuple{Any, Any, Any}"><code>mlirOperationStateAddResults</code></a>(). Note that if enabled, the <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationCreate-Tuple{Any}"><code>mlirOperationCreate</code></a>() call is failable: it will return a null operation on inference failure and will emit diagnostics.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3447]||(e[3447]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1086-L1090",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ly,[t("summary",null,[e[3449]||(e[3449]=t("a",{id:"Reactant.MLIR.API.mlirOperationStateGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirOperationStateGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationStateGet")],-1)),e[3450]||(e[3450]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3452]||(e[3452]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationStateGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name, loc)</span></span></code></pre></div><p>Constructs an operation state from a name and a location.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3451]||(e[3451]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1040-L1044",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ny,[t("summary",null,[e[3453]||(e[3453]=t("a",{id:"Reactant.MLIR.API.mlirOperationVerify-Tuple{Any}",href:"#Reactant.MLIR.API.mlirOperationVerify-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationVerify")],-1)),e[3454]||(e[3454]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3456]||(e[3456]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationVerify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Verify the operation and return true if it passes, false if it fails.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3455]||(e[3455]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1720-L1724",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ry,[t("summary",null,[e[3457]||(e[3457]=t("a",{id:"Reactant.MLIR.API.mlirOperationWalk-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirOperationWalk-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationWalk")],-1)),e[3458]||(e[3458]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3460]||(e[3460]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationWalk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, callback, userData, walkOrder)</span></span></code></pre></div><p>Walks operation <code>op</code> in <code>walkOrder</code> and calls <code>callback</code> on that operation. <code>*userData</code> is passed to the callback as well and can be used to tunnel some context or other data into the callback.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3459]||(e[3459]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1785-L1789",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",oy,[t("summary",null,[e[3461]||(e[3461]=t("a",{id:"Reactant.MLIR.API.mlirOperationWriteBytecode-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirOperationWriteBytecode-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationWriteBytecode")],-1)),e[3462]||(e[3462]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3464]||(e[3464]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationWriteBytecode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, callback, userData)</span></span></code></pre></div><p>Same as <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationPrint-Tuple{Any, Any, Any}"><code>mlirOperationPrint</code></a> but writing the bytecode format.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3463]||(e[3463]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1686-L1690",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",py,[t("summary",null,[e[3465]||(e[3465]=t("a",{id:"Reactant.MLIR.API.mlirOperationWriteBytecodeWithConfig-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirOperationWriteBytecodeWithConfig-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirOperationWriteBytecodeWithConfig")],-1)),e[3466]||(e[3466]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3468]||(e[3468]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationWriteBytecodeWithConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, config, callback, userData)</span></span></code></pre></div><p>Same as <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirOperationWriteBytecode-Tuple{Any, Any, Any}"><code>mlirOperationWriteBytecode</code></a> but with writer config and returns failure only if desired bytecode could not be honored.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3467]||(e[3467]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1697-L1701",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dy,[t("summary",null,[e[3469]||(e[3469]=t("a",{id:"Reactant.MLIR.API.mlirParsePassPipeline-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirParsePassPipeline-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirParsePassPipeline")],-1)),e[3470]||(e[3470]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3472]||(e[3472]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirParsePassPipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, pipeline, callback, userData)</span></span></code></pre></div><p>Parse a textual MLIR pass pipeline and assign it to the provided OpPassManager. If parsing fails an error message is reported using the provided callback.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3471]||(e[3471]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9093-L9097",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",uy,[t("summary",null,[e[3473]||(e[3473]=t("a",{id:"Reactant.MLIR.API.mlirPassManagerAddOwnedPass-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirPassManagerAddOwnedPass-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPassManagerAddOwnedPass")],-1)),e[3474]||(e[3474]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3476]||(e[3476]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerAddOwnedPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, pass)</span></span></code></pre></div><p>Add a pass and transfer ownership to the provided top-level mlirPassManager. If the pass is not a generic operation pass or a ModulePass, a new OpPassManager is implicitly nested under the provided PassManager.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3475]||(e[3475]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9046-L9050",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",by,[t("summary",null,[e[3477]||(e[3477]=t("a",{id:"Reactant.MLIR.API.mlirPassManagerCreate-Tuple{Any}",href:"#Reactant.MLIR.API.mlirPassManagerCreate-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPassManagerCreate")],-1)),e[3478]||(e[3478]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3480]||(e[3480]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Create a new top-level PassManager with the default anchor.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3479]||(e[3479]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8896-L8900",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cy,[t("summary",null,[e[3481]||(e[3481]=t("a",{id:"Reactant.MLIR.API.mlirPassManagerCreateOnOperation-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirPassManagerCreateOnOperation-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPassManagerCreateOnOperation")],-1)),e[3482]||(e[3482]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3484]||(e[3484]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerCreateOnOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, anchorOp)</span></span></code></pre></div><p>Create a new top-level PassManager anchored on <code>anchorOp</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3483]||(e[3483]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8905-L8909",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hy,[t("summary",null,[e[3485]||(e[3485]=t("a",{id:"Reactant.MLIR.API.mlirPassManagerDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirPassManagerDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPassManagerDestroy")],-1)),e[3486]||(e[3486]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3488]||(e[3488]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager)</span></span></code></pre></div><p>Destroy the provided PassManager.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3487]||(e[3487]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8916-L8920",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yy,[t("summary",null,[e[3489]||(e[3489]=t("a",{id:"Reactant.MLIR.API.mlirPassManagerEnableIRPrinting-NTuple{8, Any}",href:"#Reactant.MLIR.API.mlirPassManagerEnableIRPrinting-NTuple{8, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPassManagerEnableIRPrinting")],-1)),e[3490]||(e[3490]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3492]||(e[3492]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerEnableIRPrinting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, printBeforeAll, printAfterAll, printModuleScope, printAfterOnlyOnChange, printAfterOnlyOnFailure, flags, treePrintingPath)</span></span></code></pre></div><p>Enable IR printing. The treePrintingPath argument is an optional path to a directory where the dumps will be produced. If it isn&#39;t provided then dumps are produced to stderr.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3491]||(e[3491]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8956-L8960",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gy,[t("summary",null,[e[3493]||(e[3493]=t("a",{id:"Reactant.MLIR.API.mlirPassManagerEnableStatistics-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirPassManagerEnableStatistics-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPassManagerEnableStatistics")],-1)),e[3494]||(e[3494]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3496]||(e[3496]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerEnableStatistics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, displayMode)</span></span></code></pre></div><p>Enable pass statistics.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3495]||(e[3495]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9013-L9017",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",my,[t("summary",null,[e[3497]||(e[3497]=t("a",{id:"Reactant.MLIR.API.mlirPassManagerEnableTiming-Tuple{Any}",href:"#Reactant.MLIR.API.mlirPassManagerEnableTiming-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPassManagerEnableTiming")],-1)),e[3498]||(e[3498]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3500]||(e[3500]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerEnableTiming</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager)</span></span></code></pre></div><p>Enable pass timing.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3499]||(e[3499]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8994-L8998",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ky,[t("summary",null,[e[3501]||(e[3501]=t("a",{id:"Reactant.MLIR.API.mlirPassManagerEnableVerifier-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirPassManagerEnableVerifier-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPassManagerEnableVerifier")],-1)),e[3502]||(e[3502]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3504]||(e[3504]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerEnableVerifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, enable)</span></span></code></pre></div><p>Enable / disable verify-each.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3503]||(e[3503]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8983-L8987",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ry,[t("summary",null,[e[3505]||(e[3505]=t("a",{id:"Reactant.MLIR.API.mlirPassManagerGetAsOpPassManager-Tuple{Any}",href:"#Reactant.MLIR.API.mlirPassManagerGetAsOpPassManager-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPassManagerGetAsOpPassManager")],-1)),e[3506]||(e[3506]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3508]||(e[3508]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerGetAsOpPassManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager)</span></span></code></pre></div><p>Cast a top-level PassManager to a generic OpPassManager.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3507]||(e[3507]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8934-L8938",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fy,[t("summary",null,[e[3509]||(e[3509]=t("a",{id:"Reactant.MLIR.API.mlirPassManagerGetNestedUnder-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirPassManagerGetNestedUnder-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPassManagerGetNestedUnder")],-1)),e[3510]||(e[3510]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3512]||(e[3512]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerGetNestedUnder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, operationName)</span></span></code></pre></div><p>Nest an OpPassManager under the top-level PassManager, the nested passmanager will only run on operations matching the provided name. The returned OpPassManager will be destroyed when the parent is destroyed. To further nest more OpPassManager under the newly returned one, see <code>mlirOpPassManagerNest</code> below.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3511]||(e[3511]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9024-L9028",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Iy,[t("summary",null,[e[3513]||(e[3513]=t("a",{id:"Reactant.MLIR.API.mlirPassManagerIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirPassManagerIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPassManagerIsNull")],-1)),e[3514]||(e[3514]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3516]||(e[3516]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager)</span></span></code></pre></div><p>Checks if a PassManager is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3515]||(e[3515]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8925-L8929",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ty,[t("summary",null,[e[3517]||(e[3517]=t("a",{id:"Reactant.MLIR.API.mlirPassManagerRunOnOp-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirPassManagerRunOnOp-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPassManagerRunOnOp")],-1)),e[3518]||(e[3518]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3520]||(e[3520]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerRunOnOp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, op)</span></span></code></pre></div><p>Run the provided <code>passManager</code> on the given <code>op</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3519]||(e[3519]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8945-L8949",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ay,[t("summary",null,[e[3521]||(e[3521]=t("a",{id:"Reactant.MLIR.API.mlirPatternRewriterAsBase-Tuple{Any}",href:"#Reactant.MLIR.API.mlirPatternRewriterAsBase-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPatternRewriterAsBase")],-1)),e[3522]||(e[3522]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3524]||(e[3524]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPatternRewriterAsBase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter)</span></span></code></pre></div><p>Cast the PatternRewriter to a RewriterBase</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3523]||(e[3523]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9681-L9685",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jy,[t("summary",null,[e[3525]||(e[3525]=t("a",{id:"Reactant.MLIR.API.mlirPrintPassPipeline-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirPrintPassPipeline-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirPrintPassPipeline")],-1)),e[3526]||(e[3526]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3528]||(e[3528]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPrintPassPipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, callback, userData)</span></span></code></pre></div><p>Print a textual MLIR pass pipeline by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3527]||(e[3527]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9082-L9086",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_y,[t("summary",null,[e[3529]||(e[3529]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeCastExpressedToStorageType-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeCastExpressedToStorageType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeCastExpressedToStorageType")],-1)),e[3530]||(e[3530]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3532]||(e[3532]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeCastExpressedToStorageType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, candidate)</span></span></code></pre></div><p>Casts from a type based on the expressed type of the given quantized type to equivalent type based on storage type of the same quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3531]||(e[3531]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7781-L7785",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",My,[t("summary",null,[e[3533]||(e[3533]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeCastFromExpressedType-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeCastFromExpressedType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeCastFromExpressedType")],-1)),e[3534]||(e[3534]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3536]||(e[3536]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeCastFromExpressedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, candidate)</span></span></code></pre></div><p>Casts from a type based on the expressed type of the given type to a corresponding type based on the given type. Returns a null type if the cast is not valid.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3535]||(e[3535]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7761-L7765",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ey,[t("summary",null,[e[3537]||(e[3537]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeCastFromStorageType-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeCastFromStorageType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeCastFromStorageType")],-1)),e[3538]||(e[3538]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3540]||(e[3540]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeCastFromStorageType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, candidate)</span></span></code></pre></div><p>Casts from a type based on the storage type of the given type to a corresponding type based on the given type. Returns a null type if the cast is not valid.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3539]||(e[3539]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7741-L7745",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ly,[t("summary",null,[e[3541]||(e[3541]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeCastToExpressedType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeCastToExpressedType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeCastToExpressedType")],-1)),e[3542]||(e[3542]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3544]||(e[3544]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeCastToExpressedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Casts from a type based on a quantized type to a corresponding typed based on the expressed type. Returns a null type if the cast is not valid.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3543]||(e[3543]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7772-L7776",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Cy,[t("summary",null,[e[3545]||(e[3545]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeCastToStorageType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeCastToStorageType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeCastToStorageType")],-1)),e[3546]||(e[3546]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3548]||(e[3548]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeCastToStorageType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Casts from a type based on a quantized type to a corresponding typed based on the storage type. Returns a null type if the cast is not valid.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3547]||(e[3547]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7752-L7756",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vy,[t("summary",null,[e[3549]||(e[3549]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMaximumForInteger-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMaximumForInteger-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMaximumForInteger")],-1)),e[3550]||(e[3550]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3552]||(e[3552]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetDefaultMaximumForInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(isSigned, integralWidth)</span></span></code></pre></div><p>Returns the maximum possible value stored by a quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3551]||(e[3551]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7647-L7651",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Py,[t("summary",null,[e[3553]||(e[3553]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMinimumForInteger-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMinimumForInteger-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMinimumForInteger")],-1)),e[3554]||(e[3554]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3556]||(e[3556]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetDefaultMinimumForInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(isSigned, integralWidth)</span></span></code></pre></div><p>Returns the minimum possible value stored by a quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3555]||(e[3555]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7636-L7640",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xy,[t("summary",null,[e[3557]||(e[3557]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeGetExpressedType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeGetExpressedType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeGetExpressedType")],-1)),e[3558]||(e[3558]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3560]||(e[3560]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetExpressedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the original type approximated by the given quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3559]||(e[3559]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7658-L7662",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sy,[t("summary",null,[e[3561]||(e[3561]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeGetFlags-Tuple{Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeGetFlags-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeGetFlags")],-1)),e[3562]||(e[3562]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3564]||(e[3564]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetFlags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the flags associated with the given quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3563]||(e[3563]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7667-L7671",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Dy,[t("summary",null,[e[3565]||(e[3565]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeGetQuantizedElementType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeGetQuantizedElementType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeGetQuantizedElementType")],-1)),e[3566]||(e[3566]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3568]||(e[3568]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetQuantizedElementType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the element type of the given quantized type as another quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3567]||(e[3567]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7732-L7736",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fy,[t("summary",null,[e[3569]||(e[3569]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeGetSignedFlag-Tuple{}",href:"#Reactant.MLIR.API.mlirQuantizedTypeGetSignedFlag-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeGetSignedFlag")],-1)),e[3570]||(e[3570]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3572]||(e[3572]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetSignedFlag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the bit flag used to indicate signedness of a quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3571]||(e[3571]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7627-L7631",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vy,[t("summary",null,[e[3573]||(e[3573]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeGetStorageType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeGetStorageType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeGetStorageType")],-1)),e[3574]||(e[3574]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3576]||(e[3576]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetStorageType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the underlying type used to store the values.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3575]||(e[3575]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7685-L7689",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Oy,[t("summary",null,[e[3577]||(e[3577]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeIntegralWidth-Tuple{Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeIntegralWidth-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeIntegralWidth")],-1)),e[3578]||(e[3578]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3580]||(e[3580]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetStorageTypeIntegralWidth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the integral bitwidth that the storage type of the given quantized type can represent exactly.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3579]||(e[3579]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7712-L7716",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",By,[t("summary",null,[e[3581]||(e[3581]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMax-Tuple{Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMax-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMax")],-1)),e[3582]||(e[3582]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3584]||(e[3584]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetStorageTypeMax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the maximum value that the storage type of the given quantized type can take.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3583]||(e[3583]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7703-L7707",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ny,[t("summary",null,[e[3585]||(e[3585]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMin-Tuple{Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMin-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMin")],-1)),e[3586]||(e[3586]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3588]||(e[3588]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetStorageTypeMin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the minimum value that the storage type of the given quantized type can take.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3587]||(e[3587]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7694-L7698",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gy,[t("summary",null,[e[3589]||(e[3589]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeIsCompatibleExpressedType-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeIsCompatibleExpressedType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeIsCompatibleExpressedType")],-1)),e[3590]||(e[3590]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3592]||(e[3592]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeIsCompatibleExpressedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, candidate)</span></span></code></pre></div><p>Returns <code>true</code> if the <code>candidate</code> type is compatible with the given quantized <code>type</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3591]||(e[3591]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7721-L7725",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zy,[t("summary",null,[e[3593]||(e[3593]=t("a",{id:"Reactant.MLIR.API.mlirQuantizedTypeIsSigned-Tuple{Any}",href:"#Reactant.MLIR.API.mlirQuantizedTypeIsSigned-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirQuantizedTypeIsSigned")],-1)),e[3594]||(e[3594]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3596]||(e[3596]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeIsSigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is signed, <code>false</code> otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3595]||(e[3595]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7676-L7680",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wy,[t("summary",null,[e[3597]||(e[3597]=t("a",{id:"Reactant.MLIR.API.mlirRankedTensorTypeGet-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirRankedTensorTypeGet-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRankedTensorTypeGet")],-1)),e[3598]||(e[3598]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3600]||(e[3600]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRankedTensorTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rank, shape, elementType, encoding)</span></span></code></pre></div><p>Creates a tensor type of a fixed rank with the given shape, element type, and optional encoding in the same context as the element type. The type is owned by the context. Tensor types without any specific encoding field should assign <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirAttributeGetNull-Tuple{}"><code>mlirAttributeGetNull</code></a>() to this parameter.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3599]||(e[3599]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5829-L5833",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Uy,[t("summary",null,[e[3601]||(e[3601]=t("a",{id:"Reactant.MLIR.API.mlirRankedTensorTypeGetChecked-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirRankedTensorTypeGetChecked-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRankedTensorTypeGetChecked")],-1)),e[3602]||(e[3602]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3604]||(e[3604]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRankedTensorTypeGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, rank, shape, elementType, encoding)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirRankedTensorTypeGet-NTuple{4, Any}"><code>mlirRankedTensorTypeGet</code></a>&quot; but returns a nullptr wrapping <a href="./@ref"><code>MlirType</code></a> on illegal arguments, emitting appropriate diagnostics.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3603]||(e[3603]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5840-L5844",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qy,[t("summary",null,[e[3605]||(e[3605]=t("a",{id:"Reactant.MLIR.API.mlirRankedTensorTypeGetEncoding-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRankedTensorTypeGetEncoding-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRankedTensorTypeGetEncoding")],-1)),e[3606]||(e[3606]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3608]||(e[3608]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRankedTensorTypeGetEncoding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the &#39;encoding&#39; attribute from the ranked tensor type, returning a null attribute if none.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3607]||(e[3607]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5855-L5859",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qy,[t("summary",null,[e[3609]||(e[3609]=t("a",{id:"Reactant.MLIR.API.mlirRankedTensorTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirRankedTensorTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRankedTensorTypeGetTypeID")],-1)),e[3610]||(e[3610]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3612]||(e[3612]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRankedTensorTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an RankedTensor type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3611]||(e[3611]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5793-L5797",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wy,[t("summary",null,[e[3613]||(e[3613]=t("a",{id:"Reactant.MLIR.API.mlirRegionAppendOwnedBlock-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRegionAppendOwnedBlock-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegionAppendOwnedBlock")],-1)),e[3614]||(e[3614]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3616]||(e[3616]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionAppendOwnedBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, block)</span></span></code></pre></div><p>Takes a block owned by the caller and appends it to the given region.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3615]||(e[3615]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1844-L1848",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zy,[t("summary",null,[e[3617]||(e[3617]=t("a",{id:"Reactant.MLIR.API.mlirRegionCreate-Tuple{}",href:"#Reactant.MLIR.API.mlirRegionCreate-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegionCreate")],-1)),e[3618]||(e[3618]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3620]||(e[3620]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a new empty region and transfers ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3619]||(e[3619]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1799-L1803",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hy,[t("summary",null,[e[3621]||(e[3621]=t("a",{id:"Reactant.MLIR.API.mlirRegionDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRegionDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegionDestroy")],-1)),e[3622]||(e[3622]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3624]||(e[3624]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region)</span></span></code></pre></div><p>Takes a region owned by the caller and destroys it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3623]||(e[3623]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1808-L1812",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jy,[t("summary",null,[e[3625]||(e[3625]=t("a",{id:"Reactant.MLIR.API.mlirRegionEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRegionEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegionEqual")],-1)),e[3626]||(e[3626]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3628]||(e[3628]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, other)</span></span></code></pre></div><p>Checks whether two region handles point to the same region. This does not perform deep comparison.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3627]||(e[3627]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1826-L1830",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ky,[t("summary",null,[e[3629]||(e[3629]=t("a",{id:"Reactant.MLIR.API.mlirRegionGetFirstBlock-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRegionGetFirstBlock-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegionGetFirstBlock")],-1)),e[3630]||(e[3630]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3632]||(e[3632]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionGetFirstBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region)</span></span></code></pre></div><p>Gets the first block in the region.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3631]||(e[3631]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1835-L1839",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$y,[t("summary",null,[e[3633]||(e[3633]=t("a",{id:"Reactant.MLIR.API.mlirRegionGetNextInOperation-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRegionGetNextInOperation-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegionGetNextInOperation")],-1)),e[3634]||(e[3634]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3636]||(e[3636]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionGetNextInOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region)</span></span></code></pre></div><p>Returns the region immediately following the given region in its parent operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3635]||(e[3635]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1895-L1899",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xy,[t("summary",null,[e[3637]||(e[3637]=t("a",{id:"Reactant.MLIR.API.mlirRegionInsertOwnedBlock-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirRegionInsertOwnedBlock-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegionInsertOwnedBlock")],-1)),e[3638]||(e[3638]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3640]||(e[3640]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionInsertOwnedBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, pos, block)</span></span></code></pre></div><p>Takes a block owned by the caller and inserts it at <code>pos</code> to the given region. This is an expensive operation that linearly scans the region, prefer insertAfter/Before instead.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3639]||(e[3639]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1853-L1857",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yy,[t("summary",null,[e[3641]||(e[3641]=t("a",{id:"Reactant.MLIR.API.mlirRegionInsertOwnedBlockAfter-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirRegionInsertOwnedBlockAfter-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegionInsertOwnedBlockAfter")],-1)),e[3642]||(e[3642]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3644]||(e[3644]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionInsertOwnedBlockAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, reference, block)</span></span></code></pre></div><p>Takes a block owned by the caller and inserts it after the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, prepends the block to the region.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3643]||(e[3643]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1864-L1868",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",eg,[t("summary",null,[e[3645]||(e[3645]=t("a",{id:"Reactant.MLIR.API.mlirRegionInsertOwnedBlockBefore-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirRegionInsertOwnedBlockBefore-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegionInsertOwnedBlockBefore")],-1)),e[3646]||(e[3646]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3648]||(e[3648]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionInsertOwnedBlockBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, reference, block)</span></span></code></pre></div><p>Takes a block owned by the caller and inserts it before the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, appends the block to the region.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3647]||(e[3647]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1875-L1879",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",tg,[t("summary",null,[e[3649]||(e[3649]=t("a",{id:"Reactant.MLIR.API.mlirRegionIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRegionIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegionIsNull")],-1)),e[3650]||(e[3650]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3652]||(e[3652]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region)</span></span></code></pre></div><p>Checks whether a region is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3651]||(e[3651]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1817-L1821",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sg,[t("summary",null,[e[3653]||(e[3653]=t("a",{id:"Reactant.MLIR.API.mlirRegionTakeBody-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRegionTakeBody-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegionTakeBody")],-1)),e[3654]||(e[3654]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3656]||(e[3656]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionTakeBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, source)</span></span></code></pre></div><p>Moves the entire content of the source region to the target region.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3655]||(e[3655]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L1904-L1908",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ag,[t("summary",null,[e[3657]||(e[3657]=t("a",{id:"Reactant.MLIR.API.mlirRegisterAllDialects-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRegisterAllDialects-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegisterAllDialects")],-1)),e[3658]||(e[3658]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3660]||(e[3660]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegisterAllDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(registry)</span></span></code></pre></div><p>Appends all upstream dialects and extensions to the dialect registry.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3659]||(e[3659]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9166-L9170",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ig,[t("summary",null,[e[3661]||(e[3661]=t("a",{id:"Reactant.MLIR.API.mlirRegisterAllLLVMTranslations-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRegisterAllLLVMTranslations-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegisterAllLLVMTranslations")],-1)),e[3662]||(e[3662]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3664]||(e[3664]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegisterAllLLVMTranslations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Register all translations to LLVM IR for dialects that can support it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3663]||(e[3663]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9175-L9179",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",lg,[t("summary",null,[e[3665]||(e[3665]=t("a",{id:"Reactant.MLIR.API.mlirRegisterAllPasses-Tuple{}",href:"#Reactant.MLIR.API.mlirRegisterAllPasses-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRegisterAllPasses")],-1)),e[3666]||(e[3666]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3668]||(e[3668]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegisterAllPasses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Register all compiler passes of MLIR.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3667]||(e[3667]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9184-L9188",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ng,[t("summary",null,[e[3669]||(e[3669]=t("a",{id:"Reactant.MLIR.API.mlirRewritePatternSetAdd-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewritePatternSetAdd-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewritePatternSetAdd")],-1)),e[3670]||(e[3670]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3672]||(e[3672]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewritePatternSetAdd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, pattern)</span></span></code></pre></div><p>Add the given <a href="./@ref"><code>MlirRewritePattern</code></a> into a <a href="./@ref"><code>MlirRewritePatternSet</code></a>. Note that the ownership of the pattern is transferred to the set after this call.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3671]||(e[3671]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9744-L9748",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rg,[t("summary",null,[e[3673]||(e[3673]=t("a",{id:"Reactant.MLIR.API.mlirRewritePatternSetCreate-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRewritePatternSetCreate-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewritePatternSetCreate")],-1)),e[3674]||(e[3674]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3676]||(e[3676]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewritePatternSetCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Create an empty <a href="./@ref"><code>MlirRewritePatternSet</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3675]||(e[3675]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9726-L9730",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",og,[t("summary",null,[e[3677]||(e[3677]=t("a",{id:"Reactant.MLIR.API.mlirRewritePatternSetDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRewritePatternSetDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewritePatternSetDestroy")],-1)),e[3678]||(e[3678]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3680]||(e[3680]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewritePatternSetDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Destruct the given <a href="./@ref"><code>MlirRewritePatternSet</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3679]||(e[3679]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9735-L9739",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pg,[t("summary",null,[e[3681]||(e[3681]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseCancelOpModification-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseCancelOpModification-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseCancelOpModification")],-1)),e[3682]||(e[3682]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3684]||(e[3684]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseCancelOpModification</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>This method cancels a pending in-place modification. This can only be called on operations that were provided to a call to <code>startOpModification</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3683]||(e[3683]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9527-L9531",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dg,[t("summary",null,[e[3685]||(e[3685]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseClearInsertionPoint-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseClearInsertionPoint-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseClearInsertionPoint")],-1)),e[3686]||(e[3686]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3688]||(e[3688]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseClearInsertionPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter)</span></span></code></pre></div><p>Reset the insertion point to no location. Creating an operation without a set insertion point is an error, but this can still be useful when the current insertion point a builder refers to is being removed.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3687]||(e[3687]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9226-L9230",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ug,[t("summary",null,[e[3689]||(e[3689]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseClone-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseClone-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseClone")],-1)),e[3690]||(e[3690]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3692]||(e[3692]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseClone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>Creates a deep copy of the specified operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3691]||(e[3691]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9347-L9351",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bg,[t("summary",null,[e[3693]||(e[3693]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseCloneRegionBefore-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseCloneRegionBefore-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseCloneRegionBefore")],-1)),e[3694]||(e[3694]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3696]||(e[3696]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseCloneRegionBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, region, before)</span></span></code></pre></div><p>Clone the blocks that belong to &quot;region&quot; before the given position in another region &quot;parent&quot;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3695]||(e[3695]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9369-L9373",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cg,[t("summary",null,[e[3697]||(e[3697]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseCloneWithoutRegions-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseCloneWithoutRegions-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseCloneWithoutRegions")],-1)),e[3698]||(e[3698]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3700]||(e[3700]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseCloneWithoutRegions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>Creates a deep copy of this operation but keep the operation regions empty.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3699]||(e[3699]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9358-L9362",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hg,[t("summary",null,[e[3701]||(e[3701]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseCreateBlockBefore-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseCreateBlockBefore-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseCreateBlockBefore")],-1)),e[3702]||(e[3702]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3704]||(e[3704]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseCreateBlockBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, insertBefore, nArgTypes, argTypes, locations)</span></span></code></pre></div><p>Add new block with &#39;argTypes&#39; arguments and set the insertion point to the end of it. The block is placed before &#39;insertBefore&#39;. <code>locs</code> contains the locations of the inserted arguments, and should match the size of <code>argTypes</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3703]||(e[3703]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9319-L9323",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yg,[t("summary",null,[e[3705]||(e[3705]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseEraseBlock-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseEraseBlock-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseEraseBlock")],-1)),e[3706]||(e[3706]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3708]||(e[3708]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseEraseBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, block)</span></span></code></pre></div><p>Erases a block along with all operations inside it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3707]||(e[3707]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9427-L9431",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gg,[t("summary",null,[e[3709]||(e[3709]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseEraseOp-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseEraseOp-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseEraseOp")],-1)),e[3710]||(e[3710]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3712]||(e[3712]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseEraseOp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>Erases an operation that is known to have no uses.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3711]||(e[3711]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9416-L9420",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mg,[t("summary",null,[e[3713]||(e[3713]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseFinalizeOpModification-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseFinalizeOpModification-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseFinalizeOpModification")],-1)),e[3714]||(e[3714]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3716]||(e[3716]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseFinalizeOpModification</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>This method is used to signal the end of an in-place modification of the given operation. This can only be called on operations that were provided to a call to <code>startOpModification</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3715]||(e[3715]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9516-L9520",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",kg,[t("summary",null,[e[3717]||(e[3717]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseGetBlock-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseGetBlock-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseGetBlock")],-1)),e[3718]||(e[3718]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3720]||(e[3720]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseGetBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter)</span></span></code></pre></div><p>Returns the current block of the rewriter.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3719]||(e[3719]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9299-L9303",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rg,[t("summary",null,[e[3721]||(e[3721]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseGetContext-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseGetContext-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseGetContext")],-1)),e[3722]||(e[3722]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3724]||(e[3724]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter)</span></span></code></pre></div><p>Get the MLIR context referenced by the rewriter.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3723]||(e[3723]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9217-L9221",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fg,[t("summary",null,[e[3725]||(e[3725]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseGetInsertionBlock-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseGetInsertionBlock-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseGetInsertionBlock")],-1)),e[3726]||(e[3726]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3728]||(e[3728]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseGetInsertionBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter)</span></span></code></pre></div><p>Return the block the current insertion point belongs to. Note that the insertion point is not necessarily the end of the block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3727]||(e[3727]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9290-L9294",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ig,[t("summary",null,[e[3729]||(e[3729]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseGetOperationAfterInsertion-Tuple{Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseGetOperationAfterInsertion-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseGetOperationAfterInsertion")],-1)),e[3730]||(e[3730]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3732]||(e[3732]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseGetOperationAfterInsertion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter)</span></span></code></pre></div><p>Returns the operation right after the current insertion point of the rewriter. A null <a href="./@ref"><code>MlirOperation</code></a> will be returned</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3731]||(e[3731]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9308-L9312",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Tg,[t("summary",null,[e[3733]||(e[3733]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseInlineBlockBefore-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseInlineBlockBefore-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseInlineBlockBefore")],-1)),e[3734]||(e[3734]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3736]||(e[3736]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseInlineBlockBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, source, op, nArgValues, argValues)</span></span></code></pre></div><p>Inline the operations of block &#39;source&#39; before the operation &#39;op&#39;. The source block will be deleted and must have no uses. &#39;argValues&#39; is used to replace the block arguments of &#39;source&#39;</p><p>The source block must have no successors. Otherwise, the resulting IR would have unreachable operations.</p>',3)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3735]||(e[3735]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9438-L9444",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ag,[t("summary",null,[e[3737]||(e[3737]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseInlineRegionBefore-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseInlineRegionBefore-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseInlineRegionBefore")],-1)),e[3738]||(e[3738]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3740]||(e[3740]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseInlineRegionBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, region, before)</span></span></code></pre></div><p>Move the blocks that belong to &quot;region&quot; before the given position in another region &quot;parent&quot;. The two regions must be different. The caller is responsible for creating or updating the operation transferring flow of control to the region and passing it the correct block arguments.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3739]||(e[3739]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9380-L9384",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jg,[t("summary",null,[e[3741]||(e[3741]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseInsert-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseInsert-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseInsert")],-1)),e[3742]||(e[3742]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3744]||(e[3744]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseInsert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>Insert the given operation at the current insertion point and return it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3743]||(e[3743]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9336-L9340",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_g,[t("summary",null,[e[3745]||(e[3745]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseMergeBlocks-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseMergeBlocks-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseMergeBlocks")],-1)),e[3746]||(e[3746]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3748]||(e[3748]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseMergeBlocks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, source, dest, nArgValues, argValues)</span></span></code></pre></div><p>Inline the operations of block &#39;source&#39; into the end of block &#39;dest&#39;. The source block will be deleted and must have no uses. &#39;argValues&#39; is used to replace the block arguments of &#39;source&#39;</p><p>The dest block must have no successors. Otherwise, the resulting IR would have unreachable operation.</p>',3)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3747]||(e[3747]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9455-L9461",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mg,[t("summary",null,[e[3749]||(e[3749]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseMoveBlockBefore-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseMoveBlockBefore-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseMoveBlockBefore")],-1)),e[3750]||(e[3750]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3752]||(e[3752]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseMoveBlockBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, block, existingBlock)</span></span></code></pre></div><p>Unlink this block and insert it right before <code>existingBlock</code>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3751]||(e[3751]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9494-L9498",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Eg,[t("summary",null,[e[3753]||(e[3753]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseMoveOpAfter-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseMoveOpAfter-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseMoveOpAfter")],-1)),e[3754]||(e[3754]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3756]||(e[3756]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseMoveOpAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op, existingOp)</span></span></code></pre></div><p>Unlink this operation from its current block and insert it right after <code>existingOp</code> which may be in the same or another block in the same function.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3755]||(e[3755]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9483-L9487",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Lg,[t("summary",null,[e[3757]||(e[3757]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseMoveOpBefore-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseMoveOpBefore-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseMoveOpBefore")],-1)),e[3758]||(e[3758]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3760]||(e[3760]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseMoveOpBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op, existingOp)</span></span></code></pre></div><p>Unlink this operation from its current block and insert it right before <code>existingOp</code> which may be in the same or another block in the same function.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3759]||(e[3759]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9472-L9476",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Cg,[t("summary",null,[e[3761]||(e[3761]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseReplaceAllOpUsesWithOperation-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseReplaceAllOpUsesWithOperation-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseReplaceAllOpUsesWithOperation")],-1)),e[3762]||(e[3762]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3764]||(e[3764]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceAllOpUsesWithOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, from, to)</span></span></code></pre></div><p>Find uses of <code>from</code> and replace them with <code>to</code>. Also notify the listener about every in-place op modification (for every use that was replaced) and that the <code>from</code> operation is about to be replaced.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3763]||(e[3763]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9574-L9578",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vg,[t("summary",null,[e[3765]||(e[3765]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseReplaceAllOpUsesWithValueRange-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseReplaceAllOpUsesWithValueRange-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseReplaceAllOpUsesWithValueRange")],-1)),e[3766]||(e[3766]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3768]||(e[3768]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceAllOpUsesWithValueRange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, from, nTo, to)</span></span></code></pre></div><p>Find uses of <code>from</code> and replace them with <code>to</code>. Also notify the listener about every in-place op modification (for every use that was replaced) and that the <code>from</code> operation is about to be replaced.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3767]||(e[3767]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9563-L9567",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pg,[t("summary",null,[e[3769]||(e[3769]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseReplaceAllUsesExcept-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseReplaceAllUsesExcept-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseReplaceAllUsesExcept")],-1)),e[3770]||(e[3770]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3772]||(e[3772]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceAllUsesExcept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, from, to, exceptedUser)</span></span></code></pre></div><p>Find uses of <code>from</code> and replace them with <code>to</code> except if the user is <code>exceptedUser</code>. Also notify the listener about every in-place op modification (for every use that was replaced).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3771]||(e[3771]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9602-L9606",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xg,[t("summary",null,[e[3773]||(e[3773]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseReplaceAllUsesWith-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseReplaceAllUsesWith-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseReplaceAllUsesWith")],-1)),e[3774]||(e[3774]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3776]||(e[3776]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceAllUsesWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, from, to)</span></span></code></pre></div><p>Find uses of <code>from</code> and replace them with <code>to</code>. Also notify the listener about every in-place op modification (for every use that was replaced).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3775]||(e[3775]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9538-L9542",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sg,[t("summary",null,[e[3777]||(e[3777]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseReplaceAllValueRangeUsesWith-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseReplaceAllValueRangeUsesWith-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseReplaceAllValueRangeUsesWith")],-1)),e[3778]||(e[3778]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3780]||(e[3780]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceAllValueRangeUsesWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, nValues, from, to)</span></span></code></pre></div><p>Find uses of <code>from</code> and replace them with <code>to</code>. Also notify the listener about every in-place op modification (for every use that was replaced).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3779]||(e[3779]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9549-L9553",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Dg,[t("summary",null,[e[3781]||(e[3781]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseReplaceOpUsesWithinBlock-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseReplaceOpUsesWithinBlock-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseReplaceOpUsesWithinBlock")],-1)),e[3782]||(e[3782]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3784]||(e[3784]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceOpUsesWithinBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op, nNewValues, newValues, block)</span></span></code></pre></div><p>Find uses of <code>from</code> within <code>block</code> and replace them with <code>to</code>. Also notify the listener about every in-place op modification (for every use that was replaced). The optional <code>allUsesReplaced</code> flag is set to &quot;true&quot; if all uses were replaced.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3783]||(e[3783]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9585-L9589",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fg,[t("summary",null,[e[3785]||(e[3785]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseReplaceOpWithOperation-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseReplaceOpWithOperation-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseReplaceOpWithOperation")],-1)),e[3786]||(e[3786]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3788]||(e[3788]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceOpWithOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op, newOp)</span></span></code></pre></div><p>Replace the results of the given (original) operation with the specified new op (replacement). The result types of the two ops must match. The original op is erased.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3787]||(e[3787]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9405-L9409",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vg,[t("summary",null,[e[3789]||(e[3789]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseReplaceOpWithValues-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseReplaceOpWithValues-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseReplaceOpWithValues")],-1)),e[3790]||(e[3790]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3792]||(e[3792]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceOpWithValues</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op, nValues, values)</span></span></code></pre></div><p>Replace the results of the given (original) operation with the specified list of values (replacements). The result types of the given op and the replacements must match. The original op is erased.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3791]||(e[3791]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9391-L9395",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Og,[t("summary",null,[e[3793]||(e[3793]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointAfter-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointAfter-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointAfter")],-1)),e[3794]||(e[3794]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3796]||(e[3796]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseSetInsertionPointAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>Sets the insertion point to the node after the specified operation, which will cause subsequent insertions to go right after it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3795]||(e[3795]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9246-L9250",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bg,[t("summary",null,[e[3797]||(e[3797]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointAfterValue-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointAfterValue-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointAfterValue")],-1)),e[3798]||(e[3798]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3800]||(e[3800]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseSetInsertionPointAfterValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, value)</span></span></code></pre></div><p>Sets the insertion point to the node after the specified value. If value has a defining operation, sets the insertion point to the node after such defining operation. This will cause subsequent insertions to go right after it. Otherwise, value is a BlockArgument. Sets the insertion point to the start of its block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3799]||(e[3799]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9257-L9261",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ng,[t("summary",null,[e[3801]||(e[3801]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointBefore-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointBefore-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointBefore")],-1)),e[3802]||(e[3802]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3804]||(e[3804]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseSetInsertionPointBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>Sets the insertion point to the specified operation, which will cause subsequent insertions to go right before it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3803]||(e[3803]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9235-L9239",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gg,[t("summary",null,[e[3805]||(e[3805]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointToEnd-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointToEnd-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointToEnd")],-1)),e[3806]||(e[3806]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3808]||(e[3808]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseSetInsertionPointToEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, block)</span></span></code></pre></div><p>Sets the insertion point to the end of the specified block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3807]||(e[3807]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9279-L9283",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zg,[t("summary",null,[e[3809]||(e[3809]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointToStart-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointToStart-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointToStart")],-1)),e[3810]||(e[3810]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3812]||(e[3812]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseSetInsertionPointToStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, block)</span></span></code></pre></div><p>Sets the insertion point to the start of the specified block.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3811]||(e[3811]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9268-L9272",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wg,[t("summary",null,[e[3813]||(e[3813]=t("a",{id:"Reactant.MLIR.API.mlirRewriterBaseStartOpModification-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirRewriterBaseStartOpModification-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirRewriterBaseStartOpModification")],-1)),e[3814]||(e[3814]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3816]||(e[3816]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseStartOpModification</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>This method is used to notify the rewriter that an in-place operation modification is about to happen. A call to this function <em>must</em> be followed by a call to either <code>finalizeOpModification</code> or <code>cancelOpModification</code>. This is a minor efficiency win (it avoids creating a new operation and removing the old one) but also often allows simpler code in the client.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3815]||(e[3815]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9505-L9509",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ug,[t("summary",null,[e[3817]||(e[3817]=t("a",{id:"Reactant.MLIR.API.mlirSMTAttrCheckBVCmpPredicate-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirSMTAttrCheckBVCmpPredicate-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTAttrCheckBVCmpPredicate")],-1)),e[3818]||(e[3818]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3820]||(e[3820]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTAttrCheckBVCmpPredicate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, str)</span></span></code></pre></div><p>Checks if the given string is a valid smt::BVCmpPredicate.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3819]||(e[3819]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8245-L8249",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qg,[t("summary",null,[e[3821]||(e[3821]=t("a",{id:"Reactant.MLIR.API.mlirSMTAttrCheckIntPredicate-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirSMTAttrCheckIntPredicate-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTAttrCheckIntPredicate")],-1)),e[3822]||(e[3822]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3824]||(e[3824]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTAttrCheckIntPredicate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, str)</span></span></code></pre></div><p>Checks if the given string is a valid smt::IntPredicate.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3823]||(e[3823]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8254-L8258",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qg,[t("summary",null,[e[3825]||(e[3825]=t("a",{id:"Reactant.MLIR.API.mlirSMTAttrGetBVCmpPredicate-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirSMTAttrGetBVCmpPredicate-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTAttrGetBVCmpPredicate")],-1)),e[3826]||(e[3826]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3828]||(e[3828]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTAttrGetBVCmpPredicate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, str)</span></span></code></pre></div><p>Creates a smt::BVCmpPredicateAttr with the given string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3827]||(e[3827]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8283-L8287",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wg,[t("summary",null,[e[3829]||(e[3829]=t("a",{id:"Reactant.MLIR.API.mlirSMTAttrGetBitVector-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirSMTAttrGetBitVector-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTAttrGetBitVector")],-1)),e[3830]||(e[3830]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3832]||(e[3832]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTAttrGetBitVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, value, width)</span></span></code></pre></div><p>Creates a smt::BitVectorAttr with the given value and width.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3831]||(e[3831]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8272-L8276",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zg,[t("summary",null,[e[3833]||(e[3833]=t("a",{id:"Reactant.MLIR.API.mlirSMTAttrGetIntPredicate-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirSMTAttrGetIntPredicate-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTAttrGetIntPredicate")],-1)),e[3834]||(e[3834]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3836]||(e[3836]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTAttrGetIntPredicate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, str)</span></span></code></pre></div><p>Creates a smt::IntPredicateAttr with the given string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3835]||(e[3835]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8294-L8298",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hg,[t("summary",null,[e[3837]||(e[3837]=t("a",{id:"Reactant.MLIR.API.mlirSMTAttrIsASMTAttribute-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSMTAttrIsASMTAttribute-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTAttrIsASMTAttribute")],-1)),e[3838]||(e[3838]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3840]||(e[3840]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTAttrIsASMTAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks if the given attribute is a smt::SMTAttribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3839]||(e[3839]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8263-L8267",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jg,[t("summary",null,[e[3841]||(e[3841]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeGetArray-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirSMTTypeGetArray-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeGetArray")],-1)),e[3842]||(e[3842]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3844]||(e[3844]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeGetArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, domainType, rangeType)</span></span></code></pre></div><p>Creates an array type with the given domain and range types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3843]||(e[3843]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8134-L8138",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Kg,[t("summary",null,[e[3845]||(e[3845]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeGetBitVector-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirSMTTypeGetBitVector-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeGetBitVector")],-1)),e[3846]||(e[3846]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3848]||(e[3848]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeGetBitVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, width)</span></span></code></pre></div><p>Creates a smt::BitVectorType with the given width.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3847]||(e[3847]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8154-L8158",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$g,[t("summary",null,[e[3849]||(e[3849]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeGetBool-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSMTTypeGetBool-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeGetBool")],-1)),e[3850]||(e[3850]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3852]||(e[3852]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeGetBool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a smt::BoolType.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3851]||(e[3851]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8172-L8176",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xg,[t("summary",null,[e[3853]||(e[3853]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeGetInt-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSMTTypeGetInt-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeGetInt")],-1)),e[3854]||(e[3854]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3856]||(e[3856]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeGetInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a smt::IntType.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3855]||(e[3855]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8190-L8194",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yg,[t("summary",null,[e[3857]||(e[3857]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeGetSMTFunc-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirSMTTypeGetSMTFunc-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeGetSMTFunc")],-1)),e[3858]||(e[3858]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3860]||(e[3860]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeGetSMTFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, numberOfDomainTypes, domainTypes, rangeType)</span></span></code></pre></div><p>Creates a smt::FuncType with the given domain and range types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3859]||(e[3859]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8208-L8212",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",em,[t("summary",null,[e[3861]||(e[3861]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeGetSort-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirSMTTypeGetSort-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeGetSort")],-1)),e[3862]||(e[3862]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3864]||(e[3864]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeGetSort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, identifier, numberOfSortParams, sortParams)</span></span></code></pre></div><p>Creates a smt::SortType with the given identifier and sort parameters.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3863]||(e[3863]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8231-L8235",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",tm,[t("summary",null,[e[3865]||(e[3865]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeIsAArray-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSMTTypeIsAArray-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeIsAArray")],-1)),e[3866]||(e[3866]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3868]||(e[3868]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeIsAArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks if the given type is a smt::ArrayType.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3867]||(e[3867]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8125-L8129",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sm,[t("summary",null,[e[3869]||(e[3869]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeIsABitVector-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSMTTypeIsABitVector-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeIsABitVector")],-1)),e[3870]||(e[3870]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3872]||(e[3872]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeIsABitVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks if the given type is a smt::BitVectorType.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3871]||(e[3871]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8145-L8149",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",am,[t("summary",null,[e[3873]||(e[3873]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeIsABool-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSMTTypeIsABool-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeIsABool")],-1)),e[3874]||(e[3874]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3876]||(e[3876]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeIsABool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks if the given type is a smt::BoolType.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3875]||(e[3875]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8163-L8167",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",im,[t("summary",null,[e[3877]||(e[3877]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeIsAInt-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSMTTypeIsAInt-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeIsAInt")],-1)),e[3878]||(e[3878]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3880]||(e[3880]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeIsAInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks if the given type is a smt::IntType.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3879]||(e[3879]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8181-L8185",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",lm,[t("summary",null,[e[3881]||(e[3881]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeIsASMTFunc-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSMTTypeIsASMTFunc-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeIsASMTFunc")],-1)),e[3882]||(e[3882]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3884]||(e[3884]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeIsASMTFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks if the given type is a smt::FuncType.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3883]||(e[3883]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8199-L8203",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",nm,[t("summary",null,[e[3885]||(e[3885]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeIsASort-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSMTTypeIsASort-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeIsASort")],-1)),e[3886]||(e[3886]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3888]||(e[3888]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeIsASort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks if the given type is a smt::SortType.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3887]||(e[3887]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8222-L8226",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rm,[t("summary",null,[e[3889]||(e[3889]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeIsAnyNonFuncSMTValueType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSMTTypeIsAnyNonFuncSMTValueType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeIsAnyNonFuncSMTValueType")],-1)),e[3890]||(e[3890]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3892]||(e[3892]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeIsAnyNonFuncSMTValueType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks if the given type is any non-func SMT value type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3891]||(e[3891]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8107-L8111",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",om,[t("summary",null,[e[3893]||(e[3893]=t("a",{id:"Reactant.MLIR.API.mlirSMTTypeIsAnySMTValueType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSMTTypeIsAnySMTValueType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSMTTypeIsAnySMTValueType")],-1)),e[3894]||(e[3894]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3896]||(e[3896]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSMTTypeIsAnySMTValueType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks if the given type is any SMT value type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3895]||(e[3895]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8116-L8120",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pm,[t("summary",null,[e[3897]||(e[3897]=t("a",{id:"Reactant.MLIR.API.mlirSetGlobalDebugType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSetGlobalDebugType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSetGlobalDebugType")],-1)),e[3898]||(e[3898]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3900]||(e[3900]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSetGlobalDebugType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Sets the current debug type, similarly to <code>-debug-only=type</code> in the command-line tools. Note that global debug should be enabled for any output to be produced.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3899]||(e[3899]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6230-L6234",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dm,[t("summary",null,[e[3901]||(e[3901]=t("a",{id:"Reactant.MLIR.API.mlirSetGlobalDebugTypes-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirSetGlobalDebugTypes-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSetGlobalDebugTypes")],-1)),e[3902]||(e[3902]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3904]||(e[3904]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSetGlobalDebugTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(types, n)</span></span></code></pre></div><p>Sets multiple current debug types, similarly to `-debug-only=type1,type2&quot; in the command-line tools. Note that global debug should be enabled for any output to be produced.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3903]||(e[3903]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6239-L6243",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",um,[t("summary",null,[e[3905]||(e[3905]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeGetDimSize-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirShapedTypeGetDimSize-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeGetDimSize")],-1)),e[3906]||(e[3906]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3908]||(e[3908]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeGetDimSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, dim)</span></span></code></pre></div><p>Returns the dim-th dimension of the given ranked shaped type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3907]||(e[3907]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5637-L5641",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bm,[t("summary",null,[e[3909]||(e[3909]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeGetDynamicSize-Tuple{}",href:"#Reactant.MLIR.API.mlirShapedTypeGetDynamicSize-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeGetDynamicSize")],-1)),e[3910]||(e[3910]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3912]||(e[3912]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeGetDynamicSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the value indicating a dynamic size in a shaped type. Prefer <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirShapedTypeIsDynamicSize-Tuple{Any}"><code>mlirShapedTypeIsDynamicSize</code></a> and <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirShapedTypeIsStaticSize-Tuple{Any}"><code>mlirShapedTypeIsStaticSize</code></a> to direct comparisons with this value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3911]||(e[3911]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5664-L5668",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cm,[t("summary",null,[e[3913]||(e[3913]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeGetDynamicStrideOrOffset-Tuple{}",href:"#Reactant.MLIR.API.mlirShapedTypeGetDynamicStrideOrOffset-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeGetDynamicStrideOrOffset")],-1)),e[3914]||(e[3914]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3916]||(e[3916]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeGetDynamicStrideOrOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the value indicating a dynamic stride or offset in a shaped type. Prefer <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirShapedTypeIsDynamicStrideOrOffset-Tuple{Any}"><code>mlirShapedTypeIsDynamicStrideOrOffset</code></a> and <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirShapedTypeIsStaticStrideOrOffset-Tuple{Any}"><code>mlirShapedTypeIsStaticStrideOrOffset</code></a> to direct comparisons with this value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3915]||(e[3915]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5691-L5695",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hm,[t("summary",null,[e[3917]||(e[3917]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeGetElementType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirShapedTypeGetElementType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeGetElementType")],-1)),e[3918]||(e[3918]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3920]||(e[3920]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeGetElementType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the element type of the shaped type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3919]||(e[3919]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5583-L5587",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ym,[t("summary",null,[e[3921]||(e[3921]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeGetRank-Tuple{Any}",href:"#Reactant.MLIR.API.mlirShapedTypeGetRank-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeGetRank")],-1)),e[3922]||(e[3922]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3924]||(e[3924]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeGetRank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the rank of the given ranked shaped type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3923]||(e[3923]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5601-L5605",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gm,[t("summary",null,[e[3925]||(e[3925]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeHasRank-Tuple{Any}",href:"#Reactant.MLIR.API.mlirShapedTypeHasRank-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeHasRank")],-1)),e[3926]||(e[3926]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3928]||(e[3928]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeHasRank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given shaped type is ranked.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3927]||(e[3927]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5592-L5596",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mm,[t("summary",null,[e[3929]||(e[3929]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeHasStaticShape-Tuple{Any}",href:"#Reactant.MLIR.API.mlirShapedTypeHasStaticShape-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeHasStaticShape")],-1)),e[3930]||(e[3930]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3932]||(e[3932]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeHasStaticShape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given shaped type has a static shape.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3931]||(e[3931]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5610-L5614",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",km,[t("summary",null,[e[3933]||(e[3933]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeIsDynamicDim-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirShapedTypeIsDynamicDim-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeIsDynamicDim")],-1)),e[3934]||(e[3934]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3936]||(e[3936]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeIsDynamicDim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, dim)</span></span></code></pre></div><p>Checks whether the dim-th dimension of the given shaped type is dynamic.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3935]||(e[3935]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5619-L5623",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rm,[t("summary",null,[e[3937]||(e[3937]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeIsDynamicSize-Tuple{Any}",href:"#Reactant.MLIR.API.mlirShapedTypeIsDynamicSize-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeIsDynamicSize")],-1)),e[3938]||(e[3938]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3940]||(e[3940]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeIsDynamicSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size)</span></span></code></pre></div><p>Checks whether the given value is used as a placeholder for dynamic sizes in shaped types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3939]||(e[3939]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5646-L5650",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fm,[t("summary",null,[e[3941]||(e[3941]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeIsDynamicStrideOrOffset-Tuple{Any}",href:"#Reactant.MLIR.API.mlirShapedTypeIsDynamicStrideOrOffset-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeIsDynamicStrideOrOffset")],-1)),e[3942]||(e[3942]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3944]||(e[3944]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeIsDynamicStrideOrOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val)</span></span></code></pre></div><p>Checks whether the given value is used as a placeholder for dynamic strides and offsets in shaped types.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3943]||(e[3943]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5673-L5677",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Im,[t("summary",null,[e[3945]||(e[3945]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeIsStaticDim-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirShapedTypeIsStaticDim-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeIsStaticDim")],-1)),e[3946]||(e[3946]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3948]||(e[3948]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeIsStaticDim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, dim)</span></span></code></pre></div><p>Checks whether the dim-th dimension of the given shaped type is static.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3947]||(e[3947]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5628-L5632",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Tm,[t("summary",null,[e[3949]||(e[3949]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeIsStaticSize-Tuple{Any}",href:"#Reactant.MLIR.API.mlirShapedTypeIsStaticSize-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeIsStaticSize")],-1)),e[3950]||(e[3950]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3952]||(e[3952]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeIsStaticSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size)</span></span></code></pre></div><p>Checks whether the given shaped type dimension value is statically-sized.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3951]||(e[3951]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5655-L5659",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Am,[t("summary",null,[e[3953]||(e[3953]=t("a",{id:"Reactant.MLIR.API.mlirShapedTypeIsStaticStrideOrOffset-Tuple{Any}",href:"#Reactant.MLIR.API.mlirShapedTypeIsStaticStrideOrOffset-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirShapedTypeIsStaticStrideOrOffset")],-1)),e[3954]||(e[3954]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3956]||(e[3956]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeIsStaticStrideOrOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val)</span></span></code></pre></div><p>Checks whether the given dimension value of a stride or an offset is statically-sized.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3955]||(e[3955]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5682-L5686",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jm,[t("summary",null,[e[3957]||(e[3957]=t("a",{id:"Reactant.MLIR.API.mlirSimplifyAffineExpr-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirSimplifyAffineExpr-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSimplifyAffineExpr")],-1)),e[3958]||(e[3958]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3960]||(e[3960]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSimplifyAffineExpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(expr, numDims, numSymbols)</span></span></code></pre></div><p>Simplify an affine expression by flattening and some amount of simple analysis. This has complexity linear in the number of nodes in &#39;expr&#39;. Returns the simplified expression, which is the same as the input expression if it can&#39;t be simplified. When <code>expr</code> is semi-affine, a simplified semi-affine expression is constructed in the sorted order of dimension and symbol positions.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3959]||(e[3959]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2823-L2827",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_m,[t("summary",null,[e[3961]||(e[3961]=t("a",{id:"Reactant.MLIR.API.mlirSparseElementsAttrGetIndices-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSparseElementsAttrGetIndices-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseElementsAttrGetIndices")],-1)),e[3962]||(e[3962]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3964]||(e[3964]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseElementsAttrGetIndices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the dense elements attribute containing 64-bit integer indices of non-null elements in the given sparse elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3963]||(e[3963]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4893-L4897",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mm,[t("summary",null,[e[3965]||(e[3965]=t("a",{id:"Reactant.MLIR.API.mlirSparseElementsAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirSparseElementsAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseElementsAttrGetTypeID")],-1)),e[3966]||(e[3966]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3968]||(e[3968]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseElementsAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a SparseElements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3967]||(e[3967]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4911-L4915",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Em,[t("summary",null,[e[3969]||(e[3969]=t("a",{id:"Reactant.MLIR.API.mlirSparseElementsAttrGetValues-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSparseElementsAttrGetValues-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseElementsAttrGetValues")],-1)),e[3970]||(e[3970]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3972]||(e[3972]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseElementsAttrGetValues</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the dense elements attribute containing the non-null elements in the given sparse elements attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3971]||(e[3971]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4902-L4906",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Lm,[t("summary",null,[e[3973]||(e[3973]=t("a",{id:"Reactant.MLIR.API.mlirSparseElementsAttribute-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirSparseElementsAttribute-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseElementsAttribute")],-1)),e[3974]||(e[3974]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3976]||(e[3976]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseElementsAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, denseIndices, denseValues)</span></span></code></pre></div><p>Creates a sparse elements attribute of the given shape from a list of indices and a list of associated values. Both lists are expected to be dense elements attributes with the same number of elements. The list of indices is expected to contain 64-bit integers. The attribute is created in the same context as the type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3975]||(e[3975]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4882-L4886",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Cm,[t("summary",null,[e[3977]||(e[3977]=t("a",{id:"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGet-NTuple{9, Any}",href:"#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGet-NTuple{9, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGet")],-1)),e[3978]||(e[3978]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3980]||(e[3980]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, lvlRank, lvlTypes, dimToLvl, lvlTodim, posWidth, crdWidth, explicitVal, implicitVal)</span></span></code></pre></div><p>Creates a <code>sparse\\_tensor.encoding</code> attribute with the given parameters.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3979]||(e[3979]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8348-L8352",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vm,[t("summary",null,[e[3981]||(e[3981]=t("a",{id:"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetCrdWidth-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetCrdWidth-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetCrdWidth")],-1)),e[3982]||(e[3982]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3984]||(e[3984]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetCrdWidth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the coordinate bitwidth of the <code>sparse\\_tensor.encoding</code> attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3983]||(e[3983]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8431-L8435",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pm,[t("summary",null,[e[3985]||(e[3985]=t("a",{id:"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetDimToLvl-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetDimToLvl-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetDimToLvl")],-1)),e[3986]||(e[3986]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3988]||(e[3988]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetDimToLvl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the dimension-to-level mapping of the <code>sparse\\_tensor.encoding</code> attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3987]||(e[3987]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8400-L8404",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xm,[t("summary",null,[e[3989]||(e[3989]=t("a",{id:"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetExplicitVal-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetExplicitVal-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetExplicitVal")],-1)),e[3990]||(e[3990]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3992]||(e[3992]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetExplicitVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the explicit value of the <code>sparse\\_tensor.encoding</code> attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3991]||(e[3991]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8440-L8444",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sm,[t("summary",null,[e[3993]||(e[3993]=t("a",{id:"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetImplicitVal-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetImplicitVal-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetImplicitVal")],-1)),e[3994]||(e[3994]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3996]||(e[3996]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetImplicitVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the implicit value of the <code>sparse\\_tensor.encoding</code> attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3995]||(e[3995]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8451-L8455",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Dm,[t("summary",null,[e[3997]||(e[3997]=t("a",{id:"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlFmt-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlFmt-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlFmt")],-1)),e[3998]||(e[3998]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4e3]||(e[4e3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetLvlFmt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, lvl)</span></span></code></pre></div><p>Returns a specified level-format of the <code>sparse\\_tensor.encoding</code> attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3999]||(e[3999]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8389-L8393",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fm,[t("summary",null,[e[4001]||(e[4001]=t("a",{id:"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlToDim-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlToDim-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlToDim")],-1)),e[4002]||(e[4002]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4004]||(e[4004]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetLvlToDim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the level-to-dimension mapping of the <code>sparse\\_tensor.encoding</code> attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4003]||(e[4003]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8411-L8415",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vm,[t("summary",null,[e[4005]||(e[4005]=t("a",{id:"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlType-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlType")],-1)),e[4006]||(e[4006]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4008]||(e[4008]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetLvlType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, lvl)</span></span></code></pre></div><p>Returns a specified level-type of the <code>sparse\\_tensor.encoding</code> attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4007]||(e[4007]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8378-L8382",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Om,[t("summary",null,[e[4009]||(e[4009]=t("a",{id:"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetPosWidth-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetPosWidth-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetPosWidth")],-1)),e[4010]||(e[4010]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4012]||(e[4012]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetPosWidth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the position bitwidth of the <code>sparse\\_tensor.encoding</code> attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4011]||(e[4011]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8422-L8426",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bm,[t("summary",null,[e[4013]||(e[4013]=t("a",{id:"Reactant.MLIR.API.mlirSparseTensorEncodingGetLvlRank-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSparseTensorEncodingGetLvlRank-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSparseTensorEncodingGetLvlRank")],-1)),e[4014]||(e[4014]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4016]||(e[4016]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingGetLvlRank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the level-rank of the <code>sparse\\_tensor.encoding</code> attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4015]||(e[4015]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8369-L8373",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Nm,[t("summary",null,[e[4017]||(e[4017]=t("a",{id:"Reactant.MLIR.API.mlirStridedLayoutAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirStridedLayoutAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirStridedLayoutAttrGetTypeID")],-1)),e[4018]||(e[4018]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4020]||(e[4020]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStridedLayoutAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a StridedLayout attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4019]||(e[4019]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4944-L4948",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gm,[t("summary",null,[e[4021]||(e[4021]=t("a",{id:"Reactant.MLIR.API.mlirStringAttrGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirStringAttrGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirStringAttrGet")],-1)),e[4022]||(e[4022]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4024]||(e[4024]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, str)</span></span></code></pre></div><p>Creates a string attribute in the given context containing the given string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4023]||(e[4023]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3910-L3914",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zm,[t("summary",null,[e[4025]||(e[4025]=t("a",{id:"Reactant.MLIR.API.mlirStringAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirStringAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirStringAttrGetTypeID")],-1)),e[4026]||(e[4026]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4028]||(e[4028]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a String attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4027]||(e[4027]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3937-L3941",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wm,[t("summary",null,[e[4029]||(e[4029]=t("a",{id:"Reactant.MLIR.API.mlirStringAttrGetValue-Tuple{Any}",href:"#Reactant.MLIR.API.mlirStringAttrGetValue-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirStringAttrGetValue")],-1)),e[4030]||(e[4030]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4032]||(e[4032]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the attribute values as a string reference. The data remains live as long as the context in which the attribute lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4031]||(e[4031]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3928-L3932",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Um,[t("summary",null,[e[4033]||(e[4033]=t("a",{id:"Reactant.MLIR.API.mlirStringAttrTypedGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirStringAttrTypedGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirStringAttrTypedGet")],-1)),e[4034]||(e[4034]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4036]||(e[4036]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringAttrTypedGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, str)</span></span></code></pre></div><p>Creates a string attribute in the given context containing the given string. Additionally, the attribute has the given type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4035]||(e[4035]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3919-L3923",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qm,[t("summary",null,[e[4037]||(e[4037]=t("a",{id:"Reactant.MLIR.API.mlirStringRefCreate-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirStringRefCreate-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirStringRefCreate")],-1)),e[4038]||(e[4038]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4040]||(e[4040]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringRefCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str, length)</span></span></code></pre></div><p>Constructs a string reference from the pointer and length. The pointer need not reference to a null-terminated string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4039]||(e[4039]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L78-L82",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qm,[t("summary",null,[e[4041]||(e[4041]=t("a",{id:"Reactant.MLIR.API.mlirStringRefCreateFromCString-Tuple{Any}",href:"#Reactant.MLIR.API.mlirStringRefCreateFromCString-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirStringRefCreateFromCString")],-1)),e[4042]||(e[4042]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4044]||(e[4044]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringRefCreateFromCString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str)</span></span></code></pre></div><p>Constructs a string reference from a null-terminated C string. Prefer <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirStringRefCreate-Tuple{Any, Any}"><code>mlirStringRefCreate</code></a> if the length of the string is known.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4043]||(e[4043]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L87-L91",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wm,[t("summary",null,[e[4045]||(e[4045]=t("a",{id:"Reactant.MLIR.API.mlirStringRefEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirStringRefEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirStringRefEqual")],-1)),e[4046]||(e[4046]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4048]||(e[4048]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringRefEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(string, other)</span></span></code></pre></div><p>Returns true if two string references are equal, false otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4047]||(e[4047]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L96-L100",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zm,[t("summary",null,[e[4049]||(e[4049]=t("a",{id:"Reactant.MLIR.API.mlirSymbolRefAttrGet-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirSymbolRefAttrGet-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolRefAttrGet")],-1)),e[4050]||(e[4050]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4052]||(e[4052]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolRefAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, symbol, numReferences, references)</span></span></code></pre></div><p>Creates a symbol reference attribute in the given context referencing a symbol identified by the given string inside a list of nested references. Each of the references in the list must not be nested.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4051]||(e[4051]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3955-L3959",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hm,[t("summary",null,[e[4053]||(e[4053]=t("a",{id:"Reactant.MLIR.API.mlirSymbolRefAttrGetLeafReference-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSymbolRefAttrGetLeafReference-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolRefAttrGetLeafReference")],-1)),e[4054]||(e[4054]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4056]||(e[4056]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolRefAttrGetLeafReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the string reference to the leaf referenced symbol. The data remains live as long as the context in which the attribute lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4055]||(e[4055]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3978-L3982",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jm,[t("summary",null,[e[4057]||(e[4057]=t("a",{id:"Reactant.MLIR.API.mlirSymbolRefAttrGetNestedReference-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirSymbolRefAttrGetNestedReference-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolRefAttrGetNestedReference")],-1)),e[4058]||(e[4058]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4060]||(e[4060]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolRefAttrGetNestedReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, pos)</span></span></code></pre></div><p>Returns pos-th reference nested in the given symbol reference attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4059]||(e[4059]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3996-L4000",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Km,[t("summary",null,[e[4061]||(e[4061]=t("a",{id:"Reactant.MLIR.API.mlirSymbolRefAttrGetNumNestedReferences-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSymbolRefAttrGetNumNestedReferences-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolRefAttrGetNumNestedReferences")],-1)),e[4062]||(e[4062]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4064]||(e[4064]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolRefAttrGetNumNestedReferences</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the number of references nested in the given symbol reference attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4063]||(e[4063]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3987-L3991",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$m,[t("summary",null,[e[4065]||(e[4065]=t("a",{id:"Reactant.MLIR.API.mlirSymbolRefAttrGetRootReference-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSymbolRefAttrGetRootReference-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolRefAttrGetRootReference")],-1)),e[4066]||(e[4066]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4068]||(e[4068]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolRefAttrGetRootReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the string reference to the root referenced symbol. The data remains live as long as the context in which the attribute lives.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4067]||(e[4067]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L3969-L3973",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xm,[t("summary",null,[e[4069]||(e[4069]=t("a",{id:"Reactant.MLIR.API.mlirSymbolRefAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirSymbolRefAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolRefAttrGetTypeID")],-1)),e[4070]||(e[4070]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4072]||(e[4072]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolRefAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an SymbolRef attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4071]||(e[4071]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4007-L4011",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ym,[t("summary",null,[e[4073]||(e[4073]=t("a",{id:"Reactant.MLIR.API.mlirSymbolTableCreate-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSymbolTableCreate-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolTableCreate")],-1)),e[4074]||(e[4074]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4076]||(e[4076]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(operation)</span></span></code></pre></div><p>Creates a symbol table for the given operation. If the operation does not have the SymbolTable trait, returns a null symbol table.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4075]||(e[4075]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2601-L2605",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ek,[t("summary",null,[e[4077]||(e[4077]=t("a",{id:"Reactant.MLIR.API.mlirSymbolTableDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSymbolTableDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolTableDestroy")],-1)),e[4078]||(e[4078]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4080]||(e[4080]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbolTable)</span></span></code></pre></div><p>Destroys the symbol table created with <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirSymbolTableCreate-Tuple{Any}"><code>mlirSymbolTableCreate</code></a>. This does not affect the operations in the table.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4079]||(e[4079]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2619-L2623",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",tk,[t("summary",null,[e[4081]||(e[4081]=t("a",{id:"Reactant.MLIR.API.mlirSymbolTableErase-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirSymbolTableErase-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolTableErase")],-1)),e[4082]||(e[4082]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4084]||(e[4084]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableErase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbolTable, operation)</span></span></code></pre></div><p>Removes the given operation from the symbol table and erases it.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4083]||(e[4083]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2650-L2654",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sk,[t("summary",null,[e[4085]||(e[4085]=t("a",{id:"Reactant.MLIR.API.mlirSymbolTableGetSymbolAttributeName-Tuple{}",href:"#Reactant.MLIR.API.mlirSymbolTableGetSymbolAttributeName-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolTableGetSymbolAttributeName")],-1)),e[4086]||(e[4086]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4088]||(e[4088]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableGetSymbolAttributeName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the name of the attribute used to store symbol names compatible with symbol tables.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4087]||(e[4087]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2583-L2587",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ak,[t("summary",null,[e[4089]||(e[4089]=t("a",{id:"Reactant.MLIR.API.mlirSymbolTableGetVisibilityAttributeName-Tuple{}",href:"#Reactant.MLIR.API.mlirSymbolTableGetVisibilityAttributeName-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolTableGetVisibilityAttributeName")],-1)),e[4090]||(e[4090]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4092]||(e[4092]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableGetVisibilityAttributeName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the name of the attribute used to store symbol visibility.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4091]||(e[4091]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2592-L2596",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ik,[t("summary",null,[e[4093]||(e[4093]=t("a",{id:"Reactant.MLIR.API.mlirSymbolTableInsert-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirSymbolTableInsert-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolTableInsert")],-1)),e[4094]||(e[4094]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4096]||(e[4096]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableInsert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbolTable, operation)</span></span></code></pre></div><p>Inserts the given operation into the given symbol table. The operation must have the symbol trait. If the symbol table already has a symbol with the same name, renames the symbol being inserted to ensure name uniqueness. Note that this does not move the operation itself into the block of the symbol table operation, this should be done separately. Returns the name of the symbol after insertion.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4095]||(e[4095]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2639-L2643",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",lk,[t("summary",null,[e[4097]||(e[4097]=t("a",{id:"Reactant.MLIR.API.mlirSymbolTableIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirSymbolTableIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolTableIsNull")],-1)),e[4098]||(e[4098]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4100]||(e[4100]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbolTable)</span></span></code></pre></div><p>Returns true if the symbol table is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4099]||(e[4099]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2610-L2614",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",nk,[t("summary",null,[e[4101]||(e[4101]=t("a",{id:"Reactant.MLIR.API.mlirSymbolTableLookup-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirSymbolTableLookup-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolTableLookup")],-1)),e[4102]||(e[4102]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4104]||(e[4104]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableLookup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbolTable, name)</span></span></code></pre></div><p>Looks up a symbol with the given name in the given symbol table and returns the operation that corresponds to the symbol. If the symbol cannot be found, returns a null operation.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4103]||(e[4103]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2628-L2632",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rk,[t("summary",null,[e[4105]||(e[4105]=t("a",{id:"Reactant.MLIR.API.mlirSymbolTableReplaceAllSymbolUses-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirSymbolTableReplaceAllSymbolUses-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolTableReplaceAllSymbolUses")],-1)),e[4106]||(e[4106]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4108]||(e[4108]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableReplaceAllSymbolUses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldSymbol, newSymbol, from)</span></span></code></pre></div><p>Attempt to replace all uses that are nested within the given operation of the given symbol &#39;oldSymbol&#39; with the provided &#39;newSymbol&#39;. This does not traverse into nested symbol tables. Will fail atomically if there are any unknown operations that may be potential symbol tables.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4107]||(e[4107]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2661-L2665",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ok,[t("summary",null,[e[4109]||(e[4109]=t("a",{id:"Reactant.MLIR.API.mlirSymbolTableWalkSymbolTables-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirSymbolTableWalkSymbolTables-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirSymbolTableWalkSymbolTables")],-1)),e[4110]||(e[4110]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4112]||(e[4112]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableWalkSymbolTables</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(from, allSymUsesVisible, callback, userData)</span></span></code></pre></div><p>Walks all symbol table operations nested within, and including, <code>op</code>. For each symbol table operation, the provided callback is invoked with the op and a boolean signifying if the symbols within that symbol table can be treated as if all uses within the IR are visible to the caller. <code>allSymUsesVisible</code> identifies whether all of the symbol uses of symbols within <code>op</code> are visible.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4111]||(e[4111]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2672-L2676",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pk,[t("summary",null,[e[4113]||(e[4113]=t("a",{id:"Reactant.MLIR.API.mlirTF32TypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTF32TypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTF32TypeGet")],-1)),e[4114]||(e[4114]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4116]||(e[4116]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTF32TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a TF32 type in the given context. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4115]||(e[4115]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5502-L5506",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dk,[t("summary",null,[e[4117]||(e[4117]=t("a",{id:"Reactant.MLIR.API.mlirTPUTiledLayoutAttrGetTiles-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTPUTiledLayoutAttrGetTiles-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTPUTiledLayoutAttrGetTiles")],-1)),e[4118]||(e[4118]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4120]||(e[4120]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTPUTiledLayoutAttrGetTiles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Encodes the tiles as an ArrayAttr of DenseI64ArrayAttrs.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4119]||(e[4119]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L11273-L11277",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",uk,[t("summary",null,[e[4121]||(e[4121]=t("a",{id:"Reactant.MLIR.API.mlirTransformApplyNamedSequence-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirTransformApplyNamedSequence-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTransformApplyNamedSequence")],-1)),e[4122]||(e[4122]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4124]||(e[4124]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformApplyNamedSequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(payload, transformRoot, transformModule, transformOptions)</span></span></code></pre></div><p>Applies the transformation script starting at the given transform root operation to the given payload operation. The module containing the transform root as well as the transform options should be provided. The transform operation must implement TransformOpInterface and the module must be a ModuleOp. Returns the status of the application.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4123]||(e[4123]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8628-L8632",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bk,[t("summary",null,[e[4125]||(e[4125]=t("a",{id:"Reactant.MLIR.API.mlirTransformOptionsCreate-Tuple{}",href:"#Reactant.MLIR.API.mlirTransformOptionsCreate-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTransformOptionsCreate")],-1)),e[4126]||(e[4126]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4128]||(e[4128]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformOptionsCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a default-initialized transform options object.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4127]||(e[4127]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8566-L8570",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ck,[t("summary",null,[e[4129]||(e[4129]=t("a",{id:"Reactant.MLIR.API.mlirTransformOptionsDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTransformOptionsDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTransformOptionsDestroy")],-1)),e[4130]||(e[4130]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4132]||(e[4132]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformOptionsDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transformOptions)</span></span></code></pre></div><p>Destroys a transform options object previously created by <a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirTransformOptionsCreate-Tuple{}"><code>mlirTransformOptionsCreate</code></a>.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4131]||(e[4131]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8619-L8623",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hk,[t("summary",null,[e[4133]||(e[4133]=t("a",{id:"Reactant.MLIR.API.mlirTransformOptionsEnableExpensiveChecks-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirTransformOptionsEnableExpensiveChecks-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTransformOptionsEnableExpensiveChecks")],-1)),e[4134]||(e[4134]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4136]||(e[4136]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformOptionsEnableExpensiveChecks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transformOptions, enable)</span></span></code></pre></div><p>Enables or disables expensive checks in transform options.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4135]||(e[4135]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8575-L8579",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yk,[t("summary",null,[e[4137]||(e[4137]=t("a",{id:"Reactant.MLIR.API.mlirTransformOptionsEnforceSingleTopLevelTransformOp-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirTransformOptionsEnforceSingleTopLevelTransformOp-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTransformOptionsEnforceSingleTopLevelTransformOp")],-1)),e[4138]||(e[4138]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4140]||(e[4140]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformOptionsEnforceSingleTopLevelTransformOp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transformOptions, enable)</span></span></code></pre></div><p>Enables or disables the enforcement of the top-level transform op being single in transform options.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4139]||(e[4139]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8597-L8601",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gk,[t("summary",null,[e[4141]||(e[4141]=t("a",{id:"Reactant.MLIR.API.mlirTransformOptionsGetEnforceSingleTopLevelTransformOp-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTransformOptionsGetEnforceSingleTopLevelTransformOp-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTransformOptionsGetEnforceSingleTopLevelTransformOp")],-1)),e[4142]||(e[4142]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4144]||(e[4144]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformOptionsGetEnforceSingleTopLevelTransformOp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transformOptions)</span></span></code></pre></div><p>Returns true if the enforcement of the top-level transform op being single is enabled in transform options.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4143]||(e[4143]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8608-L8612",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mk,[t("summary",null,[e[4145]||(e[4145]=t("a",{id:"Reactant.MLIR.API.mlirTransformOptionsGetExpensiveChecksEnabled-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTransformOptionsGetExpensiveChecksEnabled-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTransformOptionsGetExpensiveChecksEnabled")],-1)),e[4146]||(e[4146]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4148]||(e[4148]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformOptionsGetExpensiveChecksEnabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transformOptions)</span></span></code></pre></div><p>Returns true if expensive checks are enabled in transform options.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4147]||(e[4147]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8586-L8590",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",kk,[t("summary",null,[e[4149]||(e[4149]=t("a",{id:"Reactant.MLIR.API.mlirTranslateModuleToLLVMIR-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirTranslateModuleToLLVMIR-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTranslateModuleToLLVMIR")],-1)),e[4150]||(e[4150]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4152]||(e[4152]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTranslateModuleToLLVMIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module, context)</span></span></code></pre></div><p>Translate operation that satisfies LLVM dialect module requirements into an LLVM IR module living in the given context. This translates operations from any dilalect that has a registered implementation of LLVMTranslationDialectInterface.</p><p><strong>Returns</strong></p><p>the generated LLVM IR Module from the translated MLIR module, it is owned by the caller.</p>',4)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4151]||(e[4151]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9996-L10003",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Rk,[t("summary",null,[e[4153]||(e[4153]=t("a",{id:"Reactant.MLIR.API.mlirTranslateModuleToSMTLIB-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirTranslateModuleToSMTLIB-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTranslateModuleToSMTLIB")],-1)),e[4154]||(e[4154]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4156]||(e[4156]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTranslateModuleToSMTLIB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1, arg2, userData, inlineSingleUseValues, indentLetBody)</span></span></code></pre></div><p>Emits SMTLIB for the specified module using the provided callback and user data</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4155]||(e[4155]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L9755-L9759",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fk,[t("summary",null,[e[4157]||(e[4157]=t("a",{id:"Reactant.MLIR.API.mlirTupleTypeGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirTupleTypeGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTupleTypeGet")],-1)),e[4158]||(e[4158]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4160]||(e[4160]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTupleTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, numElements, elements)</span></span></code></pre></div><p>Creates a tuple type that consists of the given list of elemental types. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4159]||(e[4159]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6067-L6071",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ik,[t("summary",null,[e[4161]||(e[4161]=t("a",{id:"Reactant.MLIR.API.mlirTupleTypeGetNumTypes-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTupleTypeGetNumTypes-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTupleTypeGetNumTypes")],-1)),e[4162]||(e[4162]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4164]||(e[4164]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTupleTypeGetNumTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of types contained in a tuple.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4163]||(e[4163]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6078-L6082",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Tk,[t("summary",null,[e[4165]||(e[4165]=t("a",{id:"Reactant.MLIR.API.mlirTupleTypeGetType-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirTupleTypeGetType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTupleTypeGetType")],-1)),e[4166]||(e[4166]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4168]||(e[4168]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTupleTypeGetType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns the pos-th type in the tuple type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4167]||(e[4167]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6087-L6091",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ak,[t("summary",null,[e[4169]||(e[4169]=t("a",{id:"Reactant.MLIR.API.mlirTupleTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirTupleTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTupleTypeGetTypeID")],-1)),e[4170]||(e[4170]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4172]||(e[4172]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTupleTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Tuple type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4171]||(e[4171]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6049-L6053",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jk,[t("summary",null,[e[4173]||(e[4173]=t("a",{id:"Reactant.MLIR.API.mlirTypeAttrGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeAttrGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeAttrGet")],-1)),e[4174]||(e[4174]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4176]||(e[4176]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Creates a type attribute wrapping the given type in the same context as the type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4175]||(e[4175]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4063-L4067",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_k,[t("summary",null,[e[4177]||(e[4177]=t("a",{id:"Reactant.MLIR.API.mlirTypeAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirTypeAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeAttrGetTypeID")],-1)),e[4178]||(e[4178]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4180]||(e[4180]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a Type attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4179]||(e[4179]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4081-L4085",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Mk,[t("summary",null,[e[4181]||(e[4181]=t("a",{id:"Reactant.MLIR.API.mlirTypeAttrGetValue-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeAttrGetValue-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeAttrGetValue")],-1)),e[4182]||(e[4182]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4184]||(e[4184]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the type stored in the given type attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4183]||(e[4183]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4072-L4076",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ek,[t("summary",null,[e[4185]||(e[4185]=t("a",{id:"Reactant.MLIR.API.mlirTypeDump-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeDump-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeDump")],-1)),e[4186]||(e[4186]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4188]||(e[4188]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Prints the type to the standard error stream.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4187]||(e[4187]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2440-L2444",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Lk,[t("summary",null,[e[4189]||(e[4189]=t("a",{id:"Reactant.MLIR.API.mlirTypeEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirTypeEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeEqual")],-1)),e[4190]||(e[4190]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4192]||(e[4192]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t1, t2)</span></span></code></pre></div><p>Checks if two types are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4191]||(e[4191]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2420-L2424",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ck,[t("summary",null,[e[4193]||(e[4193]=t("a",{id:"Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorCreate-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorCreate-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorCreate")],-1)),e[4194]||(e[4194]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4196]||(e[4196]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeFromLLVMIRTranslatorCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Create an LLVM::TypeFromLLVMIRTranslator and transfer ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4195]||(e[4195]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L10018-L10022",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",vk,[t("summary",null,[e[4197]||(e[4197]=t("a",{id:"Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorDestroy")],-1)),e[4198]||(e[4198]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4200]||(e[4200]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeFromLLVMIRTranslatorDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(translator)</span></span></code></pre></div><p>Takes an LLVM::TypeFromLLVMIRTranslator owned by the caller and destroys it. It is the responsibility of the user to only pass an LLVM::TypeFromLLVMIRTranslator class.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4199]||(e[4199]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L10029-L10033",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pk,[t("summary",null,[e[4201]||(e[4201]=t("a",{id:"Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorTranslateType-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorTranslateType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorTranslateType")],-1)),e[4202]||(e[4202]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4204]||(e[4204]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeFromLLVMIRTranslatorTranslateType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(translator, llvmType)</span></span></code></pre></div><p>Translates the given LLVM IR type to the MLIR LLVM dialect.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4203]||(e[4203]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L10040-L10044",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xk,[t("summary",null,[e[4205]||(e[4205]=t("a",{id:"Reactant.MLIR.API.mlirTypeGetContext-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeGetContext-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeGetContext")],-1)),e[4206]||(e[4206]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4208]||(e[4208]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the context that a type was created with.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4207]||(e[4207]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2384-L2388",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Sk,[t("summary",null,[e[4209]||(e[4209]=t("a",{id:"Reactant.MLIR.API.mlirTypeGetDialect-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeGetDialect-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeGetDialect")],-1)),e[4210]||(e[4210]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4212]||(e[4212]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeGetDialect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the dialect a type belongs to.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4211]||(e[4211]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2402-L2406",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Dk,[t("summary",null,[e[4213]||(e[4213]=t("a",{id:"Reactant.MLIR.API.mlirTypeGetTypeID-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeGetTypeID-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeGetTypeID")],-1)),e[4214]||(e[4214]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4216]||(e[4216]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the type ID of the type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4215]||(e[4215]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2393-L2397",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fk,[t("summary",null,[e[4217]||(e[4217]=t("a",{id:"Reactant.MLIR.API.mlirTypeIDAllocatorAllocateTypeID-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIDAllocatorAllocateTypeID-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIDAllocatorAllocateTypeID")],-1)),e[4218]||(e[4218]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4220]||(e[4220]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDAllocatorAllocateTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allocator)</span></span></code></pre></div><p>Allocates a type id that is valid for the lifetime of the allocator</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4219]||(e[4219]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L230-L234",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Vk,[t("summary",null,[e[4221]||(e[4221]=t("a",{id:"Reactant.MLIR.API.mlirTypeIDAllocatorCreate-Tuple{}",href:"#Reactant.MLIR.API.mlirTypeIDAllocatorCreate-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIDAllocatorCreate")],-1)),e[4222]||(e[4222]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4224]||(e[4224]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDAllocatorCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a type id allocator for dynamic type id creation</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4223]||(e[4223]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L212-L216",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ok,[t("summary",null,[e[4225]||(e[4225]=t("a",{id:"Reactant.MLIR.API.mlirTypeIDAllocatorDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIDAllocatorDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIDAllocatorDestroy")],-1)),e[4226]||(e[4226]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4228]||(e[4228]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDAllocatorDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allocator)</span></span></code></pre></div><p>Deallocates the allocator and all allocated type ids</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4227]||(e[4227]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L221-L225",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Bk,[t("summary",null,[e[4229]||(e[4229]=t("a",{id:"Reactant.MLIR.API.mlirTypeIDCreate-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIDCreate-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIDCreate")],-1)),e[4230]||(e[4230]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4232]||(e[4232]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ptr)</span></span></code></pre></div><p><code>ptr</code> must be 8 byte aligned and unique to a type valid for the duration of the returned type id&#39;s usage</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4231]||(e[4231]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L176-L180",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Nk,[t("summary",null,[e[4233]||(e[4233]=t("a",{id:"Reactant.MLIR.API.mlirTypeIDEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirTypeIDEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIDEqual")],-1)),e[4234]||(e[4234]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4236]||(e[4236]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(typeID1, typeID2)</span></span></code></pre></div><p>Checks if two type ids are equal.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4235]||(e[4235]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L194-L198",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Gk,[t("summary",null,[e[4237]||(e[4237]=t("a",{id:"Reactant.MLIR.API.mlirTypeIDHashValue-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIDHashValue-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIDHashValue")],-1)),e[4238]||(e[4238]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4240]||(e[4240]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDHashValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(typeID)</span></span></code></pre></div><p>Returns the hash value of the type id.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4239]||(e[4239]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L203-L207",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",zk,[t("summary",null,[e[4241]||(e[4241]=t("a",{id:"Reactant.MLIR.API.mlirTypeIDIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIDIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIDIsNull")],-1)),e[4242]||(e[4242]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4244]||(e[4244]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(typeID)</span></span></code></pre></div><p>Checks whether a type id is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4243]||(e[4243]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L185-L189",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",wk,[t("summary",null,[e[4245]||(e[4245]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAAnyQuantizedType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAAnyQuantizedType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAAnyQuantizedType")],-1)),e[4246]||(e[4246]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4248]||(e[4248]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAAnyQuantizedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is an AnyQuantizedType.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4247]||(e[4247]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7792-L7796",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Uk,[t("summary",null,[e[4249]||(e[4249]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsABF16-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsABF16-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsABF16")],-1)),e[4250]||(e[4250]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4252]||(e[4252]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsABF16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a bf16 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4251]||(e[4251]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5385-L5389",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qk,[t("summary",null,[e[4253]||(e[4253]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsACalibratedQuantizedType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsACalibratedQuantizedType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsACalibratedQuantizedType")],-1)),e[4254]||(e[4254]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4256]||(e[4256]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsACalibratedQuantizedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is a CalibratedQuantizedType.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4255]||(e[4255]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8057-L8061",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Qk,[t("summary",null,[e[4257]||(e[4257]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAComplex-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAComplex-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAComplex")],-1)),e[4258]||(e[4258]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4260]||(e[4260]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAComplex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Complex type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4259]||(e[4259]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5547-L5551",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Wk,[t("summary",null,[e[4261]||(e[4261]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAF16-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAF16-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAF16")],-1)),e[4262]||(e[4262]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4264]||(e[4264]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAF16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f16 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4263]||(e[4263]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5412-L5416",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Zk,[t("summary",null,[e[4265]||(e[4265]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAF32-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAF32-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAF32")],-1)),e[4266]||(e[4266]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4268]||(e[4268]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAF32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f32 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4267]||(e[4267]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5439-L5443",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Hk,[t("summary",null,[e[4269]||(e[4269]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAF64-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAF64-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAF64")],-1)),e[4270]||(e[4270]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4272]||(e[4272]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAF64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f64 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4271]||(e[4271]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5466-L5470",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Jk,[t("summary",null,[e[4273]||(e[4273]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFloat-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFloat-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFloat")],-1)),e[4274]||(e[4274]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4276]||(e[4276]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a floating-point type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4275]||(e[4275]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5061-L5065",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Kk,[t("summary",null,[e[4277]||(e[4277]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFloat4E2M1FN-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFloat4E2M1FN-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFloat4E2M1FN")],-1)),e[4278]||(e[4278]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4280]||(e[4280]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat4E2M1FN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f4E2M1FN type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4279]||(e[4279]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5088-L5092",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$k,[t("summary",null,[e[4281]||(e[4281]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFloat6E2M3FN-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFloat6E2M3FN-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFloat6E2M3FN")],-1)),e[4282]||(e[4282]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4284]||(e[4284]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat6E2M3FN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f6E2M3FN type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4283]||(e[4283]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5115-L5119",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xk,[t("summary",null,[e[4285]||(e[4285]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFloat6E3M2FN-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFloat6E3M2FN-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFloat6E3M2FN")],-1)),e[4286]||(e[4286]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4288]||(e[4288]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat6E3M2FN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f6E3M2FN type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4287]||(e[4287]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5142-L5146",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Yk,[t("summary",null,[e[4289]||(e[4289]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFloat8E3M4-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFloat8E3M4-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFloat8E3M4")],-1)),e[4290]||(e[4290]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4292]||(e[4292]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E3M4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E3M4 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4291]||(e[4291]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5331-L5335",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",e2,[t("summary",null,[e[4293]||(e[4293]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFloat8E4M3-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFloat8E4M3-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFloat8E4M3")],-1)),e[4294]||(e[4294]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4296]||(e[4296]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E4M3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4295]||(e[4295]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5196-L5200",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",t2,[t("summary",null,[e[4297]||(e[4297]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFloat8E4M3B11FNUZ-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFloat8E4M3B11FNUZ-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFloat8E4M3B11FNUZ")],-1)),e[4298]||(e[4298]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4300]||(e[4300]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E4M3B11FNUZ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3B11FNUZ type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4299]||(e[4299]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5304-L5308",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",s2,[t("summary",null,[e[4301]||(e[4301]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FN-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FN-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FN")],-1)),e[4302]||(e[4302]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4304]||(e[4304]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E4M3FN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3FN type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4303]||(e[4303]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5223-L5227",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",a2,[t("summary",null,[e[4305]||(e[4305]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FNUZ-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FNUZ-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FNUZ")],-1)),e[4306]||(e[4306]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4308]||(e[4308]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E4M3FNUZ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3FNUZ type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4307]||(e[4307]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5277-L5281",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",i2,[t("summary",null,[e[4309]||(e[4309]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFloat8E5M2-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFloat8E5M2-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFloat8E5M2")],-1)),e[4310]||(e[4310]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4312]||(e[4312]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E5M2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E5M2 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4311]||(e[4311]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5169-L5173",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",l2,[t("summary",null,[e[4313]||(e[4313]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFloat8E5M2FNUZ-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFloat8E5M2FNUZ-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFloat8E5M2FNUZ")],-1)),e[4314]||(e[4314]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4316]||(e[4316]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E5M2FNUZ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E5M2FNUZ type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4315]||(e[4315]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5250-L5254",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",n2,[t("summary",null,[e[4317]||(e[4317]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFloat8E8M0FNU-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFloat8E8M0FNU-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFloat8E8M0FNU")],-1)),e[4318]||(e[4318]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4320]||(e[4320]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E8M0FNU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E8M0FNU type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4319]||(e[4319]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5358-L5362",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",r2,[t("summary",null,[e[4321]||(e[4321]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAFunction-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAFunction-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAFunction")],-1)),e[4322]||(e[4322]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4324]||(e[4324]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a function type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4323]||(e[4323]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6105-L6109",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",o2,[t("summary",null,[e[4325]||(e[4325]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAIndex-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAIndex-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAIndex")],-1)),e[4326]||(e[4326]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4328]||(e[4328]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an index type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4327]||(e[4327]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5043-L5047",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",p2,[t("summary",null,[e[4329]||(e[4329]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAInteger-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAInteger-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAInteger")],-1)),e[4330]||(e[4330]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4332]||(e[4332]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an integer type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4331]||(e[4331]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4962-L4966",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",d2,[t("summary",null,[e[4333]||(e[4333]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsALLVMPointerType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsALLVMPointerType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsALLVMPointerType")],-1)),e[4334]||(e[4334]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4336]||(e[4336]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsALLVMPointerType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the type is an LLVM dialect pointer type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4335]||(e[4335]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6648-L6652",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",u2,[t("summary",null,[e[4337]||(e[4337]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsALLVMStructType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsALLVMStructType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsALLVMStructType")],-1)),e[4338]||(e[4338]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4340]||(e[4340]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsALLVMStructType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the type is an LLVM dialect struct type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4339]||(e[4339]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6734-L6738",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b2,[t("summary",null,[e[4341]||(e[4341]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAMemRef-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAMemRef-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAMemRef")],-1)),e[4342]||(e[4342]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4344]||(e[4344]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAMemRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a MemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4343]||(e[4343]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5893-L5897",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",c2,[t("summary",null,[e[4345]||(e[4345]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsANone-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsANone-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsANone")],-1)),e[4346]||(e[4346]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4348]||(e[4348]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsANone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a None type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4347]||(e[4347]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5520-L5524",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",h2,[t("summary",null,[e[4349]||(e[4349]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAOpaque-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAOpaque-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAOpaque")],-1)),e[4350]||(e[4350]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4352]||(e[4352]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAOpaque</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an opaque type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4351]||(e[4351]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6174-L6178",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y2,[t("summary",null,[e[4353]||(e[4353]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAQuantizedType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAQuantizedType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAQuantizedType")],-1)),e[4354]||(e[4354]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4356]||(e[4356]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAQuantizedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is a quantization dialect type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4355]||(e[4355]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7618-L7622",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g2,[t("summary",null,[e[4357]||(e[4357]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsARankedTensor-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsARankedTensor-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsARankedTensor")],-1)),e[4358]||(e[4358]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4360]||(e[4360]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsARankedTensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a ranked tensor type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4359]||(e[4359]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5802-L5806",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",m2,[t("summary",null,[e[4361]||(e[4361]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAShaped-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAShaped-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAShaped")],-1)),e[4362]||(e[4362]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4364]||(e[4364]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAShaped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Shaped type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4363]||(e[4363]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5574-L5578",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",k2,[t("summary",null,[e[4365]||(e[4365]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsATF32-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsATF32-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsATF32")],-1)),e[4366]||(e[4366]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4368]||(e[4368]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsATF32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an TF32 type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4367]||(e[4367]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5493-L5497",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",R2,[t("summary",null,[e[4369]||(e[4369]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsATensor-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsATensor-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsATensor")],-1)),e[4370]||(e[4370]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4372]||(e[4372]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsATensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Tensor type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4371]||(e[4371]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5784-L5788",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f2,[t("summary",null,[e[4373]||(e[4373]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsATuple-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsATuple-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsATuple")],-1)),e[4374]||(e[4374]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4376]||(e[4376]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsATuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a tuple type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4375]||(e[4375]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6058-L6062",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I2,[t("summary",null,[e[4377]||(e[4377]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAUniformQuantizedPerAxisType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAUniformQuantizedPerAxisType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAUniformQuantizedPerAxisType")],-1)),e[4378]||(e[4378]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4380]||(e[4380]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAUniformQuantizedPerAxisType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is a UniformQuantizedPerAxisType.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4379]||(e[4379]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7873-L7877",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",T2,[t("summary",null,[e[4381]||(e[4381]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAUniformQuantizedSubChannelType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAUniformQuantizedSubChannelType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAUniformQuantizedSubChannelType")],-1)),e[4382]||(e[4382]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4384]||(e[4384]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAUniformQuantizedSubChannelType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is a UniformQuantizedSubChannel.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4383]||(e[4383]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7962-L7966",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",A2,[t("summary",null,[e[4385]||(e[4385]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAUniformQuantizedType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAUniformQuantizedType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAUniformQuantizedType")],-1)),e[4386]||(e[4386]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4388]||(e[4388]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAUniformQuantizedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is a UniformQuantizedType.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4387]||(e[4387]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7818-L7822",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",j2,[t("summary",null,[e[4389]||(e[4389]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAUnrankedMemRef-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAUnrankedMemRef-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAUnrankedMemRef")],-1)),e[4390]||(e[4390]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4392]||(e[4392]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAUnrankedMemRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an UnrankedMemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4391]||(e[4391]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5911-L5915",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_2,[t("summary",null,[e[4393]||(e[4393]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAUnrankedTensor-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAUnrankedTensor-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAUnrankedTensor")],-1)),e[4394]||(e[4394]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4396]||(e[4396]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAUnrankedTensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an unranked tensor type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4395]||(e[4395]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5820-L5824",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",M2,[t("summary",null,[e[4397]||(e[4397]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsAVector-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsAVector-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsAVector")],-1)),e[4398]||(e[4398]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4400]||(e[4400]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Vector type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4399]||(e[4399]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5709-L5713",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",E2,[t("summary",null,[e[4401]||(e[4401]=t("a",{id:"Reactant.MLIR.API.mlirTypeIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeIsNull")],-1)),e[4402]||(e[4402]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4404]||(e[4404]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether a type is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4403]||(e[4403]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2411-L2415",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",L2,[t("summary",null,[e[4405]||(e[4405]=t("a",{id:"Reactant.MLIR.API.mlirTypeParseGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirTypeParseGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeParseGet")],-1)),e[4406]||(e[4406]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4408]||(e[4408]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeParseGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, type)</span></span></code></pre></div><p>Parses a type. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4407]||(e[4407]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2375-L2379",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",C2,[t("summary",null,[e[4409]||(e[4409]=t("a",{id:"Reactant.MLIR.API.mlirTypePrint-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirTypePrint-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypePrint")],-1)),e[4410]||(e[4410]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4412]||(e[4412]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypePrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, callback, userData)</span></span></code></pre></div><p>Prints a location by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4411]||(e[4411]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2429-L2433",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",v2,[t("summary",null,[e[4413]||(e[4413]=t("a",{id:"Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorCreate-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorCreate-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorCreate")],-1)),e[4414]||(e[4414]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4416]||(e[4416]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeToLLVMIRTranslatorCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Create an LLVM::TypeToLLVMIRTranslator and transfer ownership to the caller.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4415]||(e[4415]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L10055-L10059",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",P2,[t("summary",null,[e[4417]||(e[4417]=t("a",{id:"Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorDestroy-Tuple{Any}",href:"#Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorDestroy-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorDestroy")],-1)),e[4418]||(e[4418]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4420]||(e[4420]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeToLLVMIRTranslatorDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(translator)</span></span></code></pre></div><p>Takes an LLVM::TypeToLLVMIRTranslator owned by the caller and destroys it. It is the responsibility of the user to only pass an LLVM::TypeToLLVMIRTranslator class.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4419]||(e[4419]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L10066-L10070",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",x2,[t("summary",null,[e[4421]||(e[4421]=t("a",{id:"Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorTranslateType-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorTranslateType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorTranslateType")],-1)),e[4422]||(e[4422]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4424]||(e[4424]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeToLLVMIRTranslatorTranslateType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(translator, mlirType)</span></span></code></pre></div><p>Translates the given MLIR LLVM dialect to the LLVM IR type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4423]||(e[4423]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L10077-L10081",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",S2,[t("summary",null,[e[4425]||(e[4425]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGet-NTuple{9, Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGet-NTuple{9, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGet")],-1)),e[4426]||(e[4426]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4428]||(e[4428]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedPerAxisTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, storageType, expressedType, nDims, scales, zeroPoints, quantizedDimension, storageTypeMin, storageTypeMax)</span></span></code></pre></div><p>Creates an instance of UniformQuantizedPerAxisType with the given parameters in the same context as <code>storageType</code> and returns it. <code>scales</code> and <code>zeroPoints</code> point to <code>nDims</code> number of elements. The instance is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4427]||(e[4427]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7882-L7886",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",D2,[t("summary",null,[e[4429]||(e[4429]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetNumDims-Tuple{Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetNumDims-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetNumDims")],-1)),e[4430]||(e[4430]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4432]||(e[4432]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedPerAxisTypeGetNumDims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of axes in the given quantized per-axis type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4431]||(e[4431]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7911-L7915",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",F2,[t("summary",null,[e[4433]||(e[4433]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetQuantizedDimension-Tuple{Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetQuantizedDimension-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetQuantizedDimension")],-1)),e[4434]||(e[4434]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4436]||(e[4436]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedPerAxisTypeGetQuantizedDimension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the index of the quantized dimension in the given quantized per-axis type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4435]||(e[4435]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7942-L7946",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",V2,[t("summary",null,[e[4437]||(e[4437]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetScale-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetScale-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetScale")],-1)),e[4438]||(e[4438]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4440]||(e[4440]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedPerAxisTypeGetScale</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th scale of the given quantized per-axis type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4439]||(e[4439]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7920-L7924",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",O2,[t("summary",null,[e[4441]||(e[4441]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetZeroPoint-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetZeroPoint-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetZeroPoint")],-1)),e[4442]||(e[4442]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4444]||(e[4444]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedPerAxisTypeGetZeroPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th zero point of the given quantized per-axis type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4443]||(e[4443]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7931-L7935",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",B2,[t("summary",null,[e[4445]||(e[4445]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeIsFixedPoint-Tuple{Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeIsFixedPoint-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeIsFixedPoint")],-1)),e[4446]||(e[4446]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4448]||(e[4448]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedPerAxisTypeIsFixedPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given uniform quantized per-axis type is fixed-point.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4447]||(e[4447]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7953-L7957",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",N2,[t("summary",null,[e[4449]||(e[4449]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGet-NTuple{10, Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGet-NTuple{10, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGet")],-1)),e[4450]||(e[4450]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4452]||(e[4452]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedSubChannelTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, storageType, expressedType, scalesAttr, zeroPointsAttr, blockSizeInfoLength, quantizedDimensions, blockSizes, storageTypeMin, storageTypeMax)</span></span></code></pre></div><p>Creates a UniformQuantizedSubChannelType with the given parameters.</p><p>The type is owned by the context. <code>scalesAttr</code> and <code>zeroPointsAttr</code> must be DenseElementsAttrs. <code>quantizedDimensions</code> and <code>blockSizes</code> point to <code>blockSizeInfoLength</code> number of elements, describing respectively the quantization axis and corresponding block size.</p>',3)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4451]||(e[4451]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7971-L7977",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",G2,[t("summary",null,[e[4453]||(e[4453]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetBlockSize-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetBlockSize-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetBlockSize")],-1)),e[4454]||(e[4454]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4456]||(e[4456]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedSubChannelTypeGetBlockSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns the block size at the given position.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4455]||(e[4455]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8026-L8030",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",z2,[t("summary",null,[e[4457]||(e[4457]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetNumBlockSizes-Tuple{Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetNumBlockSizes-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetNumBlockSizes")],-1)),e[4458]||(e[4458]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4460]||(e[4460]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedSubChannelTypeGetNumBlockSizes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of block sizes provided in type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4459]||(e[4459]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8004-L8008",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",w2,[t("summary",null,[e[4461]||(e[4461]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetQuantizedDimension-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetQuantizedDimension-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetQuantizedDimension")],-1)),e[4462]||(e[4462]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4464]||(e[4464]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedSubChannelTypeGetQuantizedDimension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns the quantized dimension at the given position.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4463]||(e[4463]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8015-L8019",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",U2,[t("summary",null,[e[4465]||(e[4465]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetScales-Tuple{Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetScales-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetScales")],-1)),e[4466]||(e[4466]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4468]||(e[4468]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedSubChannelTypeGetScales</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the scales of the quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4467]||(e[4467]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8037-L8041",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",q2,[t("summary",null,[e[4469]||(e[4469]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetZeroPoints-Tuple{Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetZeroPoints-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedSubChannelTypeGetZeroPoints")],-1)),e[4470]||(e[4470]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4472]||(e[4472]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedSubChannelTypeGetZeroPoints</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the zero-points of the quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4471]||(e[4471]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L8046-L8050",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Q2,[t("summary",null,[e[4473]||(e[4473]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedTypeGet-NTuple{7, Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedTypeGet-NTuple{7, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedTypeGet")],-1)),e[4474]||(e[4474]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4476]||(e[4476]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, storageType, expressedType, scale, zeroPoint, storageTypeMin, storageTypeMax)</span></span></code></pre></div><p>Creates an instance of UniformQuantizedType with the given parameters in the same context as <code>storageType</code> and returns it. The instance is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4475]||(e[4475]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7827-L7831",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",W2,[t("summary",null,[e[4477]||(e[4477]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedTypeGetScale-Tuple{Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedTypeGetScale-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedTypeGetScale")],-1)),e[4478]||(e[4478]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4480]||(e[4480]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedTypeGetScale</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the scale of the given uniform quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4479]||(e[4479]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7846-L7850",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Z2,[t("summary",null,[e[4481]||(e[4481]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedTypeGetZeroPoint-Tuple{Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedTypeGetZeroPoint-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedTypeGetZeroPoint")],-1)),e[4482]||(e[4482]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4484]||(e[4484]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedTypeGetZeroPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the zero point of the given uniform quantized type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4483]||(e[4483]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7855-L7859",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",H2,[t("summary",null,[e[4485]||(e[4485]=t("a",{id:"Reactant.MLIR.API.mlirUniformQuantizedTypeIsFixedPoint-Tuple{Any}",href:"#Reactant.MLIR.API.mlirUniformQuantizedTypeIsFixedPoint-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUniformQuantizedTypeIsFixedPoint")],-1)),e[4486]||(e[4486]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4488]||(e[4488]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedTypeIsFixedPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given uniform quantized type is fixed-point.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4487]||(e[4487]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L7864-L7868",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",J2,[t("summary",null,[e[4489]||(e[4489]=t("a",{id:"Reactant.MLIR.API.mlirUnitAttrGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirUnitAttrGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUnitAttrGet")],-1)),e[4490]||(e[4490]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4492]||(e[4492]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnitAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a unit attribute in the given context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4491]||(e[4491]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4099-L4103",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",K2,[t("summary",null,[e[4493]||(e[4493]=t("a",{id:"Reactant.MLIR.API.mlirUnitAttrGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirUnitAttrGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUnitAttrGetTypeID")],-1)),e[4494]||(e[4494]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4496]||(e[4496]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnitAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a Unit attribute.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4495]||(e[4495]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4108-L4112",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$2,[t("summary",null,[e[4497]||(e[4497]=t("a",{id:"Reactant.MLIR.API.mlirUnmanagedDenseResourceElementsAttrGet-NTuple{8, Any}",href:"#Reactant.MLIR.API.mlirUnmanagedDenseResourceElementsAttrGet-NTuple{8, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUnmanagedDenseResourceElementsAttrGet")],-1)),e[4498]||(e[4498]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4500]||(e[4500]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnmanagedDenseResourceElementsAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, name, data, dataLength, dataAlignment, dataIsMutable, deleter, userData)</span></span></code></pre></div><p>Unlike the typed accessors below, constructs the attribute with a raw data buffer and no type/alignment checking. Use a more strongly typed accessor if possible. If dataIsMutable is false, then an immutable AsmResourceBlob will be created and that passed data contents will be treated as const. If the deleter is non NULL, then it will be called when the data buffer can no longer be accessed (passing userData to it).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4499]||(e[4499]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L4661-L4665",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",X2,[t("summary",null,[e[4501]||(e[4501]=t("a",{id:"Reactant.MLIR.API.mlirUnrankedMemRefTypeGet-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirUnrankedMemRefTypeGet-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUnrankedMemRefTypeGet")],-1)),e[4502]||(e[4502]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4504]||(e[4504]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedMemRefTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, memorySpace)</span></span></code></pre></div><p>Creates an Unranked MemRef type with the given element type and in the given memory space. The type is owned by the context of element type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4503]||(e[4503]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5980-L5984",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Y2,[t("summary",null,[e[4505]||(e[4505]=t("a",{id:"Reactant.MLIR.API.mlirUnrankedMemRefTypeGetChecked-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirUnrankedMemRefTypeGetChecked-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUnrankedMemRefTypeGetChecked")],-1)),e[4506]||(e[4506]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4508]||(e[4508]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedMemRefTypeGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, elementType, memorySpace)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirUnrankedMemRefTypeGet-Tuple{Any, Any}"><code>mlirUnrankedMemRefTypeGet</code></a>&quot; but returns a nullptr wrapping <a href="./@ref"><code>MlirType</code></a> on illegal arguments, emitting appropriate diagnostics.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4507]||(e[4507]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5991-L5995",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",eR,[t("summary",null,[e[4509]||(e[4509]=t("a",{id:"Reactant.MLIR.API.mlirUnrankedMemRefTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirUnrankedMemRefTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUnrankedMemRefTypeGetTypeID")],-1)),e[4510]||(e[4510]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4512]||(e[4512]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedMemRefTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an UnrankedMemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4511]||(e[4511]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5902-L5906",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",tR,[t("summary",null,[e[4513]||(e[4513]=t("a",{id:"Reactant.MLIR.API.mlirUnrankedMemrefGetMemorySpace-Tuple{Any}",href:"#Reactant.MLIR.API.mlirUnrankedMemrefGetMemorySpace-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUnrankedMemrefGetMemorySpace")],-1)),e[4514]||(e[4514]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4516]||(e[4516]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedMemrefGetMemorySpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the memory spcae of the given Unranked MemRef type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4515]||(e[4515]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L6040-L6044",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",sR,[t("summary",null,[e[4517]||(e[4517]=t("a",{id:"Reactant.MLIR.API.mlirUnrankedTensorTypeGet-Tuple{Any}",href:"#Reactant.MLIR.API.mlirUnrankedTensorTypeGet-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUnrankedTensorTypeGet")],-1)),e[4518]||(e[4518]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4520]||(e[4520]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedTensorTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType)</span></span></code></pre></div><p>Creates an unranked tensor type with the given element type in the same context as the element type. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4519]||(e[4519]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5864-L5868",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",aR,[t("summary",null,[e[4521]||(e[4521]=t("a",{id:"Reactant.MLIR.API.mlirUnrankedTensorTypeGetChecked-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirUnrankedTensorTypeGetChecked-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUnrankedTensorTypeGetChecked")],-1)),e[4522]||(e[4522]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4524]||(e[4524]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedTensorTypeGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, elementType)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirUnrankedTensorTypeGet-Tuple{Any}"><code>mlirUnrankedTensorTypeGet</code></a>&quot; but returns a nullptr wrapping <a href="./@ref"><code>MlirType</code></a> on illegal arguments, emitting appropriate diagnostics.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4523]||(e[4523]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5873-L5877",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",iR,[t("summary",null,[e[4525]||(e[4525]=t("a",{id:"Reactant.MLIR.API.mlirUnrankedTensorTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirUnrankedTensorTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirUnrankedTensorTypeGetTypeID")],-1)),e[4526]||(e[4526]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4528]||(e[4528]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedTensorTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an UnrankedTensor type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4527]||(e[4527]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5811-L5815",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",lR,[t("summary",null,[e[4529]||(e[4529]=t("a",{id:"Reactant.MLIR.API.mlirValueDump-Tuple{Any}",href:"#Reactant.MLIR.API.mlirValueDump-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValueDump")],-1)),e[4530]||(e[4530]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4532]||(e[4532]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Prints the value to the standard error stream.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4531]||(e[4531]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2246-L2250",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",nR,[t("summary",null,[e[4533]||(e[4533]=t("a",{id:"Reactant.MLIR.API.mlirValueEqual-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirValueEqual-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValueEqual")],-1)),e[4534]||(e[4534]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4536]||(e[4536]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value1, value2)</span></span></code></pre></div><p>Returns 1 if two values are equal, 0 otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4535]||(e[4535]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2156-L2160",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",rR,[t("summary",null,[e[4537]||(e[4537]=t("a",{id:"Reactant.MLIR.API.mlirValueGetContext-Tuple{Any}",href:"#Reactant.MLIR.API.mlirValueGetContext-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValueGetContext")],-1)),e[4538]||(e[4538]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4540]||(e[4540]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v)</span></span></code></pre></div><p>Gets the context that a value was created with.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4539]||(e[4539]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2321-L2325",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",oR,[t("summary",null,[e[4541]||(e[4541]=t("a",{id:"Reactant.MLIR.API.mlirValueGetFirstUse-Tuple{Any}",href:"#Reactant.MLIR.API.mlirValueGetFirstUse-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValueGetFirstUse")],-1)),e[4542]||(e[4542]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4544]||(e[4544]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueGetFirstUse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns an op operand representing the first use of the value, or a null op operand if there are no uses.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4543]||(e[4543]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2280-L2284",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pR,[t("summary",null,[e[4545]||(e[4545]=t("a",{id:"Reactant.MLIR.API.mlirValueGetLocation-Tuple{Any}",href:"#Reactant.MLIR.API.mlirValueGetLocation-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValueGetLocation")],-1)),e[4546]||(e[4546]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4548]||(e[4548]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueGetLocation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v)</span></span></code></pre></div><p>Gets the location of the value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4547]||(e[4547]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2312-L2316",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",dR,[t("summary",null,[e[4549]||(e[4549]=t("a",{id:"Reactant.MLIR.API.mlirValueGetType-Tuple{Any}",href:"#Reactant.MLIR.API.mlirValueGetType-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValueGetType")],-1)),e[4550]||(e[4550]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4552]||(e[4552]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueGetType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the type of the value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4551]||(e[4551]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2228-L2232",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",uR,[t("summary",null,[e[4553]||(e[4553]=t("a",{id:"Reactant.MLIR.API.mlirValueIsABlockArgument-Tuple{Any}",href:"#Reactant.MLIR.API.mlirValueIsABlockArgument-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValueIsABlockArgument")],-1)),e[4554]||(e[4554]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4556]||(e[4556]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueIsABlockArgument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns 1 if the value is a block argument, 0 otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4555]||(e[4555]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2165-L2169",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",bR,[t("summary",null,[e[4557]||(e[4557]=t("a",{id:"Reactant.MLIR.API.mlirValueIsAOpResult-Tuple{Any}",href:"#Reactant.MLIR.API.mlirValueIsAOpResult-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValueIsAOpResult")],-1)),e[4558]||(e[4558]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4560]||(e[4560]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueIsAOpResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns 1 if the value is an operation result, 0 otherwise.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4559]||(e[4559]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2174-L2178",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",cR,[t("summary",null,[e[4561]||(e[4561]=t("a",{id:"Reactant.MLIR.API.mlirValueIsNull-Tuple{Any}",href:"#Reactant.MLIR.API.mlirValueIsNull-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValueIsNull")],-1)),e[4562]||(e[4562]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4564]||(e[4564]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns whether the value is null.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4563]||(e[4563]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2147-L2151",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",hR,[t("summary",null,[e[4565]||(e[4565]=t("a",{id:"Reactant.MLIR.API.mlirValuePrint-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirValuePrint-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValuePrint")],-1)),e[4566]||(e[4566]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4568]||(e[4568]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValuePrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, callback, userData)</span></span></code></pre></div><p>Prints a value by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4567]||(e[4567]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2255-L2259",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",yR,[t("summary",null,[e[4569]||(e[4569]=t("a",{id:"Reactant.MLIR.API.mlirValuePrintAsOperand-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirValuePrintAsOperand-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValuePrintAsOperand")],-1)),e[4570]||(e[4570]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4572]||(e[4572]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValuePrintAsOperand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, state, callback, userData)</span></span></code></pre></div><p>Prints a value as an operand (i.e., the ValueID).</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4571]||(e[4571]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2266-L2270",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",gR,[t("summary",null,[e[4573]||(e[4573]=t("a",{id:"Reactant.MLIR.API.mlirValueReplaceAllUsesExcept-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirValueReplaceAllUsesExcept-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValueReplaceAllUsesExcept")],-1)),e[4574]||(e[4574]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4576]||(e[4576]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueReplaceAllUsesExcept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(of, with, numExceptions, exceptions)</span></span></code></pre></div><p>Replace all uses of &#39;of&#39; value with &#39;with&#39; value, updating anything in the IR that uses &#39;of&#39; to use &#39;with&#39; instead, except if the user is listed in &#39;exceptions&#39;. The &#39;exceptions&#39; parameter is an array of <a href="./@ref"><code>MlirOperation</code></a> pointers with a length of &#39;numExceptions&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4575]||(e[4575]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2298-L2302",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",mR,[t("summary",null,[e[4577]||(e[4577]=t("a",{id:"Reactant.MLIR.API.mlirValueReplaceAllUsesOfWith-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirValueReplaceAllUsesOfWith-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValueReplaceAllUsesOfWith")],-1)),e[4578]||(e[4578]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4580]||(e[4580]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueReplaceAllUsesOfWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(of, with)</span></span></code></pre></div><p>Replace all uses of &#39;of&#39; value with the &#39;with&#39; value, updating anything in the IR that uses &#39;of&#39; to use the other value instead. When this returns there are zero uses of &#39;of&#39;.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4579]||(e[4579]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2289-L2293",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",kR,[t("summary",null,[e[4581]||(e[4581]=t("a",{id:"Reactant.MLIR.API.mlirValueSetType-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirValueSetType-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirValueSetType")],-1)),e[4582]||(e[4582]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4584]||(e[4584]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueSetType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, type)</span></span></code></pre></div><p>Set the type of the value.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4583]||(e[4583]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L2237-L2241",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",RR,[t("summary",null,[e[4585]||(e[4585]=t("a",{id:"Reactant.MLIR.API.mlirVectorTypeGet-Tuple{Any, Any, Any}",href:"#Reactant.MLIR.API.mlirVectorTypeGet-Tuple{Any, Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirVectorTypeGet")],-1)),e[4586]||(e[4586]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4588]||(e[4588]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rank, shape, elementType)</span></span></code></pre></div><p>Creates a vector type of the shape identified by its rank and dimensions, with the given element type in the same context as the element type. The type is owned by the context.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4587]||(e[4587]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5718-L5722",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fR,[t("summary",null,[e[4589]||(e[4589]=t("a",{id:"Reactant.MLIR.API.mlirVectorTypeGetChecked-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirVectorTypeGetChecked-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirVectorTypeGetChecked")],-1)),e[4590]||(e[4590]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4592]||(e[4592]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, rank, shape, elementType)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirVectorTypeGet-Tuple{Any, Any, Any}"><code>mlirVectorTypeGet</code></a>&quot; but returns a nullptr wrapping <a href="./@ref"><code>MlirType</code></a> on illegal arguments, emitting appropriate diagnostics.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4591]||(e[4591]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5729-L5733",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",IR,[t("summary",null,[e[4593]||(e[4593]=t("a",{id:"Reactant.MLIR.API.mlirVectorTypeGetScalable-NTuple{4, Any}",href:"#Reactant.MLIR.API.mlirVectorTypeGetScalable-NTuple{4, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirVectorTypeGetScalable")],-1)),e[4594]||(e[4594]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4596]||(e[4596]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeGetScalable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rank, shape, scalable, elementType)</span></span></code></pre></div><p>Creates a scalable vector type with the shape identified by its rank and dimensions. A subset of dimensions may be marked as scalable via the corresponding flag list, which is expected to have as many entries as the rank of the vector. The vector is created in the same context as the element type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4595]||(e[4595]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5740-L5744",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",TR,[t("summary",null,[e[4597]||(e[4597]=t("a",{id:"Reactant.MLIR.API.mlirVectorTypeGetScalableChecked-NTuple{5, Any}",href:"#Reactant.MLIR.API.mlirVectorTypeGetScalableChecked-NTuple{5, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirVectorTypeGetScalableChecked")],-1)),e[4598]||(e[4598]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4600]||(e[4600]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeGetScalableChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, rank, shape, scalable, elementType)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/dev/api/mlirc#Reactant.MLIR.API.mlirVectorTypeGetScalable-NTuple{4, Any}"><code>mlirVectorTypeGetScalable</code></a>&quot; but returns a nullptr wrapping <a href="./@ref"><code>MlirType</code></a> on illegal arguments, emitting appropriate diagnostics.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4599]||(e[4599]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5751-L5755",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",AR,[t("summary",null,[e[4601]||(e[4601]=t("a",{id:"Reactant.MLIR.API.mlirVectorTypeGetTypeID-Tuple{}",href:"#Reactant.MLIR.API.mlirVectorTypeGetTypeID-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirVectorTypeGetTypeID")],-1)),e[4602]||(e[4602]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4604]||(e[4604]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Vector type.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4603]||(e[4603]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5700-L5704",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",jR,[t("summary",null,[e[4605]||(e[4605]=t("a",{id:"Reactant.MLIR.API.mlirVectorTypeIsDimScalable-Tuple{Any, Any}",href:"#Reactant.MLIR.API.mlirVectorTypeIsDimScalable-Tuple{Any, Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirVectorTypeIsDimScalable")],-1)),e[4606]||(e[4606]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4608]||(e[4608]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeIsDimScalable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, dim)</span></span></code></pre></div><p>Checks whether the &quot;dim&quot;-th dimension of the given vector is scalable.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4607]||(e[4607]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5775-L5779",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_R,[t("summary",null,[e[4609]||(e[4609]=t("a",{id:"Reactant.MLIR.API.mlirVectorTypeIsScalable-Tuple{Any}",href:"#Reactant.MLIR.API.mlirVectorTypeIsScalable-Tuple{Any}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.API.mlirVectorTypeIsScalable")],-1)),e[4610]||(e[4610]=i()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[4612]||(e[4612]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeIsScalable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given vector type is scalable, i.e., has at least one scalable dimension.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[4611]||(e[4611]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ccd6fb985b86be4f2d739a238ba4029e1ae0da35/src/mlir/libMLIR_h.jl#L5766-L5770",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[4615]||(e[4615]=t("h1",{id:"Other-Functions",tabindex:"-1"},[i("Other Functions "),t("a",{class:"header-anchor",href:"#Other-Functions","aria-label":'Permalink to "Other Functions {#Other-Functions}"'},"​")],-1))])}const DR=r(u,[["render",MR]]);export{SR as __pageData,DR as default};
