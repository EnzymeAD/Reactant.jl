import{_ as i,C as r,o as u,c as d,j as t,a,E as n,w as s,al as o}from"./chunks/framework.DjEp87BS.js";const J=JSON.parse('{"title":"Enzyme Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/enzyme.md","filePath":"api/dialects/enzyme.md","lastUpdated":null}'),R={name:"api/dialects/enzyme.md"},p={class:"jldocstring custom-block"},c={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},M={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},z={class:"jldocstring custom-block"},D={class:"jldocstring custom-block"},V={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},x={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"},E={class:"jldocstring custom-block"},A={class:"jldocstring custom-block"},w={class:"jldocstring custom-block"},v={class:"jldocstring custom-block"},O={class:"jldocstring custom-block"},N={class:"jldocstring custom-block"},C={class:"jldocstring custom-block"},S={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},B={class:"jldocstring custom-block"};function G(P,e,U,F,X,$){const l=r("Badge");return u(),d("div",null,[e[143]||(e[143]=t("h1",{id:"Enzyme-Dialect",tabindex:"-1"},[a("Enzyme Dialect "),t("a",{class:"header-anchor",href:"#Enzyme-Dialect","aria-label":'Permalink to "Enzyme Dialect {#Enzyme-Dialect}"'},"​")],-1)),t("details",p,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addTo-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.addTo-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addTo")],-1)),e[1]||(e[1]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=t("p",null,[t("code",null,"addTo")],-1)),e[4]||(e[4]=t("p",null,"TODO",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L16-L20",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",c,[t("summary",null,[e[5]||(e[5]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.broadcast-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.broadcast-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.broadcast")],-1)),e[6]||(e[6]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[8]||(e[8]=t("p",null,[t("code",null,"broadcast")],-1)),e[9]||(e[9]=t("p",null,[a("Broadcast the operand by adding extra dimensions with sizes provided by the "),t("code",null,"shape"),a(" attribute to the front. For scalar operands, ranked tensor is created.")],-1)),e[10]||(e[10]=t("p",null,[a("NOTE: Only works for scalar and "),t("em",null,"ranked"),a(" tensor operands for now.")],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[7]||(e[7]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L158-L165",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",m,[t("summary",null,[e[11]||(e[11]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.cholesky-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.cholesky-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.cholesky")],-1)),e[12]||(e[12]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[14]||(e[14]=t("p",null,[t("code",null,"cholesky")],-1)),e[15]||(e[15]=t("p",null,"Computes the Cholesky decomposition of a symmetric positive definite matrix A. Returns L such that A = L @ L^T (if lower=true) or A = U^T @ U (if lower=false).",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[13]||(e[13]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L185-L190",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[16]||(e[16]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.concat-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.concat-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.concat")],-1)),e[17]||(e[17]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[19]||(e[19]=t("p",null,[t("code",null,"concat")],-1)),e[20]||(e[20]=t("p",null,"Concat list of input arguments into a generic value",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[18]||(e[18]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L211-L215",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b,[t("summary",null,[e[21]||(e[21]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.dot-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.dot-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.dot")],-1)),e[22]||(e[22]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[24]||(e[24]=t("p",null,[t("code",null,"dot")],-1)),e[25]||(e[25]=t("p",null,[a("Computes a general dot product operation. To be lowered to "),t("code",null,"stablehlo.dot_general"),a(".")],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[23]||(e[23]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L235-L239",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y,[t("summary",null,[e[26]||(e[26]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.dump-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.dump-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.dump")],-1)),e[27]||(e[27]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[29]||(e[29]=t("p",null,[t("code",null,"dump")],-1)),e[30]||(e[30]=t("p",null,"Debug operation that dumps a tensor value with a label.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[28]||(e[28]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L273-L277",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I,[t("summary",null,[e[31]||(e[31]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.dynamic_slice-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.dynamic_slice-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.dynamic_slice")],-1)),e[32]||(e[32]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[34]||(e[34]=t("p",null,[t("code",null,"dynamic_slice")],-1)),e[35]||(e[35]=t("p",null,"Extract a slice from a tensor at dynamic start indices.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[33]||(e[33]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L297-L301",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",L,[t("summary",null,[e[36]||(e[36]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.dynamic_update_slice-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.dynamic_update_slice-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.dynamic_update_slice")],-1)),e[37]||(e[37]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[39]||(e[39]=t("p",null,[t("code",null,"dynamic_update_slice")],-1)),e[40]||(e[40]=t("p",null,"Update a slice in a tensor at dynamic start indices.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[38]||(e[38]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L327-L331",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",M,[t("summary",null,[e[41]||(e[41]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.extract-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.extract-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.extract")],-1)),e[42]||(e[42]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[44]||(e[44]=t("p",null,[t("code",null,"extract")],-1)),e[45]||(e[45]=t("p",null,"Extract value from batched operand at index",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[43]||(e[43]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L357-L361",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[46]||(e[46]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.for_loop-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.for_loop-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.for_loop")],-1)),e[47]||(e[47]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[49]||(e[49]=t("p",null,[t("code",null,"for_loop")],-1)),e[50]||(e[50]=t("p",null,[a("A counted loop operation that iterates from "),t("code",null,"lowerBound"),a(" to "),t("code",null,"upperBound"),a(" by "),t("code",null,"step"),a(", carrying "),t("code",null,"iter_args"),a(" through each iteration. The iteration variable and iter_args are passed to the body region.")],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[48]||(e[48]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L381-L387",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",j,[t("summary",null,[e[51]||(e[51]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.generate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.generate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.generate")],-1)),e[52]||(e[52]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[54]||(e[54]=t("p",null,[t("code",null,"generate")],-1)),e[55]||(e[55]=t("p",null,"Generates from a generative function with some addresses constrained. The constraint tensor contains flattened constrained values in the order specified by constrained_addresses.",-1)),e[56]||(e[56]=t("p",null,"Returns: (trace, weight, rng, retvals...)",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[53]||(e[53]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L483-L491",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",z,[t("summary",null,[e[57]||(e[57]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.if_-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.if_-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.if_")],-1)),e[58]||(e[58]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[60]||(e[60]=t("p",null,[t("code",null,"if_")],-1)),e[61]||(e[61]=t("p",null,"A conditional operation that executes exactly one of two branches based on a boolean predicate.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[59]||(e[59]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L582-L587",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",D,[t("summary",null,[e[62]||(e[62]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.log_add_exp-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.log_add_exp-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.log_add_exp")],-1)),e[63]||(e[63]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[65]||(e[65]=t("p",null,[t("code",null,"log_add_exp")],-1)),e[66]||(e[66]=t("p",null,"Computes log(exp(x) + exp(y)).",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[64]||(e[64]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L670-L674",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",V,[t("summary",null,[e[67]||(e[67]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.logistic-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.logistic-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.logistic")],-1)),e[68]||(e[68]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[70]||(e[70]=t("p",null,[t("code",null,"logistic")],-1)),e[71]||(e[71]=t("p",null,"Computes the logistic (sigmoid) function: 1 / (1 + exp(-x)).",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[69]||(e[69]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L694-L698",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",T,[t("summary",null,[e[72]||(e[72]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.mcmc",href:"#Reactant.MLIR.Dialects.enzyme.mcmc"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.mcmc")],-1)),e[73]||(e[73]=a()),n(l,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[75]||(e[75]=o("<p><code>mcmc</code></p><p>Runs MCMC inference on selected addresses.</p><p>Two modes of operation:</p><ol><li><p>Trace-based mode: <code>fn</code> and <code>original_trace</code> are provided. The model function with <code>enzyme.sample</code> ops defines the density.</p></li><li><p>Custom logpdf mode: <code>logpdf_fn</code> and <code>initial_position</code> are provided. The logpdf function maps position → scalar log-density directly.</p></li></ol><p>The <code>selection</code> attribute determines which addresses to sample via HMC/NUTS. All sample addresses are included in the trace tensor for consistency.</p><p>Returns: (trace, diagnostics, rng)</p><ul><li><p>trace: tensor&lt;num_samples x position_size x f64&gt;</p></li><li><p>diagnostics: tensor&lt;num_samples x i1&gt; - placeholder for future expansion</p></li><li><p>rng: updated RNG state</p></li></ul>",7)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[74]||(e[74]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L718-L736",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",x,[t("summary",null,[e[76]||(e[76]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.mh-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.mh-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.mh")],-1)),e[77]||(e[77]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[79]||(e[79]=t("p",null,[t("code",null,"mh")],-1)),e[80]||(e[80]=t("p",null,"Performs one MH step: regenerates selected addresses and accepts/rejects based on weight ratio.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[78]||(e[78]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L801-L806",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",k,[t("summary",null,[e[81]||(e[81]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.popcount-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.popcount-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.popcount")],-1)),e[82]||(e[82]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[84]||(e[84]=t("p",null,[t("code",null,"popcount")],-1)),e[85]||(e[85]=t("p",null,"Returns the number of 1-bits elementwise.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[83]||(e[83]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L882-L886",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",E,[t("summary",null,[e[86]||(e[86]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.random-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.random-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.random")],-1)),e[87]||(e[87]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[89]||(e[89]=t("p",null,[t("code",null,"random")],-1)),e[90]||(e[90]=t("p",null,"Generates random numbers using the rng_distribution algorithm and produces a result tensor.",-1)),e[91]||(e[91]=t("p",null,"If rng_distribution = UNIFORM, then the random numbers are generated following the uniform distribution over the interval [a, b). If a >= b, the behavior is undefined.",-1)),e[92]||(e[92]=t("p",null,"If rng_distribution = NORMAL, then the random numbers are generated following the normal distribution with mean = a and standard deviation = b. If b < 0, the behavior is undefined.",-1)),e[93]||(e[93]=t("p",null,"If rng_distribution = MULTINORMAL, then the random numbers are generated following the multivariate normal distribution with mean = a (scalar or vector) and covariance matrix = b. The parameter b should be a positive definite matrix.",-1)),e[94]||(e[94]=t("p",null,"By convention, the 0th operand in inputs is the initial RNG state and the 0th operand in results is the updated RNG state.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[88]||(e[88]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L925-L945",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",A,[t("summary",null,[e[95]||(e[95]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.randomSplit-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.randomSplit-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.randomSplit")],-1)),e[96]||(e[96]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[98]||(e[98]=t("p",null,[t("code",null,"randomSplit")],-1)),e[99]||(e[99]=t("p",null,[a("Splits an RNG state into multiple independent RNG states. Reference: "),t("a",{href:"https://github.com/jax-ml/jax/blob/c25e095fcec9678a4ce5f723afce0c6a3c48a5e7/jax/_src/random.py#L281-L294",target:"_blank",rel:"noreferrer"},"https://github.com/jax-ml/jax/blob/c25e095fcec9678a4ce5f723afce0c6a3c48a5e7/jax/_src/random.py#L281-L294")],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[97]||(e[97]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L973-L978",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",w,[t("summary",null,[e[100]||(e[100]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.regenerate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.regenerate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.regenerate")],-1)),e[101]||(e[101]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[103]||(e[103]=t("p",null,[t("code",null,"regenerate")],-1)),e[104]||(e[104]=t("p",null,"Regenerates selected addresses while keeping others fixed. Used internally by MH.",-1)),e[105]||(e[105]=t("p",null,"Takes explicit old_trace and returns new trace with weight.",-1)),e[106]||(e[106]=t("p",null,"Returns: (new_trace, weight, retvals...)",-1)),e[107]||(e[107]=t("ul",null,[t("li",null,[t("p",null,"new_trace: tensor<1 x position_size x f64> - flattened samples")]),t("li",null,[t("p",null,"weight: tensor<f64> - accumulated log probability")]),t("li",null,[t("p",null,"retvals: original function return values")])],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[102]||(e[102]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L1000-L1012",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",v,[t("summary",null,[e[108]||(e[108]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.sample-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.sample-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.sample")],-1)),e[109]||(e[109]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[111]||(e[111]=t("p",null,[t("code",null,"sample")],-1)),e[112]||(e[112]=t("p",null,[a("Sample from a distribution. By convention, the 0th operand in "),t("code",null,"inputs"),a(" or "),t("code",null,"outputs"),a(" is the initial RNG state (seed).")],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[110]||(e[110]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L1067-L1072",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",O,[t("summary",null,[e[113]||(e[113]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.select")],-1)),e[114]||(e[114]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[116]||(e[116]=t("p",null,[t("code",null,"select")],-1)),e[117]||(e[117]=t("p",null,"Extended select operation that supports:",-1)),e[118]||(e[118]=t("ul",null,[t("li",null,[t("p",null,[t("code",null,"tensor<i1>"),a(" conditions with differently-sized operands")])]),t("li",null,[t("p",null,[a("standard cases supported by "),t("code",null,"arith.select")])])],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[115]||(e[115]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L1105-L1111",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",N,[t("summary",null,[e[119]||(e[119]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.simulate-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.simulate-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.simulate")],-1)),e[120]||(e[120]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[122]||(e[122]=o("<p><code>simulate</code></p><p>Simulates a generative function, building a trace tensor containing all sampled values and computing the accumulated log probability weight.</p><p>The <code>selection</code> attribute specifies all sample addresses in order, determining the trace tensor layout.</p><p>Returns: (trace, weight, rng, retvals...)</p><ul><li><p>trace: tensor&lt;1 x position_size x f64&gt; - flattened samples</p></li><li><p>weight: tensor&lt;f64&gt; - accumulated log probability</p></li><li><p>rng: updated RNG state</p></li><li><p>retvals: original function return values</p></li></ul>",5)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[121]||(e[121]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L1156-L1170",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",C,[t("summary",null,[e[123]||(e[123]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.slice-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.slice-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.slice")],-1)),e[124]||(e[124]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[126]||(e[126]=t("p",null,[t("code",null,"slice")],-1)),e[127]||(e[127]=t("p",null,"Extract a static slice from a tensor.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[125]||(e[125]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L1202-L1206",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",S,[t("summary",null,[e[128]||(e[128]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.triangular_solve-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.triangular_solve-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.triangular_solve")],-1)),e[129]||(e[129]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[131]||(e[131]=t("p",null,[t("code",null,"triangular_solve")],-1)),e[132]||(e[132]=t("p",null,"Solves a system of linear equations with a triangular coefficient matrix. If left_side=true, solves op(A) @ X = B for X. If left_side=false, solves X @ op(A) = B for X. op(A) is determined by transpose_a: NO_TRANSPOSE, TRANSPOSE, or ADJOINT.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[130]||(e[130]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L1256-L1263",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",h,[t("summary",null,[e[133]||(e[133]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.untracedCall-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.untracedCall-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.untracedCall")],-1)),e[134]||(e[134]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[136]||(e[136]=t("p",null,[t("code",null,"untracedCall")],-1)),e[137]||(e[137]=t("p",null,[a("Call a probabilistic function without tracing. By convention, the 0th operand in "),t("code",null,"inputs"),a(" or "),t("code",null,"outputs"),a(" is the initial RNG state (seed).")],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[135]||(e[135]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L1297-L1302",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",B,[t("summary",null,[e[138]||(e[138]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.while_loop-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.while_loop-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.while_loop")],-1)),e[139]||(e[139]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[141]||(e[141]=t("p",null,[t("code",null,"while_loop")],-1)),e[142]||(e[142]=t("p",null,[a("A while loop operation that continues iterating as long as the condition evaluates to true. Intended to be lowered to "),t("code",null,"stablehlo.while"),a(".")],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[140]||(e[140]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2b0405c6b96454365113ef4fe73923851812dd44/src/mlir/Dialects/Enzyme.jl#L1325-L1330",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const q=i(R,[["render",G]]);export{J as __pageData,q as default};
