import{_ as i,C as d,c as r,o as p,j as t,a as o,al as l,G as a,w as n}from"./chunks/framework.BwggG5wH.js";const A=JSON.parse('{"title":"Shardy Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/shardy.md","filePath":"api/dialects/shardy.md","lastUpdated":null}'),c={name:"api/dialects/shardy.md"},u={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},_={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},x={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},v={class:"jldocstring custom-block"},M={class:"jldocstring custom-block"};function j(L,e,D,k,q,w){const s=d("Badge");return p(),r("div",null,[e[66]||(e[66]=t("h1",{id:"Shardy-Dialect",tabindex:"-1"},[o("Shardy Dialect "),t("a",{class:"header-anchor",href:"#Shardy-Dialect","aria-label":'Permalink to "Shardy Dialect {#Shardy-Dialect}"'},"â€‹")],-1)),e[67]||(e[67]=t("p",null,[o("Refer to the "),t("a",{href:"https://openxla.org/shardy",target:"_blank",rel:"noreferrer"},"official documentation"),o(" for more details.")],-1)),t("details",u,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.sdy.all_gather-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.sdy.all_gather-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.all_gather")],-1)),e[1]||(e[1]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=l("",8)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L16-L43",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[2]})]),t("details",h,[t("summary",null,[e[4]||(e[4]=t("a",{id:"Reactant.MLIR.Dialects.sdy.all_reduce-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.sdy.all_reduce-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.all_reduce")],-1)),e[5]||(e[5]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[7]||(e[7]=l("",4)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[6]||(e[6]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L73-L84",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[6]})]),t("details",g,[t("summary",null,[e[8]||(e[8]=t("a",{id:"Reactant.MLIR.Dialects.sdy.all_slice-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.sdy.all_slice-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.all_slice")],-1)),e[9]||(e[9]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[11]||(e[11]=l("",8)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[10]||(e[10]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L114-L142",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[10]})]),t("details",m,[t("summary",null,[e[12]||(e[12]=t("a",{id:"Reactant.MLIR.Dialects.sdy.all_to_all-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.sdy.all_to_all-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.all_to_all")],-1)),e[13]||(e[13]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[15]||(e[15]=l("",9)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[14]||(e[14]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L172-L210",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[14]})]),t("details",f,[t("summary",null,[e[16]||(e[16]=t("a",{id:"Reactant.MLIR.Dialects.sdy.collective_permute-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.sdy.collective_permute-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.collective_permute")],-1)),e[17]||(e[17]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[19]||(e[19]=l("",9)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[18]||(e[18]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L239-L269",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[18]})]),t("details",b,[t("summary",null,[e[20]||(e[20]=t("a",{id:"Reactant.MLIR.Dialects.sdy.constant-Tuple{}",href:"#Reactant.MLIR.Dialects.sdy.constant-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.constant")],-1)),e[21]||(e[21]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[23]||(e[23]=l("",6)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[22]||(e[22]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L292-L310",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[22]})]),t("details",y,[t("summary",null,[e[24]||(e[24]=t("a",{id:"Reactant.MLIR.Dialects.sdy.data_flow_edge-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.sdy.data_flow_edge-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.data_flow_edge")],-1)),e[25]||(e[25]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[27]||(e[27]=l("",12)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[26]||(e[26]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L331-L386",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[26]})]),t("details",_,[t("summary",null,[e[28]||(e[28]=t("a",{id:"Reactant.MLIR.Dialects.sdy.manual_computation-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.sdy.manual_computation-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.manual_computation")],-1)),e[29]||(e[29]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[31]||(e[31]=l("",5)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[30]||(e[30]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L413-L431",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[30]})]),t("details",R,[t("summary",null,[e[32]||(e[32]=t("a",{id:"Reactant.MLIR.Dialects.sdy.mesh-Tuple{}",href:"#Reactant.MLIR.Dialects.sdy.mesh-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.mesh")],-1)),e[33]||(e[33]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[35]||(e[35]=t("p",null,[t("code",null,"mesh")],-1)),e[36]||(e[36]=t("p",null,[o("Defines a new named mesh. All meshes in a module must have the same number of devices (except for meshes with a single device_id). The mesh is a "),t("code",null,"Symbol"),o(" operation that appears in the module's "),t("code",null,"SymbolTable"),o(" and can be referenced by its "),t("code",null,"name"),o(".")],-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[34]||(e[34]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L463-L470",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[34]})]),t("details",x,[t("summary",null,[e[37]||(e[37]=t("a",{id:"Reactant.MLIR.Dialects.sdy.named_computation-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.sdy.named_computation-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.named_computation")],-1)),e[38]||(e[38]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[40]||(e[40]=l("",6)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[39]||(e[39]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L492-L513",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[39]})]),t("details",T,[t("summary",null,[e[41]||(e[41]=t("a",{id:"Reactant.MLIR.Dialects.sdy.propagation_barrier-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.sdy.propagation_barrier-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.propagation_barrier")],-1)),e[42]||(e[42]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[44]||(e[44]=l("",4)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[43]||(e[43]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L545-L559",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[43]})]),t("details",I,[t("summary",null,[e[45]||(e[45]=t("a",{id:"Reactant.MLIR.Dialects.sdy.reshard-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.sdy.reshard-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.reshard")],-1)),e[46]||(e[46]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[48]||(e[48]=t("p",null,[t("code",null,"reshard")],-1)),e[49]||(e[49]=t("p",null,"Reshards the input tensor with the specified sharding, which is different from the input tensor's existing sharding.",-1)),e[50]||(e[50]=t("p",null,"Both ShardingConstraintOp and ReshardOp attach a sharding to a tensor. Their lifespan is:",-1)),e[51]||(e[51]=t("ol",null,[t("li",null,[t("p",null,"Before sharding propagation, ShardingConstraintOp is added by users.")]),t("li",null,[t("p",null,"Sharding propagation consumes ShardingConstraintOp. There is no ShardingConstraintOp in the results of sharding propagation. Instead, ReshardOp may be added if needed.")]),t("li",null,[t("p",null,"A partitioner converts a ReshardOp into a collective op (or an identity op). There should be no ReshardOp in the results of the partitioner.")])],-1)),e[52]||(e[52]=t("p",null,"// TODO(b/331680067). Add a canonicalization pattern to remove redundant // reshard ops.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[47]||(e[47]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L585-L602",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[47]})]),t("details",v,[t("summary",null,[e[53]||(e[53]=t("a",{id:"Reactant.MLIR.Dialects.sdy.sharding_constraint-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.sdy.sharding_constraint-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.sharding_constraint")],-1)),e[54]||(e[54]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[56]||(e[56]=t("p",null,[t("code",null,"sharding_constraint")],-1)),e[57]||(e[57]=t("p",null,"Attaches a sharding to an intermediate tensor (e.g. the result of a matmul) to indicate that this is how that tensor, or a subset of its uses, should be sharded.",-1)),e[58]||(e[58]=t("p",null,"If the sharding has open dimensions and unconstraint axes, it means the tensor can be further sharded along the open dimensions.",-1)),e[59]||(e[59]=t("p",null,"This op can either:",-1)),e[60]||(e[60]=t("ul",null,[t("li",null,[t("p",null,"Have no uses (dangling) - which means the attached sharding is how the input tensor itself should be sharded.")]),t("li",null,[t("p",null,"Have uses - which means the attached sharding is how the uses of the sharding constraint op should be sharded, while other uses of the input tensor might have a different sharding (if the input tensor has no other uses then the behavior is the same as the no uses case).")])],-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[55]||(e[55]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L644-L661",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[55]})]),t("details",M,[t("summary",null,[e[61]||(e[61]=t("a",{id:"Reactant.MLIR.Dialects.sdy.sharding_group-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.sdy.sharding_group-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.sdy.sharding_group")],-1)),e[62]||(e[62]=o()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[64]||(e[64]=t("p",null,[t("code",null,"sharding_group")],-1)),e[65]||(e[65]=t("p",null,"This op provides an interface to assign tensors to sharding groups ( groups of tensors that will be enforced to have identical shardings). During propagation, as soon as one group element is sharded, all other members will be sharded in exactly the same way. This operation takes the argument group ID and returns no result, but instead modifies the internal sharding group representation to add the input tensor to the group with the given ID.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:n(()=>e[63]||(e[63]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/2bdedbd7917142e39c67a367042417c62f29b342/src/mlir/Dialects/Shardy.jl#L684-L694",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[63]})])])}const C=i(c,[["render",j]]);export{A as __pageData,C as default};
