import{_ as i,C as p,c as r,o as c,j as t,a as l,al as n,G as a,w as o}from"./chunks/framework.rCMFjQra.js";const yt=JSON.parse('{"title":"StableHLO Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/stablehlo.md","filePath":"api/dialects/stablehlo.md","lastUpdated":null}'),d={name:"api/dialects/stablehlo.md"},b={class:"jldocstring custom-block"},u={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},_={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},x={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},M={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},v={class:"jldocstring custom-block"},D={class:"jldocstring custom-block"},V={class:"jldocstring custom-block"},S={class:"jldocstring custom-block"},A={class:"jldocstring custom-block"},C={class:"jldocstring custom-block"},E={class:"jldocstring custom-block"},P={class:"jldocstring custom-block"},O={class:"jldocstring custom-block"},w={class:"jldocstring custom-block"},z={class:"jldocstring custom-block"},H={class:"jldocstring custom-block"},q={class:"jldocstring custom-block"},N={class:"jldocstring custom-block"},F={class:"jldocstring custom-block"},B={class:"jldocstring custom-block"},U={class:"jldocstring custom-block"},W={class:"jldocstring custom-block"},G={class:"jldocstring custom-block"},X={class:"jldocstring custom-block"},$={class:"jldocstring custom-block"},Y={class:"jldocstring custom-block"},J={class:"jldocstring custom-block"},K={class:"jldocstring custom-block"},Q={class:"jldocstring custom-block"},Z={class:"jldocstring custom-block"},ee={class:"jldocstring custom-block"},te={class:"jldocstring custom-block"},se={class:"jldocstring custom-block"},ae={class:"jldocstring custom-block"},le={class:"jldocstring custom-block"},ne={class:"jldocstring custom-block"},oe={class:"jldocstring custom-block"},ie={class:"jldocstring custom-block"},pe={class:"jldocstring custom-block"},re={class:"jldocstring custom-block"},ce={class:"jldocstring custom-block"},de={class:"jldocstring custom-block"},be={class:"jldocstring custom-block"},ue={class:"jldocstring custom-block"},he={class:"jldocstring custom-block"},me={class:"jldocstring custom-block"},ge={class:"jldocstring custom-block"},Re={class:"jldocstring custom-block"},_e={class:"jldocstring custom-block"},fe={class:"jldocstring custom-block"},Ie={class:"jldocstring custom-block"},xe={class:"jldocstring custom-block"},Te={class:"jldocstring custom-block"},Le={class:"jldocstring custom-block"},ye={class:"jldocstring custom-block"},Me={class:"jldocstring custom-block"},ke={class:"jldocstring custom-block"},je={class:"jldocstring custom-block"},ve={class:"jldocstring custom-block"},De={class:"jldocstring custom-block"},Ve={class:"jldocstring custom-block"},Se={class:"jldocstring custom-block"},Ae={class:"jldocstring custom-block"},Ce={class:"jldocstring custom-block"},Ee={class:"jldocstring custom-block"},Pe={class:"jldocstring custom-block"},Oe={class:"jldocstring custom-block"},we={class:"jldocstring custom-block"},ze={class:"jldocstring custom-block"},He={class:"jldocstring custom-block"},qe={class:"jldocstring custom-block"},Ne={class:"jldocstring custom-block"},Fe={class:"jldocstring custom-block"},Be={class:"jldocstring custom-block"},Ue={class:"jldocstring custom-block"},We={class:"jldocstring custom-block"},Ge={class:"jldocstring custom-block"},Xe={class:"jldocstring custom-block"},$e={class:"jldocstring custom-block"},Ye={class:"jldocstring custom-block"},Je={class:"jldocstring custom-block"},Ke={class:"jldocstring custom-block"},Qe={class:"jldocstring custom-block"},Ze={class:"jldocstring custom-block"},et={class:"jldocstring custom-block"},tt={class:"jldocstring custom-block"},st={class:"jldocstring custom-block"},at={class:"jldocstring custom-block"},lt={class:"jldocstring custom-block"},nt={class:"jldocstring custom-block"},ot={class:"jldocstring custom-block"},it={class:"jldocstring custom-block"},pt={class:"jldocstring custom-block"},rt={class:"jldocstring custom-block"},ct={class:"jldocstring custom-block"},dt={class:"jldocstring custom-block"},bt={class:"jldocstring custom-block"},ut={class:"jldocstring custom-block"},ht={class:"jldocstring custom-block"},mt={class:"jldocstring custom-block"},gt={class:"jldocstring custom-block"};function Rt(_t,e,ft,It,xt,Tt){const s=p("Badge");return c(),r("div",null,[e[452]||(e[452]=t("h1",{id:"StableHLO-Dialect",tabindex:"-1"},[l("StableHLO Dialect "),t("a",{class:"header-anchor",href:"#StableHLO-Dialect","aria-label":'Permalink to "StableHLO Dialect {#StableHLO-Dialect}"'},"â€‹")],-1)),e[453]||(e[453]=t("p",null,[l("Refer to the "),t("a",{href:"https://openxla.org/stablehlo",target:"_blank",rel:"noreferrer"},"official documentation"),l(" for more details.")],-1)),t("details",b,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.abs-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.abs-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.abs")],-1)),e[1]||(e[1]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=n('<p><code>abs</code></p><p>Performs element-wise abs operation on <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#abs" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#abs</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.abs %operand : tensor&lt;3xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L16-L29",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",u,[t("summary",null,[e[4]||(e[4]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.add-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.add-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.add")],-1)),e[5]||(e[5]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[7]||(e[7]=n('<p><code>add</code></p><p>Performs element-wise addition of two tensors <code>lhs</code> and <code>rhs</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#add" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#add</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.add %lhs, %rhs : tensor&lt;2x2xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[6]||(e[6]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L50-L63",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",h,[t("summary",null,[e[8]||(e[8]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.after_all-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.after_all-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.after_all")],-1)),e[9]||(e[9]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[11]||(e[11]=n('<p><code>after_all</code></p><p>Ensures that the operations producing the <code>inputs</code> are executed before any operations that depend on <code>result</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#after_all" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#after_all</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.after_all %input0, %input1 : !stablehlo.token</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[10]||(e[10]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L86-L99",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",m,[t("summary",null,[e[12]||(e[12]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.all_gather-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.all_gather-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.all_gather")],-1)),e[13]||(e[13]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[15]||(e[15]=n(`<p><code>all_gather</code></p><p>Within each process group in the process grid, concatenates the values of the <code>operand</code> tensor from each process along <code>all_gather_dim</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#all_gather" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#all_gather</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result:2 = &quot;stablehlo.all_gather&quot;(%operand0, %operand1) {</span></span>
<span class="line"><span>  all_gather_dim = 1 : i64,</span></span>
<span class="line"><span>  replica_groups = dense&lt;[[0, 1]]&gt; : tensor&lt;1x2xi64&gt;,</span></span>
<span class="line"><span>  channel_handle = #stablehlo.channel_handle&lt;handle = 0, type = 0&gt;</span></span>
<span class="line"><span>} : (tensor&lt;2x2xi64&gt;, tensor&lt;2x2xi64&gt;) -&gt; (tensor&lt;2x4xi64&gt;, tensor&lt;2x4xi64&gt;)</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[14]||(e[14]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L122-L140",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",g,[t("summary",null,[e[16]||(e[16]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.all_reduce-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.all_reduce-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.all_reduce")],-1)),e[17]||(e[17]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[19]||(e[19]=n(`<p><code>all_reduce</code></p><p>Within each process group in the process grid, applies a reduction function <code>computation</code> to the values of the <code>operand</code> tensor from each process and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#all_reduce" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#all_reduce</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result:2 = &quot;stablehlo.all_reduce&quot;(%operand0, %operand0) ({</span></span>
<span class="line"><span>  ^bb0(%arg0: tensor&lt;i64&gt;, %arg1: tensor&lt;i64&gt;):</span></span>
<span class="line"><span>  %0 = &quot;stablehlo.add&quot;(%arg0, %arg1) : (tensor&lt;i64&gt;, tensor&lt;i64&gt;) -&gt; tensor&lt;i64&gt;</span></span>
<span class="line"><span>  &quot;stablehlo.return&quot;(%0) : (tensor&lt;i64&gt;) -&gt; ()</span></span>
<span class="line"><span>}) {</span></span>
<span class="line"><span>  replica_groups = dense&lt;[[0, 1]]&gt; : tensor&lt;1x2xi64&gt;,</span></span>
<span class="line"><span>  channel_handle = #stablehlo.channel_handle&lt;handle = 0, type = 0&gt;</span></span>
<span class="line"><span>} : (tensor&lt;4xi64&gt;, tensor&lt;4xi64&gt;) -&gt; (tensor&lt;4xi64&gt;, tensor&lt;4xi64&gt;)</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[18]||(e[18]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L175-L196",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",R,[t("summary",null,[e[20]||(e[20]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.all_to_all-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.all_to_all-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.all_to_all")],-1)),e[21]||(e[21]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[23]||(e[23]=n(`<p><code>all_to_all</code></p><p>Within each process group in the process grid, splits the values of the <code>operand</code> tensor along <code>split_dimension</code> into parts, scatters the split parts between the processes, concatenates the scattered parts along <code>concat_dimension</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#all_to_all" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#all_to_all</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result:2 = &quot;stablehlo.all_to_all&quot;(%operand1, %operand2) {</span></span>
<span class="line"><span>  split_dimension = 1 : i64,</span></span>
<span class="line"><span>  concat_dimension = 0 : i64,</span></span>
<span class="line"><span>  split_count = 2 : i64,</span></span>
<span class="line"><span>  replica_groups = dense&lt;[[0, 1]]&gt; : tensor&lt;1x2xi64&gt;</span></span>
<span class="line"><span>} : (tensor&lt;2x4xi64&gt;, tensor&lt;2x4xi64&gt;) -&gt; (tensor&lt;4x2xi64&gt;, tensor&lt;4x2xi64&gt;)</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[22]||(e[22]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L228-L248",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",_,[t("summary",null,[e[24]||(e[24]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.and-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.and-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.and")],-1)),e[25]||(e[25]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[27]||(e[27]=n('<p><code>and</code></p><p>Performs element-wise AND of two tensors <code>lhs</code> and <code>rhs</code> and produces a <code>result</code> tensor</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#and" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#and</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.and %lhs, %rhs : tensor&lt;2x2xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[26]||(e[26]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L285-L298",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",f,[t("summary",null,[e[28]||(e[28]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.atan2-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.atan2-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.atan2")],-1)),e[29]||(e[29]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[31]||(e[31]=n('<p><code>atan2</code></p><p>Performs element-wise atan2 operation on <code>lhs</code> and <code>rhs</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#atan2" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#atan2</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.atan2 %lhs, %rhs : tensor&lt;3xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[30]||(e[30]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L321-L334",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",I,[t("summary",null,[e[32]||(e[32]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.batch_norm_grad-NTuple{5, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.batch_norm_grad-NTuple{5, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.batch_norm_grad")],-1)),e[33]||(e[33]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[35]||(e[35]=n(`<p><code>batch_norm_grad</code></p><p>Computes gradients of several inputs of BatchNormTrainingOp backpropagating from <code>grad_output</code>, and produces <code>grad_operand</code>, <code>grad_scale</code> and <code>grad_offset</code> tensors.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#batch_norm_grad" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#batch_norm_grad</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%grad_operand, %grad_scale, %grad_offset =</span></span>
<span class="line"><span>&quot;stablehlo.batch_norm_grad&quot;(%operand, %scale, %mean, %variance, %grad_output) {</span></span>
<span class="line"><span>  epsilon = 0.0 : f32,</span></span>
<span class="line"><span>  feature_index = 2 : i64</span></span>
<span class="line"><span>} : (tensor&lt;2x2x2xf64&gt;, tensor&lt;2xf64&gt;, tensor&lt;2xf64&gt;, tensor&lt;2xf64&gt;,</span></span>
<span class="line"><span>     tensor&lt;2x2x2xf64&gt;) -&gt; (tensor&lt;2x2x2xf64&gt;, tensor&lt;2xf64&gt;, tensor&lt;2xf64&gt;)</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[34]||(e[34]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L357-L376",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",x,[t("summary",null,[e[36]||(e[36]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.batch_norm_inference-NTuple{5, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.batch_norm_inference-NTuple{5, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.batch_norm_inference")],-1)),e[37]||(e[37]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[39]||(e[39]=n(`<p><code>batch_norm_inference</code></p><p>Normalizes the <code>operand</code> tensor across all dimensions except for the <code>feature_index</code> dimension and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#batch_norm_inference" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#batch_norm_inference</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.batch_norm_inference&quot;(%operand, %scale, %offset, %mean, %variance) {</span></span>
<span class="line"><span>  epsilon = 0.0 : f32,</span></span>
<span class="line"><span>  feature_index = 2 : i64</span></span>
<span class="line"><span>} : (tensor&lt;2x2x2xf64&gt;, tensor&lt;2xf64&gt;, tensor&lt;2xf64&gt;, tensor&lt;2xf64&gt;, tensor&lt;2xf64&gt;) -&gt; tensor&lt;2x2x2xf64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[38]||(e[38]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L413-L429",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",T,[t("summary",null,[e[40]||(e[40]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.batch_norm_training-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.batch_norm_training-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.batch_norm_training")],-1)),e[41]||(e[41]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[43]||(e[43]=n(`<p><code>batch_norm_training</code></p><p>Computes mean and variance across batch and spatial dimensions and normalizes the <code>operand</code> tensor, for each feature in the <code>feature_index</code> dimension and produces <code>output</code>, <code>batch_mean</code> and <code>batch_var</code> tensors.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#batch_norm_training" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#batch_norm_training</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%output, %batch_mean, %batch_var = &quot;stablehlo.batch_norm_training&quot;(%operand, %scale, %offset) {</span></span>
<span class="line"><span>  epsilon = 0.0 : f32,</span></span>
<span class="line"><span>  feature_index = 2 : i64</span></span>
<span class="line"><span>} : (tensor&lt;2x2x2xf64&gt;, tensor&lt;2xf64&gt;, tensor&lt;2xf64&gt;) -&gt;</span></span>
<span class="line"><span>    (tensor&lt;2x2x2xf64&gt;, tensor&lt;2xf64&gt;, tensor&lt;2xf64&gt;)</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[42]||(e[42]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L462-L480",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",L,[t("summary",null,[e[44]||(e[44]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.bitcast_convert-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.bitcast_convert-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.bitcast_convert")],-1)),e[45]||(e[45]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[47]||(e[47]=n('<p><code>bitcast_convert</code></p><p>Performs a bitcast operation on <code>operand</code> tensor and produces a <code>result</code> tensor where the bits of the entire <code>operand</code> tensor are reinterpreted using the type of the <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#bitcast_convert" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#bitcast_convert</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.bitcast_convert %operand : (tensor&lt;f64&gt;) -&gt; tensor&lt;4xf16&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[46]||(e[46]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L515-L529",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",y,[t("summary",null,[e[48]||(e[48]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.broadcast-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.broadcast-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.broadcast")],-1)),e[49]||(e[49]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[51]||(e[51]=n('<p><code>broadcast</code></p><p>This operation is on its way out of StableHLO, so it is not included in the StableHLO specification: <a href="https://github.com/openxla/stablehlo/issues/3" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/issues/3</a>.</p><p>Informally, this operation does the same thing as XLA&#39;s Broadcast: <a href="https://www.tensorflow.org/xla/operation_semantics#broadcast" target="_blank" rel="noreferrer">https://www.tensorflow.org/xla/operation_semantics#broadcast</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.broadcast %operand, sizes = [1, 2] : (tensor&lt;3xi32&gt;) -&gt; tensor&lt;1x2x3xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[50]||(e[50]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L586-L599",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",M,[t("summary",null,[e[52]||(e[52]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.broadcast_in_dim-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.broadcast_in_dim-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.broadcast_in_dim")],-1)),e[53]||(e[53]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[55]||(e[55]=n('<p><code>broadcast_in_dim</code></p><p>Expands the dimensions and/or rank of an input tensor by duplicating the data in the <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#broadcast_in_dim" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#broadcast_in_dim</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.broadcast_in_dim %operand, dims = [2, 1] : (tensor&lt;1x3xi32&gt;) -&gt; tensor&lt;2x3x2xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[54]||(e[54]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L549-L562",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",k,[t("summary",null,[e[56]||(e[56]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.case-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.case-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.case")],-1)),e[57]||(e[57]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[59]||(e[59]=n(`<p><code>case</code></p><p>Produces the output from executing exactly one <code>function</code> from <code>branches</code> depending on the value of <code>index</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#case" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#case</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result0, %result1 = &quot;stablehlo.case&quot;(%index) ({</span></span>
<span class="line"><span>  stablehlo.return %result_branch0, %result_branch0 : tensor&lt;2xi64&gt;, tensor&lt;2xi64&gt;</span></span>
<span class="line"><span>}, {</span></span>
<span class="line"><span>  stablehlo.return %result_branch1, %result_branch1 : tensor&lt;2xi64&gt;, tensor&lt;2xi64&gt;</span></span>
<span class="line"><span>}) : (tensor&lt;i32&gt;) -&gt; (tensor&lt;2xi64&gt;, tensor&lt;2xi64&gt;)</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[58]||(e[58]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L625-L642",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",j,[t("summary",null,[e[60]||(e[60]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.cbrt-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.cbrt-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.cbrt")],-1)),e[61]||(e[61]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[63]||(e[63]=n('<p><code>cbrt</code></p><p>Performs element-wise cubic root operation on <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#cbrt" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#cbrt</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.cbrt %operand : tensor&lt;4xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[62]||(e[62]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L664-L677",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",v,[t("summary",null,[e[64]||(e[64]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.ceil-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.ceil-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.ceil")],-1)),e[65]||(e[65]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[67]||(e[67]=n('<p><code>ceil</code></p><p>Performs element-wise ceil of <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#ceil" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#ceil</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.ceil %operand : tensor&lt;5xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[66]||(e[66]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L705-L717",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",D,[t("summary",null,[e[68]||(e[68]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.cholesky-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.cholesky-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.cholesky")],-1)),e[69]||(e[69]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[71]||(e[71]=n('<p><code>cholesky</code></p><p>Computes the Cholesky decomposition of a batch of matrices.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#cholesky" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#cholesky</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.cholesky %a, lower = true : tensor&lt;3x3xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[70]||(e[70]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L738-L750",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",V,[t("summary",null,[e[72]||(e[72]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.clamp-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.clamp-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.clamp")],-1)),e[73]||(e[73]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[75]||(e[75]=n('<p><code>clamp</code></p><p>Clamps every element of the <code>operand</code> tensor between a minimum and maximum value and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#clamp" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#clamp</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.clamp %min, %operand, %max : tensor&lt;3xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[74]||(e[74]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L774-L787",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",S,[t("summary",null,[e[76]||(e[76]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.collective_broadcast-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.collective_broadcast-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.collective_broadcast")],-1)),e[77]||(e[77]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[79]||(e[79]=n(`<p><code>collective_broadcast</code></p><p>Within each process group in the process grid, send the value of the <code>operand</code> tensor from the source process to the target processes and produce a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#collective_broadcast" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#collective_broadcast</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.collective_broadcast&quot;(%operand) {</span></span>
<span class="line"><span>  replica_groups = dense&lt;[[0, 1]]&gt; : tensor&lt;1x2xi64&gt;,</span></span>
<span class="line"><span>  channel_handle = #stablehlo.channel_handle&lt;handle = 0, type = 0&gt;</span></span>
<span class="line"><span>} : (tensor&lt;1x2xi64&gt;) -&gt; tensor&lt;1x2xi64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[78]||(e[78]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L850-L867",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",A,[t("summary",null,[e[80]||(e[80]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.collective_permute-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.collective_permute-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.collective_permute")],-1)),e[81]||(e[81]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[83]||(e[83]=n(`<p><code>collective_permute</code></p><p>Within each process group in the process grid, sends the value of the <code>operand</code> tensor from the source process to the target process and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#collective_permute" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#collective_permute</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.collective_permute&quot;(%operand) {</span></span>
<span class="line"><span>  source_target_pairs = dense&lt;[[0, 1], [1, 2]]&gt; : tensor&lt;2x2xi64&gt;,</span></span>
<span class="line"><span>  channel_handle = #stablehlo.channel_handle&lt;handle = 0, type = 0&gt;</span></span>
<span class="line"><span>} : (tensor&lt;2x2xi64&gt;) -&gt; tensor&lt;2x2xi64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[82]||(e[82]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L896-L913",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",C,[t("summary",null,[e[84]||(e[84]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.compare-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.compare-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.compare")],-1)),e[85]||(e[85]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[87]||(e[87]=n('<p><code>compare</code></p><p>Performs element-wise comparison of <code>lhs</code> and <code>rhs</code> tensors according to <code>comparison_direction</code> and <code>compare_type</code>, and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#compare" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#compare</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.compare LT, %lhs, %rhs, FLOAT : (tensor&lt;2xf32&gt;, tensor&lt;2xf32&gt;) -&gt; tensor&lt;2xi1&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[86]||(e[86]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L942-L955",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",E,[t("summary",null,[e[88]||(e[88]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.complex-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.complex-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.complex")],-1)),e[89]||(e[89]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[91]||(e[91]=n('<p><code>complex</code></p><p>Performs element-wise conversion to a complex value from a pair of real and imaginary values, <code>lhs</code> and <code>rhs</code>, and produces a <code>result</code> tensor. See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#complex" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#complex</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.complex %lhs, %rhs : tensor&lt;2xcomplex&lt;f64&gt;&gt;</span></span></code></pre></div>',4)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[90]||(e[90]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L987-L998",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",P,[t("summary",null,[e[92]||(e[92]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.composite-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.composite-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.composite")],-1)),e[93]||(e[93]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[95]||(e[95]=n(`<p><code>composite</code></p><p>Encapsulates an operation made up (composed) of other StableHLO operations, taking <code>inputs</code> and <code>composite_attributes</code> and producing <code>results</code>. The semantics of the op are implemented by the <code>decomposition</code> attribute. The <code>composite</code> op can be replaced with its decomposition without changing program semantics. In cases where inlining the decomposition does not provide the same op semantics, prefer using <code>custom_call</code>.</p><p>The <code>version</code> field (defaults to <code>0</code>) is used to denote when a composite&#39;s semantics change.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#composite" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#composite</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%results = stablehlo.composite &quot;my.op&quot; %input0, %input1 {</span></span>
<span class="line"><span>  composite_attributes = {</span></span>
<span class="line"><span>    my_attribute = &quot;my_value&quot;</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  decomposition = @my_op,</span></span>
<span class="line"><span>  version = 1 : i32</span></span>
<span class="line"><span>} : (tensor&lt;f32&gt;, tensor&lt;f32&gt;) -&gt; tensor&lt;f32&gt;</span></span></code></pre></div>`,6)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[94]||(e[94]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1021-L1047",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",O,[t("summary",null,[e[96]||(e[96]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.concatenate-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.concatenate-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.concatenate")],-1)),e[97]||(e[97]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[99]||(e[99]=n('<p><code>concatenate</code></p><p>Concatenates a variadic number of tensors in <code>inputs</code> along <code>dimension</code> dimension in the same order as the given arguments and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#concatenate" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#concatenate</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.concatenate %input0, %input1, dim = 0 : (tensor&lt;3x2xi64&gt;, tensor&lt;1x2xi64&gt;) -&gt; tensor&lt;4x2xi64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[98]||(e[98]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1080-L1094",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",w,[t("summary",null,[e[100]||(e[100]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.constant-Tuple{}",href:"#Reactant.MLIR.Dialects.stablehlo.constant-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.constant")],-1)),e[101]||(e[101]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[103]||(e[103]=n('<p><code>constant</code></p><p>Produces an <code>output</code> tensor from a constant <code>value</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#constant" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#constant</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%output = stablehlo.constant dense&lt;[[0.0, 1.0], [2.0, 3.0]]&gt; : tensor&lt;2x2xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[102]||(e[102]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1120-L1132",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",z,[t("summary",null,[e[104]||(e[104]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.convert-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.convert-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.convert")],-1)),e[105]||(e[105]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[107]||(e[107]=n('<p><code>convert</code></p><p>Performs an element-wise conversion from one element type to another on <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#convert" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#convert</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.convert %operand : (tensor&lt;3xi64&gt;) -&gt; tensor&lt;3xcomplex&lt;f64&gt;&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[106]||(e[106]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1153-L1166",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",H,[t("summary",null,[e[108]||(e[108]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.convolution-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.convolution-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.convolution")],-1)),e[109]||(e[109]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[111]||(e[111]=n(`<p><code>convolution</code></p><p>Computes dot products between windows of <code>lhs</code> and slices of <code>rhs</code> and produces <code>result</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#convolution" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#convolution</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.convolution(%lhs, %rhs)</span></span>
<span class="line"><span>  dim_numbers = [b, 0, 1, f]x[0, 1, i, o]-&gt;[b, 0, 1, f],</span></span>
<span class="line"><span>  window = {</span></span>
<span class="line"><span>    stride = [4, 4],</span></span>
<span class="line"><span>    pad = [[0, 0], [0, 0]],</span></span>
<span class="line"><span>    lhs_dilate = [2, 2],</span></span>
<span class="line"><span>    rhs_dilate = [1, 1],</span></span>
<span class="line"><span>    reverse = [0, 0]</span></span>
<span class="line"><span>  } {</span></span>
<span class="line"><span>    feature_group_count = 1 : i64,</span></span>
<span class="line"><span>    batch_group_count = 1 : i64,</span></span>
<span class="line"><span>    precision_config = [#stablehlo&lt;precision DEFAULT&gt;, #stablehlo&lt;precision DEFAULT&gt;]</span></span>
<span class="line"><span>  } :</span></span>
<span class="line"><span>(tensor&lt;1x4x4x1xi64&gt;, tensor&lt;3x3x1x1xi64&gt;) -&gt; tensor&lt;1x2x2x1xi64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[110]||(e[110]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1186-L1212",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",q,[t("summary",null,[e[112]||(e[112]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.cosine-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.cosine-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.cosine")],-1)),e[113]||(e[113]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[115]||(e[115]=n('<p><code>cosine</code></p><p>Performs element-wise cosine operation on <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#cosine" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#cosine</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.cosine %operand : tensor&lt;2xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[114]||(e[114]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1261-L1274",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",N,[t("summary",null,[e[116]||(e[116]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.count_leading_zeros-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.count_leading_zeros-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.count_leading_zeros")],-1)),e[117]||(e[117]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[119]||(e[119]=n('<p><code>count_leading_zeros</code></p><p>Performs element-wise count of the number of leading zero bits in the <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#count_leading_zeros" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#count_leading_zeros</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.count_leading_zeros %operand : tensor&lt;2x2xi64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[118]||(e[118]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L814-L827",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",F,[t("summary",null,[e[120]||(e[120]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.create_token-Tuple{}",href:"#Reactant.MLIR.Dialects.stablehlo.create_token-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.create_token")],-1)),e[121]||(e[121]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[123]||(e[123]=n('<p><code>create_token</code></p><p>This operation is on its way out of StableHLO, so it is not included in the StableHLO specification: <a href="https://github.com/openxla/stablehlo/issues/3" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/issues/3</a>.</p><p>Informally, this operation does the same thing as AfterAllOp with 0 inputs: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#after_all" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#after_all</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%output = stablehlo.create_token : !stablehlo.token</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[122]||(e[122]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1302-L1315",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",B,[t("summary",null,[e[124]||(e[124]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.cross_replica_sum-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.cross_replica_sum-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.cross_replica_sum")],-1)),e[125]||(e[125]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[127]||(e[127]=n(`<p><code>cross_replica_sum</code></p><p>This operation is on its way out of StableHLO, so it is not included in the StableHLO specification: <a href="https://github.com/openxla/stablehlo/issues/3" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/issues/3</a>.</p><p>Informally, this operation does the same thing as AllReduceOp with <code>channel_id = 0</code>, <code>use_global_device_ids = false</code> and <code>computation</code> implementing addition: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#all_reduce" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#all_reduce</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.cross-replica-sum&quot;(%operand) {</span></span>
<span class="line"><span>  replica_groups = dense&lt;[[0, 1]]&gt; : tensor&lt;1x2xi64&gt;</span></span>
<span class="line"><span>} : (tensor&lt;4xf32&gt;) -&gt; tensor&lt;4xf32&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[126]||(e[126]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1336-L1353",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",U,[t("summary",null,[e[128]||(e[128]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.custom_call-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.custom_call-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.custom_call")],-1)),e[129]||(e[129]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[131]||(e[131]=n(`<p><code>custom_call</code></p><p>Encapsulates an implementation-defined operation <code>call_target_name</code> that takes <code>inputs</code> and <code>called_computations</code> and produces <code>results</code>.</p><p>Depending on the API version there are two ways to pass extra bits of static information to the external function:</p><ol><li><p>Use <code>API_VERSION_TYPED_FFI</code> which allows passing a dictionary attribute.</p></li><li><p>Use a previous API version with a StringAttr to encode backend config.</p></li></ol><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#custom_call" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#custom_call</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%results = stablehlo.custom_call @foo(%input0) {</span></span>
<span class="line"><span>  backend_config = {bar = 42 : i32},</span></span>
<span class="line"><span>  api_version = 4 : i32,</span></span>
<span class="line"><span>  called_computations = [@foo]</span></span>
<span class="line"><span>} : (tensor&lt;f64&gt;) -&gt; tensor&lt;f64&gt;</span></span></code></pre></div>`,7)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[130]||(e[130]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1379-L1401",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",W,[t("summary",null,[e[132]||(e[132]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.divide-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.divide-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.divide")],-1)),e[133]||(e[133]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[135]||(e[135]=n('<p><code>divide</code></p><p>Performs element-wise division of dividend <code>lhs</code> and divisor <code>rhs</code> tensors and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#divide" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#divide</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.divide %lhs, %rhs : tensor&lt;4xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[134]||(e[134]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1446-L1459",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",G,[t("summary",null,[e[136]||(e[136]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.dot-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.dot-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.dot")],-1)),e[137]||(e[137]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[139]||(e[139]=n('<p><code>dot</code></p><p>This operation is on its way out of StableHLO, so it is not included in the StableHLO specification: <a href="https://github.com/openxla/stablehlo/issues/3" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/issues/3</a>.</p><p>Informally, this operation does the same thing as XLA&#39;s Dot: <a href="https://www.tensorflow.org/xla/operation_semantics#dot" target="_blank" rel="noreferrer">https://www.tensorflow.org/xla/operation_semantics#dot</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = stablehlo.dot %arg0, %arg1 : (tensor&lt;1x2xi32&gt;, tensor&lt;2x1xi32&gt;) -&gt; tensor&lt;1x1xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[138]||(e[138]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1533-L1546",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",X,[t("summary",null,[e[140]||(e[140]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.dot_general-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.dot_general-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.dot_general")],-1)),e[141]||(e[141]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[143]||(e[143]=n(`<p><code>dot_general</code></p><p>Computes dot products between slices of <code>lhs</code> and slices of <code>rhs</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dot_general" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dot_general</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.dot_general %lhs, %rhs,</span></span>
<span class="line"><span>  batching_dims = [0] x [0],</span></span>
<span class="line"><span>  contracting_dims = [2] x [1],</span></span>
<span class="line"><span>  precision = [DEFAULT, DEFAULT],</span></span>
<span class="line"><span>  algorithm = &lt;lhs_precision_type = tf32, rhs_precision_type = tf32, accumulation_type = f32, lhs_component_count = 1, rhs_component_count = 1, num_primitive_operations = 1, allow_imprecise_accumulation = false&gt;</span></span>
<span class="line"><span>  : (tensor&lt;2x2x2xi64&gt;, tensor&lt;2x2x2xi64&gt;) -&gt; tensor&lt;2x2x2xi64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[142]||(e[142]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1482-L1500",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",$,[t("summary",null,[e[144]||(e[144]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.dynamic_broadcast_in_dim-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.dynamic_broadcast_in_dim-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.dynamic_broadcast_in_dim")],-1)),e[145]||(e[145]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[147]||(e[147]=n(`<p><code>dynamic_broadcast_in_dim</code></p><p>This operation is functionally identical to <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#broadcast_in_dim" target="_blank" rel="noreferrer">broadcast_in_dim</a> op, but the result shape is specified dynamically via <code>output_dimensions</code>.</p><p>It also accepts optional attributes to express static knowledge about the expanding behavior of dimensions. If not specified, all dimensions are assumed to be possibly expanding. The sets of dimensions that are known to be expanding and the set of dimensions that are known to be non-expanding must be disjoint and they must be a subset of the operand&#39;s dimensions.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_broadcast_in_dim" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_broadcast_in_dim</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%operand = stablehlo.constant dense&lt;[[1, 2, 3]]&gt; : tensor&lt;1x3xi64&gt;</span></span>
<span class="line"><span>%output_dimensions = stablehlo.constant dense&lt;[2, 3, 2]&gt; : tensor&lt;3xi64&gt;</span></span>
<span class="line"><span>%result = &quot;stablehlo.dynamic_broadcast_in_dim&quot;(%operand, %output_dimensions) {</span></span>
<span class="line"><span>  broadcast_dimensions = array&lt;i64: 2, 1&gt;,</span></span>
<span class="line"><span>  known_expanding_dimensions = array&lt;i64: 0&gt;,</span></span>
<span class="line"><span>  known_nonexpanding_dimensions = array&lt;i64: 1&gt;</span></span>
<span class="line"><span>} : (tensor&lt;1x3xi64&gt;, tensor&lt;3xi64&gt;) -&gt; tensor&lt;2x3x2xi64&gt;</span></span></code></pre></div>`,6)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[146]||(e[146]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1570-L1595",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Y,[t("summary",null,[e[148]||(e[148]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.dynamic_conv-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.dynamic_conv-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.dynamic_conv")],-1)),e[149]||(e[149]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[151]||(e[151]=n(`<p><code>dynamic_conv</code></p><p>This operation is functionally identical to <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#convolution" target="_blank" rel="noreferrer">convolution</a> op, but the padding is specified dynamically via <code>padding</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%padding = stablehlo.constant dense&lt;2&gt; : tensor&lt;2x2xi64&gt;</span></span>
<span class="line"><span>%result = &quot;stablehlo.dynamic_conv&quot;(%lhs, %rhs, %padding) {</span></span>
<span class="line"><span>  window_strides = array&lt;i64: 4, 4&gt;,</span></span>
<span class="line"><span>  lhs_dilation = array&lt;i64: 2, 2&gt;,</span></span>
<span class="line"><span>  rhs_dilation = array&lt;i64: 1, 1&gt;,</span></span>
<span class="line"><span>  window_reversal = array&lt;i1: false, false&gt;,</span></span>
<span class="line"><span>  dimension_numbers = #stablehlo.conv&lt;[b, 0, 1, f]x[0, 1, i, o]-&gt;[b, 0, 1, f]&gt;,</span></span>
<span class="line"><span>  batch_group_count = 1 : i64,</span></span>
<span class="line"><span>  feature_group_count = 1 : i64,</span></span>
<span class="line"><span>  precision_config = [#stablehlo&lt;precision DEFAULT&gt;, #stablehlo&lt;precision DEFAULT&gt;]</span></span>
<span class="line"><span>} : (tensor&lt;1x4x4x1xi64&gt;, tensor&lt;3x3x1x1xi64&gt;, tensor&lt;2x2xi64&gt;) -&gt; tensor&lt;1x2x2x1xi64&gt;</span></span></code></pre></div>`,4)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[150]||(e[150]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1633-L1654",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",J,[t("summary",null,[e[152]||(e[152]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.dynamic_gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.dynamic_gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.dynamic_gather")],-1)),e[153]||(e[153]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[155]||(e[155]=n(`<p><code>dynamic_gather</code></p><p>This operation is functionally identical to <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#gather" target="_blank" rel="noreferrer">gather</a> op, with the <code>slice_sizes</code> specified dynamically as an operand.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%slice_sizes = stablehlo.constant dense&lt;[1, 2, 2]&gt; : tensor&lt;3xi64&gt;</span></span>
<span class="line"><span>%result = &quot;stablehlo.dynamic_gather&quot;(%operand, %start_indices, %slice_sizes) {</span></span>
<span class="line"><span>  dimension_numbers = #stablehlo.gather&lt;</span></span>
<span class="line"><span>    offset_dims = [2, 3],</span></span>
<span class="line"><span>    collapsed_slice_dims = [0],</span></span>
<span class="line"><span>    start_index_map = [0, 2],</span></span>
<span class="line"><span>    index_vector_dim = 2&gt;,</span></span>
<span class="line"><span>  indices_are_sorted = false</span></span>
<span class="line"><span>} : (tensor&lt;3x4x2xi64&gt;, tensor&lt;2x3x2xi64&gt;, tensor&lt;3xi64&gt;) -&gt; tensor&lt;2x3x2x2xi64&gt;</span></span></code></pre></div>`,4)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[154]||(e[154]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1702-L1721",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",K,[t("summary",null,[e[156]||(e[156]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.dynamic_iota-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.dynamic_iota-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.dynamic_iota")],-1)),e[157]||(e[157]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[159]||(e[159]=n(`<p><code>dynamic_iota</code></p><p>This operation is functionally identical to <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#iota" target="_blank" rel="noreferrer">iota</a> op, but the result shape is specified dynamically via <code>output_shape</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_iota" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_iota</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%output_shape = stablehlo.constant dense&lt;[4, 5]&gt; : tensor&lt;2xi64&gt;</span></span>
<span class="line"><span>%0 = stablehlo.dynamic_iota %output_shape, dim = 0 : (tensor&lt;2xi64&gt;) -&gt; tensor&lt;4x5xi64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[158]||(e[158]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1752-L1767",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Q,[t("summary",null,[e[160]||(e[160]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.dynamic_pad-NTuple{5, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.dynamic_pad-NTuple{5, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.dynamic_pad")],-1)),e[161]||(e[161]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[163]||(e[163]=n(`<p><code>dynamic_pad</code></p><p>This operation is functionally identical to <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#pad" target="_blank" rel="noreferrer">pad</a> <a href="https://github.com/openxla/stablehlo/pull/2306#discussion_r1595669709" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/pull/2306#discussion_r1595669709</a> op, but with <code>edge_padding_low</code>,<code>edge_padding_high</code>and<code>interior_padding</code> specified dynamically as values.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_pad" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_pad</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%edge_padding_low = stablehlo.constant dense&lt;[0, 1]&gt; : tensor&lt;2xi32&gt;</span></span>
<span class="line"><span>%edge_padding_high = stablehlo.constant dense&lt;[2, 1]&gt; : tensor&lt;2xi32&gt;</span></span>
<span class="line"><span>%interior_padding = stablehlo.constant dense&lt;[1, 2]&gt; : tensor&lt;2xi32&gt;</span></span>
<span class="line"><span>%result = stablehlo.dynamic_pad %operand, %padding_value,</span></span>
<span class="line"><span>            %edge_padding_low, %edge_padding_high, %interior_padding</span></span>
<span class="line"><span>            : (tensor&lt;2x3xi64&gt;, tensor&lt;i64&gt;, tensor&lt;2xi64&gt;, tensor&lt;2xi64&gt;, tensor&lt;2xi64&gt;) -&gt; tensor&lt;5x9xi64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[162]||(e[162]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1789-L1809",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Z,[t("summary",null,[e[164]||(e[164]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.dynamic_reshape-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.dynamic_reshape-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.dynamic_reshape")],-1)),e[165]||(e[165]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[167]||(e[167]=n(`<p><code>dynamic_reshape</code></p><p>This operation is functionally identical to <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reshape" target="_blank" rel="noreferrer">reshape</a> op, but the result shape is specified dynamically via <code>output_shape</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_reshape" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_reshape</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%output_shape = stablehlo.constant dense&lt;[3, 2]&gt; : tensor&lt;2xi64&gt;</span></span>
<span class="line"><span>%result = stablehlo.dynamic_reshape %operand, %output_shape : (tensor&lt;2x3xi64&gt;, tensor&lt;2xi64&gt;) -&gt; tensor&lt;3x2xi64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[166]||(e[166]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1839-L1854",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ee,[t("summary",null,[e[168]||(e[168]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.dynamic_slice-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.dynamic_slice-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.dynamic_slice")],-1)),e[169]||(e[169]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[171]||(e[171]=n(`<p><code>dynamic_slice</code></p><p>Extracts a slice from the <code>operand</code> using dynamically-computed starting indices and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_slice" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_slice</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.dynamic_slice %operand, %start_indices0, %start_indices1, sizes = [2, 2]</span></span>
<span class="line"><span>  : (tensor&lt;4x4xi32&gt;, tensor&lt;i64&gt;, tensor&lt;i64&gt;) -&gt; tensor&lt;2x2xi32&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[170]||(e[170]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1876-L1890",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",te,[t("summary",null,[e[172]||(e[172]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.dynamic_update_slice-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.dynamic_update_slice-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.dynamic_update_slice")],-1)),e[173]||(e[173]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[175]||(e[175]=n(`<p><code>dynamic_update_slice</code></p><p>Produces a <code>result</code> tensor which is equal to the <code>operand</code> tensor except that the slice starting at <code>start_indices</code> is updated with the values in <code>update</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_update_slice" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_update_slice</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.dynamic_update_slice %operand, %update, %start_indices0, %start_indices1</span></span>
<span class="line"><span>  : (tensor&lt;4x4xi32&gt;, tensor&lt;2x2xi32&gt;, tensor&lt;i64&gt;, tensor&lt;i64&gt;) -&gt; tensor&lt;4x4xi32&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[174]||(e[174]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1917-L1932",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",se,[t("summary",null,[e[176]||(e[176]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.einsum-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.einsum-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.einsum")],-1)),e[177]||(e[177]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[179]||(e[179]=n(`<p><code>einsum</code></p><p>This operation is on its way out of StableHLO, so it is not included in the StableHLO specification: <a href="https://github.com/openxla/stablehlo/issues/3" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/issues/3</a>.</p><p>Informally, this operation does the same thing as TF&#39;s einsum: <a href="https://www.tensorflow.org/api_docs/python/tf/einsum" target="_blank" rel="noreferrer">https://www.tensorflow.org/api_docs/python/tf/einsum</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.einsum&quot;(%lhs, %rhs) {</span></span>
<span class="line"><span>  einsum_config = &quot;ab,bc-&gt;ac&quot;</span></span>
<span class="line"><span>} : (tensor&lt;4x16xf32&gt;, tensor&lt;16x4xf32&gt;) -&gt; tensor&lt;4x4xf32&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[178]||(e[178]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1959-L1974",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ae,[t("summary",null,[e[180]||(e[180]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.exponential-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.exponential-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.exponential")],-1)),e[181]||(e[181]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[183]||(e[183]=n('<p><code>exponential</code></p><p>Performs element-wise exponential operation on <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#exponential" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#exponential</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.exponential %operand : tensor&lt;2x2xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[182]||(e[182]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L1996-L2009",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",le,[t("summary",null,[e[184]||(e[184]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.exponential_minus_one-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.exponential_minus_one-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.exponential_minus_one")],-1)),e[185]||(e[185]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[187]||(e[187]=n('<p><code>exponential_minus_one</code></p><p>Performs element-wise exponential minus one operation on <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#exponential_minus_one" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#exponential_minus_one</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.exponential_minus_one %operand : tensor&lt;2xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[186]||(e[186]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2037-L2050",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ne,[t("summary",null,[e[188]||(e[188]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.fft-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.fft-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.fft")],-1)),e[189]||(e[189]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[191]||(e[191]=n('<p><code>fft</code></p><p>Performs the forward and inverse Fourier transforms for real and complex inputs/outputs.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#fft" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#fft</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.fft %operand, type = FFT, length = [4] : (tensor&lt;4xcomplex&lt;f32&gt;&gt;) -&gt; tensor&lt;4xcomplex&lt;f32&gt;&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[190]||(e[190]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2078-L2091",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",oe,[t("summary",null,[e[192]||(e[192]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.floor-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.floor-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.floor")],-1)),e[193]||(e[193]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[195]||(e[195]=n('<p><code>floor</code></p><p>Performs element-wise floor of <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#floor" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#floor</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.floor %operand : tensor&lt;2xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[194]||(e[194]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2120-L2133",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ie,[t("summary",null,[e[196]||(e[196]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.gather")],-1)),e[197]||(e[197]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[199]||(e[199]=n(`<p><code>gather</code></p><p>Gathers slices from <code>operand</code> tensor from offsets specified in <code>start_indices</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#gather" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#gather</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.gather&quot;(%operand, %start_indices) {</span></span>
<span class="line"><span>  dimension_numbers = #stablehlo.gather&lt;</span></span>
<span class="line"><span>    offset_dims = [3, 4],</span></span>
<span class="line"><span>    collapsed_slice_dims = [1],</span></span>
<span class="line"><span>    operand_batching_dims = [0],</span></span>
<span class="line"><span>    start_indices_batching_dims = [1],</span></span>
<span class="line"><span>    start_index_map = [2, 1],</span></span>
<span class="line"><span>    index_vector_dim = 3&gt;,</span></span>
<span class="line"><span>  slice_sizes = array&lt;i64: 1, 1, 2, 2&gt;,</span></span>
<span class="line"><span>  indices_are_sorted = false</span></span>
<span class="line"><span>} : (tensor&lt;2x3x4x2xi64&gt;, tensor&lt;2x2x3x2xi64&gt;) -&gt; tensor&lt;2x2x3x2x2xi64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[198]||(e[198]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2154-L2177",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",pe,[t("summary",null,[e[200]||(e[200]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.get_dimension_size-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.get_dimension_size-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.get_dimension_size")],-1)),e[201]||(e[201]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[203]||(e[203]=n('<p><code>get_dimension_size</code></p><p>Produces the size of the given <code>dimension</code> of the <code>operand</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#get_dimension_size" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#get_dimension_size</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.get_dimension_size %operand, dim = 1 : (tensor&lt;2x3xi64&gt;) -&gt; tensor&lt;i32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[202]||(e[202]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2211-L2223",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",re,[t("summary",null,[e[204]||(e[204]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.get_tuple_element-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.get_tuple_element-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.get_tuple_element")],-1)),e[205]||(e[205]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[207]||(e[207]=n('<p><code>get_tuple_element</code></p><p>Extracts element at <code>index</code> position of the <code>operand</code> tuple and produces a <code>result</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#get_tuple_element" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#get_tuple_element</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.get_tuple_element %operand[0] : (tuple&lt;tensor&lt;2xf64&gt;, tuple&lt;tensor&lt;i64&gt;&gt;&gt;) -&gt; tensor&lt;2xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[206]||(e[206]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2246-L2259",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ce,[t("summary",null,[e[208]||(e[208]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.if_-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.if_-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.if_")],-1)),e[209]||(e[209]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[211]||(e[211]=n('<p><code>if_</code></p><p>Produces the output from executing exactly one branch from <code>true_branch</code> or <code>false_branch</code> depending on the value of <code>pred</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#if" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#if</a></p><p><strong>Example</strong></p><p>%result = &quot;stablehlo.if&quot;(%pred) ({ &quot;stablehlo.return&quot;(%result_true_branch) : (tensor&lt;i32&gt;) -&gt; () }, { &quot;stablehlo.return&quot;(%result_false_branch) : (tensor&lt;i32&gt;) -&gt; () }) : (tensor&lt;i1&gt;) -&gt; tensor&lt;i32&gt;</p>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[210]||(e[210]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2282-L2297",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",de,[t("summary",null,[e[212]||(e[212]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.imag-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.imag-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.imag")],-1)),e[213]||(e[213]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[215]||(e[215]=n('<p><code>imag</code></p><p>Extracts the imaginary part, element-wise, from the <code>operand</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#imag" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#imag</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.imag %operand : (tensor&lt;2xcomplex&lt;f32&gt;&gt;) -&gt; tensor&lt;2xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[214]||(e[214]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2323-L2336",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",be,[t("summary",null,[e[216]||(e[216]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.infeed-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.infeed-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.infeed")],-1)),e[217]||(e[217]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[219]||(e[219]=n(`<p><code>infeed</code></p><p>Reads data from the infeed and produces <code>results</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#infeed" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#infeed</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%results0:2 = &quot;stablehlo.infeed&quot;(%token) :</span></span>
<span class="line"><span>    (!stablehlo.token) -&gt; (tensor&lt;2x2xi64&gt;, !stablehlo.token)</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[218]||(e[218]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2357-L2370",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ue,[t("summary",null,[e[220]||(e[220]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.iota-Tuple{}",href:"#Reactant.MLIR.Dialects.stablehlo.iota-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.iota")],-1)),e[221]||(e[221]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[223]||(e[223]=n('<p><code>iota</code></p><p>Fills an <code>output</code> tensor with values in increasing order starting from zero along the <code>iota_dimension</code> dimension.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#iota" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#iota</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%output = stablehlo.iota dim = 0 : tensor&lt;4x5xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[222]||(e[222]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2399-L2412",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",he,[t("summary",null,[e[224]||(e[224]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.is_finite-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.is_finite-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.is_finite")],-1)),e[225]||(e[225]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[227]||(e[227]=n('<p><code>is_finite</code></p><p>Performs element-wise check whether the value in <code>x</code> is finite (i.e. is neither +Inf, -Inf, nor NaN) and produces a <code>y</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#is_finite" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#is_finite</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%y = stablehlo.is_finite %x : (tensor&lt;7xf64&gt;) -&gt; tensor&lt;7xi1&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[226]||(e[226]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2432-L2445",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",me,[t("summary",null,[e[228]||(e[228]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.log-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.log-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.log")],-1)),e[229]||(e[229]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[231]||(e[231]=n('<p><code>log</code></p><p>Performs element-wise logarithm operation on <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#log" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#log</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.log %operand : tensor&lt;2x2xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[230]||(e[230]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2507-L2520",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ge,[t("summary",null,[e[232]||(e[232]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.log_plus_one-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.log_plus_one-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.log_plus_one")],-1)),e[233]||(e[233]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[235]||(e[235]=n('<p><code>log_plus_one</code></p><p>Performs element-wise logarithm plus one operation on <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#log_plus_one" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#log_plus_one</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.log_plus_one %operand : tensor&lt;5xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[234]||(e[234]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2466-L2479",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Re,[t("summary",null,[e[236]||(e[236]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.logistic-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.logistic-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.logistic")],-1)),e[237]||(e[237]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[239]||(e[239]=n('<p><code>logistic</code></p><p>Performs element-wise logistic operation on <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#logistic" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#logistic</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.logistic %operand : tensor&lt;2x2xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[238]||(e[238]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2548-L2561",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",_e,[t("summary",null,[e[240]||(e[240]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.map-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.map-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.map")],-1)),e[241]||(e[241]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[243]||(e[243]=n(`<p><code>map</code></p><p>Applies a map function <code>computation</code> to <code>inputs</code> along the <code>dimensions</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#map" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#map</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.map&quot;(%input0, %input1) ({</span></span>
<span class="line"><span>  ^bb0(%arg0: tensor&lt;i64&gt;, %arg1: tensor&lt;i64&gt;):</span></span>
<span class="line"><span>    %0 = stablehlo.multiply %arg0, %arg1 : tensor&lt;i64&gt;</span></span>
<span class="line"><span>    stablehlo.return %0 : tensor&lt;i64&gt;</span></span>
<span class="line"><span>}) {</span></span>
<span class="line"><span>  dimensions = array&lt;i64: 0, 1&gt;</span></span>
<span class="line"><span>} : (tensor&lt;2x2xi64&gt;, tensor&lt;2x2xi64&gt;) -&gt; tensor&lt;2x2xi64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[242]||(e[242]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2589-L2608",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",fe,[t("summary",null,[e[244]||(e[244]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.maximum-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.maximum-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.maximum")],-1)),e[245]||(e[245]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[247]||(e[247]=n('<p><code>maximum</code></p><p>Performs element-wise max operation on tensors <code>lhs</code> and <code>rhs</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#maximum" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#maximum</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.maximum %lhs, %rhs : tensor&lt;4xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[246]||(e[246]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2634-L2647",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Ie,[t("summary",null,[e[248]||(e[248]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.minimum-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.minimum-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.minimum")],-1)),e[249]||(e[249]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[251]||(e[251]=n('<p><code>minimum</code></p><p>Performs element-wise min operation on tensors <code>lhs</code> and <code>rhs</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#minimum" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#minimum</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.minimum %lhs, %rhs : tensor&lt;4xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[250]||(e[250]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2670-L2683",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",xe,[t("summary",null,[e[252]||(e[252]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.multiply-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.multiply-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.multiply")],-1)),e[253]||(e[253]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[255]||(e[255]=n('<p><code>multiply</code></p><p>Performs element-wise product of two tensors <code>lhs</code> and <code>rhs</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#multiply" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#multiply</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.multiply %lhs, %rhs : tensor&lt;2xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[254]||(e[254]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2706-L2719",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Te,[t("summary",null,[e[256]||(e[256]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.negate-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.negate-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.negate")],-1)),e[257]||(e[257]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[259]||(e[259]=n('<p><code>negate</code></p><p>Performs element-wise negation of <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#negate" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#negate</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.negate %operand : tensor&lt;2x3xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[258]||(e[258]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2742-L2755",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Le,[t("summary",null,[e[260]||(e[260]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.not-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.not-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.not")],-1)),e[261]||(e[261]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[263]||(e[263]=n('<p><code>not</code></p><p>Performs element-wise NOT of tensor <code>operand</code> of type integer and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#not" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#not</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.not %operand : tensor&lt;5x3x1xi1&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[262]||(e[262]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2776-L2789",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ye,[t("summary",null,[e[264]||(e[264]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.optimization_barrier-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.optimization_barrier-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.optimization_barrier")],-1)),e[265]||(e[265]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[267]||(e[267]=n('<p><code>optimization_barrier</code></p><p>Ensures that the operations that produce the <code>operand</code> are executed before any operations that depend on the <code>result</code> and prevents compiler transformations from moving operations across the barrier. Other than that, the operation is an identity, i.e. <code>result</code> = <code>operand</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#optimization_barrier" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#optimization_barrier</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result0, %result1 = stablehlo.optimization_barrier %operand0, %operand1 : tensor&lt;f32&gt;, tensor&lt;f32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[266]||(e[266]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2810-L2825",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Me,[t("summary",null,[e[268]||(e[268]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.or-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.or-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.or")],-1)),e[269]||(e[269]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[271]||(e[271]=n('<p><code>or</code></p><p>Performs element-wise OR of two tensors <code>lhs</code> and <code>rhs</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#or" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#or</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.or %lhs, %rhs : tensor&lt;2xi1&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[270]||(e[270]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2850-L2863",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ke,[t("summary",null,[e[272]||(e[272]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.outfeed-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.outfeed-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.outfeed")],-1)),e[273]||(e[273]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[275]||(e[275]=n(`<p><code>outfeed</code></p><p>Writes <code>inputs</code> to the outfeed and produces a <code>result</code> token.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#outfeed" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#outfeed</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.outfeed&quot;(%input0, %token) :</span></span>
<span class="line"><span>    (tensor&lt;2x2x2xi64&gt;, !stablehlo.token) -&gt; !stablehlo.token</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[274]||(e[274]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2886-L2899",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",je,[t("summary",null,[e[276]||(e[276]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.pad-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.pad-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.pad")],-1)),e[277]||(e[277]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[279]||(e[279]=n(`<p><code>pad</code></p><p>Expands <code>operand</code> by padding around the tensor as well as between the elements of the tensor with the given <code>padding_value</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#pad" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#pad</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = stablehlo.pad %arg0, %arg1, low = [0, 1], high = [2, 1], interior = [1, 2]</span></span>
<span class="line"><span>  : (tensor&lt;2x3xi32&gt;, tensor&lt;i32&gt;) -&gt; tensor&lt;5x9xi32&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[278]||(e[278]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2928-L2942",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ve,[t("summary",null,[e[280]||(e[280]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.partition_id-Tuple{}",href:"#Reactant.MLIR.Dialects.stablehlo.partition_id-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.partition_id")],-1)),e[281]||(e[281]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[283]||(e[283]=n('<p><code>partition_id</code></p><p>Produces <code>partition_id</code> of the current process.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#partition_id" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#partition_id</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.partition_id : tensor&lt;ui32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[282]||(e[282]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L2975-L2987",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",De,[t("summary",null,[e[284]||(e[284]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.popcnt-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.popcnt-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.popcnt")],-1)),e[285]||(e[285]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[287]||(e[287]=n('<p><code>popcnt</code></p><p>Performs element-wise count of the number of bits set in the <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#popcnt" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#popcnt</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.popcnt %operand : tensor&lt;4xi64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[286]||(e[286]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3008-L3021",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Ve,[t("summary",null,[e[288]||(e[288]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.power-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.power-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.power")],-1)),e[289]||(e[289]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[291]||(e[291]=n('<p><code>power</code></p><p>Performs element-wise exponentiation of <code>lhs</code> tensor by <code>rhs</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#power" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#power</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.power %lhs, %rhs : tensor&lt;6xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[290]||(e[290]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3042-L3055",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Se,[t("summary",null,[e[292]||(e[292]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.real-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.real-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.real")],-1)),e[293]||(e[293]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[295]||(e[295]=n('<p><code>real</code></p><p>Extracts the real part, element-wise, from the <code>operand</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#real" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#real</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.real %operand : (tensor&lt;2xcomplex&lt;f32&gt;&gt;) -&gt; tensor&lt;2xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[294]||(e[294]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3121-L3134",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Ae,[t("summary",null,[e[296]||(e[296]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.real_dynamic_slice-NTuple{4, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.real_dynamic_slice-NTuple{4, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.real_dynamic_slice")],-1)),e[297]||(e[297]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[299]||(e[299]=n(`<p><code>real_dynamic_slice</code></p><p>This operation is a work in progress, so it is not yet included in the StableHLO specification: <a href="https://github.com/openxla/stablehlo/issues/8" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/issues/8</a>.</p><p>Informally, this operation does the same thing as SliceOp except that <code>start_indices</code>, <code>limit_indices</code> and <code>strides</code> are specified dynamically: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#slice" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#slice</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.real_dynamic_slice %operand,</span></span>
<span class="line"><span>            %start_indices, %limit_indices, %strides</span></span>
<span class="line"><span>       : (tensor&lt;256x?xf32&gt;, tensor&lt;2xindex&gt;, tensor&lt;2xindex&gt;, tensor&lt;2xindex&gt;) -&gt; tensor&lt;256x?xf32&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[298]||(e[298]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3078-L3094",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Ce,[t("summary",null,[e[300]||(e[300]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.recv-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.recv-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.recv")],-1)),e[301]||(e[301]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[303]||(e[303]=n(`<p><code>recv</code></p><p>Receives data from a channel with <code>channel_id</code> and produces <code>results</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#recv" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#recv</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%results:2 = &quot;stablehlo.recv&quot;(%token) {</span></span>
<span class="line"><span>  channel_handle = #stablehlo.channel_handle&lt;handle = 1, type = 3&gt;,</span></span>
<span class="line"><span>  is_host_transfer = true</span></span>
<span class="line"><span>} : (!stablehlo.token) -&gt; (tensor&lt;2x2xi64&gt;, !stablehlo.token)</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[302]||(e[302]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3155-L3170",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Ee,[t("summary",null,[e[304]||(e[304]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.reduce-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.reduce-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.reduce")],-1)),e[305]||(e[305]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[307]||(e[307]=n(`<p><code>reduce</code></p><p>Applies a reduction function <code>body</code> to <code>inputs</code> and <code>init_values</code> along the <code>dimensions</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reduce" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reduce</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.reduce&quot;(%input, %init_value) ({</span></span>
<span class="line"><span>  ^bb0(%arg0: tensor&lt;i64&gt;, %arg1: tensor&lt;i64&gt;):</span></span>
<span class="line"><span>    %0 = stablehlo.add %arg0, %arg1 : tensor&lt;i64&gt;</span></span>
<span class="line"><span>    stablehlo.return %0 : tensor&lt;i64&gt;</span></span>
<span class="line"><span>}) {</span></span>
<span class="line"><span>  dimensions = array&lt;i64: 1&gt;</span></span>
<span class="line"><span>} : (tensor&lt;1x6xi64&gt;, tensor&lt;i64&gt;) -&gt; tensor&lt;1xi64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[306]||(e[306]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3198-L3217",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Pe,[t("summary",null,[e[308]||(e[308]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.reduce_precision-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.reduce_precision-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.reduce_precision")],-1)),e[309]||(e[309]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[311]||(e[311]=n('<p><code>reduce_precision</code></p><p>Performs element-wise conversion of <code>operand</code> to another floating-point type that uses <code>exponent_bits</code> and <code>mantissa_bits</code> and back to the original floating-point type and produces an <code>output</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reduce_precision" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reduce_precision</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%output = stablehlo.reduce_precision %operand, format = e5m10 : tensor&lt;6xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[310]||(e[310]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3244-L3258",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Oe,[t("summary",null,[e[312]||(e[312]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.reduce_scatter-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.reduce_scatter-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.reduce_scatter")],-1)),e[313]||(e[313]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[315]||(e[315]=n('<p><code>reduce_scatter</code></p><p>Within each process group in the process grid, performs reduction, using <code>computations</code>, over the values of the <code>operand</code> tensor from each process, splits the reduction result along <code>scatter_dimension</code> into parts, and scatters the split parts between the processes to produce the <code>result</code>.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>See:</span></span>\n<span class="line"><span>https://github.com/openxla/stablehlo/blob/main/docs/spec#reduce_scatter</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Example:</span></span>\n<span class="line"><span>```mlir</span></span>\n<span class="line"><span>%result = &quot;stablehlo.reduce_scatter&quot;(%operand) ({</span></span></code></pre></div><p>^bb0(%arg0: tensor&lt;i64&gt;, %arg1: tensor&lt;i64&gt;): %0 = stablehlo.add %arg0, %arg1 : tensor&lt;i64&gt; stablehlo.return %0 : tensor&lt;i64&gt; }) { scatter_dimension = 1 : i64, replica_groups = dense&lt;[[0, 1]]&gt; : tensor&lt;1x2xi64&gt;, channel_handle = #stablehlo.channel_handle&lt;handle = 0, type = 0&gt; } : (tensor&lt;2x4xi64&gt;) -&gt; tensor&lt;2x2xi64&gt; ```</p>',4)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[314]||(e[314]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3288-L3311",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",we,[t("summary",null,[e[316]||(e[316]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.reduce_window-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.reduce_window-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.reduce_window")],-1)),e[317]||(e[317]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[319]||(e[319]=n(`<p><code>reduce_window</code></p><p>Applies a reduction function <code>body</code> to windows of <code>inputs</code> and <code>init_values</code> and produces <code>results</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reduce_window" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reduce_window</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.reduce_window&quot;(%input, %init_value) ({</span></span>
<span class="line"><span>  ^bb0(%arg0: tensor&lt;i64&gt;, %arg1: tensor&lt;i64&gt;):</span></span>
<span class="line"><span>    %0 = stablehlo.add %arg0, %arg1 : tensor&lt;i64&gt;</span></span>
<span class="line"><span>    stablehlo.return %0 : tensor&lt;i64&gt;</span></span>
<span class="line"><span>}) {</span></span>
<span class="line"><span>  window_dimensions = array&lt;i64: 2, 1&gt;,</span></span>
<span class="line"><span>  window_strides = array&lt;i64: 4, 1&gt;,</span></span>
<span class="line"><span>  base_dilations = array&lt;i64: 2, 1&gt;,</span></span>
<span class="line"><span>  window_dilations = array&lt;i64: 3, 1&gt;,</span></span>
<span class="line"><span>  padding = dense&lt;[[2, 1], [0, 0]]&gt; : tensor&lt;2x2xi64&gt;</span></span>
<span class="line"><span>} : (tensor&lt;3x2xi64&gt;, tensor&lt;i64&gt;) -&gt; tensor&lt;2x2xi64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[318]||(e[318]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3347-L3370",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ze,[t("summary",null,[e[320]||(e[320]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.remainder-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.remainder-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.remainder")],-1)),e[321]||(e[321]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[323]||(e[323]=n('<p><code>remainder</code></p><p>Performs element-wise remainder of dividend <code>lhs</code> and divisor <code>rhs</code> tensors and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#remainder" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#remainder</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.remainder %lhs, %rhs : tensor&lt;4xi64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[322]||(e[322]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3408-L3421",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",He,[t("summary",null,[e[324]||(e[324]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.replica_id-Tuple{}",href:"#Reactant.MLIR.Dialects.stablehlo.replica_id-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.replica_id")],-1)),e[325]||(e[325]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[327]||(e[327]=n('<p><code>replica_id</code></p><p>Produces <code>replica_id</code> of the current process.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#replica_id" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#replica_id</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.replica_id : tensor&lt;ui32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[326]||(e[326]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3444-L3456",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",qe,[t("summary",null,[e[328]||(e[328]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.reshape-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.reshape-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.reshape")],-1)),e[329]||(e[329]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[331]||(e[331]=n('<p><code>reshape</code></p><p>Performs reshape of <code>operand</code> tensor to a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reshape" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reshape</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.reshape %operand : (tensor&lt;2xf32&gt;) -&gt; tensor&lt;1x2xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[330]||(e[330]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3477-L3489",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Ne,[t("summary",null,[e[332]||(e[332]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.reverse-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.reverse-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.reverse")],-1)),e[333]||(e[333]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[335]||(e[335]=n('<p><code>reverse</code></p><p>Reverses the order of elements in the <code>operand</code> along the specified <code>dimensions</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reverse" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reverse</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.reverse %operand, dims = [1] : tensor&lt;3x2xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[334]||(e[334]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3528-L3541",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Fe,[t("summary",null,[e[336]||(e[336]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.rng-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.rng-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.rng")],-1)),e[337]||(e[337]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[339]||(e[339]=n('<p><code>rng</code></p><p>Generates random numbers using the <code>rng_distribution</code> algorithm and produces a <code>result</code> tensor of a given shape <code>shape</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#rng" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#rng</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.rng %a, %b, %shape, distribution = NORMAL : (tensor&lt;i32&gt;, tensor&lt;i32&gt;, tensor&lt;2xi64&gt;) -&gt; tensor&lt;3x3xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[338]||(e[338]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3604-L3617",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Be,[t("summary",null,[e[340]||(e[340]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.rng_bit_generator-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.rng_bit_generator-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.rng_bit_generator")],-1)),e[341]||(e[341]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[343]||(e[343]=n('<p><code>rng_bit_generator</code></p><p>Returns an <code>output</code> filled with uniform random data and an updated output state <code>output_state</code> given an initial state <code>initial_state</code> using the pseudorandom number generator algorithm <code>rng_algorithm</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#rng_bit_generator" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#rng_bit_generator</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%output_state, %output = stablehlo.rng_bit_generator %initial_state, algorithm = THREE_FRY : (tensor&lt;2xui64&gt;) -&gt; (tensor&lt;2xui64&gt;, tensor&lt;2x2xui64&gt;)</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[342]||(e[342]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3564-L3578",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Ue,[t("summary",null,[e[344]||(e[344]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.round_nearest_afz-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.round_nearest_afz-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.round_nearest_afz")],-1)),e[345]||(e[345]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[347]||(e[347]=n('<p><code>round_nearest_afz</code></p><p>Performs element-wise rounding towards the nearest integer, breaking ties away from zero, on the <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#round_nearest_afz" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#round_nearest_afz</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.round_nearest_afz %operand : tensor&lt;5xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[346]||(e[346]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3682-L3695",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",We,[t("summary",null,[e[348]||(e[348]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.round_nearest_even-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.round_nearest_even-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.round_nearest_even")],-1)),e[349]||(e[349]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[351]||(e[351]=n('<p><code>round_nearest_even</code></p><p>Performs element-wise rounding towards the nearest integer, breaking ties towards the even integer, on the <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#round_nearest_even" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#round_nearest_even</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.round_nearest_even %operand : tensor&lt;5xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[350]||(e[350]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3645-L3659",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Ge,[t("summary",null,[e[352]||(e[352]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.rsqrt-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.rsqrt-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.rsqrt")],-1)),e[353]||(e[353]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[355]||(e[355]=n('<p><code>rsqrt</code></p><p>Performs element-wise reciprocal square root operation on <code>operand</code> tensor and produces a <code>result</code> tensor, implementing the <code>rSqrt</code> operation from the IEEE-754 specification.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#rsqrt" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#rsqrt</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.rsqrt %operand : tensor&lt;2x2xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[354]||(e[354]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3718-L3732",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Xe,[t("summary",null,[e[356]||(e[356]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.scatter-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.scatter-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.scatter")],-1)),e[357]||(e[357]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[359]||(e[359]=n('<p><code>scatter</code></p><p>Produces <code>results</code> tensors which are equal to <code>inputs</code> tensors except that several slices specified by <code>scatter_indices</code> are updated with the values <code>updates</code> using <code>update_computation</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#scatter" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#scatter</a></p><p>Example: <code>mlir %result = &quot;stablehlo.scatter&quot;(%input, %scatter_indices, %update) ({ ^bb0(%arg0: tensor&lt;i64&gt;, %arg1: tensor&lt;i64&gt;): %0 = stablehlo.add %arg0, %arg1 : tensor&lt;i64&gt; stablehlo.return %0 : tensor&lt;i64&gt; }) { scatter_dimension_numbers = #stablehlo.scatter&lt; update_window_dims = [3, 4], inserted_window_dims = [1], input_batching_dims = [0], scatter_indices_batching_dims = [1], scatter_dims_to_operand_dims = [2, 1], index_vector_dim = 3&gt;, indices_are_sorted = false, unique_indices = false } : (tensor&lt;2x3x4x2xi64&gt;, tensor&lt;2x2x3x2xi64&gt;, tensor&lt;2x2x3x2x2xi64&gt;) -&gt; tensor&lt;2x3x4x2xi64&gt;</code></p>',4)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[358]||(e[358]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3760-L3788",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",$e,[t("summary",null,[e[360]||(e[360]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.select")],-1)),e[361]||(e[361]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[363]||(e[363]=n('<p><code>select</code></p><p>Produces a <code>result</code> tensor where each element is selected from <code>on_true</code> or <code>on_false</code> tensor based on the value of the corresponding element of <code>pred</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#select" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#select</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.select %pred, %on_true, %on_false : tensor&lt;2x2xi1&gt;, tensor&lt;2x2xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[362]||(e[362]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3886-L3899",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Ye,[t("summary",null,[e[364]||(e[364]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.select_and_scatter-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.select_and_scatter-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.select_and_scatter")],-1)),e[365]||(e[365]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[367]||(e[367]=n(`<p><code>select_and_scatter</code></p><p>Scatters the values from the <code>source</code> tensor using <code>scatter</code> based on the outcome of <code>reduce_window</code> of the <code>input</code> tensor using <code>select</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#select_and_scatter" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#select_and_scatter</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.select_and_scatter&quot;(%operand, %source, %init_value) ({</span></span>
<span class="line"><span>  ^bb0(%arg0: tensor&lt;i64&gt;, %arg1: tensor&lt;i64&gt;):</span></span>
<span class="line"><span>    %0 = stablehlo.compare GE, %arg0, %arg1 : (tensor&lt;i64&gt;, tensor&lt;i64&gt;) -&gt; tensor&lt;i1&gt;</span></span>
<span class="line"><span>    stablehlo.return %0 : tensor&lt;i1&gt;</span></span>
<span class="line"><span>}, {</span></span>
<span class="line"><span>  ^bb0(%arg0: tensor&lt;i64&gt;, %arg1: tensor&lt;i64&gt;):</span></span>
<span class="line"><span>    %0 = stablehlo.add %arg0, %arg1 : tensor&lt;i64&gt;</span></span>
<span class="line"><span>    stablehlo.return %0 : tensor&lt;i64&gt;</span></span>
<span class="line"><span>}) {</span></span>
<span class="line"><span>  window_dimensions = dense&lt;[3, 1]&gt; : tensor&lt;2xi64&gt;,</span></span>
<span class="line"><span>  window_strides = dense&lt;[2, 1]&gt; : tensor&lt;2xi64&gt;,</span></span>
<span class="line"><span>  padding = dense&lt;[[0, 1], [0, 0]]&gt; : tensor&lt;2x2xi64&gt;</span></span>
<span class="line"><span>} : (tensor&lt;4x2xi64&gt;, tensor&lt;2x2xi64&gt;, tensor&lt;i64&gt;) -&gt; tensor&lt;4x2xi64&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[366]||(e[366]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3824-L3850",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Je,[t("summary",null,[e[368]||(e[368]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.send-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.send-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.send")],-1)),e[369]||(e[369]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[371]||(e[371]=n(`<p><code>send</code></p><p>Sends <code>inputs</code> to a channel <code>channel_id</code> and produces a <code>result</code> token.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#send" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#send</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.send&quot;(%operand, %token) {</span></span>
<span class="line"><span>  channel_handle = #stablehlo.channel_handle&lt;handle = 1, type = 2&gt;,</span></span>
<span class="line"><span>  is_host_transfer = true</span></span>
<span class="line"><span>} : (tensor&lt;2x2xi64&gt;, !stablehlo.token) -&gt; !stablehlo.token</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[370]||(e[370]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3926-L3941",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Ke,[t("summary",null,[e[372]||(e[372]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.set_dimension_size-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.set_dimension_size-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.set_dimension_size")],-1)),e[373]||(e[373]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[375]||(e[375]=n('<p><code>set_dimension_size</code></p><p>This operation is a work in progress, so it is not yet included in the StableHLO specification: <a href="https://github.com/openxla/stablehlo/issues/8" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/issues/8</a>.</p><p>Informally, this operation does the same thing as XLA&#39;s SetDimensionSize: <a href="https://www.tensorflow.org/xla/operation_semantics#setdimensionsize" target="_blank" rel="noreferrer">https://www.tensorflow.org/xla/operation_semantics#setdimensionsize</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = stablehlo.set_dimension_size %arg0, %arg1, dim = 1 : (tensor&lt;4x2xf32&gt;, tensor&lt;i32&gt;) -&gt; tensor&lt;4x2xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[374]||(e[374]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L3971-L3984",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Qe,[t("summary",null,[e[376]||(e[376]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.shift_left-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.shift_left-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.shift_left")],-1)),e[377]||(e[377]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[379]||(e[379]=n('<p><code>shift_left</code></p><p>Performs element-wise left-shift operation on the <code>lhs</code> tensor by <code>rhs</code> number of bits and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#shift_left" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#shift_left</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.shift_left %lhs, %rhs : tensor&lt;3xi64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[378]||(e[378]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4011-L4024",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",Ze,[t("summary",null,[e[380]||(e[380]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.shift_right_arithmetic-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.shift_right_arithmetic-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.shift_right_arithmetic")],-1)),e[381]||(e[381]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[383]||(e[383]=n('<p><code>shift_right_arithmetic</code></p><p>Performs element-wise arithmetic right-shift operation on the <code>lhs</code> tensor by <code>rhs</code> number of bits and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#shift_right_arithmetic" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#shift_right_arithmetic</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.shift_right_arithmetic %lhs, %rhs : tensor&lt;3xi64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[382]||(e[382]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4047-L4060",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",et,[t("summary",null,[e[384]||(e[384]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.shift_right_logical-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.shift_right_logical-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.shift_right_logical")],-1)),e[385]||(e[385]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[387]||(e[387]=n('<p><code>shift_right_logical</code></p><p>Performs element-wise logical right-shift operation on the <code>lhs</code> tensor by <code>rhs</code> number of bits and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#shift_right_logical" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#shift_right_logical</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.shift_right_logical %lhs, %rhs : tensor&lt;3xi64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[386]||(e[386]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4083-L4096",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",tt,[t("summary",null,[e[388]||(e[388]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.sign-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.sign-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.sign")],-1)),e[389]||(e[389]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[391]||(e[391]=n('<p><code>sign</code></p><p>Returns the sign of the <code>operand</code> element-wise and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#sign" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#sign</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.sign %operand : tensor&lt;5xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[390]||(e[390]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4119-L4132",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",st,[t("summary",null,[e[392]||(e[392]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.sine-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.sine-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.sine")],-1)),e[393]||(e[393]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[395]||(e[395]=n('<p><code>sine</code></p><p>Performs element-wise sine operation on <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#sine" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#sine</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.sine %operand : tensor&lt;2xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[394]||(e[394]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4153-L4166",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",at,[t("summary",null,[e[396]||(e[396]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.slice-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.slice-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.slice")],-1)),e[397]||(e[397]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[399]||(e[399]=n('<p><code>slice</code></p><p>Extracts a slice from the <code>operand</code> using statically-computed starting indices and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#slice" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#slice</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.slice %operand [1:3, 4:8:2]</span></span>\n<span class="line"><span>   : (tensor&lt;3x8xi64&gt;) -&gt; tensor&lt;2x2xi64&gt;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// Same in generic form: the `1:3` above is mapped to the first entry in</span></span>\n<span class="line"><span>// `start_indices` and `limit_indices`, while `strides` is implicitly 1.</span></span>\n<span class="line"><span>// The `4:8:2` above is parsed into the second entry of `start_indices`,</span></span>\n<span class="line"><span>// `limit_indices` and `strides` respectively.</span></span>\n<span class="line"><span>%result = &quot;stablehlo.slice&quot; (%operand) {</span></span>\n<span class="line"><span>  start_indices = array&lt;i64: 1, 4&gt;,</span></span>\n<span class="line"><span>  limit_indices = array&lt;i64: 3, 8&gt;,</span></span>\n<span class="line"><span>  strides = array&lt;i64: 1, 2&gt;</span></span>\n<span class="line"><span>} : (tensor&lt;3x8xi64&gt;) -&gt; tensor&lt;2x2xi64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[398]||(e[398]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4194-L4218",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",lt,[t("summary",null,[e[400]||(e[400]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.sort-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.sort-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.sort")],-1)),e[401]||(e[401]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[403]||(e[403]=n(`<p><code>sort</code></p><p>Sorts a variadic number of tensors in <code>inputs</code> together, according to a custom <code>comparator</code>, along the given <code>dimension</code> and produces a variadic number of tensors as <code>results</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#sort" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#sort</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;Badge type=&quot;info&quot; class=&quot;source-link&quot; text=&quot;source&quot;&gt;&lt;a href=&quot;https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4250-L4270&quot; target=&quot;_blank&quot; rel=&quot;noreferrer&quot;&gt;source&lt;/a&gt;&lt;/Badge&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;/details&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;details class=&#39;jldocstring custom-block&#39; &gt;</span></span>
<span class="line"><span>&lt;summary&gt;&lt;a id=&#39;Reactant.MLIR.Dialects.stablehlo.sqrt-Tuple{Reactant.MLIR.IR.Value}&#39; href=&#39;#Reactant.MLIR.Dialects.stablehlo.sqrt-Tuple{Reactant.MLIR.IR.Value}&#39;&gt;&lt;span class=&quot;jlbinding&quot;&gt;Reactant.MLIR.Dialects.stablehlo.sqrt&lt;/span&gt;&lt;/a&gt; &lt;Badge type=&quot;info&quot; class=&quot;jlObjectType jlMethod&quot; text=&quot;Method&quot; /&gt;&lt;/summary&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>\`sqrt\`</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Performs element-wise square root operation on \`operand\` tensor and produces a \`result\` tensor.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>See: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#sqrt</span></span>
<span class="line"><span></span></span>
<span class="line"><span>**Example**</span></span>
<span class="line"><span></span></span>
<span class="line"><span>\`\`\`mlir</span></span>
<span class="line"><span>%result = stablehlo.sqrt %operand : tensor&lt;2x2xf32&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[402]||(e[402]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4299-L4312",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",nt,[t("summary",null,[e[404]||(e[404]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.subtract-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.subtract-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.subtract")],-1)),e[405]||(e[405]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[407]||(e[407]=n('<p><code>subtract</code></p><p>Performs element-wise subtraction of two tensors <code>lhs</code> and <code>rhs</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#subtract" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#subtract</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.subtract %lhs, %rhs : tensor&lt;2xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[406]||(e[406]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4340-L4353",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ot,[t("summary",null,[e[408]||(e[408]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.tan-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.tan-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.tan")],-1)),e[409]||(e[409]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[411]||(e[411]=n('<p><code>tan</code></p><p>Performs element-wise tangent operation on <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#tan" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#tan</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.tan %operand : tensor&lt;2x2xf64&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[410]||(e[410]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4376-L4389",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",it,[t("summary",null,[e[412]||(e[412]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.tanh-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.tanh-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.tanh")],-1)),e[413]||(e[413]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[415]||(e[415]=n('<p><code>tanh</code></p><p>Performs element-wise hyperbolic tangent operation on <code>operand</code> tensor and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#tanh" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#tanh</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.tanh %operand : tensor&lt;2xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[414]||(e[414]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4417-L4430",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",pt,[t("summary",null,[e[416]||(e[416]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.torch_index_select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.torch_index_select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.torch_index_select")],-1)),e[417]||(e[417]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[419]||(e[419]=n(`<p><code>torch_index_select</code></p><p>This operation is on its way out of StableHLO, so it is not included in the StableHLO specification: <a href="https://github.com/openxla/stablehlo/issues/3" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/issues/3</a>.</p><p>Informally, this operation does the same thing as PyTorch&#39;s index_select, augmented with support for batch dimensions: <a href="https://pytorch.org/docs/stable/generated/torch.index_select.html" target="_blank" rel="noreferrer">https://pytorch.org/docs/stable/generated/torch.index_select.html</a>.</p><p>The <code>batch_dims</code> attribute specifies the number of major batch dimensions (0 or more) that act like a multidimensional loop over both the operand and the index.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.torch_index_select&quot;(%operand, %index) {</span></span>
<span class="line"><span>  dim = 2 : i64,</span></span>
<span class="line"><span>  batch_dims = 1 : i64</span></span>
<span class="line"><span>} : (tensor&lt;8x128x3072x64xf32&gt;, tensor&lt;8x16x1024xi32&gt;) -&gt; tensor&lt;8x128x16x1024x64xf32&gt;</span></span></code></pre></div>`,6)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[418]||(e[418]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4458-L4479",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",rt,[t("summary",null,[e[420]||(e[420]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.transpose-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.transpose-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.transpose")],-1)),e[421]||(e[421]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[423]||(e[423]=n('<p><code>transpose</code></p><p>Permutes the dimensions of <code>operand</code> tensor using <code>permutation</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#transpose" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#transpose</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = stablehlo.transpose %arg0, dims = [2, 1, 0] : (tensor&lt;1x2x3xi32&gt;) -&gt; tensor&lt;3x2x1xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[422]||(e[422]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4503-L4516",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ct,[t("summary",null,[e[424]||(e[424]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.triangular_solve-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.triangular_solve-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.triangular_solve")],-1)),e[425]||(e[425]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[427]||(e[427]=n(`<p><code>triangular_solve</code></p><p>Solves batches of systems of linear equations with lower or upper triangular coefficient matrices.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#triangular_solve" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#triangular_solve</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.triangular_solve&quot;(%a, %b) {</span></span>
<span class="line"><span>  left_side = true,</span></span>
<span class="line"><span>  lower = true,</span></span>
<span class="line"><span>  unit_diagonal = false,</span></span>
<span class="line"><span>  transpose_a = #stablehlo&lt;transpose NO_TRANSPOSE&gt;</span></span>
<span class="line"><span>} : (tensor&lt;3x3xf32&gt;, tensor&lt;3x3xf32&gt;) -&gt; tensor&lt;3x3xf32&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[426]||(e[426]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4539-L4557",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",dt,[t("summary",null,[e[428]||(e[428]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.tuple-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.tuple-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.tuple")],-1)),e[429]||(e[429]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[431]||(e[431]=n('<p><code>tuple</code></p><p>Produces a <code>result</code> tuple from values <code>val</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#tuple" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#tuple</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.tuple %val0, %val1 : tuple&lt;tensor&lt;2xf64&gt;, tuple&lt;tensor&lt;i64&gt;&gt;&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[430]||(e[430]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4592-L4604",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",bt,[t("summary",null,[e[432]||(e[432]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.unary_einsum-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.unary_einsum-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.unary_einsum")],-1)),e[433]||(e[433]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[435]||(e[435]=n(`<p><code>unary_einsum</code></p><p>This operation is on its way out of StableHLO, so it is not included in the StableHLO specification: <a href="https://github.com/openxla/stablehlo/issues/3" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/issues/3</a>.</p><p>Informally, this operation does the same thing as TF&#39;s einsum: <a href="https://www.tensorflow.org/api_docs/python/tf/einsum" target="_blank" rel="noreferrer">https://www.tensorflow.org/api_docs/python/tf/einsum</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = &quot;stablehlo.unary_einsum&quot;(%operand) {</span></span>
<span class="line"><span>  einsum_config = &quot;ab-&gt;a&quot;</span></span>
<span class="line"><span>} : (tensor&lt;4x16xf32&gt;) -&gt; tensor&lt;4xf32&gt;</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[434]||(e[434]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4627-L4642",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ut,[t("summary",null,[e[436]||(e[436]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.uniform_dequantize-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.uniform_dequantize-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.uniform_dequantize")],-1)),e[437]||(e[437]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[439]||(e[439]=n('<p><code>uniform_dequantize</code></p><p>Performs element-wise conversion of quantized tensor <code>operand</code> to a floating-point tensor <code>result</code> according to the quantization parameters defined by the <code>operand</code> type.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#uniform_dequantize" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#uniform_dequantize</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.uniform_dequantize %operand : (tensor&lt;2x!quant.uniform&lt;i8:f32:0, {0.1:-30,0.5:-20}&gt;&gt;) -&gt; tensor&lt;2xf32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[438]||(e[438]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4662-L4676",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",ht,[t("summary",null,[e[440]||(e[440]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.uniform_quantize-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.uniform_quantize-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.uniform_quantize")],-1)),e[441]||(e[441]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[443]||(e[443]=n('<p><code>uniform_quantize</code></p><p>Performs element-wise conversion of floating-point tensor or quantized tensor <code>operand</code> to a quantized tensor <code>result</code> according to the quantization parameters defined by the <code>result</code> type.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#uniform_quantize" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#uniform_quantize</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.uniform_quantize %operand : (tensor&lt;2xf32&gt;) -&gt; tensor&lt;2x!quant.uniform&lt;i8:f32:0, {0.1:-30,0.5:-20}&gt;&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[442]||(e[442]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4699-L4713",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",mt,[t("summary",null,[e[444]||(e[444]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.while_-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.stablehlo.while_-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.while_")],-1)),e[445]||(e[445]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[447]||(e[447]=n(`<p><code>while_</code></p><p>Produces the output from executing <code>body</code> function 0 or more times while the <code>cond</code> function outputs <code>true</code>.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#while" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#while</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%results0, %results1 = stablehlo.while(%arg0 = %init_i, %arg1 = %init_sum) : tensor&lt;i64&gt;, tensor&lt;i64&gt;</span></span>
<span class="line"><span>cond {</span></span>
<span class="line"><span>  %cond = stablehlo.compare LT, %arg0, %ten : (tensor&lt;i64&gt;, tensor&lt;i64&gt;) -&gt; tensor&lt;i1&gt;</span></span>
<span class="line"><span>  stablehlo.return %cond : tensor&lt;i1&gt;</span></span>
<span class="line"><span>} do {</span></span>
<span class="line"><span>  %new_sum = stablehlo.add %arg1, %one : tensor&lt;i64&gt;</span></span>
<span class="line"><span>  %new_i = stablehlo.add %arg0, %one : tensor&lt;i64&gt;</span></span>
<span class="line"><span>  stablehlo.return %new_i, %new_sum : tensor&lt;i64&gt;, tensor&lt;i64&gt;</span></span>
<span class="line"><span>}</span></span></code></pre></div>`,5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[446]||(e[446]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4733-L4754",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),t("details",gt,[t("summary",null,[e[448]||(e[448]=t("a",{id:"Reactant.MLIR.Dialects.stablehlo.xor-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.stablehlo.xor-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.stablehlo.xor")],-1)),e[449]||(e[449]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[451]||(e[451]=n('<p><code>xor</code></p><p>Performs element-wise XOR of two tensors <code>lhs</code> and <code>rhs</code> and produces a <code>result</code> tensor.</p><p>See: <a href="https://github.com/openxla/stablehlo/blob/main/docs/spec.md#xor" target="_blank" rel="noreferrer">https://github.com/openxla/stablehlo/blob/main/docs/spec.md#xor</a></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = stablehlo.xor %lhs, %rhs : tensor&lt;2xi32&gt;</span></span></code></pre></div>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[450]||(e[450]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/44d3d637b7eedc9a41154bf52272e8b25927bda6/src/mlir/Dialects/StableHLO.jl#L4780-L4793",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})])])}const Mt=i(d,[["render",Rt]]);export{yt as __pageData,Mt as default};
