import{_ as a,c as s,o as t,a2 as e}from"./chunks/framework.Ctk6uDM1.js";const r=JSON.parse('{"title":"","description":"","frontmatter":{"layout":"home","hero":{"name":"Reactant.jl Docs","text":"Optimizing Julia Functions with MLIR","tagline":"Optimize Julia Functions With MLIR and XLA for High-Performance Execution on CPU, GPU, TPU and more.","actions":[{"theme":"brand","text":"Tutorials","link":"/tutorials"},{"theme":"alt","text":"API Reference ðŸ“š","link":"/api/api"},{"theme":"alt","text":"View on GitHub","link":"https://github.com/EnzymeAD/Reactant.jl"}],"image":{"src":"/logo.svg","alt":"Reactant.jl"}},"features":[{"icon":"ðŸš€","title":"Fast & Device Agnostic","details":"Effortlessly execute your code on CPU, GPU, and TPU with MLIR and XLA.","link":"/introduction"},{"icon":"âˆ‚","title":"Built-In MLIR AD","details":"Leverage Enzyme-Powered Automatic Differentiation to Differentiate MLIR Functions","link":"/introduction"},{"icon":"ðŸ§©","title":"Composable","details":"Executes and optimizes generic Julia code without requiring special rewriting","link":"/introduction"},{"icon":"âš¡","title":"Compiler Optimizations","details":"Fancy MLIR Optimizations seamlessly optimize your Julia code","link":"/introduction"}]},"headers":[],"relativePath":"index.md","filePath":"index.md","lastUpdated":null}'),n={name:"index.md"};function l(h,i,p,k,d,o){return t(),s("div",null,i[0]||(i[0]=[e("",7)]))}const u=a(n,[["render",l]]);export{r as __pageData,u as default};
