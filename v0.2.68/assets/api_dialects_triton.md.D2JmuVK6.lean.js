import{_ as Q,C as i,c as o,o as r,j as e,a as s,G as l,w as n,al as T}from"./chunks/framework.BX5sClTa.js";const o1=JSON.parse('{"title":"Triton Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/triton.md","filePath":"api/dialects/triton.md","lastUpdated":null}'),d={name:"api/dialects/triton.md"},p={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},u={class:"jldocstring custom-block"},c={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},M={class:"MathJax",jax:"SVG",display:"true",style:{direction:"ltr",display:"block","text-align":"center",margin:"1em 0",position:"relative"}},y={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"20.248ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 8949.4 1000","aria-hidden":"true"},I={class:"jldocstring custom-block"},x={class:"MathJax",jax:"SVG",display:"true",style:{direction:"ltr",display:"block","text-align":"center",margin:"1em 0",position:"relative"}},k={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"26.094ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 11533.4 1000","aria-hidden":"true"},w={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},j={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"13.772ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 6087.3 1000","aria-hidden":"true"},D={class:"jldocstring custom-block"},V={class:"jldocstring custom-block"},H={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},v={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"8.011ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3541 1000","aria-hidden":"true"},Z={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},A={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"8.011ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3541 1000","aria-hidden":"true"},E={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},C={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"7.778ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 3438 1000","aria-hidden":"true"},z={class:"jldocstring custom-block"},O={class:"jldocstring custom-block"},S={class:"jldocstring custom-block"},P={class:"jldocstring custom-block"},F={class:"jldocstring custom-block"},N={class:"jldocstring custom-block"},B={class:"jldocstring custom-block"},G={class:"jldocstring custom-block"},q={class:"jldocstring custom-block"},J={class:"jldocstring custom-block"},U={class:"jldocstring custom-block"},$={class:"jldocstring custom-block"},W={class:"jldocstring custom-block"},X={class:"jldocstring custom-block"},Y={class:"jldocstring custom-block"},K={class:"jldocstring custom-block"},_={class:"jldocstring custom-block"};function t1(e1,t,a1,l1,s1,n1){const a=i("Badge");return r(),o("div",null,[t[186]||(t[186]=e("h1",{id:"Triton-Dialect",tabindex:"-1"},[s("Triton Dialect "),e("a",{class:"header-anchor",href:"#Triton-Dialect","aria-label":'Permalink to "Triton Dialect {#Triton-Dialect}"'},"​")],-1)),t[187]||(t[187]=e("p",null,[s("Refer to the "),e("a",{href:"https://triton-lang.org/main/dialects/TritonDialect.html",target:"_blank",rel:"noreferrer"},"official documentation"),s(" for more details.")],-1)),e("details",p,[e("summary",null,[t[0]||(t[0]=e("a",{id:"Reactant.MLIR.Dialects.tt.assert-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.assert-Tuple{Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.assert")],-1)),t[1]||(t[1]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[3]||(t[3]=e("p",null,[e("code",null,"assert")],-1)),t[4]||(t[4]=e("p",null,[e("code",null,"tt.assert"),s(" takes a condition tensor and a message string. If the condition is false, the message is printed, and the program is aborted.")],-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[2]||(t[2]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L229-L234",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",m,[e("summary",null,[t[5]||(t[5]=e("a",{id:"Reactant.MLIR.Dialects.tt.atomic_cas-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.atomic_cas-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.atomic_cas")],-1)),t[6]||(t[6]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[8]||(t[8]=e("p",null,[e("code",null,"atomic_cas")],-1)),t[9]||(t[9]=e("p",null,"compare cmp with data old at location ptr,",-1)),t[10]||(t[10]=e("p",null,"if old == cmp, store val to ptr,",-1)),t[11]||(t[11]=e("p",null,"else store old to ptr,",-1)),t[12]||(t[12]=e("p",null,"return old",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[7]||(t[7]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L254-L264",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",u,[e("summary",null,[t[13]||(t[13]=e("a",{id:"Reactant.MLIR.Dialects.tt.atomic_rmw",href:"#Reactant.MLIR.Dialects.tt.atomic_rmw"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.atomic_rmw")],-1)),t[14]||(t[14]=s()),l(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),t[16]||(t[16]=e("p",null,[e("code",null,"atomic_rmw")],-1)),t[17]||(t[17]=e("p",null,"load data at ptr, do rmw_op with val, and store result to ptr.",-1)),t[18]||(t[18]=e("p",null,"return old value at ptr",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[15]||(t[15]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L286-L292",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",c,[e("summary",null,[t[19]||(t[19]=e("a",{id:"Reactant.MLIR.Dialects.tt.broadcast-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.broadcast-Tuple{Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.broadcast")],-1)),t[20]||(t[20]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[22]||(t[22]=e("p",null,[e("code",null,"broadcast")],-1)),t[23]||(t[23]=e("p",null,"For a given tensor, broadcast changes one or more dimensions with size 1 to a new size, e.g. tensor<1x32x1xf32> -> tensor<2x32x4xf32>. You cannot change the size of a non-1 dimension.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[21]||(t[21]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L345-L351",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",f,[e("summary",null,[t[24]||(t[24]=e("a",{id:"Reactant.MLIR.Dialects.tt.call-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tt.call-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.call")],-1)),t[25]||(t[25]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[27]||(t[27]=T("",4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[26]||(t[26]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L16-L29",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",R,[e("summary",null,[t[28]||(t[28]=e("a",{id:"Reactant.MLIR.Dialects.tt.clampf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.clampf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.clampf")],-1)),t[29]||(t[29]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[31]||(t[31]=e("p",null,[e("code",null,"clampf")],-1)),t[32]||(t[32]=e("p",null,"Clamp operation for floating point types.",-1)),t[33]||(t[33]=e("p",null,"The operation takes three arguments: x, min, and max. It returns a tensor of the same shape as x with its values clamped to the range [min, max].",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[30]||(t[30]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L390-L396",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",g,[e("summary",null,[t[34]||(t[34]=e("a",{id:"Reactant.MLIR.Dialects.tt.descriptor_gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.descriptor_gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.descriptor_gather")],-1)),t[35]||(t[35]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[37]||(t[37]=e("p",null,[e("code",null,"descriptor_gather")],-1)),t[38]||(t[38]=e("p",null,[s("The "),e("code",null,"tt.desciptor_gather"),s(" op will be lowered to NVIDIA TMA load operations on targets that support it.")],-1)),t[39]||(t[39]=e("p",null,[e("code",null,"desc_ptr"),s(" is a pointer to the TMA descriptor allocated in global memory. The descriptor block must have 1 row and the indices must be a 1D tensor. Accordingly, the result is a 2D tensor multiple rows.")],-1)),t[40]||(t[40]=e("p",null,"This is an escape hatch and is only there for testing/experimenting. This op will be removed in the future.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[36]||(t[36]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L424-L436",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",h,[e("summary",null,[t[41]||(t[41]=e("a",{id:"Reactant.MLIR.Dialects.tt.descriptor_load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tt.descriptor_load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.descriptor_load")],-1)),t[42]||(t[42]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[44]||(t[44]=e("p",null,[e("code",null,"descriptor_load")],-1)),t[45]||(t[45]=e("p",null,[s("This operation will be lowered to Nvidia TMA load operation on targets supporting it. "),e("code",null,"desc"),s(" is a tensor descriptor object. The destination tensor type and shape must match the descriptor otherwise the result is undefined.")],-1)),t[46]||(t[46]=e("p",null,"This is an escape hatch and is only there for testing/experimenting. This op will be removed in the future.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[43]||(t[43]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L458-L467",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",b,[e("summary",null,[t[47]||(t[47]=e("a",{id:"Reactant.MLIR.Dialects.tt.descriptor_store-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tt.descriptor_store-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.descriptor_store")],-1)),t[48]||(t[48]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[50]||(t[50]=e("p",null,[e("code",null,"descriptor_store")],-1)),t[51]||(t[51]=e("p",null,[s("This operation will be lowered to Nvidia TMA store operation on targets supporting it. "),e("code",null,"desc"),s(" is a tensor descriptor object. The shape and types of "),e("code",null,"src"),s(" must match the descriptor otherwise the result is undefined.")],-1)),t[52]||(t[52]=e("p",null,"This is an escape hatch and is only there for testing/experimenting. This op will be removed in the future.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[49]||(t[49]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L517-L526",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",L,[e("summary",null,[t[53]||(t[53]=e("a",{id:"Reactant.MLIR.Dialects.tt.dot-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.dot-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.dot")],-1)),t[54]||(t[54]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[58]||(t[58]=e("p",null,[e("code",null,"dot")],-1)),e("mjx-container",M,[(r(),o("svg",y,t[55]||(t[55]=[T("",1)]))),t[56]||(t[56]=e("mjx-assistive-mml",{unselectable:"on",display:"block",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",overflow:"hidden",width:"100%"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[e("mi",null,"d"),e("mo",null,"="),e("mi",null,"m"),e("mi",null,"a"),e("mi",null,"t"),e("mi",null,"r"),e("mi",null,"i"),e("msub",null,[e("mi",null,"x"),e("mi",null,"m")]),e("mi",null,"u"),e("mi",null,"l"),e("mi",null,"t"),e("mi",null,"i"),e("mi",null,"p"),e("mi",null,"l"),e("mi",null,"y"),e("mo",{stretchy:"false"},"(")])],-1))]),t[59]||(t[59]=e("p",null,"a, b) + c. inputPrecision describes how to exercise the TC when the inputs are f32. It can be one of: tf32, tf32x3, ieee. tf32: use TC with tf32 ops. tf32x3: implement the 3xTF32 trick. For more info see the pass in F32DotTC.cpp ieee: don't use TC, implement dot in software. If the GPU does not have Tensor cores or the inputs are not f32, this flag is ignored.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[57]||(t[57]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L548-L557",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",I,[e("summary",null,[t[60]||(t[60]=e("a",{id:"Reactant.MLIR.Dialects.tt.dot_scaled",href:"#Reactant.MLIR.Dialects.tt.dot_scaled"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.dot_scaled")],-1)),t[61]||(t[61]=s()),l(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),t[69]||(t[69]=e("p",null,[e("code",null,"dot_scaled")],-1)),e("mjx-container",x,[(r(),o("svg",k,t[62]||(t[62]=[T("",1)]))),t[63]||(t[63]=e("mjx-assistive-mml",{unselectable:"on",display:"block",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",overflow:"hidden",width:"100%"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[e("mi",null,"d"),e("mo",null,"="),e("mi",null,"m"),e("mi",null,"a"),e("mi",null,"t"),e("mi",null,"r"),e("mi",null,"i"),e("msub",null,[e("mi",null,"x"),e("mi",null,"m")]),e("mi",null,"u"),e("mi",null,"l"),e("mi",null,"t"),e("mi",null,"i"),e("mi",null,"p"),e("mi",null,"l"),e("mi",null,"y"),e("mo",{stretchy:"false"},"("),e("mi",null,"s"),e("mi",null,"c"),e("mi",null,"a"),e("mi",null,"l"),e("mi",null,"e"),e("mo",{stretchy:"false"},"(")])],-1))]),e("p",null,[t[66]||(t[66]=s("a, ")),e("mjx-container",w,[(r(),o("svg",j,t[64]||(t[64]=[T("",1)]))),t[65]||(t[65]=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("msub",null,[e("mi",null,"a"),e("mi",null,"s")]),e("mi",null,"c"),e("mi",null,"a"),e("mi",null,"l"),e("mi",null,"e"),e("mo",{stretchy:"false"},")"),e("mo",null,","),e("mi",null,"s"),e("mi",null,"c"),e("mi",null,"a"),e("mi",null,"l"),e("mi",null,"e"),e("mo",{stretchy:"false"},"(")])],-1))]),t[67]||(t[67]=s("b, b_scale)) + c. Where scale(x, s) is a function that applies the scale per block following microscaling spec."))]),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[68]||(t[68]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L590-L595",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",D,[e("summary",null,[t[70]||(t[70]=e("a",{id:"Reactant.MLIR.Dialects.tt.elementwise_inline_asm-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tt.elementwise_inline_asm-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.elementwise_inline_asm")],-1)),t[71]||(t[71]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[73]||(t[73]=e("p",null,[e("code",null,"elementwise_inline_asm")],-1)),t[74]||(t[74]=e("p",null,"Runs an inline asm block to generate one or more tensors.",-1)),t[75]||(t[75]=e("p",null,[s("The asm block is given "),e("code",null,"packed_element"),s(" elements at a time. Exactly which elems it receives is unspecified.")],-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[72]||(t[72]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L644-L651",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",V,[e("summary",null,[t[76]||(t[76]=e("a",{id:"Reactant.MLIR.Dialects.tt.extern_elementwise-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tt.extern_elementwise-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.extern_elementwise")],-1)),t[77]||(t[77]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[89]||(t[89]=e("p",null,[e("code",null,"extern_elementwise")],-1)),e("p",null,[t[84]||(t[84]=s("call an external function $symbol implemented in ")),e("mjx-container",H,[(r(),o("svg",v,t[78]||(t[78]=[T("",1)]))),t[79]||(t[79]=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mi",null,"l"),e("mi",null,"i"),e("mi",null,"b"),e("mi",null,"p"),e("mi",null,"a"),e("mi",null,"t"),e("mi",null,"h"),e("mrow",{"data-mjx-texclass":"ORD"},[e("mo",null,"/")])])],-1))]),t[85]||(t[85]=s("libname with $args return ")),e("mjx-container",Z,[(r(),o("svg",A,t[80]||(t[80]=[T("",1)]))),t[81]||(t[81]=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mi",null,"l"),e("mi",null,"i"),e("mi",null,"b"),e("mi",null,"p"),e("mi",null,"a"),e("mi",null,"t"),e("mi",null,"h"),e("mrow",{"data-mjx-texclass":"ORD"},[e("mo",null,"/")])])],-1))]),t[86]||(t[86]=s("libname:")),e("mjx-container",E,[(r(),o("svg",C,t[82]||(t[82]=[T("",1)]))),t[83]||(t[83]=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mi",null,"s"),e("mi",null,"y"),e("mi",null,"m"),e("mi",null,"b"),e("mi",null,"o"),e("mi",null,"l"),e("mo",{stretchy:"false"},"(")])],-1))]),t[87]||(t[87]=s("args...)"))]),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[88]||(t[88]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L779-L784",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",z,[e("summary",null,[t[90]||(t[90]=e("a",{id:"Reactant.MLIR.Dialects.tt.fp_to_fp-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.fp_to_fp-Tuple{Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.fp_to_fp")],-1)),t[91]||(t[91]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[93]||(t[93]=e("p",null,[e("code",null,"fp_to_fp")],-1)),t[94]||(t[94]=e("p",null,"Floating point casting for custom types (F8), and non-default rounding modes.",-1)),t[95]||(t[95]=e("p",null,"F8 <-> FP16, BF16, FP32, FP64",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[92]||(t[92]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L817-L823",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",O,[e("summary",null,[t[96]||(t[96]=e("a",{id:"Reactant.MLIR.Dialects.tt.func-Tuple{}",href:"#Reactant.MLIR.Dialects.tt.func-Tuple{}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.func")],-1)),t[97]||(t[97]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[99]||(t[99]=T("",5)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[98]||(t[98]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L58-L96",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",S,[e("summary",null,[t[100]||(t[100]=e("a",{id:"Reactant.MLIR.Dialects.tt.gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.gather")],-1)),t[101]||(t[101]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[103]||(t[103]=e("p",null,[e("code",null,"gather")],-1)),t[104]||(t[104]=e("p",null,"Gather elements from the input tensor using the indices tensor along a single specified axis. The output tensor has the same shape as the indices tensor. The input and indices tensors must have the same number of dimension, and each dimension of the indices tensor that is not the gather dimension cannot be greater than the corresponding dimension in the input tensor.",-1)),t[105]||(t[105]=e("p",null,[s("The "),e("code",null,"efficient_layout"),s(" attribute is set when the compiler has determined an optimized layout for the operation, indicating that it should not be changed.")],-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[102]||(t[102]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L844-L857",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",P,[e("summary",null,[t[106]||(t[106]=e("a",{id:"Reactant.MLIR.Dialects.tt.histogram-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.histogram-Tuple{Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.histogram")],-1)),t[107]||(t[107]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[109]||(t[109]=e("p",null,[e("code",null,"histogram")],-1)),t[110]||(t[110]=e("p",null,"Return the histogram of the input tensor. The number of bins is equal to the dimension of the output tensor. Each bins has a width of 1 and bins start at 0.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[108]||(t[108]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L929-L935",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",F,[e("summary",null,[t[111]||(t[111]=e("a",{id:"Reactant.MLIR.Dialects.tt.join-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.join-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.join")],-1)),t[112]||(t[112]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[114]||(t[114]=e("p",null,[e("code",null,"join")],-1)),t[115]||(t[115]=e("p",null,"For example, if the two input tensors are 4x8xf32, returns a tensor of shape 4x8x2xf32.",-1)),t[116]||(t[116]=e("p",null,"Because Triton tensors always have a power-of-two number of elements, the two input tensors must have the same shape.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[113]||(t[113]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L974-L982",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",N,[e("summary",null,[t[117]||(t[117]=e("a",{id:"Reactant.MLIR.Dialects.tt.make_range-Tuple{}",href:"#Reactant.MLIR.Dialects.tt.make_range-Tuple{}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.make_range")],-1)),t[118]||(t[118]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[120]||(t[120]=e("p",null,[e("code",null,"make_range")],-1)),t[121]||(t[121]=e("p",null,"Returns an 1D int32 tensor.",-1)),t[122]||(t[122]=e("p",null,"Values span from start to $end (exclusive), with step = 1",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[119]||(t[119]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L1051-L1057",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",B,[e("summary",null,[t[123]||(t[123]=e("a",{id:"Reactant.MLIR.Dialects.tt.make_tensor_descriptor-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tt.make_tensor_descriptor-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.make_tensor_descriptor")],-1)),t[124]||(t[124]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[126]||(t[126]=e("p",null,[e("code",null,"make_tensor_descriptor")],-1)),t[127]||(t[127]=e("p",null,[e("code",null,"tt.make_tensor_descriptor"),s(" takes both meta information of the parent tensor and the block size, and returns a descriptor object which can be used to load/store from the tensor in global memory.")],-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[125]||(t[125]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L1077-L1082",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",G,[e("summary",null,[t[128]||(t[128]=e("a",{id:"Reactant.MLIR.Dialects.tt.make_tensor_ptr-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tt.make_tensor_ptr-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.make_tensor_ptr")],-1)),t[129]||(t[129]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[131]||(t[131]=e("p",null,[e("code",null,"make_tensor_ptr")],-1)),t[132]||(t[132]=e("p",null,[e("code",null,"tt.make_tensor_ptr"),s(" takes both meta information of the parent tensor and the block tensor, then it returns a pointer to the block tensor, e.g. returns a type of "),e("code",null,"tt.ptr<tensor<8x8xf16>>"),s(".")],-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[130]||(t[130]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L1108-L1113",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",q,[e("summary",null,[t[133]||(t[133]=e("a",{id:"Reactant.MLIR.Dialects.tt.mulhiui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.mulhiui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.mulhiui")],-1)),t[134]||(t[134]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[136]||(t[136]=e("p",null,[e("code",null,"mulhiui")],-1)),t[137]||(t[137]=e("p",null,"Most significant N bits of the 2N-bit product of two integers.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[135]||(t[135]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L1141-L1145",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",J,[e("summary",null,[t[138]||(t[138]=e("a",{id:"Reactant.MLIR.Dialects.tt.precise_divf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.precise_divf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.precise_divf")],-1)),t[139]||(t[139]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[141]||(t[141]=e("p",null,[e("code",null,"precise_divf")],-1)),t[142]||(t[142]=e("p",null,"Precise div for floating point types.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[140]||(t[140]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L1168-L1172",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",U,[e("summary",null,[t[143]||(t[143]=e("a",{id:"Reactant.MLIR.Dialects.tt.precise_sqrt-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.precise_sqrt-Tuple{Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.precise_sqrt")],-1)),t[144]||(t[144]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[146]||(t[146]=e("p",null,[e("code",null,"precise_sqrt")],-1)),t[147]||(t[147]=e("p",null,"Precise sqrt for floating point types.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[145]||(t[145]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L1195-L1199",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",$,[e("summary",null,[t[148]||(t[148]=e("a",{id:"Reactant.MLIR.Dialects.tt.print-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tt.print-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.print")],-1)),t[149]||(t[149]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[151]||(t[151]=e("p",null,[e("code",null,"print")],-1)),t[152]||(t[152]=e("p",null,[e("code",null,"tt.print"),s(" takes a literal string prefix and an arbitrary number of scalar or tensor arguments that should be printed. format are generated automatically from the arguments.")],-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[150]||(t[150]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L1220-L1225",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",W,[e("summary",null,[t[153]||(t[153]=e("a",{id:"Reactant.MLIR.Dialects.tt.reinterpret_tensor_descriptor-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.reinterpret_tensor_descriptor-Tuple{Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.reinterpret_tensor_descriptor")],-1)),t[154]||(t[154]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[156]||(t[156]=e("p",null,[e("code",null,"reinterpret_tensor_descriptor")],-1)),t[157]||(t[157]=e("p",null,"This Op exists to help the transition from untyped raw TMA objects to typed Tensor descriptor objects. Ideally, we can remove this once the APIs are fully fleshed out.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[155]||(t[155]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L130-L135",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",X,[e("summary",null,[t[158]||(t[158]=e("a",{id:"Reactant.MLIR.Dialects.tt.reshape-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.reshape-Tuple{Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.reshape")],-1)),t[159]||(t[159]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[161]||(t[161]=e("p",null,[e("code",null,"reshape")],-1)),t[162]||(t[162]=e("p",null,"reinterpret a tensor to a different shape.",-1)),t[163]||(t[163]=e("p",null,"If allow_reorder is set the compiler is free to change the order of elements to generate more efficient code.",-1)),t[164]||(t[164]=e("p",null,"If efficient_layout is set, this is a hint that the destination layout should be kept for performance reason. The compiler is still free to change it for better performance.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[160]||(t[160]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L1312-L1322",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",Y,[e("summary",null,[t[165]||(t[165]=e("a",{id:"Reactant.MLIR.Dialects.tt.return_-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tt.return_-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.return_")],-1)),t[166]||(t[166]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[168]||(t[168]=T("",4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[167]||(t[167]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L155-L171",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",K,[e("summary",null,[t[169]||(t[169]=e("a",{id:"Reactant.MLIR.Dialects.tt.split-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.split-Tuple{Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.split")],-1)),t[170]||(t[170]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[172]||(t[172]=e("p",null,[e("code",null,"split")],-1)),t[173]||(t[173]=e("p",null,"The input must be a tensor whose last dimension has size 2. Returns two tensors, src[..., 0] and src[..., 1].",-1)),t[174]||(t[174]=e("p",null,"For example, if the input shape is 4x8x2xf32, returns two tensors of shape 4x8xf32.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[171]||(t[171]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L1418-L1426",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})]),e("details",_,[e("summary",null,[t[175]||(t[175]=e("a",{id:"Reactant.MLIR.Dialects.tt.trans-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tt.trans-Tuple{Reactant.MLIR.IR.Value}"},[e("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tt.trans")],-1)),t[176]||(t[176]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[178]||(t[178]=e("p",null,[e("code",null,"trans")],-1)),t[179]||(t[179]=e("p",null,"For example, given a tensor x with shape [1,2,4], transpose(x) with order=[2,0,1] rearranges the tensor to have shape [4,1,2].",-1)),t[180]||(t[180]=e("p",null,`Although this op is called "trans", it implements both tl.trans() and tl.permute(). ("permute" might be a better name, but it's called "trans" because originally it only supported 2D tensors.)`,-1)),t[181]||(t[181]=e("p",null,[e("strong",null,"Implementation note on encodings:")],-1)),t[182]||(t[182]=e("p",null,"In the TritonGPU dialect (and probably others), an encoding is chosen for this op's output so it's a nop from the perspective of code generation.",-1)),t[183]||(t[183]=e("p",null,`For example, suppose tensor x has an encoding such that GPU thread [i,j,k] has a register containing element [i,j,k] of the tensor. Now we transpose x with order [2,1,0], i.e. we reverse the order of its dimensions. In TritonGPU, we will choose a layout for the output of the transpose so that GPU thread [i,j,k] has element [k,j,i] of transpose(x). But this is the same element it had before! All we've done is "rename" the element that thread [i,j,k] has.`,-1)),t[184]||(t[184]=e("p",null,'The "real" transpose – i.e. moving data between GPU threads – occurs in convertLayout ops that appear before and/or after the operation.',-1)),t[185]||(t[185]=e("p",null,"We do this so that you can chain multiple data-movement ops (e.g. transpose+reshape+concat) without going to shared memory after each one.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>t[177]||(t[177]=[e("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/80bcbd9e5220c41cf02e84f0d5a4c9115b097f41/src/mlir/Dialects/Triton.jl#L1485-L1513",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1})])])}const r1=Q(d,[["render",t1]]);export{o1 as __pageData,r1 as default};
