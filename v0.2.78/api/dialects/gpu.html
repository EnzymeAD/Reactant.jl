<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>GPU Dialect | Reactant.jl</title>
    <meta name="description" content="Documentation for Reactant.jl">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/Reactant.jl/v0.2.78/assets/style.DBTHpfuy.css" as="style">
    <link rel="preload stylesheet" href="/Reactant.jl/v0.2.78/vp-icons.css" as="style">
    
    <script type="module" src="/Reactant.jl/v0.2.78/assets/app.DKOTnbSa.js"></script>
    <link rel="preload" href="/Reactant.jl/v0.2.78/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Reactant.jl/v0.2.78/assets/chunks/theme.Bs3fAscZ.js">
    <link rel="modulepreload" href="/Reactant.jl/v0.2.78/assets/chunks/framework.D9Da5sbx.js">
    <link rel="modulepreload" href="/Reactant.jl/v0.2.78/assets/api_dialects_gpu.md.Bfc-9Ouo.lean.js">
    <link rel="icon" href="/Reactant.jl/v0.2.78/favicon.ico">
    <script src="/versions.js"></script>
    <script src="/Reactant.jl/v0.2.78/siteinfo.js"></script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-a9a9e638><!--[--><!--]--><!--[--><span tabindex="-1" data-v-492508fc></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-492508fc>Skip to content</a><!--]--><!----><header class="VPNav" data-v-a9a9e638 data-v-f1e365da><div class="VPNavBar" data-v-f1e365da data-v-822684d1><div class="wrapper" data-v-822684d1><div class="container" data-v-822684d1><div class="title" data-v-822684d1><div class="VPNavBarTitle has-sidebar" data-v-822684d1 data-v-0f4f798b><a class="title" href="/Reactant.jl/v0.2.78/" data-v-0f4f798b><!--[--><!--]--><!--[--><!--[--><!--[--><img class="VPImage dark logo" src="/Reactant.jl/v0.2.78/logo.svg" alt data-v-35a7d0b8><!--]--><!--[--><img class="VPImage light logo" src="/Reactant.jl/v0.2.78/logo.svg" alt data-v-35a7d0b8><!--]--><!--]--><!--]--><span data-v-0f4f798b>Reactant.jl</span><!--[--><!--]--></a></div></div><div class="content" data-v-822684d1><div class="content-body" data-v-822684d1><!--[--><!--]--><div class="VPNavBarSearch search" data-v-822684d1><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-822684d1 data-v-e6d46098><span id="main-nav-aria-label" class="visually-hidden" data-v-e6d46098> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Reactant.jl/v0.2.78/" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Home</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>Getting Started</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/introduction" data-v-acbfed09><!--[--><span data-v-acbfed09>Introduction</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/introduction/configuration" data-v-acbfed09><!--[--><span data-v-acbfed09>Configuration</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link vp-external-link-icon VPNavBarMenuLink" href="https://enzymead.github.io/Reactant.jl/benchmarks/" target="_blank" rel="noreferrer" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Benchmarks</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>Tutorials</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/tutorials/" data-v-acbfed09><!--[--><span data-v-acbfed09>Overview</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/tutorials/profiling" data-v-acbfed09><!--[--><span data-v-acbfed09>Profiling</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/tutorials/multihost" data-v-acbfed09><!--[--><span data-v-acbfed09>Distributed</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/tutorials/local-build" data-v-acbfed09><!--[--><span data-v-acbfed09>Local build</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>API</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/api" data-v-acbfed09><!--[--><span data-v-acbfed09>Core Reactant API</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/sharding" data-v-acbfed09><!--[--><span data-v-acbfed09>Sharding</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/ops" data-v-acbfed09><!--[--><span data-v-acbfed09>Ops</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuGroup" data-v-7dd3104a data-v-48c802d0><p class="title" data-v-48c802d0>MLIR Dialects</p><!--[--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/arith" data-v-acbfed09><!--[--><span data-v-acbfed09>ArithOps</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/affine" data-v-acbfed09><!--[--><span data-v-acbfed09>Affine</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/builtin" data-v-acbfed09><!--[--><span data-v-acbfed09>Builtin</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/chlo" data-v-acbfed09><!--[--><span data-v-acbfed09>Chlo</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/enzyme" data-v-acbfed09><!--[--><span data-v-acbfed09>Enzyme</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/enzymexla" data-v-acbfed09><!--[--><span data-v-acbfed09>EnzymeXLA</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/func" data-v-acbfed09><!--[--><span data-v-acbfed09>Func</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link active" href="/Reactant.jl/v0.2.78/api/dialects/gpu" data-v-acbfed09><!--[--><span data-v-acbfed09>GPU</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/llvm" data-v-acbfed09><!--[--><span data-v-acbfed09>LLVM</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/mpi" data-v-acbfed09><!--[--><span data-v-acbfed09>MPI</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/memref" data-v-acbfed09><!--[--><span data-v-acbfed09>MemRef</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/nvvm" data-v-acbfed09><!--[--><span data-v-acbfed09>NVVM</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/shardy" data-v-acbfed09><!--[--><span data-v-acbfed09>Shardy</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/stablehlo" data-v-acbfed09><!--[--><span data-v-acbfed09>StableHLO</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/triton" data-v-acbfed09><!--[--><span data-v-acbfed09>Triton</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/tpu" data-v-acbfed09><!--[--><span data-v-acbfed09>TPU</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/dialects/vhlo" data-v-acbfed09><!--[--><span data-v-acbfed09>VHLO</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-7dd3104a data-v-48c802d0><p class="title" data-v-48c802d0>Low-Level API</p><!--[--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/mlirc" data-v-acbfed09><!--[--><span data-v-acbfed09>MLIR API</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/xla" data-v-acbfed09><!--[--><span data-v-acbfed09>XLA</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.78/api/internal" data-v-acbfed09><!--[--><span data-v-acbfed09>Internal API</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><!----><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-822684d1 data-v-af096f4a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-af096f4a data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-822684d1 data-v-164c457f data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://julialang.org/slack/" aria-label="slack" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-slack"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-822684d1 data-v-925effce data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-04f5c5e9><span class="vpi-more-horizontal icon" data-v-04f5c5e9></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><!----><!--[--><!--[--><!----><div class="group" data-v-925effce><div class="item appearance" data-v-925effce><p class="label" data-v-925effce>Appearance</p><div class="appearance-action" data-v-925effce><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-925effce data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div></div></div><div class="group" data-v-925effce><div class="item social-links" data-v-925effce><div class="VPSocialLinks social-links-list" data-v-925effce data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://julialang.org/slack/" aria-label="slack" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-slack"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--[--><!--[--><!--[--><a target="_blank" data-decoration="★" title="150 GitHub stars" href="https://github.com/EnzymeAD/Reactant.jl" data-v-b4d08338><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align:middle;margin-right:0.25rem;margin-left:0.5rem;" data-v-b4d08338><path d="M12 .297C5.375.297 0 5.673 0 12.3c0 5.292 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577 0-.285-.01-1.04-.015-2.04-3.338.727-4.042-1.61-4.042-1.61-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.807 1.305 3.493.997.107-.774.42-1.305.762-1.605-2.665-.3-5.467-1.333-5.467-5.931 0-1.31.47-2.382 1.236-3.222-.123-.303-.535-1.52.117-3.166 0 0 1.01-.323 3.31 1.23.96-.267 1.98-.4 3-.405 1.02.005 2.04.138 3 .405 2.3-1.553 3.31-1.23 3.31-1.23.653 1.646.24 2.863.117 3.166.765.84 1.236 1.912 1.236 3.222 0 4.61-2.807 5.625-5.477 5.921.43.372.823 1.102.823 2.222 0 1.606-.015 2.902-.015 3.293 0 .32.192.693.8.577C20.565 22.1 24 17.588 24 12.297 24 5.673 18.627.297 12 .297z" data-v-b4d08338></path></svg><span data-v-b4d08338>0.1k</span></a><a class="mobile" target="_blank" title="150 GitHub stars" href="https://github.com/EnzymeAD/Reactant.jl" data-v-b4d08338><svg xmlns="http://www.w3.org/2000/svg" width="21" height="21" viewBox="0 0 21 21" fill="none" data-v-b4d08338><path d="M19.625 5.60534C18.7083 4.03477 17.4649 2.79135 15.8945 1.87479C14.3238 0.958185 12.6091 0.5 10.7492 0.5C8.88947 0.5 7.17422 0.958325 5.60388 1.87479C4.0333 2.7913 2.78997 4.03477 1.87332 5.60534C0.956814 7.17587 0.498535 8.89089 0.498535 10.7504C0.498535 12.984 1.15021 14.9926 2.4539 16.7766C3.75744 18.5607 5.44142 19.7952 7.50571 20.4803C7.746 20.5249 7.92388 20.4936 8.03954 20.387C8.15524 20.2804 8.21302 20.1467 8.21302 19.9868C8.21302 19.9601 8.21073 19.7199 8.20629 19.266C8.20171 18.8122 8.19956 18.4162 8.19956 18.0783L7.89256 18.1315C7.69682 18.1673 7.44989 18.1825 7.15178 18.1782C6.8538 18.174 6.54446 18.1428 6.22419 18.0847C5.90377 18.0272 5.60575 17.8937 5.32988 17.6846C5.05416 17.4755 4.85842 17.2018 4.74272 16.8639L4.60925 16.5568C4.52029 16.3523 4.38023 16.1251 4.18888 15.8761C3.99754 15.6269 3.80405 15.458 3.60831 15.369L3.51486 15.3021C3.45259 15.2577 3.39481 15.204 3.34138 15.1418C3.28799 15.0796 3.24802 15.0173 3.22132 14.955C3.19458 14.8926 3.21674 14.8414 3.28804 14.8012C3.35933 14.761 3.48817 14.7416 3.67512 14.7416L3.94196 14.7814C4.11993 14.8171 4.34007 14.9236 4.60266 15.1017C4.86511 15.2796 5.08085 15.5109 5.24994 15.7956C5.4547 16.1605 5.7014 16.4385 5.99072 16.6299C6.27982 16.8212 6.5713 16.9167 6.86488 16.9167C7.15846 16.9167 7.41203 16.8945 7.62567 16.8502C7.83908 16.8057 8.0393 16.7388 8.22625 16.6499C8.30633 16.0535 8.52437 15.5953 8.88017 15.275C8.37304 15.2217 7.9171 15.1414 7.51212 15.0347C7.10736 14.9278 6.6891 14.7544 6.25761 14.5139C5.82589 14.2738 5.46774 13.9756 5.18309 13.6198C4.89839 13.2639 4.66474 12.7966 4.48247 12.2183C4.3001 11.6399 4.20889 10.9726 4.20889 10.2163C4.20889 9.13941 4.56044 8.22304 5.26341 7.46665C4.93411 6.65705 4.96519 5.74947 5.35676 4.744C5.61482 4.66382 5.9975 4.72399 6.50463 4.92412C7.01186 5.12434 7.38323 5.29587 7.61912 5.43808C7.85502 5.58024 8.04402 5.70071 8.18642 5.79842C9.01411 5.56715 9.86825 5.45149 10.7491 5.45149C11.6299 5.45149 12.4843 5.56715 13.312 5.79842L13.8192 5.47823C14.166 5.26459 14.5756 5.06881 15.0469 4.89083C15.5185 4.71295 15.8791 4.66396 16.1284 4.74414C16.5286 5.74966 16.5643 6.65719 16.2349 7.46679C16.9378 8.22318 17.2895 9.13978 17.2895 10.2164C17.2895 10.9727 17.198 11.6421 17.0159 12.225C16.8336 12.808 16.5979 13.2749 16.3088 13.6265C16.0194 13.9781 15.659 14.274 15.2275 14.5141C14.7959 14.7544 14.3775 14.9278 13.9728 15.0347C13.5678 15.1415 13.1119 15.2219 12.6047 15.2752C13.0673 15.6755 13.2986 16.3073 13.2986 17.1704V19.9864C13.2986 20.1464 13.3542 20.2799 13.4656 20.3867C13.5768 20.4932 13.7524 20.5246 13.9927 20.4799C16.0573 19.7949 17.7413 18.5603 19.0448 16.7762C20.3481 14.9922 21 12.9837 21 10.75C20.9996 8.89075 20.541 7.17587 19.625 5.60534Z" fill="currentColor" data-v-b4d08338></path></svg></a><!--]--><div class="VPFlyout VPNolebaseEnhancedReadabilitiesMenu VPNolebaseEnhancedReadabilitiesMenuFlyout" aria-label="Enhanced Readability" role="menuitem" data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><span class="i-icon-park-outline:book-open option-icon" data-v-04f5c5e9></span><!----><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><!----><!--[--><!--]--></div></div></div><!--]--><!--]--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-822684d1 data-v-5dea55bf><span class="container" data-v-5dea55bf><span class="top" data-v-5dea55bf></span><span class="middle" data-v-5dea55bf></span><span class="bottom" data-v-5dea55bf></span></span></button></div></div></div></div><div class="divider" data-v-822684d1><div class="divider-line" data-v-822684d1></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-a9a9e638 data-v-070ab83d><div class="container" data-v-070ab83d><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-070ab83d><span class="vpi-align-left menu-icon" data-v-070ab83d></span><span class="menu-text" data-v-070ab83d>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-070ab83d data-v-168ddf5d><button data-v-168ddf5d>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-a9a9e638 data-v-18756405><div class="curtain" data-v-18756405></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-18756405><span class="visually-hidden" id="sidebar-aria-label" data-v-18756405> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0 collapsible has-active" data-v-9e426adc data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h2 class="text" data-v-a4b0d9bf>API Reference</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/api" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Reactant API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/sharding" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Sharding</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/ops" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Ops</p><!--]--></a><!----></div><!----></div><section class="VPSidebarItem level-1 collapsible has-active" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h3 class="text" data-v-a4b0d9bf>MLIR Dialects</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/arith" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>ArithOps</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/affine" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Affine</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/builtin" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Builtin</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/chlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Chlo</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/enzyme" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Enzyme</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/enzymexla" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>EnzymeXLA</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/func" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Func</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/gpu" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>GPU</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/llvm" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>LLVM</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/mpi" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MPI</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/memref" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MemRef</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/nvvm" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>NVVM</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/shardy" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Shardy</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/stablehlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>StableHLO</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/triton" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Triton</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/tpu" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>TPU</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/dialects/vhlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>VHLO</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 collapsible" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h3 class="text" data-v-a4b0d9bf>Low-Level API</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/mlirc" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MLIR API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/xla" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>XLA</p><!--]--></a><!----></div><!----></div><!--]--></div></section><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.78/api/internal" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Internal API</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-a9a9e638 data-v-91765379><div class="VPDoc has-sidebar has-aside" data-v-91765379 data-v-83890dd9><!--[--><!--]--><div class="container" data-v-83890dd9><div class="aside" data-v-83890dd9><div class="aside-curtain" data-v-83890dd9></div><div class="aside-container" data-v-83890dd9><div class="aside-content" data-v-83890dd9><div class="VPDocAside" data-v-83890dd9 data-v-6d7b3c46><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-6d7b3c46 data-v-b38bf2ff><div class="content" data-v-b38bf2ff><div class="outline-marker" data-v-b38bf2ff></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-b38bf2ff>On this page</div><ul class="VPDocOutlineItem root" data-v-b38bf2ff data-v-3f927ebe><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-6d7b3c46></div><!--[--><!--[--><!--[--><!--[--><!--[--><br><h2> Trusted by </h2><a class="enjoyer" href="https://lux.csail.mit.edu/" target="_blank"><img width="32" height="32" src="https://raw.githubusercontent.com/LuxDL/Lux.jl/refs/heads/main/assets/lux-logo.svg"><span><p class="extra-info">Scientific Computing</p><p class="heading">Lux.jl</p><p class="extra-info">Machine Learning</p></span></a><a class="enjoyer" href="https://bsc-quantic.github.io/Tenet.jl/stable/" target="_blank"><img width="32" height="32" src="https://raw.githubusercontent.com/bsc-quantic/Tenet.jl/refs/heads/master/docs/src/assets/logo.svg"><span><p class="extra-info">Quantum Simulation</p><p class="heading">Tenet.jl</p><p class="extra-info">Tensor Networks</p></span></a><!--]--><!--]--><!--]--><!--]--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-83890dd9><div class="content-container" data-v-83890dd9><!--[--><!--]--><main class="main" data-v-83890dd9><div style="position:relative;" class="vp-doc _Reactant_jl_v0_2_78_api_dialects_gpu" data-v-83890dd9><div><h1 id="GPU-Dialect" tabindex="-1">GPU Dialect <a class="header-anchor" href="#GPU-Dialect" aria-label="Permalink to &quot;GPU Dialect {#GPU-Dialect}&quot;">​</a></h1><p>Refer to the <a href="https://mlir.llvm.org/docs/Dialects/GPU/" target="_blank" rel="noreferrer">official documentation</a> for more details.</p><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.all_reduce-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.all_reduce-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.all_reduce</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>all_reduce</code></p><p>The <code>all_reduce</code> op reduces the value of every work item across a local workgroup. The result is equal for all work items of a workgroup.</p><p>For example, both</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = gpu.all_reduce add %0 {} : (f32) -&gt; (f32)</span></span>
<span class="line"><span>%2 = gpu.all_reduce %0 {</span></span>
<span class="line"><span>^bb(%lhs : f32, %rhs : f32):</span></span>
<span class="line"><span>  %sum = arith.addf %lhs, %rhs : f32</span></span>
<span class="line"><span>  &quot;gpu.yield&quot;(%sum) : (f32) -&gt; ()</span></span>
<span class="line"><span>} : (f32) -&gt; (f32)</span></span></code></pre></div><p>compute the sum of each work item&#39;s %0 value. The first version specifies the accumulation as operation, whereas the second version specifies the accumulation as code region. The reduction operation must be one of:</p><ul><li><p>Integer types: <code>add</code>, <code>mul</code>, <code>minui</code>, <code>minsi</code>, <code>maxui</code>, <code>maxsi</code>, <code>and</code>, <code>or</code>, <code>xor</code></p></li><li><p>Floating point types: <code>add</code>, <code>mul</code>, <code>minnumf</code>, <code>maxnumf</code>, <code>minimumf</code>, <code>maximumf</code></p></li></ul><p>If <code>uniform</code> flag is set either none or all work items of a workgroup need to execute this op in convergence.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L16-L43" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.alloc-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.gpu.alloc-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.alloc</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>alloc</code></p><p>The <code>gpu.alloc</code> operation allocates a region of memory on the GPU. It is similar to the <code>memref.alloc</code> op, but supports asynchronous GPU execution.</p><p>The op does not execute before all async dependencies have finished executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it also returns a !gpu.async.token.</p><p>If the <code>host_shared</code> keyword is present, the memory will be allocated in a memory accessible both on host and on device.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%memref, %token = gpu.alloc async [%dep] host_shared (%width) : memref&lt;64x?xf32, 1&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L73-L94" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.barrier-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.barrier-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.barrier</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>barrier</code></p><p>The &quot;barrier&quot; op synchronizes all work items of a workgroup. It is used to coordinate communication between the work items of the workgroup.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpu.barrier</span></span></code></pre></div><p>waits until all work items in the workgroup have reached this point and all memory accesses made by these work items prior to the op are visible to all work items in the workgroup. Data hazards between work items accessing the same memory can be avoided by synchronizing work items in-between these accesses.</p><p>Either none or all work items of a workgroup need to execute this op in convergence.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L130-L148" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.binary-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.binary-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.binary</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>binary</code></p><p>GPU binaries provide a semantic mechanism for storing GPU objects, e.g. the result of compiling a GPU module to an object file.</p><p>This operation has 3 arguments:</p><ul><li><p>The name of the binary.</p></li><li><p>An optional attribute implementing the offloading LLVM translation interface.</p></li><li><p>An array of GPU object attributes.</p></li></ul><p>During translation, the offloading attribute will be called for translating GPU <code>binary</code> and <code>launch_func</code> operations. The default offloading handler is: <code>#gpu.select_object</code>, this handler selects the first object from the array and embeds it as a string.</p><p>Examples:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  // Selects the first object.</span></span>
<span class="line"><span>  gpu.binary @myobject [#gpu.object&lt;...&gt;, #gpu.object&lt;...&gt;]</span></span>
<span class="line"><span>  // Uses the `#foo.my_handler` for handling the binary during translation.</span></span>
<span class="line"><span>  gpu.binary @myobject &lt;#foo.my_handler&gt; [#gpu.object&lt;...&gt;, #gpu.object&lt;...&gt;]</span></span>
<span class="line"><span>  // Selects the object with the `#rocdl.target` target attribute.</span></span>
<span class="line"><span>  gpu.binary @myobject &lt;#gpu.select_object&lt;#rocdl.target&gt;&gt; [#gpu.object&lt;...&gt;, #gpu.object&lt;#rocdl.target, ...&gt;]</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L168-L193" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.block_dim-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.block_dim-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.block_dim</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>block_dim</code></p><p>Returns the number of threads in the thread block (aka the block size) along the x, y, or z <code>dimension</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%bDimX = gpu.block_dim x</span></span></code></pre></div><p>If <code>known_block_size</code> is set on an this operation&#39;s enclosing <code>gpu.func</code>, or <code>gpu.known_block_size</code> is set on an enclosing <code>FunctionOpInterface</code> implementor, or if the enclosing <code>gpu.launch</code> specifies a constant size for <code>dimension</code>&#39;s blocks, these contextual facts may be used to infer that this operation has a constant value, though such a transformation will not be performed by canonicalization or the default constant folder. Executions which cause that constant-value assumption to be false incur undefined behavior.</p><p>If <code>upper_bound</code> is set, executions where the bblock size along <code>dimension</code> exceeds <code>upper_bound</code> cause undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L217-L241" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.block_id-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.block_id-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.block_id</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>block_id</code></p><p>Returns the block id, i.e. the index of the current block within the grid along the x, y, or z <code>dimension</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%bIdY = gpu.block_id y</span></span></code></pre></div><p>If <code>upper_bound</code> is set, or if one can be inferred from <code>known_grid_size</code>-type annotations in context, executions where the block index in <code>dimension</code> would be greater than or equal to that bound cause undefined behavior. <code>upper_bound</code> takes priority over bounds inferrable from context.</p><p>There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L268-L286" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.cluster_block_id-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.cluster_block_id-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.cluster_block_id</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>cluster_block_id</code></p><p>Returns the block id within the cluster along the x, y, or z <code>dimension</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%cBlockIdY = gpu.cluster_block_id y</span></span></code></pre></div><p>If <code>upper_bound</code> is set, then executing (a lowering of) this operation in an environment where the number of thread blocks per cluster along <code>dimension</code> is greater than <code>upper_bound</code> causes undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxClusterDim</code> (currently 8).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L313-L329" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.cluster_dim-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.cluster_dim-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.cluster_dim</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>cluster_dim</code></p><p>Returns the number of cluster identifiers per grid along the x, y, or z <code>dimension</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%cDimX = gpu.cluster_dim x</span></span></code></pre></div><p>If <code>upper_bound</code> is set, then executing (a lowering of) this operation in an environment where the clusters per grid is greater than <code>upper_bound</code> causes undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L400-L417" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.cluster_dim_blocks-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.cluster_dim_blocks-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.cluster_dim_blocks</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>cluster_dim_blocks</code></p><p>Returns the number of thread blocks in the cluster along the x, y, or z <code>dimension</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%cDimBlocksX = gpu.cluster_dim_blocks x</span></span></code></pre></div><p>If <code>upper_bound</code> is set, then executing (a lowering of) this operation in an environment where the thread blocks per cluster is greater than <code>upper_bound</code> causes undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxClusterDim</code> (currently 8).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L356-L373" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.cluster_id-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.cluster_id-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.cluster_id</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>cluster_id</code></p><p>Returns the cluster id, i.e. the index of the current cluster within the grid along the x, y, or z <code>dimension</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%cIdY = gpu.cluster_id y</span></span></code></pre></div><p>If <code>upper_bound</code> is set, then executing (a lowering of) this operation in an environment where the number of clusters in the grid along <code>dimension</code> is greater than <code>upper_bound</code> causes undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L444-L461" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.create_2to4_spmat-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.create_2to4_spmat-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.create_2to4_spmat</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>create_2to4_spmat</code></p><p>The <code>gpu.create_2to4_spmat</code> operation initializes a sparse matrix in dense format with 2:4 sparsity. The buffers must already be copied from the host to the device prior to using this operation. The operation returns a handle to the sparse matrix descriptor.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%spmat, %token = gpu.create_2to4_spmat async [%dep] {PRUNE_AND_CHECK} %rows, %cols, %mem: memref&lt;?xf64&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L488-L506" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.create_bsr-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 8}}" href="#Reactant.MLIR.Dialects.gpu.create_bsr-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 8}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.create_bsr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>create_bsr</code></p><p>The <code>gpu.create_bsr</code> operation initializes a sparse matrix in BSR format with the given sizes for the matrix and blocks from the given position, index, and values buffers. The buffers must already be copied from the host to the device prior to using this operation. The operation returns a handle to the sparse matrix descriptor.</p><p>The BSR format is similar to CSR, where the column indices represent two-dimensional blocks instead of a single matrix entry. Note that this operation (currently) only supports storage with <strong>square</strong> blocks, i.e., <code>rBlockSize == cBlockSize</code>.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%spmat, %token = gpu.create_bsr async [%dep]</span></span>
<span class="line"><span>   %brows, %bcols, %bnnz, %rBlockSize, %cBlockSize,</span></span>
<span class="line"><span>   %bRowPos, %bColIdxs, %values : memref&lt;?xindex&gt;, memref&lt;?xindex&gt;, memref&lt;?xf64&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L537-L562" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.create_coo-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 6}}" href="#Reactant.MLIR.Dialects.gpu.create_coo-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 6}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.create_coo</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>create_coo</code></p><p>The <code>gpu.create_coo</code> operation initializes a sparse matrix in COO format with the given sizes from the given index and values buffers. The buffers must already be copied from the host to the device prior to using this operation. The operation returns a handle to the sparse matrix descriptor. Note that this operation builds the COO in SoA format.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%spmat, %token = gpu.create_coo async [%dep] %rows, %cols, %nnz, %rowIdx,</span></span>
<span class="line"><span>    %colIdx, %values : memref&lt;?xindex&gt;, memref&lt;?xindex&gt;, memref&lt;?xf64&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L658-L677" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.create_coo_aos-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 5}}" href="#Reactant.MLIR.Dialects.gpu.create_coo_aos-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 5}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.create_coo_aos</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>create_coo_aos</code></p><p>The <code>gpu.create_coo_aos</code> operation initializes a sparse matrix in COO format with the given sizes from the given index and values buffers. The buffers must already be copied from the host to the device prior to using this operation. The operation returns a handle to the sparse matrix descriptor. Unlike the default <code>gpu.create_coo</code> operation, this operation builds the COO format from a single index buffer in AoS format (note that this feature has been deprecated in cuSparse 11.2).</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%spmat, %token = gpu.create_coo_aos async [%dep] %rows, %cols, %nnz, %idxs,</span></span>
<span class="line"><span>    %values : memref&lt;?xindex&gt;, memref&lt;?xf64&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L606-L627" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.create_csc-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 6}}" href="#Reactant.MLIR.Dialects.gpu.create_csc-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 6}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.create_csc</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>create_csc</code></p><p>The <code>gpu.create_csc</code> operation initializes a sparse matrix in CSC format with the given sizes from the given position, index, and values buffers. The buffers must already be copied from the host to the device prior to using this operation. The operation returns a handle to the sparse matrix descriptor.</p><p>The CSC format has exactly the same memory layout as its transpose in CSR format (and vice versa).</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%spmat, %token = gpu.create_csc async [%dep] %rows, %cols, %nnz, %colPos,</span></span>
<span class="line"><span>    %rowIdx, %values : memref&lt;?xindex&gt;, memref&lt;?xindex&gt;, memref&lt;?xf64&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L709-L731" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.create_csr-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 6}}" href="#Reactant.MLIR.Dialects.gpu.create_csr-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 6}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.create_csr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>create_csr</code></p><p>The <code>gpu.create_csr</code> operation initializes a sparse matrix in CSR format with the given sizes from the given position, index, and values buffers. The buffers must already be copied from the host to the device prior to using this operation. The operation returns a handle to the sparse matrix descriptor.</p><p>The CSR format has exactly the same memory layout as its transpose in CSC format (and vice versa).</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%spmat, %token = gpu.create_csr async [%dep] %rows, %cols, %nnz, %rowPos,</span></span>
<span class="line"><span>    %colIdx, %values : memref&lt;?xindex&gt;, memref&lt;?xindex&gt;, memref&lt;?xf64&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L763-L785" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.create_dn_tensor-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.gpu.create_dn_tensor-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.create_dn_tensor</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>create_dn_tensor</code></p><p>The <code>gpu.create_dn_tensor</code> operation initializes a dense tensor from the given values buffer and sizes. The buffer must already be copied from the host to the device prior to using this operation. The operation returns a handle to the dense tensor descriptor.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%dmat, %token = gpu.create_dn_tensor async [%dep] %mem, %dims : index, index into memref&lt;?xf64&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L817-L834" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.dealloc-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.dealloc-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.dealloc</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>dealloc</code></p><p>The <code>gpu.dealloc</code> operation frees the region of memory referenced by a memref which was originally created by the <code>gpu.alloc</code> operation. It is similar to the <code>memref.dealloc</code> op, but supports asynchronous GPU execution.</p><p>The op does not execute before all async dependencies have finished executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.dealloc async [%dep] %memref : memref&lt;8x64xf32, 1&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L863-L882" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.destroy_dn_tensor-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.destroy_dn_tensor-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.destroy_dn_tensor</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>destroy_dn_tensor</code></p><p>The <code>gpu.destroy_dn_tensor</code> operation releases all resources of a dense tensor represented by a handle that was previously created by a <code>gpu.create_dn_tensor</code> operation.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.destroy_dn_tensor async [%dep] %dnTensor</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L908-L924" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.destroy_sp_mat-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.destroy_sp_mat-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.destroy_sp_mat</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>destroy_sp_mat</code></p><p>The <code>gpu.destroy_sp_mat</code> operation releases all resources of a sparse matrix represented by a handle that was previously created by a one of the sparse matrix creation operations.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.destroy_sp_mat async [%dep] %spmat</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L950-L966" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.dynamic_shared_memory-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.dynamic_shared_memory-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.dynamic_shared_memory</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>dynamic_shared_memory</code></p><p>This operation provides a memref pointer to the start of dynamic shared memory, often referred to as workgroup memory. It&#39;s important to note that this dynamic shared memory needs to be allocated at kernel launch. One can conveniently utilize <code>the dynamic_shared_memory_size</code> parameter of <code>gpu.launch</code> for this purpose.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = gpu.dynamic.shared.memory : memref&lt;?xi8, #gpu.address_space&lt;workgroup&gt;&gt;</span></span>
<span class="line"><span>%1 = memref.view %0[%c8192][] : memref&lt;?xi8, #gpu.address_space&lt;workgroup&gt;&gt;</span></span>
<span class="line"><span>                        to memref&lt;32x64xf32, #gpu.address_space&lt;workgroup&gt;&gt;</span></span>
<span class="line"><span>%2 = memref.view %0[%c16384][] : memref&lt;?xi8, #gpu.address_space&lt;workgroup&gt;&gt;</span></span>
<span class="line"><span>                        to memref&lt;32x64xf32, #gpu.address_space&lt;workgroup&gt;&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L992-L1009" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.func-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.func-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.func</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>func</code></p><p>Defines a function that can be executed on a GPU. This supports memory attribution and its body has a particular execution model.</p><p>GPU functions are either kernels (as indicated by the <code>kernel</code> attribute) or regular functions. The former can be launched from the host side, while the latter are device side only.</p><p>The memory attribution defines SSA values that correspond to memory buffers allocated in the memory hierarchy of the GPU (see below).</p><p>The operation has one attached region that corresponds to the body of the function. The region arguments consist of the function arguments without modification, followed by buffers defined in memory annotations. The body of a GPU function, when launched, is executed by multiple work items. There are no guarantees on the order in which work items execute, or on the connection between them. In particular, work items are not necessarily executed in lock-step. Synchronization ops such as &quot;gpu.barrier&quot; should be used to coordinate work items. Declarations of GPU functions, i.e. not having the body region, are not supported.</p><p>A function may optionally be annotated with the block and/or grid sizes that will be used when it is launched using the <code>known_block_size</code> and <code>known_grid_size</code> attributes, respectively. If set, these attributes must be arrays of three 32-bit integers giving the x, y, and z launch dimensions. Launching a kernel that has these annotations, or that calls a function with these annotations, using a block size or grid size other than what is specified is undefined behavior. These attributes may be set on non-<code>gpu.func</code> functions by using <code>gpu.known_block_size</code> or <code>gpu.known_grid_size</code>, but this carries the risk that they will de discarded.</p><p><strong>Syntax</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>op ::= `gpu.func` symbol-ref-id `(` argument-list `)` (`-&gt;`</span></span>
<span class="line"><span>function-result-list)?</span></span>
<span class="line"><span>       memory-attribution `kernel`? function-attributes? region</span></span>
<span class="line"><span></span></span>
<span class="line"><span>memory-attribution ::= (`workgroup` `(` ssa-id-and-type-list `)`)?</span></span>
<span class="line"><span>                       (`private` `(` ssa-id-and-type-list `)`)?</span></span></code></pre></div><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpu.func @foo(%arg0: index)</span></span>
<span class="line"><span>    workgroup(%workgroup: memref&lt;32xf32, 3&gt;)</span></span>
<span class="line"><span>    private(%private: memref&lt;1xf32, 5&gt;)</span></span>
<span class="line"><span>    kernel</span></span>
<span class="line"><span>    attributes {qux: &quot;quux&quot;} {</span></span>
<span class="line"><span>  gpu.return</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>The generic form illustrates the concept</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;gpu.func&quot;(%arg: index) {sym_name: &quot;foo&quot;, kernel, qux: &quot;quux&quot;} ({</span></span>
<span class="line"><span>^bb0(%arg0: index, %workgroup: memref&lt;32xf32, 3&gt;,</span></span>
<span class="line"><span>     %private: memref&lt;1xf32, 5&gt;):</span></span>
<span class="line"><span>  &quot;gpu.return&quot;() : () -&gt; ()</span></span>
<span class="line"><span>}) : (index) -&gt; ()</span></span></code></pre></div><p>Note the non-default memory spaces used in memref types in memory attribution.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1029-L1097" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.global_id-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.global_id-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.global_id</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>global_id</code></p><p>Returns the unique global workitem/thread id, i.e., the unique index of the current workitem/thread within all workgroups / grid along the x, y, or z <code>dimension</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%gidX = gpu.global_id x</span></span>
<span class="line"><span>%gidX = gpu.global_id x upper_bound 65536</span></span></code></pre></div><p>The <code>upper_bound</code> attribute defines an upper bound analogously to the ones on <code>thread_id</code> and <code>block_id</code>. If one is not set, the bound may be inferred from a combination of <code>known_block_size</code> and <code>known_grid_size</code>-type annotations.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1204-L1221" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.grid_dim-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.grid_dim-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.grid_dim</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>grid_dim</code></p><p>Returns the number of thread blocks in the grid along the x, y, or z <code>dimension</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%gDimZ = gpu.grid_dim z</span></span></code></pre></div><p>If <code>known_grid_size</code> is set on an this operation&#39;s enclosing <code>gpu.func</code>, or <code>gpu.known_grid_size</code> is set on an enclosing <code>FunctionOpInterface</code> implementor, or if the enclosing <code>gpu.launch</code> specifies a constant size for <code>dimension</code>&#39;s grid length, these contextual facts may be used to infer that this operation has a constant value, though such a transformation will not be performed by canonicalization or the default constant folder. Executions which cause that constant-value assumption to be false incur undefined behavior.</p><p>If <code>upper_bound</code> is set, executions where the grid size in <code>dimension</code> would exceed <code>upper_bound</code> cause undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1248-L1273" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.host_register-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.host_register-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.host_register</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>host_register</code></p><p>This op maps the provided host buffer into the device address space.</p><p>This operation may not be supported in every environment, there is not yet a way to check at runtime whether this feature is supported.</p><p>Writes from the host are guaranteed to be visible to device kernels that are launched afterwards. Writes from the device are guaranteed to be visible on the host after synchronizing with the device kernel completion.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1300-L1311" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.host_unregister-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.host_unregister-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.host_unregister</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>host_unregister</code></p><p>This op unmaps the provided host buffer from the device address space.</p><p>This operation may not be supported in every environment, there is not yet a way to check at runtime whether this feature is supported.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1331-L1338" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.lane_id-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.lane_id-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.lane_id</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>lane_id</code></p><p>Returns the lane id within the subgroup (warp/wave).</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%laneId = gpu.lane_id</span></span></code></pre></div><p>If <code>upper_bound</code> is set, executions with more than <code>upper_bound</code> lanes per subgroup cause undefined behavior. In the abscence of <code>upper_bound</code>, the lane id is still assumed to be non-negative and less than the target-independent <code>kMaxSubgroupSize</code> (currently 128).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1358-L1372" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.launch" href="#Reactant.MLIR.Dialects.gpu.launch"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.launch</span></a> <span class="VPBadge info jlObjectType jlFunction"><!--[-->Function<!--]--></span></summary><p><code>launch</code></p><p>Launch a kernel on the specified grid of thread blocks. The body of the kernel is defined by the single region that this operation contains. The operation takes an optional list of async dependencies followed by six operands and an optional operand.</p><p>The <code>async</code> keyword indicates the kernel should be launched asynchronously; the operation returns a new !gpu.async.token when the keyword is specified. The kernel launched does not start executing until the ops producing its async dependencies (optional operands) have completed.</p><p>The first three operands (following any async dependencies) are grid sizes along the x,y,z dimensions and the following three are block sizes along the x,y,z dimensions. When a lower-dimensional kernel is required, unused sizes must be explicitly set to <code>1</code>. The last operand is optional and corresponds to the amount of dynamic shared memory a kernel&#39;s workgroup should be allocated; when this operand is not present, a zero size is assumed.</p><p>The body region has at least <em>twelve</em> arguments, or <em>eighteen</em> if cluster dimensions are present, grouped as follows:</p><ul><li><p>three optional arguments that contain cluster identifiers along x,y,z dimensions;</p></li><li><p>three arguments that contain block identifiers along x,y,z dimensions;</p></li><li><p>three arguments that contain thread identifiers along x,y,z dimensions;</p></li><li><p>operands of the <code>gpu.launch</code> operation as is (i.e. the operands for grid and block sizes).</p></li><li><p>a variadic number of Workgroup memory attributions.</p></li><li><p>a variadic number of Private memory attributions.</p></li></ul><p>The <code>kernelFunc</code> and <code>kernelModule</code> attributes are optional and specifies the kernel name and a module in which the kernel should be outlined.</p><p><strong>Syntax</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>operation ::= `gpu.launch` (`async` (`[` ssa-id-list `]`)? )?</span></span>
<span class="line"><span>                         ( `clusters` `(` ssa-id-list `)` `in` ssa-reassignment )?</span></span>
<span class="line"><span>                         `blocks` `(` ssa-id-list `)` `in` ssa-reassignment</span></span>
<span class="line"><span>                         `threads` `(` ssa-id-list `)` `in` ssa-reassignment</span></span>
<span class="line"><span>                         (dynamic_shared_memory_size ssa-use)?</span></span>
<span class="line"><span>                         memory-attribution</span></span>
<span class="line"><span>                         region attr-dict?</span></span>
<span class="line"><span>ssa-reassignment ::= `(` ssa-id `=` ssa-use (`,` ssa-id `=` ssa-use)* `)`</span></span>
<span class="line"><span>memory-attribution ::= (`workgroup` `(` ssa-id-and-type-list `)`)?</span></span>
<span class="line"><span>                       (`private` `(` ssa-id-and-type-list `)`)?</span></span></code></pre></div><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpu.launch blocks(%bx, %by, %bz) in (%sz_bx = %0, %sz_by = %1, %sz_bz = %2)</span></span>
<span class="line"><span>           threads(%tx, %ty, %tz) in (%sz_tx = %3, %sz_ty = %4, %sz_tz = %5) {</span></span>
<span class="line"><span>  // Block and thread identifiers, as well as block/grid sizes are</span></span>
<span class="line"><span>  // immediately usable inside body region.</span></span>
<span class="line"><span>  &quot;some_op&quot;(%bx, %tx) : (index, index) -&gt; ()</span></span>
<span class="line"><span>  // Assuming %val1 is defined outside the gpu.launch region.</span></span>
<span class="line"><span>  %42 = load %val1[%bx] : memref&lt;?xf32, 1&gt;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Generic syntax explains how the pretty syntax maps to the IR structure.</span></span>
<span class="line"><span>&quot;gpu.launch&quot;(%cst, %cst, %c1,</span><span>  // Grid sizes.</span></span>
<span class="line"><span>             %cst, %c1, %c1)</span><span>   // Block sizes.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    {/*attributes*/}</span></span>
<span class="line"><span>    // All sizes and identifiers have &quot;index&quot; size.</span></span>
<span class="line"><span>    : (index, index, index, index, index, index) -&gt; () {</span></span>
<span class="line"><span>// The operation passes block and thread identifiers, followed by grid and</span></span>
<span class="line"><span>// block sizes.</span></span>
<span class="line"><span>^bb0(%bx : index, %by : index, %bz : index,</span></span>
<span class="line"><span>     %tx : index, %ty : index, %tz : index,</span></span>
<span class="line"><span>     %num_bx : index, %num_by : index, %num_bz : index,</span></span>
<span class="line"><span>     %num_tx : index, %num_ty : index, %num_tz : index)</span></span>
<span class="line"><span>  &quot;some_op&quot;(%bx, %tx) : (index, index) -&gt; ()</span></span>
<span class="line"><span>  %3 = &quot;memref.load&quot;(%val1, %bx) : (memref&lt;?xf32, 1&gt;, index) -&gt; f32</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Launch with memory attributions.</span></span>
<span class="line"><span>gpu.launch blocks(%bx, %by, %bz) in (%sz_bx = %0, %sz_by = %1, %sz_bz = %2)</span></span>
<span class="line"><span>           threads(%tx, %ty, %tz) in (%sz_tx = %3, %sz_ty = %4, %sz_tz = %5)</span></span>
<span class="line"><span>           workgroup(%workgroup: memref&lt;32xf32, 3&gt;)</span></span>
<span class="line"><span>           private(%private: memref&lt;1xf32, 5&gt;) {</span></span>
<span class="line"><span>  // Block and thread identifiers, as well as block/grid sizes are</span></span>
<span class="line"><span>  // immediately usable inside body region.</span></span>
<span class="line"><span>  &quot;some_op&quot;(%bx, %tx) : (index, index) -&gt; ()</span></span>
<span class="line"><span>  // Assuming %val1 is defined outside the gpu.launch region.</span></span>
<span class="line"><span>  %42 = load %workgroup[%bx] : memref&lt;32xf32, 3&gt;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Launch with clusters.</span></span>
<span class="line"><span>gpu.launch clusters(%cx, %cy, %cz) in (%sz_cx = %0, %sz_cy = %1, %sz_cz = %2)</span></span>
<span class="line"><span>           blocks(%bx, %by, %bz) in (%sz_bx = %3, %sz_by = %4, %sz_bz = %5)</span></span>
<span class="line"><span>           threads(%tx, %ty, %tz) in (%sz_tx = %6, %sz_ty = %7, %sz_tz = %8)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  // Cluster, block and thread identifiers, as well as cluster/block/grid</span></span>
<span class="line"><span>  // sizes are immediately usable inside body region.</span></span>
<span class="line"><span>  &quot;some_op&quot;(%cx, %bx, %tx) : (index, index, index) -&gt; ()</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Rationale: using operation/block arguments gives analyses a clear way of understanding that a value has additional semantics (e.g., we will need to know what value corresponds to threadIdx.x for coalescing). We can recover these properties by analyzing the operations producing values, but it is easier just to have that information by construction.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1568-L1675" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.launch_func" href="#Reactant.MLIR.Dialects.gpu.launch_func"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.launch_func</span></a> <span class="VPBadge info jlObjectType jlFunction"><!--[-->Function<!--]--></span></summary><p><code>launch_func</code></p><p>Launch a kernel function on the specified grid of thread blocks. <code>gpu.launch</code> operations are lowered to <code>gpu.launch_func</code> operations by outlining the kernel body into a function in a dedicated module, which reflects the separate compilation process. The kernel function is required to have the <code>gpu.kernel</code> attribute. The module containing the kernel function is required to be a gpu.module. And finally, the module containing the kernel module (which thus cannot be the top-level module) is required to have the <code>gpu.container_module</code> attribute. The <code>gpu.launch_func</code> operation has a symbol attribute named <code>kernel</code> to identify the fully specified kernel function to launch (both the gpu.module and func).</p><p>The <code>gpu.launch_func</code> supports async dependencies: the kernel does not start executing until the ops producing those async dependencies have completed.</p><p>By the default, the host implicitly blocks until kernel execution has completed. If the <code>async</code> keyword is present, the host does not block but instead a <code>!gpu.async.token</code> is returned. Other async GPU ops can take this token as dependency.</p><p>The operation requires at least the grid and block sizes along the x,y,z dimensions as arguments. When a lower-dimensional kernel is required, unused sizes must be explicitly set to <code>1</code>.</p><p>The remaining operands are optional. The first optional operand corresponds to the amount of dynamic shared memory a kernel&#39;s workgroup should be allocated; when this operand is not present, a zero size is assumed.</p><p>The remaining operands if present are passed as arguments to the kernel function.</p><p>The <code>gpu.launch_func</code> also supports kernel launching with clusters if supported by the target architecture. The cluster size can be set by <code>clusterSizeX</code>, <code>clusterSizeY</code>, and <code>clusterSizeZ</code> arguments. When these arguments are present, the Op launches a kernel that clusters the given thread blocks. This feature is exclusive to certain architectures.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>module attributes {gpu.container_module} {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // This module creates a separate compilation unit for the GPU compiler.</span></span>
<span class="line"><span>  gpu.module @kernels {</span></span>
<span class="line"><span>    func.func @kernel_1(%arg0 : f32, %arg1 : memref&lt;?xf32, 1&gt;)</span></span>
<span class="line"><span>        attributes { nvvm.kernel = true } {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      // Operations that produce block/thread IDs and dimensions are</span></span>
<span class="line"><span>      // injected when outlining the `gpu.launch` body to a function called</span></span>
<span class="line"><span>      // by `gpu.launch_func`.</span></span>
<span class="line"><span>      %tIdX = gpu.thread_id x</span></span>
<span class="line"><span>      %tIdY = gpu.thread_id y</span></span>
<span class="line"><span>      %tIdZ = gpu.thread_id z</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      %bDimX = gpu.block_dim x</span></span>
<span class="line"><span>      %bDimY = gpu.block_dim y</span></span>
<span class="line"><span>      %bDimZ = gpu.block_dim z</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      %bIdX = gpu.block_id x</span></span>
<span class="line"><span>      %bIdY = gpu.block_id y</span></span>
<span class="line"><span>      %bIdZ = gpu.block_id z</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      %gDimX = gpu.grid_dim x</span></span>
<span class="line"><span>      %gDimY = gpu.grid_dim y</span></span>
<span class="line"><span>      %gDimZ = gpu.grid_dim z</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      // (Optional)  Cluster size only for support architectures</span></span>
<span class="line"><span>      %cIdX = gpu.cluster_id x</span></span>
<span class="line"><span>      %cIdY = gpu.cluster_id y</span></span>
<span class="line"><span>      %cIdZ = gpu.cluster_id z</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      %cDimX = gpu.cluster_dim x</span></span>
<span class="line"><span>      %cDimY = gpu.cluster_dim y</span></span>
<span class="line"><span>      %cDimZ = gpu.cluster_dim z</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      &quot;some_op&quot;(%bx, %tx) : (index, index) -&gt; ()</span></span>
<span class="line"><span>      %42 = load %arg1[%bx] : memref&lt;?xf32, 1&gt;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  %t0 = gpu.wait async</span></span>
<span class="line"><span>  gpu.launch_func</span></span>
<span class="line"><span>      async                           // (Optional) Don&#39;t block host, return token.</span></span>
<span class="line"><span>      [%t0]                           // (Optional) Execute only after %t0 has completed.</span></span>
<span class="line"><span>      @kernels::@kernel_1             // Kernel function.</span></span>
<span class="line"><span>      clusters in (%cst, %cst, %cst)  // (Optional) Cluster size only for support architectures.</span></span>
<span class="line"><span>      blocks in (%cst, %cst, %cst)    // Grid size.</span></span>
<span class="line"><span>      threads in (%cst, %cst, %cst)   // Block size.</span></span>
<span class="line"><span>      dynamic_shared_memory_size %s   // (Optional) Amount of dynamic shared</span></span>
<span class="line"><span>                                      // memory to allocate for a workgroup.</span></span>
<span class="line"><span>      args(%arg0 : f32,               // (Optional) Kernel arguments.</span></span>
<span class="line"><span>           %arg1 : memref&lt;?xf32, 1&gt;)</span></span>
<span class="line"><span>}</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1396-L1492" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.memcpy-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.memcpy-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.memcpy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>memcpy</code></p><p>The <code>gpu.memcpy</code> operation copies the content of one memref to another.</p><p>The op does not execute before all async dependencies have finished executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.memcpy async [%dep] %dst, %src : memref&lt;?xf32, 1&gt;, memref&lt;?xf32&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1751-L1768" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.memset-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.memset-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.memset</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>memset</code></p><p>The <code>gpu.memset</code> operation sets the content of memref to a scalar value.</p><p>The op does not execute before all async dependencies have finished executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.memset async [%dep] %dst, %value : memref&lt;?xf32, 1&gt;, f32</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1795-L1812" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.module_-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.module_-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.module_</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>module_</code></p><p>GPU module contains code that is intended to be run on a GPU. A host device can launch this code through a gpu.launc_func that creates a fully qualified symbol through the gpu.module&#39;s symbol and a gpu.func symbol contained in the gpu.module.</p><p>The module&#39;s top-level scope is modeled by a single region with a single block. GPU modules are required to have a name that is used for symbol resolution by the gpu.launch_func operation.</p><p>Using an op with a region to define a GPU module enables &quot;embedding&quot; GPU modules with SIMT execution models in other dialects in a clean manner and allows filtering of code regions to execute passes on only code intended to or not intended to be run on the separate device.</p><p>Modules can contain zero or more target attributes. These attributes encode how to transform modules into binary strings and are used by the <code>gpu-module-to-binary</code> pass to transform modules into GPU binaries.</p><p>Modules can contain an optional <code>OffloadingTranslationAttr</code> attribute. This attribute will be used during the <code>gpu-module-to-binary</code> pass to specify the <code>OffloadingTranslationAttr</code> used when creating the <code>gpu.binary</code> operation.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpu.module @symbol_name {</span></span>
<span class="line"><span>  gpu.func {}</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>// Module with offloading handler and target attributes.</span></span>
<span class="line"><span>gpu.module @symbol_name2 &lt;#gpu.select_object&lt;1&gt;&gt; [</span></span>
<span class="line"><span>    #nvvm.target,</span></span>
<span class="line"><span>    #rocdl.target&lt;chip = &quot;gfx90a&quot;&gt;] {</span></span>
<span class="line"><span>  gpu.func {}</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>}</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1137-L1175" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.num_subgroups-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.num_subgroups-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.num_subgroups</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>num_subgroups</code></p><p>Returns the number of subgroups within a workgroup.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%numSg = gpu.num_subgroups : index</span></span></code></pre></div><p>If <code>upper_bound</code> is set, executions with more than <code>upper_bound</code> subgroups per workgroup cause undefined behavior. There is a default upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1839-L1853" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.printf-Tuple{Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.gpu.printf-Tuple{Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.printf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>printf</code></p><p><code>gpu.printf</code> takes a literal format string <code>format</code> and an arbitrary number of scalar arguments that should be printed.</p><p>The format string is a C-style printf string, subject to any restrictions imposed by one&#39;s target platform.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1877-L1885" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.return_-Tuple{Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.gpu.return_-Tuple{Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.return_</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>return_</code></p><p>A terminator operation for regions that appear in the body of <code>gpu.func</code> functions. The operands to the <code>gpu.return</code> are the result values returned by an invocation of the <code>gpu.func</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1905-L1911" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.sddmm-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 4}}" href="#Reactant.MLIR.Dialects.gpu.sddmm-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 4}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.sddmm</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>sddmm</code></p><p>The <code>gpu.sddmm</code> operation performs the SDDMM operation on the given sparse and dense matrices, and buffer. The operation expects handles returned by previous sparse operations to construct an environment and the operands for SDDMM. The buffer must have been allocated on the device.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.sddmm async [%dep] %dnmatA{TRANSPOSE}, %dnmatB{TRANSPOSE}, %spmatC, %buffer into f32</span></span></code></pre></div><p>The matrix arguments can also be associated with one of the following operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value is NON_TRANSPOSE.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1986-L2007" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.sddmm_buffer_size-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.sddmm_buffer_size-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.sddmm_buffer_size</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>sddmm_buffer_size</code></p><p>The <code>gpu.sddmm_buffer_size</code> operation returns the buffer size required to perform the SDDMM operation on the given sparse and dense matrices. The operation expects handles returned by previous sparse operations to construct an environment and the operands for SDDMM.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%buffersz, %token = gpu.sddmm_buffer_size async [%dep] %dnmatA{TRANSPOSE}, %dnmatB{TRANSPOSE}, %spmatC into f32</span></span></code></pre></div><p>The matrix arguments can also be associated with one of the following operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value is NON_TRANSPOSE.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L1931-L1952" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.set_csr_pointers-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 4}}" href="#Reactant.MLIR.Dialects.gpu.set_csr_pointers-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 4}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.set_csr_pointers</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>set_csr_pointers</code></p><p>The <code>gpu.set_csr_pointers</code> assigns the given positions, coordinates, and values buffer that reside on the device directly to the given sparse matrix descriptor in csr format.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.set_csr_pointers async [%dep] %positions, %coordinates, %values</span></span>
<span class="line"><span>      : memref&lt;?xf32&gt;, memref&lt;?xindex&gt;, memref&lt;?xindex&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2041-L2058" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.set_default_device-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.set_default_device-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.set_default_device</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>set_default_device</code></p><p>Operation that sets the current default GPU, using a zero-based index into the set of GPUs on the system. The default GPU setting may be thread-local.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2087-L2093" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.shuffle-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.shuffle-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.shuffle</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>shuffle</code></p><p>The &quot;shuffle&quot; op moves values to a across lanes (a.k.a., invocations, work items) within the same subgroup. The <code>width</code> argument specifies the number of lanes that participate in the shuffle, and must be uniform across all lanes. Further, the first <code>width</code> lanes of the subgroup must be active.</p><p>The intepretation of the <code>offset</code> arguments depends on the selected <code>mode</code>.</p><p>Returns the <code>shuffleResult</code> and <code>true</code> if the current lane id is smaller than <code>width</code>, and an unspecified value and <code>false</code> otherwise.</p><p><code>xor</code> example:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1, %2 = gpu.shuffle xor %0, %offset, %width : f32</span></span></code></pre></div><p>For lane <code>k</code>, returns the value <code>%0</code> from lane <code>k ^ offset</code>. Every lane trades value with exactly one other lane.</p><p><code>down</code> example:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%cst1 = arith.constant 1 : i32</span></span>
<span class="line"><span>%3, %4 = gpu.shuffle down %0, %cst1, %width : f32</span></span></code></pre></div><p>For lane <code>k</code>, returns the value from lane <code>(k + 1) % width</code>.</p><p><code>up</code> example:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%cst1 = arith.constant 1 : i32</span></span>
<span class="line"><span>%5, %6 = gpu.shuffle up %0, %cst1, %width : f32</span></span></code></pre></div><p>For lane <code>k</code>, returns the value from lane <code>(k - 1) % width</code>.</p><p><code>idx</code> example:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%cst0 = arith.constant 0 : i32</span></span>
<span class="line"><span>%7, %8 = gpu.shuffle idx %0, %cst0, %width : f32</span></span></code></pre></div><p>Broadcasts the value from lane 0 to all lanes.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2113-L2163" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.spgemm_copy-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 4}}" href="#Reactant.MLIR.Dialects.gpu.spgemm_copy-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 4}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.spgemm_copy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>spgemm_copy</code></p><p>The <code>gpu.spgemm_copy</code> operation copies the sparse matrix result of a SpGEMM computation.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpu.spgemm_copy %spmatA, %spmatB, %spmatC, %spgemmDesc: f32</span></span></code></pre></div><p>The matrix arguments can also be associated with one of the following operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value is NON_TRANSPOSE.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2193-L2212" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.spgemm_create_descr-Tuple{Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.gpu.spgemm_create_descr-Tuple{Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.spgemm_create_descr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>spgemm_create_descr</code></p><p>The <code>gpu.spgemm_create_descr</code> creates a descriptor for the SpGEMM operation. The descriptor describes the SpGEMM operation and stores the internal data throughout the computation. It needs to be passed as an argument to spgemm_* operations.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%desc, %token = gpu.spgemm_create_descr async [%dep]</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2246-L2263" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.spgemm_destroy_descr-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.spgemm_destroy_descr-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.spgemm_destroy_descr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>spgemm_destroy_descr</code></p><p>The <code>gpu.spgemm_destroy_descr</code> destroys the SpGEMM operation descriptor.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.spgemm_destroy_descr async [%dep] %desc</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2289-L2303" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.spgemm_work_estimation_or_compute-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 6}}" href="#Reactant.MLIR.Dialects.gpu.spgemm_work_estimation_or_compute-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 6}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.spgemm_work_estimation_or_compute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>spgemm_work_estimation_or_compute</code></p><p>The <code>gpu.spgemm_work_estimation_or_compute</code> is used to call cusparseSpGEMM_workEstimation or cusparseSpGEMM_compute. Both of them are for both determining the buffer size and performing the actual computation. The operation expects handles returned by previous sparse operations to construct an environment and the operands for SpGEMM. The buffer must have been allocated on the device.</p><p>C&#39; = alpha * op(A) * op(B) + beta * C</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%bufferSz, %token = gpu.spgemm_work_estimation_or_compute async [%dep] {COMPUTE}</span></span>
<span class="line"><span>                      %desc, %spmatA{NON_TRANSPOSE}, %spmatB{NON_TRANSPOSE},</span></span>
<span class="line"><span>                      %spmatC, %spgemmDesc, %c0, %alloc: f32 into</span></span>
<span class="line"><span>                      memref&lt;0xi8&gt;</span></span></code></pre></div><p>The matrix arguments can also be associated with one of the following operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value is NON_TRANSPOSE.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2329-L2357" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.spmat_get_size-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.spmat_get_size-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.spmat_get_size</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>spmat_get_size</code></p><p>The <code>gpu.spmat_get_size</code> operation retrieves the number of rows, number of columns, and number of non-zero elements of a sparse matrix.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%rows, %cols, %nnz, %token = gpu.spmat_get_size async [%dep] %spmatC</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2617-L2632" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.spmm-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.gpu.spmm-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.spmm</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>spmm</code></p><p>The <code>gpu.spmm</code> operation performs the SpMM operation on the given sparse and dense matrix, and buffer. The operation expects handles returned by previous sparse operations to construct an environment and the operands for SpMM. The buffer must have been allocated on the device.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p>The matrix arguments can also be associated with one of the following operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value is NON_TRANSPOSE.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.spmm async [%dep] %spmatA{TRANSPOSE}, %dnmatB{TRANSPOSE}, %dnmatC, %buffers : type($buffers) into f32</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2452-L2473" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.spmm_buffer_size-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.spmm_buffer_size-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.spmm_buffer_size</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>spmm_buffer_size</code></p><p>The <code>gpu.spmm_buffer_size</code> operation returns the buffer size required to perform the SpMM operation on the given sparse and dense matrix. The operation expects handles returned by previous sparse operations to construct an environment and the operands for SpMM.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p>The matrix arguments can also be associated with one of the following operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value is NON_TRANSPOSE.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%bufferszs, %token = gpu.spmm_buffer_size async [%dep] %spmatA{TRANSPOSE}, %dnmatB{TRANSPOSE}, %dnmatC : i64 into f32</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2397-L2418" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.spmv-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 4}}" href="#Reactant.MLIR.Dialects.gpu.spmv-Tuple{Vector{Reactant.MLIR.IR.Value}, Vararg{Reactant.MLIR.IR.Value, 4}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.spmv</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>spmv</code></p><p>The <code>gpu.spmv</code> operation performs the SpMV operation on the given sparse matrix, dense vectors, and buffer. The operation expects handles returned by previous sparse operations to construct an environment and the operands for SpMV. The buffer must have been allocated on the device.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p>The matrix arguments can also be associated with one of the following operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value is NON_TRANSPOSE.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.spmv async [%dep] %spmatA{TRANSPOSE}, %dnX, %dnY : memref&lt;?xf64&gt; into bf16</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2564-L2585" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.spmv_buffer_size-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.spmv_buffer_size-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.spmv_buffer_size</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>spmv_buffer_size</code></p><p>The <code>gpu.spmv_buffer_size</code> operation returns the buffer size required to perform the SpMV operation on the given sparse matrix and dense vectors. The operation expects handles returned by previous sparse operations to construct an environment and the operands for SpMV.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token in addition to the environment.</p><p>The matrix arguments can also be associated with one of the following operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value is NON_TRANSPOSE.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%buffersz, %token = gpu.spmv_buffer_size async [%dep] %spmatA{TRANSPOSE}, %dnX, %dnY into f32</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2511-L2532" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.subgroup_id-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.subgroup_id-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.subgroup_id</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>subgroup_id</code></p><p>Returns the subgroup id, i.e., the index of the current subgroup within the workgroup.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%sgId = gpu.subgroup_id : index</span></span></code></pre></div><p>Executions where there are more than <code>upper_bound</code> subgroups per workgroup cause undefined behavior. There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2661-L2676" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.subgroup_mma_compute-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.subgroup_mma_compute-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.subgroup_mma_compute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>subgroup_mma_compute</code></p><p>The <code>gpu.subgroup_mma_compute</code> operation performs a matrix-multiply accumulate (mma) operation using all the threads in a subgroup.</p><p>This operation takes three <code>!gpu.mma_matrix</code>s as arguments: these hold <code>A</code>, <code>B</code> and <code>C</code>operands for the mma operation. The operation performed is represented as <code>C += A * B</code>. The op returns a <code>!gpu.mma_matrix</code> which contains the result of the operation held by all threads in a subgroup. <code>a_transpose</code> or <code>b_transpose</code> if present, signify that the respective operand was loaded in a transposed manner. The transpose operands are required to map to correct underlying intrisics but they currently do not seem to affect correctness even if they are absent given that the operands were loaded correctly using the <code>transpose</code> attribute in <code>gpu.subgroup_mma_load_matrix</code> op.</p><p>For integer types, the <code>A</code> and <code>B</code> matrices carry their signedness with their types. The accumulator type is expected to be signless and imply a signed integer with a greater width than the other two operands.</p><p>This op is meant to be used along with <code>gpu.subgroup_mma_store_matrix</code> and <code>gpu.subgroup_mma_load_matrix</code> ops.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%D = gpu.subgroup_mma_compute_matrix %A, %B, %C :</span></span>
<span class="line"><span>  !gpu.mma_matrix&lt;16x16xf16, &quot;AOp&quot;&gt;, !gpu.mma_matrix&lt;16x16xf16, &quot;BOp&quot;&gt;&gt;</span></span>
<span class="line"><span>  -&gt; !gpu.mma_matrix&lt;16x16xf16, &quot;COp&quot;&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2700-L2730" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.subgroup_mma_constant_matrix-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.subgroup_mma_constant_matrix-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.subgroup_mma_constant_matrix</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>subgroup_mma_constant_matrix</code></p><p>The <code>gpu.subgroup_mma_constant_matrix</code> creates a <code>!gpu.mma_matrix</code> with constant elements.</p><p>The operation takes a scalar input and return a <code>!gpu.mma_matrix</code> where each element of is equal to the operand constant. The destination mma_matrix type must have elememt type equal to the constant type. Since the layout of <code>!gpu.mma_matrix</code> is opaque this only support setting all the elements to the same value.</p><p>This op is meant to be used along with <code>gpu.subgroup_mma_compute</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> %0 = gpu.subgroup_mma_constant_matrix %a :</span></span>
<span class="line"><span>   !gpu.mma_matrix&lt;16x16xf16, &quot;AOp&quot;&gt;</span></span>
<span class="line"><span> %1 = gpu.subgroup_mma_constant_matrix %b :</span></span>
<span class="line"><span>   !gpu.mma_matrix&lt;16x16xf32, &quot;COp&quot;&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2761-L2783" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.subgroup_mma_elementwise-Tuple{Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.gpu.subgroup_mma_elementwise-Tuple{Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.subgroup_mma_elementwise</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>subgroup_mma_elementwise</code></p><p>The <code>gpu.subgroup_mma_elementwise</code> takes <code>!gpu.mma_matrix</code> inputs and compute a new <code>!gpu.mma_matrix</code> by applying an elementwise operation to each element.</p><p>Since the operation is elementwise and the matrix type must match, the matrix elements are processed independently of the matrix layout.</p><p>This op is meant to be used along with <code>gpu.subgroup_mma_compute</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> %0 =  %A, %B { opType = &quot;ADD&quot; } :</span></span>
<span class="line"><span>  (!gpu.mma_matrix&lt;16x16xf16, &quot;COp&quot;&gt;, !gpu.mma_matrix&lt;16x16xf16, &quot;COp&quot;&gt;)</span></span>
<span class="line"><span>  -&gt; !gpu.mma_matrix&lt;16x16xf16, &quot;COp&quot;&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2803-L2822" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.subgroup_mma_load_matrix-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.gpu.subgroup_mma_load_matrix-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.subgroup_mma_load_matrix</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>subgroup_mma_load_matrix</code></p><p>The <code>gpu.subgroup_mma_load_matrix</code> operation loads a matrix collectively using all the threads in a subgroup.</p><p>This operation takes a memref as its first operand: it is the source matrix from which data is to be loaded. The op returns a <code>!gpu.mma_matrix</code>. The source memref can be in global memory or shared memory. The load address is determined using <code>indices</code>. The matrix being loaded into is the result. The <code>leadDimension</code> attribute specifies the leading dimension size of the source matrix which eventually allows the lowering to determine the size of each row. If the <code>transpose</code> attribute is present then the op does a transposed load.</p><p>For integer types, the resulting <code>!gpu.mma_matrix</code> type needs to specify the signedness of the data if the matrix type is an <code>A</code> or <code>B</code> operand for <code>gpu.subgroup_mma_compute</code>.</p><p>This op is often meant to be used along with <code>gpu.subgroup_mma_store_matrix</code> and <code>gpu.subgroup_mma_compute</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> %0 = gpu.subgroup_mma_load_matrix src[%i,%j] : {leadDimension = 32 : i32}</span></span>
<span class="line"><span>      : memref&lt;32x32xf16, 3&gt;, !gpu.mma_matrix&lt;16x16xf16, &quot;AOp&quot;&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2844-L2871" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.subgroup_mma_store_matrix-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.gpu.subgroup_mma_store_matrix-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.subgroup_mma_store_matrix</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>subgroup_mma_store_matrix</code></p><p>The <code>gpu.subgroup_mma_store_matrix</code> operation stores a matrix collectively using all the threads in a subgroup.</p><p>This operation takes a <code>!gpu.mma_matrix</code> and a memref as operands. <code>!gpu.mma_matrix</code> is the source value containing the data to be stored into the destination memref which can be in global or shared memory. The store address is determined using the indices provided. The <code>leadDimension</code> attribute specifies the leading dimension of the destination matrix. If the <code>transpose</code> attribute is present then the op does a transposed store.</p><p>This op is often meant to be used along with <code>gpu.subgroup_mma_load_matrix</code> and <code>gpu.subgroup_mma_compute</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpu.subgroup_mma_store_matrix %D, %sg[%i,%j] : { leadDimension = 32 : i32}</span></span>
<span class="line"><span>                : !gpu.mma_matrix&lt;16x16xf16, &quot;COp&quot;&gt;, memref&lt;32x32xf16, 3&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2899-L2921" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.subgroup_reduce-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.gpu.subgroup_reduce-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.subgroup_reduce</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>subgroup_reduce</code></p><p>The <code>subgroup_reduce</code> op reduces the values of lanes (work items) across a subgroup.</p><p>The subgroup is divided into clusters starting at lane index 0. Within each cluster, there are <code>size</code> lanes, and the lane index advances by <code>stride</code>. A reduction is done for each cluster in parallel: every lane in the cluster is reduced, and the result is equal for all lanes in the cluster. If <code>size</code> is omitted, there is a single cluster covering the entire subgroup. If <code>stride</code> is omitted, the stride is 1 (the cluster&#39;s lanes are contiguous).</p><p>When the reduced value is of a vector type, each vector element is reduced independently. Only 1-d vector types are allowed.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = gpu.subgroup_reduce add %a : (f32) -&gt; f32</span></span>
<span class="line"><span>%2 = gpu.subgroup_reduce add %b : (vector&lt;4xf16&gt;) -&gt; vector&lt;4xf16&gt;</span></span>
<span class="line"><span>%3 = gpu.subgroup_reduce add %c cluster(size = 4) : (f32) -&gt; f32</span></span>
<span class="line"><span>%3 = gpu.subgroup_reduce add %c cluster(size = 4, stride = 2) : (f32) -&gt; f32</span></span></code></pre></div><p>If <code>uniform</code> flag is set either none or all lanes of a subgroup need to execute this op in convergence.</p><p>The reduction operation must be one of:</p><ul><li><p>Integer types: <code>add</code>, <code>mul</code>, <code>minui</code>, <code>minsi</code>, <code>maxui</code>, <code>maxsi</code>, <code>and</code>, <code>or</code>, <code>xor</code></p></li><li><p>Floating point types: <code>add</code>, <code>mul</code>, <code>minnumf</code>, <code>maxnumf</code>, <code>minimumf</code>, <code>maximumf</code></p></li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L2949-L2982" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.subgroup_size-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.subgroup_size-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.subgroup_size</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>subgroup_size</code></p><p>Returns the number of threads within a subgroup.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%sgSz = gpu.subgroup_size : index</span></span></code></pre></div><p>Executions where the number of threads per subgroup exceed <code>upper_bound</code> cause undefined behavior. When no <code>upper_bound</code> is specified, range analyses and similar machinery assume the default bound of <code>kMaxSubgroupSize</code>, currently 1.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L3016-L3031" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.terminator-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.terminator-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.terminator</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>terminator</code></p><p>A terminator operation for regions that appear in the body of <code>gpu.launch</code> operation. These regions are not expected to return any value so the terminator takes no operands.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L3055-L3061" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.thread_id-Tuple{}" href="#Reactant.MLIR.Dialects.gpu.thread_id-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.thread_id</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>thread_id</code></p><p>Returns the thread id, i.e. the index of the current thread within the block along the x, y, or z <code>dimension</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%tIdX = gpu.thread_id x</span></span></code></pre></div><p>If <code>upper_bound</code> is set, or if one can be inferred from <code>known_block_size</code>-type annotations in context, executions where the thread index would be greater than or equal to that bound cause undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L3081-L3098" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.wait-Tuple{Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.gpu.wait-Tuple{Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.wait</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>wait</code></p><p>This op synchronizes the host or the device with a list of dependent ops.</p><p>If the op contains the <code>async</code> keyword, it returns a new async token which is synchronized with the op arguments. This new token is merely a shortcut to the argument list, and one could replace the uses of the result with the arguments for the same effect. The async version of this op is primarily used to make each async token have a single use during lowering and thereby make forks in async execution explicit. Example usage:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%t0 = gpu.foo async : !gpu.async.token</span></span>
<span class="line"><span>%t1 = gpu.bar async : !gpu.async.token</span></span>
<span class="line"><span>%t2 = gpu.wait async [%t0, %t1]</span></span>
<span class="line"><span>// gpu.baz doesn&#39;t run until gpu.foo and gpu.bar have both completed, just</span></span>
<span class="line"><span>// as if the async dependencies were [%t0, %t1].</span></span>
<span class="line"><span>%t3 = gpu.baz async [%t2]</span></span></code></pre></div><p>If the op does not contain the <code>async</code> keyword, it does not return a new async token but blocks until all ops producing the async dependency tokens finished execution. All dependent memory operations are visible to the host once this op completes. Example usage:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%t0 = gpu.foo async : !gpu.async.token</span></span>
<span class="line"><span>%t1 = gpu.bar async : !gpu.async.token</span></span>
<span class="line"><span>// The gpu.wait op blocks until gpu.foo and gpu.bar have completed.</span></span>
<span class="line"><span>gpu.wait [%t0, %t1]</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L3125-L3157" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.warp_execute_on_lane_0-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.gpu.warp_execute_on_lane_0-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.warp_execute_on_lane_0</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>warp_execute_on_lane_0</code></p><p><code>warp_execute_on_lane_0</code> is an operation used to bridge the gap between vector programming and SPMD programming model like GPU SIMT. It allows to trivially convert a region of vector code meant to run on a multiple threads into a valid SPMD region and then allows incremental transformation to distribute vector operations on the threads.</p><p>Any code present in the region would only be executed on first thread/lane based on the <code>laneid</code> operand. The <code>laneid</code> operand is an integer ID between [0, <code>warp_size</code>). The <code>warp_size</code> attribute indicates the number of lanes in a warp.</p><p>Operands are vector values distributed on all lanes that may be used by the single lane execution. The matching region argument is a vector of all the values of those lanes available to the single active lane. The distributed dimension is implicit based on the shape of the operand and argument. the properties of the distribution may be described by extra attributes (e.g. affine map).</p><p>Return values are distributed on all lanes using laneId as index. The vector is distributed based on the shape ratio between the vector type of the yield and the result type. If the shapes are the same this means the value is broadcasted to all lanes. In the future the distribution can be made more explicit using affine_maps and will support having multiple Ids.</p><p>Therefore the <code>warp_execute_on_lane_0</code> operations allow to implicitly copy between lane0 and the lanes of the warp. When distributing a vector from lane0 to all the lanes, the data are distributed in a block cyclic way. For example <code>vector&lt;64xf32&gt;</code> gets distributed on 32 threads and map to <code>vector&lt;2xf32&gt;</code> where thread 0 contains vector[0] and vector[1].</p><p>During lowering values passed as operands and return value need to be visible to different lanes within the warp. This would usually be done by going through memory.</p><p>The region is <em>not</em> isolated from above. For values coming from the parent region not going through operands only the lane 0 value will be accesible so it generally only make sense for uniform values.</p><p><strong>Example</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Execute in parallel on all threads/lanes.</span></span>
<span class="line"><span>gpu.warp_execute_on_lane_0 (%laneid)[32] {</span></span>
<span class="line"><span>  // Serial code running only on thread/lane 0.</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>// Execute in parallel on all threads/lanes.</span></span></code></pre></div><p>This may be lowered to an scf.if region as below:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  // Execute in parallel on all threads/lanes.</span></span>
<span class="line"><span>  %cnd = arith.cmpi eq, %laneid, %c0 : index</span></span>
<span class="line"><span>  scf.if %cnd {</span></span>
<span class="line"><span>    // Serial code running only on thread/lane 0.</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  // Execute in parallel on all threads/lanes.</span></span></code></pre></div><p>When the region has operands and/or return values:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Execute in parallel on all threads/lanes.</span></span>
<span class="line"><span>%0 = gpu.warp_execute_on_lane_0(%laneid)[32]</span></span>
<span class="line"><span>args(%v0 : vector&lt;4xi32&gt;) -&gt; (vector&lt;1xf32&gt;) {</span></span>
<span class="line"><span>^bb0(%arg0 : vector&lt;128xi32&gt;) :</span></span>
<span class="line"><span>  // Serial code running only on thread/lane 0.</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>  gpu.yield %1 : vector&lt;32xf32&gt;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>// Execute in parallel on all threads/lanes.</span></span></code></pre></div><p>values at the region boundary would go through memory:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Execute in parallel on all threads/lanes.</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>// Store the data from each thread into memory and Synchronization.</span></span>
<span class="line"><span>%tmp0 = memreg.alloc() : memref&lt;128xf32&gt;</span></span>
<span class="line"><span>%tmp1 = memreg.alloc() : memref&lt;32xf32&gt;</span></span>
<span class="line"><span>%cnd = arith.cmpi eq, %laneid, %c0 : index</span></span>
<span class="line"><span>vector.store %v0, %tmp0[%laneid] : memref&lt;128xf32&gt;, vector&lt;4xf32&gt;</span></span>
<span class="line"><span>some_synchronization_primitive</span></span>
<span class="line"><span>scf.if %cnd {</span></span>
<span class="line"><span>  // Serialized code running only on thread 0.</span></span>
<span class="line"><span>  // Load the data from all the threads into a register from thread 0. This</span></span>
<span class="line"><span>  // allow threads 0 to access data from all the threads.</span></span>
<span class="line"><span>  %arg0 = vector.load %tmp0[%c0] : memref&lt;128xf32&gt;, vector&lt;128xf32&gt;</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>  // Store the data from thread 0 into memory.</span></span>
<span class="line"><span>  vector.store %1, %tmp1[%c0] : memref&lt;32xf32&gt;, vector&lt;32xf32&gt;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>// Synchronization and load the data in a block cyclic way so that the</span></span>
<span class="line"><span>// vector is distributed on all threads.</span></span>
<span class="line"><span>some_synchronization_primitive</span></span>
<span class="line"><span>%0 = vector.load %tmp1[%laneid] : memref&lt;32xf32&gt;, vector&lt;32xf32&gt;</span></span>
<span class="line"><span>// Execute in parallel on all threads/lanes.</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L3182-L3283" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.gpu.yield-Tuple{Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.gpu.yield-Tuple{Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.gpu.yield</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>yield</code></p><p>gpu.yield` is a special terminator operation for blocks inside regions in gpu ops. It returns values to the immediately enclosing gpu op.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gpu.yield %f0, %f1 : f32, f32</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/ff228ae3827bf0afb67acfd0e12911125693ecc1/src/mlir/Dialects/Gpu.jl#L3310-L3321" target="_blank" rel="noreferrer">source</a><!--]--></span></details></div></div></main><footer class="VPDocFooter" data-v-83890dd9 data-v-4f9813fa><!--[--><!--]--><div class="edit-info" data-v-4f9813fa><div class="edit-link" data-v-4f9813fa><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/EnzymeAD/Reactant.jl/edit/main/docs/src/api/dialects/gpu.md" target="_blank" rel="noreferrer" data-v-4f9813fa><!--[--><span class="vpi-square-pen edit-link-icon" data-v-4f9813fa></span> Edit this page on GitHub<!--]--></a></div><!----></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-4f9813fa><span class="visually-hidden" id="doc-footer-aria-label" data-v-4f9813fa>Pager</span><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link prev" href="/Reactant.jl/v0.2.78/api/dialects/func" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Previous page</span><span class="title" data-v-4f9813fa>Func</span><!--]--></a></div><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link next" href="/Reactant.jl/v0.2.78/api/dialects/llvm" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Next page</span><span class="title" data-v-4f9813fa>LLVM</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-a9a9e638 data-v-c970a860><div class="container" data-v-c970a860><p class="message" data-v-c970a860>Made with <a href="https://documenter.juliadocs.org/stable/" target="_blank"><strong>Documenter.jl</strong></a>, <a href="https://vitepress.dev" target="_blank"><strong>VitePress</strong></a> and <a href="https://luxdl.github.io/DocumenterVitepress.jl/stable" target="_blank"><strong>DocumenterVitepress.jl</strong></a><br>Released under the MIT License. Powered by the <a href="https://www.julialang.org">Julia Programming Language</a>.<br></p><p class="copyright" data-v-c970a860>© Copyright 2025 Reactant Development Team.</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"api_api.md\":\"BWTMRwIf\",\"api_dialects_affine.md\":\"4SgXZ2Zd\",\"api_dialects_arith.md\":\"CulQmdPt\",\"api_dialects_builtin.md\":\"BqT1Ul5N\",\"api_dialects_chlo.md\":\"L4fgSwXX\",\"api_dialects_enzyme.md\":\"CUgT5gMd\",\"api_dialects_enzymexla.md\":\"C2GJCdDT\",\"api_dialects_func.md\":\"iXDqREWR\",\"api_dialects_gpu.md\":\"Bfc-9Ouo\",\"api_dialects_llvm.md\":\"Dsazl8XN\",\"api_dialects_memref.md\":\"DFT_7nO2\",\"api_dialects_mpi.md\":\"BQvhCRl6\",\"api_dialects_nvvm.md\":\"DB9k7iAZ\",\"api_dialects_shardy.md\":\"OusdXnTp\",\"api_dialects_stablehlo.md\":\"CAKUrkbr\",\"api_dialects_tpu.md\":\"C8FNSWF6\",\"api_dialects_triton.md\":\"Bstb-UX4\",\"api_dialects_vhlo.md\":\"MGbK7WSH\",\"api_internal.md\":\"BiRFflyp\",\"api_mlirc.md\":\"C1qMi1GH\",\"api_ops.md\":\"CfcA7zvc\",\"api_sharding.md\":\"CsvIeGce\",\"api_xla.md\":\"Bgk2JY2Q\",\"index.md\":\"CAtGeJJP\",\"introduction_configuration.md\":\"I-Eilyqr\",\"introduction_index.md\":\"CB4b5LH1\",\"tutorials_index.md\":\"9f3Mcdax\",\"tutorials_local-build.md\":\"BVDZXs6T\",\"tutorials_multihost.md\":\"8uGm-bXc\",\"tutorials_profiling.md\":\"Ct2-sUcd\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Reactant.jl\",\"description\":\"Documentation for Reactant.jl\",\"base\":\"/Reactant.jl/v0.2.78/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"outline\":\"deep\",\"logo\":{\"light\":\"/logo.svg\",\"dark\":\"/logo.svg\"},\"search\":{\"provider\":\"local\",\"options\":{\"detailedView\":true}},\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Getting Started\",\"items\":[{\"text\":\"Introduction\",\"link\":\"/introduction\"},{\"text\":\"Configuration\",\"link\":\"/introduction/configuration\"}]},{\"text\":\"Benchmarks\",\"link\":\"https://enzymead.github.io/Reactant.jl/benchmarks/\"},{\"text\":\"Tutorials\",\"items\":[{\"text\":\"Overview\",\"link\":\"/tutorials/\"},{\"text\":\"Profiling\",\"link\":\"/tutorials/profiling\"},{\"text\":\"Distributed\",\"link\":\"/tutorials/multihost\"},{\"text\":\"Local build\",\"link\":\"/tutorials/local-build\"}]},{\"text\":\"API\",\"items\":[{\"text\":\"Core Reactant API\",\"link\":\"/api/api\"},{\"text\":\"Sharding\",\"link\":\"/api/sharding\"},{\"text\":\"Ops\",\"link\":\"/api/ops\"},{\"text\":\"MLIR Dialects\",\"items\":[{\"text\":\"ArithOps\",\"link\":\"/api/dialects/arith\"},{\"text\":\"Affine\",\"link\":\"/api/dialects/affine\"},{\"text\":\"Builtin\",\"link\":\"/api/dialects/builtin\"},{\"text\":\"Chlo\",\"link\":\"/api/dialects/chlo\"},{\"text\":\"Enzyme\",\"link\":\"/api/dialects/enzyme\"},{\"text\":\"EnzymeXLA\",\"link\":\"/api/dialects/enzymexla\"},{\"text\":\"Func\",\"link\":\"/api/dialects/func\"},{\"text\":\"GPU\",\"link\":\"/api/dialects/gpu\"},{\"text\":\"LLVM\",\"link\":\"/api/dialects/llvm\"},{\"text\":\"MPI\",\"link\":\"/api/dialects/mpi\"},{\"text\":\"MemRef\",\"link\":\"/api/dialects/memref\"},{\"text\":\"NVVM\",\"link\":\"/api/dialects/nvvm\"},{\"text\":\"Shardy\",\"link\":\"/api/dialects/shardy\"},{\"text\":\"StableHLO\",\"link\":\"/api/dialects/stablehlo\"},{\"text\":\"Triton\",\"link\":\"/api/dialects/triton\"},{\"text\":\"TPU\",\"link\":\"/api/dialects/tpu\"},{\"text\":\"VHLO\",\"link\":\"/api/dialects/vhlo\"}]},{\"text\":\"Low-Level API\",\"items\":[{\"text\":\"MLIR API\",\"link\":\"/api/mlirc\"},{\"text\":\"XLA\",\"link\":\"/api/xla\"}]},{\"text\":\"Internal API\",\"link\":\"/api/internal\"}]},{\"component\":\"VersionPicker\"}],\"sidebar\":{\"/introduction/\":[{\"text\":\"Getting Started\",\"collapsed\":false,\"items\":[{\"text\":\"Introduction\",\"link\":\"/introduction\"},{\"text\":\"Configuration\",\"link\":\"/introduction/configuration\"}]}],\"/tutorials/\":[{\"text\":\"Tutorials\",\"collapsed\":false,\"items\":[{\"text\":\"Overview\",\"link\":\"/tutorials/\"},{\"text\":\"Profiling\",\"link\":\"/tutorials/profiling\"},{\"text\":\"Distributed\",\"link\":\"/tutorials/multihost\"},{\"text\":\"Local build\",\"link\":\"/tutorials/local-build\"}]}],\"/api/\":[{\"text\":\"API Reference\",\"collapsed\":false,\"items\":[{\"text\":\"Reactant API\",\"link\":\"/api/api\"},{\"text\":\"Sharding\",\"link\":\"/api/sharding\"},{\"text\":\"Ops\",\"link\":\"/api/ops\"},{\"text\":\"MLIR Dialects\",\"collapsed\":false,\"items\":[{\"text\":\"ArithOps\",\"link\":\"/api/dialects/arith\"},{\"text\":\"Affine\",\"link\":\"/api/dialects/affine\"},{\"text\":\"Builtin\",\"link\":\"/api/dialects/builtin\"},{\"text\":\"Chlo\",\"link\":\"/api/dialects/chlo\"},{\"text\":\"Enzyme\",\"link\":\"/api/dialects/enzyme\"},{\"text\":\"EnzymeXLA\",\"link\":\"/api/dialects/enzymexla\"},{\"text\":\"Func\",\"link\":\"/api/dialects/func\"},{\"text\":\"GPU\",\"link\":\"/api/dialects/gpu\"},{\"text\":\"LLVM\",\"link\":\"/api/dialects/llvm\"},{\"text\":\"MPI\",\"link\":\"/api/dialects/mpi\"},{\"text\":\"MemRef\",\"link\":\"/api/dialects/memref\"},{\"text\":\"NVVM\",\"link\":\"/api/dialects/nvvm\"},{\"text\":\"Shardy\",\"link\":\"/api/dialects/shardy\"},{\"text\":\"StableHLO\",\"link\":\"/api/dialects/stablehlo\"},{\"text\":\"Triton\",\"link\":\"/api/dialects/triton\"},{\"text\":\"TPU\",\"link\":\"/api/dialects/tpu\"},{\"text\":\"VHLO\",\"link\":\"/api/dialects/vhlo\"}]},{\"text\":\"Low-Level API\",\"collapsed\":false,\"items\":[{\"text\":\"MLIR API\",\"link\":\"/api/mlirc\"},{\"text\":\"XLA\",\"link\":\"/api/xla\"}]},{\"text\":\"Internal API\",\"link\":\"/api/internal\"}]}]},\"editLink\":{\"pattern\":\"https://github.com/EnzymeAD/Reactant.jl/edit/main/docs/src/:path\",\"text\":\"Edit this page on GitHub\"},\"socialLinks\":[{\"icon\":\"slack\",\"link\":\"https://julialang.org/slack/\"}],\"footer\":{\"message\":\"Made with <a href=\\\"https://documenter.juliadocs.org/stable/\\\" target=\\\"_blank\\\"><strong>Documenter.jl</strong></a>, <a href=\\\"https://vitepress.dev\\\" target=\\\"_blank\\\"><strong>VitePress</strong></a> and <a href=\\\"https://luxdl.github.io/DocumenterVitepress.jl/stable\\\" target=\\\"_blank\\\"><strong>DocumenterVitepress.jl</strong></a><br>Released under the MIT License. Powered by the <a href=\\\"https://www.julialang.org\\\">Julia Programming Language</a>.<br>\",\"copyright\":\"© Copyright 2025 Reactant Development Team.\"},\"lastUpdated\":{\"text\":\"Updated at\",\"formatOptions\":{\"dateStyle\":\"full\",\"timeStyle\":\"medium\"}}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>