<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Higher level API | Reactant.jl</title>
    <meta name="description" content="Documentation for Reactant.jl">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/Reactant.jl/v0.2.45/assets/style.zBfk7xO0.css" as="style">
    <link rel="preload stylesheet" href="/Reactant.jl/v0.2.45/vp-icons.css" as="style">
    
    <script type="module" src="/Reactant.jl/v0.2.45/assets/app.CHHlpovX.js"></script>
    <link rel="preload" href="/Reactant.jl/v0.2.45/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Reactant.jl/v0.2.45/assets/chunks/theme.CQS0-wWP.js">
    <link rel="modulepreload" href="/Reactant.jl/v0.2.45/assets/chunks/framework.eaGO5jZg.js">
    <link rel="modulepreload" href="/Reactant.jl/v0.2.45/assets/api_mlirc.md.DRIeB_pG.lean.js">
    <link rel="icon" href="REPLACE_ME_DOCUMENTER_VITEPRESS_FAVICON">
    <script src="/versions.js"></script>
    <script src="/Reactant.jl/v0.2.45/siteinfo.js"></script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-a9a9e638><!--[--><!--]--><!--[--><span tabindex="-1" data-v-492508fc></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-492508fc>Skip to content</a><!--]--><!----><header class="VPNav" data-v-a9a9e638 data-v-f1e365da><div class="VPNavBar" data-v-f1e365da data-v-822684d1><div class="wrapper" data-v-822684d1><div class="container" data-v-822684d1><div class="title" data-v-822684d1><div class="VPNavBarTitle has-sidebar" data-v-822684d1 data-v-0f4f798b><a class="title" href="/Reactant.jl/v0.2.45/" data-v-0f4f798b><!--[--><!--]--><!--[--><!--[--><!--[--><img class="VPImage dark logo" src="/Reactant.jl/v0.2.45/logo.svg" alt data-v-35a7d0b8><!--]--><!--[--><img class="VPImage light logo" src="/Reactant.jl/v0.2.45/logo.svg" alt data-v-35a7d0b8><!--]--><!--]--><!--]--><span data-v-0f4f798b>Reactant.jl</span><!--[--><!--]--></a></div></div><div class="content" data-v-822684d1><div class="content-body" data-v-822684d1><!--[--><!--]--><div class="VPNavBarSearch search" data-v-822684d1><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-822684d1 data-v-e6d46098><span id="main-nav-aria-label" class="visually-hidden" data-v-e6d46098> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Reactant.jl/v0.2.45/" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Home</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>Getting Started</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/introduction" data-v-acbfed09><!--[--><span data-v-acbfed09>Introduction</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/introduction/configuration" data-v-acbfed09><!--[--><span data-v-acbfed09>Configuration</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link vp-external-link-icon VPNavBarMenuLink" href="https://enzymead.github.io/Reactant.jl/benchmarks/" target="_blank" rel="noreferrer" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Benchmarks</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>Tutorials</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/tutorials/" data-v-acbfed09><!--[--><span data-v-acbfed09>Overview</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/tutorials/profiling" data-v-acbfed09><!--[--><span data-v-acbfed09>Profiling</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/tutorials/multihost" data-v-acbfed09><!--[--><span data-v-acbfed09>Distributed</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/tutorials/local-build" data-v-acbfed09><!--[--><span data-v-acbfed09>Local build</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>API</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/api" data-v-acbfed09><!--[--><span data-v-acbfed09>Core Reactant API</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/sharding" data-v-acbfed09><!--[--><span data-v-acbfed09>Sharding</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/ops" data-v-acbfed09><!--[--><span data-v-acbfed09>Ops</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuGroup" data-v-7dd3104a data-v-48c802d0><p class="title" data-v-48c802d0>MLIR Dialects</p><!--[--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/arith" data-v-acbfed09><!--[--><span data-v-acbfed09>ArithOps</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/affine" data-v-acbfed09><!--[--><span data-v-acbfed09>Affine</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/builtin" data-v-acbfed09><!--[--><span data-v-acbfed09>Builtin</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/chlo" data-v-acbfed09><!--[--><span data-v-acbfed09>Chlo</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/enzyme" data-v-acbfed09><!--[--><span data-v-acbfed09>Enzyme</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/enzymexla" data-v-acbfed09><!--[--><span data-v-acbfed09>EnzymeXLA</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/func" data-v-acbfed09><!--[--><span data-v-acbfed09>Func</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/gpu" data-v-acbfed09><!--[--><span data-v-acbfed09>GPU</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/llvm" data-v-acbfed09><!--[--><span data-v-acbfed09>LLVM</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/mpi" data-v-acbfed09><!--[--><span data-v-acbfed09>MPI</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/memref" data-v-acbfed09><!--[--><span data-v-acbfed09>MemRef</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/nvvm" data-v-acbfed09><!--[--><span data-v-acbfed09>NVVM</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/shardy" data-v-acbfed09><!--[--><span data-v-acbfed09>Shardy</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/stablehlo" data-v-acbfed09><!--[--><span data-v-acbfed09>StableHLO</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/triton" data-v-acbfed09><!--[--><span data-v-acbfed09>Triton</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/tpu" data-v-acbfed09><!--[--><span data-v-acbfed09>TPU</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/dialects/vhlo" data-v-acbfed09><!--[--><span data-v-acbfed09>VHLO</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-7dd3104a data-v-48c802d0><p class="title" data-v-48c802d0>Low-Level API</p><!--[--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link active" href="/Reactant.jl/v0.2.45/api/mlirc" data-v-acbfed09><!--[--><span data-v-acbfed09>MLIR API</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/xla" data-v-acbfed09><!--[--><span data-v-acbfed09>XLA</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.45/api/internal" data-v-acbfed09><!--[--><span data-v-acbfed09>Internal API</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><!----><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-822684d1 data-v-af096f4a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-af096f4a data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-822684d1 data-v-164c457f data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/EnzymeAD/Reactant.jl" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-github"></span></a><a class="VPSocialLink no-icon" href="https://julialang.org/slack/" aria-label="slack" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-slack"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-822684d1 data-v-925effce data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-04f5c5e9><span class="vpi-more-horizontal icon" data-v-04f5c5e9></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><!----><!--[--><!--[--><!----><div class="group" data-v-925effce><div class="item appearance" data-v-925effce><p class="label" data-v-925effce>Appearance</p><div class="appearance-action" data-v-925effce><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-925effce data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div></div></div><div class="group" data-v-925effce><div class="item social-links" data-v-925effce><div class="VPSocialLinks social-links-list" data-v-925effce data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/EnzymeAD/Reactant.jl" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-github"></span></a><a class="VPSocialLink no-icon" href="https://julialang.org/slack/" aria-label="slack" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-slack"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-822684d1 data-v-5dea55bf><span class="container" data-v-5dea55bf><span class="top" data-v-5dea55bf></span><span class="middle" data-v-5dea55bf></span><span class="bottom" data-v-5dea55bf></span></span></button></div></div></div></div><div class="divider" data-v-822684d1><div class="divider-line" data-v-822684d1></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-a9a9e638 data-v-070ab83d><div class="container" data-v-070ab83d><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-070ab83d><span class="vpi-align-left menu-icon" data-v-070ab83d></span><span class="menu-text" data-v-070ab83d>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-070ab83d data-v-168ddf5d><button data-v-168ddf5d>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-a9a9e638 data-v-18756405><div class="curtain" data-v-18756405></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-18756405><span class="visually-hidden" id="sidebar-aria-label" data-v-18756405> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0" data-v-9e426adc data-v-a4b0d9bf><!----><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/api" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Reactant API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/sharding" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Sharding</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/ops" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Ops</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0 collapsible" data-v-9e426adc data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h2 class="text" data-v-a4b0d9bf>MLIR Dialects</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/arith" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>ArithOps</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/affine" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Affine</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/builtin" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Builtin</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/chlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Chlo</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/enzyme" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Enzyme</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/enzymexla" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>EnzymeXLA</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/func" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Func</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/gpu" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>GPU</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/llvm" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>LLVM</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/mpi" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MPI</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/memref" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MemRef</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/nvvm" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>NVVM</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/shardy" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Shardy</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/stablehlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>StableHLO</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/triton" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Triton</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/tpu" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>TPU</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/dialects/vhlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>VHLO</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0 collapsible has-active" data-v-9e426adc data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h2 class="text" data-v-a4b0d9bf>Low-Level API</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/mlirc" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MLIR API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/xla" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>XLA</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0" data-v-9e426adc data-v-a4b0d9bf><!----><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.45/api/internal" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Internal API</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-a9a9e638 data-v-91765379><div class="VPDoc has-sidebar has-aside" data-v-91765379 data-v-83890dd9><!--[--><!--]--><div class="container" data-v-83890dd9><div class="aside" data-v-83890dd9><div class="aside-curtain" data-v-83890dd9></div><div class="aside-container" data-v-83890dd9><div class="aside-content" data-v-83890dd9><div class="VPDocAside" data-v-83890dd9 data-v-6d7b3c46><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-6d7b3c46 data-v-b38bf2ff><div class="content" data-v-b38bf2ff><div class="outline-marker" data-v-b38bf2ff></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-b38bf2ff>On this page</div><ul class="VPDocOutlineItem root" data-v-b38bf2ff data-v-3f927ebe><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-6d7b3c46></div><!--[--><!--[--><!--[--><!--[--><!--[--><br><h2> Trusted by </h2><a class="enjoyer" href="https://lux.csail.mit.edu/" target="_blank"><img width="32" height="32" src="https://raw.githubusercontent.com/LuxDL/Lux.jl/refs/heads/main/assets/lux-logo.svg"><span><p class="extra-info">Scientific Computing</p><p class="heading">Lux.jl</p><p class="extra-info">Machine Learning</p></span></a><a class="enjoyer" href="https://bsc-quantic.github.io/Tenet.jl/stable/" target="_blank"><img width="32" height="32" src="https://raw.githubusercontent.com/bsc-quantic/Tenet.jl/refs/heads/master/docs/src/assets/logo.svg"><span><p class="extra-info">Quantum Simulation</p><p class="heading">Tenet.jl</p><p class="extra-info">Tensor Networks</p></span></a><!--]--><!--]--><!--]--><!--]--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-83890dd9><div class="content-container" data-v-83890dd9><!--[--><!--]--><main class="main" data-v-83890dd9><div style="position:relative;" class="vp-doc _Reactant_jl_v0_2_45_api_mlirc" data-v-83890dd9><div><h1 id="Higher-level-API" tabindex="-1">Higher level API <a class="header-anchor" href="#Higher-level-API" aria-label="Permalink to &quot;Higher level API {#Higher-level-API}&quot;">â€‹</a></h1><details class="jldocstring custom-block"><summary><a id="Core.Bool-Tuple{Reactant.MLIR.IR.Attribute}" href="#Core.Bool-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Core.Bool</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given bool attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L210-L214" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Core.Float64-Tuple{Reactant.MLIR.IR.Attribute}" href="#Core.Float64-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Core.Float64</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given floating point attribute, interpreting the value as double.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L126-L130" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Core.Int64-Tuple{Reactant.MLIR.IR.Attribute}" href="#Core.Int64-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Core.Int64</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given integer attribute, assuming the value is of signed type and fits into a signed 64-bit integer.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L174-L178" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Core.String-Tuple{Reactant.MLIR.IR.Attribute}" href="#Core.String-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Core.String</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the attribute values as a string reference. The data remains live as long as the context in which the attribute lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L287-L291" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Core.String-Tuple{Reactant.MLIR.IR.Identifier}" href="#Core.String-Tuple{Reactant.MLIR.IR.Identifier}"><span class="jlbinding">Core.String</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ident)</span></span></code></pre></div><p>Gets the string value of the identifier.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Identifier.jl#L29-L33" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Core.UInt64-Tuple{Reactant.MLIR.IR.Attribute}" href="#Core.UInt64-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Core.UInt64</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given integer attribute, assuming the value is of unsigned type and fits into an unsigned 64-bit integer.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L186-L190" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.AffineMap-Tuple{Any, Any, Vector{Reactant.MLIR.IR.AffineExpr}}" href="#Reactant.MLIR.IR.AffineMap-Tuple{Any, Any, Vector{Reactant.MLIR.IR.AffineExpr}}"><span class="jlbinding">Reactant.MLIR.IR.AffineMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ndims, nsymbols, affineExprs; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an affine map with results defined by the given list of affine expressions. The map resulting map also has the requested number of input dimensions and symbols, regardless of them being used in the results.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L50-L55" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.AffineMap-Tuple{Any, Any}" href="#Reactant.MLIR.IR.AffineMap-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.AffineMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ndims, nsymbols; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a zero result affine map of the given dimensions and symbols in the context. The affine map is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L41-L46" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.AffineMap-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.AffineMap-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.AffineMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the affine map wrapped in the given affine map attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L64-L68" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.AffineMap-Tuple{}" href="#Reactant.MLIR.IR.AffineMap-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.AffineMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a zero result affine map with no dimensions or symbols in the context. The affine map is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L10-L15" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Attribute-Tuple{AbstractString}" href="#Reactant.MLIR.IR.Attribute-Tuple{AbstractString}"><span class="jlbinding">Reactant.MLIR.IR.Attribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a string attribute in the given context containing the given string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L270-L274" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Attribute-Tuple{Bool}" href="#Reactant.MLIR.IR.Attribute-Tuple{Bool}"><span class="jlbinding">Reactant.MLIR.IR.Attribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a bool attribute in the given context with the given value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L203-L207" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Attribute-Tuple{Dict}" href="#Reactant.MLIR.IR.Attribute-Tuple{Dict}"><span class="jlbinding">Reactant.MLIR.IR.Attribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a dictionary attribute containing the given list of elements in the provided context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L93-L97" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Reactant.MLIR.IR.Attribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Creates an affine map attribute wrapping the given map. The attribute belongs to the same context as the affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L57-L61" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.Type, AbstractString}" href="#Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.Type, AbstractString}"><span class="jlbinding">Reactant.MLIR.IR.Attribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, str)</span></span></code></pre></div><p>Creates a string attribute in the given context containing the given string. Additionally, the attribute has the given type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L278-L282" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.Attribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Creates a type attribute wrapping the given type in the same context as the type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L376-L380" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Attribute-Tuple{T} where T&lt;:AbstractFloat" href="#Reactant.MLIR.IR.Attribute-Tuple{T} where T&lt;:AbstractFloat"><span class="jlbinding">Reactant.MLIR.IR.Attribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(float; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), check</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a floating point attribute in the given context with the given double value and double-precision FP semantics. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L110-L115" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Attribute-Tuple{T} where T&lt;:Complex" href="#Reactant.MLIR.IR.Attribute-Tuple{T} where T&lt;:Complex"><span class="jlbinding">Reactant.MLIR.IR.Attribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(complex; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), check</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a complex attribute in the given context with the given complex value and double-precision FP semantics.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L136-L140" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Attribute-Tuple{Vector{Reactant.MLIR.IR.Attribute}}" href="#Reactant.MLIR.IR.Attribute-Tuple{Vector{Reactant.MLIR.IR.Attribute}}"><span class="jlbinding">Reactant.MLIR.IR.Attribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an array element containing the given list of elements in the given context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L78-L82" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Attribute-Tuple{}" href="#Reactant.MLIR.IR.Attribute-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.Attribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns an empty attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L5-L9" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Attribute-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Integer" href="#Reactant.MLIR.IR.Attribute-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Integer"><span class="jlbinding">Reactant.MLIR.IR.Attribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(int)</span></span></code></pre></div><p>Creates an integer attribute of the given type with the given integer value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L166-L170" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Block-Tuple{Vector{Reactant.MLIR.IR.Type}, Vector{Reactant.MLIR.IR.Location}}" href="#Reactant.MLIR.IR.Block-Tuple{Vector{Reactant.MLIR.IR.Type}, Vector{Reactant.MLIR.IR.Location}}"><span class="jlbinding">Reactant.MLIR.IR.Block</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args, locs)</span></span></code></pre></div><p>Creates a new empty block with the given argument types and transfers ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L17-L21" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.BlockIterator" href="#Reactant.MLIR.IR.BlockIterator"><span class="jlbinding">Reactant.MLIR.IR.BlockIterator</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BlockIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Region</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Iterates over all blocks in the given region.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Iterators.jl#L1-L5" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Context-Tuple{}" href="#Reactant.MLIR.IR.Context-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.Context</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates an MLIR context and transfers its ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Context.jl#L10-L14" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.ExecutionEngine" href="#Reactant.MLIR.IR.ExecutionEngine"><span class="jlbinding">Reactant.MLIR.IR.ExecutionEngine</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ExecutionEngine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, optLevel, sharedlibs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [])</span></span></code></pre></div><p>Creates an ExecutionEngine for the provided ModuleOp. The ModuleOp is expected to be &quot;translatable&quot; to LLVM IR (only contains operations in dialects that implement the <code>LLVMTranslationDialectInterface</code>). The module ownership stays with the client and can be destroyed as soon as the call returns. <code>optLevel</code> is the optimization level to be used for transformation and code generation. LLVM passes at <code>optLevel</code> are run before code generation. The number and array of paths corresponding to shared libraries that will be loaded are specified via <code>numPaths</code> and <code>sharedLibPaths</code> respectively. TODO: figure out other options.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/ExecutionEngine.jl#L10-L20" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Identifier-Tuple{String}" href="#Reactant.MLIR.IR.Identifier-Tuple{String}"><span class="jlbinding">Reactant.MLIR.IR.Identifier</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Identifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, str)</span></span></code></pre></div><p>Gets an identifier with the given string value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Identifier.jl#L5-L9" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.IntegerSet-NTuple{4, Any}" href="#Reactant.MLIR.IR.IntegerSet-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.IR.IntegerSet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IntegerSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ndims, nsymbols, constraints, eqflags; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Gets or creates a new integer set in the given context. The set is defined by a list of affine constraints, with the given number of input dimensions and symbols, which are treated as either equalities (eqflags is 1) or inequalities (eqflags is 0). Both <code>constraints</code> and <code>eqflags</code> need to be arrays of the same length.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L18-L24" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.IntegerSet-Tuple{Any, Any}" href="#Reactant.MLIR.IR.IntegerSet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.IntegerSet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integerset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ndims, nsymbols; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Gets or creates a new canonically empty integer set with the give number of dimensions and symbols in the given context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L10-L14" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.LogicalResult" href="#Reactant.MLIR.IR.LogicalResult"><span class="jlbinding">Reactant.MLIR.IR.LogicalResult</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LogicalResult</span></span></code></pre></div><p>A logical result value, essentially a boolean with named states. LLVM convention for using boolean values to designate success or failure of an operation is a moving target, so MLIR opted for an explicit class. Instances of <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.IR.LogicalResult"><code>LogicalResult</code></a> must only be inspected using the associated functions.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/LogicalResult.jl#L1-L7" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Module" href="#Reactant.MLIR.IR.Module"><span class="jlbinding">Reactant.MLIR.IR.Module</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a new, empty module and transfers ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Module.jl#L10-L14" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.NamedAttribute-Tuple{Any, Any}" href="#Reactant.MLIR.IR.NamedAttribute-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.NamedAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name, attr)</span></span></code></pre></div><p>Associates an attribute with the name. Takes ownership of neither.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L850-L854" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.OpPassManager, Any}" href="#Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.OpPassManager, Any}"><span class="jlbinding">Reactant.MLIR.IR.OpPassManager</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpPassManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opPassManager, operationName)</span></span></code></pre></div><p>Nest an <code>OpPassManager</code> under the provided <code>OpPassManager</code>, the nested passmanager will only run on operations matching the provided name. The returned <code>OpPassManager</code> will be destroyed when the parent is destroyed.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Pass.jl#L111-L115" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.PassManager, Any}" href="#Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.PassManager, Any}"><span class="jlbinding">Reactant.MLIR.IR.OpPassManager</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpPassManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, operationName)</span></span></code></pre></div><p>Nest an <code>OpPassManager</code> under the top-level PassManager, the nested passmanager will only run on operations matching the provided name. The returned <code>OpPassManager</code> will be destroyed when the parent is destroyed. To further nest more <code>OpPassManager</code> under the newly returned one, see <code>mlirOpPassManagerNest</code> below.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Pass.jl#L102-L107" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.PassManager}" href="#Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.PassManager}"><span class="jlbinding">Reactant.MLIR.IR.OpPassManager</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpPassManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager)</span></span></code></pre></div><p>Cast a top-level <code>PassManager</code> to a generic <code>OpPassManager</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Pass.jl#L94-L98" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Operation-Tuple{Reactant.MLIR.IR.Module}" href="#Reactant.MLIR.IR.Operation-Tuple{Reactant.MLIR.IR.Module}"><span class="jlbinding">Reactant.MLIR.IR.Operation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Views the module as a generic operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Module.jl#L50-L54" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.OperationIterator" href="#Reactant.MLIR.IR.OperationIterator"><span class="jlbinding">Reactant.MLIR.IR.OperationIterator</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OperationIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Iterates over all operations for the given block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Iterators.jl#L66-L70" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.PassManager-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.PassManager-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.PassManager</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PassManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(anchorOp; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Create a new top-level PassManager anchored on <code>anchorOp</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Pass.jl#L28-L32" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.PassManager-Tuple{}" href="#Reactant.MLIR.IR.PassManager-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.PassManager</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PassManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Create a new top-level PassManager.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Pass.jl#L21-L25" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Region-Tuple{}" href="#Reactant.MLIR.IR.Region-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.Region</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Region</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a new empty region and transfers ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Region.jl#L15-L19" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.RegionIterator" href="#Reactant.MLIR.IR.RegionIterator"><span class="jlbinding">Reactant.MLIR.IR.RegionIterator</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RegionIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Iterates over all sub-regions for the given operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Iterators.jl#L34-L38" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.SymbolTable-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.SymbolTable-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.SymbolTable</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(operation)</span></span></code></pre></div><p>Creates a symbol table for the given operation. If the operation does not have the SymbolTable trait, returns a null symbol table.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/SymbolTable.jl#L10-L14" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.Type-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the type stored in the given type attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L383-L387" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Integer}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Integer}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{&lt;:Integer}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a signless integer type of the given bitwidth in the context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L80-L84" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Reactant.F8E4M3B11FNUZ}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Reactant.F8E4M3B11FNUZ}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Reactant.F8E4M3B11FNUZ}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a f8e4m3b11fnuz type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L212-L216" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Reactant.F8E4M3FNUZ}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Reactant.F8E4M3FNUZ}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Reactant.F8E4M3FNUZ}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a f8e4m3fnuz type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L230-L234" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Reactant.F8E4M3FN}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Reactant.F8E4M3FN}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Reactant.F8E4M3FN}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a f8e4m3fn type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L203-L207" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Reactant.F8E5M2FNUZ}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Reactant.F8E5M2FNUZ}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Reactant.F8E5M2FNUZ}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a f8e5m2fnuz type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L221-L225" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Reactant.F8E5M2}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Reactant.F8E5M2}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Reactant.F8E5M2}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a f8e5m2 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L194-L198" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Signed}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Signed}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{&lt;:Signed}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a signed integer type of the given bitwidth in the context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L88-L92" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Unsigned}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{&lt;:Unsigned}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{&lt;:Unsigned}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates an unsigned integer type of the given bitwidth in the context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L96-L100" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{Bool}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{Bool}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Bool}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a 1-bit signless integer type in the context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L71-L75" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{Float16}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{Float16}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Float16}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an f16 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L164-L168" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{Float32}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{Float32}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Core</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Type{Float32}; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an f32 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L180-L184" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{Float64}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{Float64}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Core</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Type{Float64}; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a f64 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L187-L191" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Type{Nothing}}" href="#Reactant.MLIR.IR.Type-Tuple{Type{Nothing}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Nothing}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a None type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L42-L46" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Tuple{Vector{Reactant.MLIR.IR.Type}}" href="#Reactant.MLIR.IR.Type-Tuple{Vector{Reactant.MLIR.IR.Type}}"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elements; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{&lt;:Tuple{T...}}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a tuple type that consists of the given list of elemental types. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L623-L628" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Type-Union{Tuple{Type{Complex{T}}}, Tuple{T}} where T" href="#Reactant.MLIR.IR.Type-Union{Tuple{Type{Complex{T}}}, Tuple{T}} where T"><span class="jlbinding">Reactant.MLIR.IR.Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Complex{T}) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T}</span></span></code></pre></div><p>Creates a complex type with the given element type in the same context as the element type. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L303-L307" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.:-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}" href="#Base.:-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Base.:*</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine mul expression with &#39;lhs&#39; and &#39;rhs&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L157-L161" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.:+-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}" href="#Base.:+-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Base.:+</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine add expression with &#39;lhs&#39; and &#39;rhs&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L143-L147" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.:==-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}" href="#Base.:==-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Base.:==</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b)</span></span></code></pre></div><p>Returns <code>true</code> if the two affine expressions are equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L12-L16" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.:==-Tuple{Reactant.MLIR.IR.AffineMap, Reactant.MLIR.IR.AffineMap}" href="#Base.:==-Tuple{Reactant.MLIR.IR.AffineMap, Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Base.:==</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b)</span></span></code></pre></div><p>Checks if two affine maps are equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L20-L24" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.:==-Tuple{Reactant.MLIR.IR.Attribute, Reactant.MLIR.IR.Attribute}" href="#Base.:==-Tuple{Reactant.MLIR.IR.Attribute, Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Base.:==</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a1, a2)</span></span></code></pre></div><p>Checks if two attributes are equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L22-L26" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.:==-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}" href="#Base.:==-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}"><span class="jlbinding">Base.:==</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, other)</span></span></code></pre></div><p>Checks whether two blocks handles point to the same block. This does not perform deep comparison.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L27-L31" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.:==-Tuple{Reactant.MLIR.IR.Identifier, Reactant.MLIR.IR.Identifier}" href="#Base.:==-Tuple{Reactant.MLIR.IR.Identifier, Reactant.MLIR.IR.Identifier}"><span class="jlbinding">Base.:==</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ident, other)</span></span></code></pre></div><p>Checks whether two identifiers are the same.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Identifier.jl#L15-L19" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.:==-Tuple{Reactant.MLIR.IR.IntegerSet, Reactant.MLIR.IR.IntegerSet}" href="#Base.:==-Tuple{Reactant.MLIR.IR.IntegerSet, Reactant.MLIR.IR.IntegerSet}"><span class="jlbinding">Base.:==</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s1, s2)</span></span></code></pre></div><p>Checks if two integer set objects are equal. This is a &quot;shallow&quot; comparison of two objects. Only the sets with some small number of constraints are uniqued and compare equal here. Set objects that represent the same integer set with different constraints may be considered non-equal by this check. Set difference followed by an (expensive) emptiness check should be used to check equivalence of the underlying integer sets.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L50-L57" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.:==-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Region}" href="#Base.:==-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Region}"><span class="jlbinding">Base.:==</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, other)</span></span></code></pre></div><p>Checks whether two region handles point to the same region. This does not perform deep comparison.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Region.jl#L25-L29" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.:==-Tuple{Reactant.MLIR.IR.Type, Reactant.MLIR.IR.Type}" href="#Base.:==-Tuple{Reactant.MLIR.IR.Type, Reactant.MLIR.IR.Type}"><span class="jlbinding">Base.:==</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t1, t2)</span></span></code></pre></div><p>Checks if two types are equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L20-L24" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.:==-Tuple{Reactant.MLIR.IR.TypeID, Reactant.MLIR.IR.TypeID}" href="#Base.:==-Tuple{Reactant.MLIR.IR.TypeID, Reactant.MLIR.IR.TypeID}"><span class="jlbinding">Base.:==</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(typeID1, typeID2)</span></span></code></pre></div><p>Checks if two type ids are equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/TypeID.jl#L23-L27" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.:==-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Base.:==-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Base.:==</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value1, value2)</span></span></code></pre></div><p>Returns 1 if two values are equal, 0 otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Value.jl#L14-L18" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.cld-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}" href="#Base.cld-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Base.cld</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine ceildiv expression with &#39;lhs&#39; and &#39;rhs&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L203-L207" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.copy-Tuple{Reactant.MLIR.IR.Operation}" href="#Base.copy-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Base.copy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">copy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Creates a deep copy of an operation. The operation is not inserted and ownership is transferred to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L21-L25" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.div-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}" href="#Base.div-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Base.div</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Ã·</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fld</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine floordiv expression with &#39;lhs&#39; and &#39;rhs&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L185-L191" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.fill-Tuple{Reactant.MLIR.IR.Attribute, Reactant.MLIR.IR.Type}" href="#Base.fill-Tuple{Reactant.MLIR.IR.Attribute, Reactant.MLIR.IR.Type}"><span class="jlbinding">Base.fill</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, shapedType)</span></span></code></pre></div><p>Creates a dense elements attribute with the given Shaped type containing a single replicated element (splat).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L435-L439" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.gcd-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Base.gcd-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Base.gcd</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gcd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the greatest known integral divisor of this affine expression. The result is always positive.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L40-L44" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.hash-Tuple{Reactant.MLIR.IR.TypeID}" href="#Base.hash-Tuple{Reactant.MLIR.IR.TypeID}"><span class="jlbinding">Base.hash</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(typeID)</span></span></code></pre></div><p>Returns the hash value of the type id.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/TypeID.jl#L14-L18" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.insert!-Tuple{Reactant.MLIR.IR.Block, Any, Reactant.MLIR.IR.Operation}" href="#Base.insert!-Tuple{Reactant.MLIR.IR.Block, Any, Reactant.MLIR.IR.Operation}"><span class="jlbinding">Base.insert!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, index, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and inserts it as <code>index</code> to the block. This is an expensive operation that scans the block linearly, prefer insertBefore/After instead.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L134-L139" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.insert!-Tuple{Reactant.MLIR.IR.Region, Any, Reactant.MLIR.IR.Block}" href="#Base.insert!-Tuple{Reactant.MLIR.IR.Region, Any, Reactant.MLIR.IR.Block}"><span class="jlbinding">Base.insert!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, index, block)</span></span></code></pre></div><p>Takes a block owned by the caller and inserts it at <code>index</code> to the given region. This is an expensive operation that linearly scans the region, prefer insertAfter/Before instead.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Region.jl#L42-L46" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.isempty-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Base.isempty-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Base.isempty</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isempty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is an empty affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L114-L118" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.isperm-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Base.isperm-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Base.isperm</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isperm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map represents a symbol-less permutation map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L180-L184" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.mod-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}" href="#Base.mod-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Base.mod</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine mod expression with &#39;lhs&#39; and &#39;rhs&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L171-L175" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.ndims-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Base.ndims-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Base.ndims</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ndims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of dimensions of the given affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L138-L142" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.ndims-Tuple{Reactant.MLIR.IR.IntegerSet}" href="#Base.ndims-Tuple{Reactant.MLIR.IR.IntegerSet}"><span class="jlbinding">Base.ndims</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ndims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of dimensions in the given set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L74-L78" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.ndims-Tuple{Reactant.MLIR.IR.Type}" href="#Base.ndims-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Base.ndims</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ndims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the rank of the given ranked shaped type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L332-L336" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.parse-Tuple{Reactant.MLIR.IR.OpPassManager, String}" href="#Base.parse-Tuple{Reactant.MLIR.IR.OpPassManager, String}"><span class="jlbinding">Base.parse</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, pipeline)</span></span></code></pre></div><p>Parse a textual MLIR pass pipeline and add it to the provided <code>OpPassManager</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Pass.jl#L159-L163" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.parse-Tuple{Type{Reactant.MLIR.IR.Attribute}, Any}" href="#Base.parse-Tuple{Type{Reactant.MLIR.IR.Attribute}, Any}"><span class="jlbinding">Base.parse</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Core.Type{Attribute}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, str; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Parses an attribute. The attribute is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L14-L18" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.parse-Tuple{Type{Reactant.MLIR.IR.Module}, Any}" href="#Base.parse-Tuple{Type{Reactant.MLIR.IR.Module}, Any}"><span class="jlbinding">Base.parse</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Type{Module}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Parses a module from the string and transfers ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Module.jl#L21-L25" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.parse-Tuple{Type{Reactant.MLIR.IR.Type}, Any}" href="#Base.parse-Tuple{Type{Reactant.MLIR.IR.Type}, Any}"><span class="jlbinding">Base.parse</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Parses a type. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L12-L16" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.push!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation}" href="#Base.push!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation}"><span class="jlbinding">Base.push!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">push!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and appends it to the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L124-L128" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.push!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block}" href="#Base.push!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block}"><span class="jlbinding">Base.push!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">push!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, block)</span></span></code></pre></div><p>Takes a block owned by the caller and appends it to the given region.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Region.jl#L32-L36" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.push!-Tuple{Reactant.MLIR.IR.SymbolTable, Reactant.MLIR.IR.Operation}" href="#Base.push!-Tuple{Reactant.MLIR.IR.SymbolTable, Reactant.MLIR.IR.Operation}"><span class="jlbinding">Base.push!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">push!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symboltable, operation)</span></span></code></pre></div><p>Inserts the given operation into the given symbol table. The operation must have the symbol trait. If the symbol table already has a symbol with the same name, renames the symbol being inserted to ensure name uniqueness. Note that this does not move the operation itself into the block of the symbol table operation, this should be done separately. Returns the name of the symbol after insertion.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/SymbolTable.jl#L40-L47" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.replace-Tuple{Reactant.MLIR.IR.AffineMap, Pair{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}, Any, Any}" href="#Base.replace-Tuple{Reactant.MLIR.IR.AffineMap, Pair{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}, Any, Any}"><span class="jlbinding">Base.replace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapReplace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, expression </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> replacement, numResultDims, numResultSyms)</span></span></code></pre></div><p>Apply <code>AffineExpr::replace(map)</code> to each of the results and return a new new AffineMap with the new results and the specified number of dims and symbols.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L214-L218" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.replace-Tuple{Reactant.MLIR.IR.IntegerSet, Any, Any}" href="#Base.replace-Tuple{Reactant.MLIR.IR.IntegerSet, Any, Any}"><span class="jlbinding">Base.replace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetReplaceGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, dimReplacements, symbolReplacements, numResultDims, numResultSymbols)</span></span></code></pre></div><p>Gets or creates a new integer set in which the values and dimensions of the given set are replaced with the given affine expressions. <code>dimReplacements</code> and <code>symbolReplacements</code> are expected to point to at least as many consecutive expressions as the given set has dimensions and symbols, respectively. The new set will have <code>numResultDims</code> and <code>numResultSymbols</code> dimensions and symbols, respectively.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L31-L37" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.reshape-Tuple{Reactant.MLIR.IR.Attribute, Any}" href="#Base.reshape-Tuple{Reactant.MLIR.IR.Attribute, Any}"><span class="jlbinding">Base.reshape</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reshape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, shapedType)</span></span></code></pre></div><p>Creates a dense elements attribute that has the same data as the given dense elements attribute and a different shaped type. The new type must have the same total number of elements.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L635-L639" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.size-Tuple{Reactant.MLIR.IR.Type, Int64}" href="#Base.size-Tuple{Reactant.MLIR.IR.Type, Int64}"><span class="jlbinding">Base.size</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, i)</span></span></code></pre></div><p>Returns the <code>i</code>-th dimension of the given ranked shaped type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L356-L360" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Base.write-Tuple{String, Reactant.MLIR.IR.ExecutionEngine}" href="#Base.write-Tuple{String, Reactant.MLIR.IR.ExecutionEngine}"><span class="jlbinding">Base.write</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fileName, jit)</span></span></code></pre></div><p>Dump as an object in <code>fileName</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/ExecutionEngine.jl#L54-L58" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.AffineDimensionExpr-Tuple{Any}" href="#Reactant.MLIR.IR.AffineDimensionExpr-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.AffineDimensionExpr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AffineDimensionExpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(position; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context)</span></span></code></pre></div><p>Creates an affine dimension expression with &#39;position&#39; in the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L69-L73" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.BFloat16Type-Tuple{}" href="#Reactant.MLIR.IR.BFloat16Type-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.BFloat16Type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p>BFloat16Type(; context=context())</p><p>Creates a bf16 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L157-L161" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.ConstantAffineMap-Tuple{Any}" href="#Reactant.MLIR.IR.ConstantAffineMap-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.ConstantAffineMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConstantAffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a single constant result affine map in the context. The affine map is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L59-L63" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.ConstantExpr-Tuple{Any}" href="#Reactant.MLIR.IR.ConstantExpr-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.ConstantExpr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConstantExpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(constant</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an affine constant expression with &#39;constant&#39; in the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L118-L122" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.DenseElementsAttribute-Tuple{AbstractArray{Bool}}" href="#Reactant.MLIR.IR.DenseElementsAttribute-Tuple{AbstractArray{Bool}}"><span class="jlbinding">Reactant.MLIR.IR.DenseElementsAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DenseElementsAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a dense elements attribute with the given shaped type from elements of a specific type. Expects the element type of the shaped type to match the data element type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L499-L503" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.DenseElementsAttribute-Tuple{AbstractArray{String}}" href="#Reactant.MLIR.IR.DenseElementsAttribute-Tuple{AbstractArray{String}}"><span class="jlbinding">Reactant.MLIR.IR.DenseElementsAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DenseElementsAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{String}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a dense elements attribute with the given shaped type from string elements.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L620-L624" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.DenseElementsAttribute-Tuple{Reactant.MLIR.IR.Type, AbstractArray}" href="#Reactant.MLIR.IR.DenseElementsAttribute-Tuple{Reactant.MLIR.IR.Type, AbstractArray}"><span class="jlbinding">Reactant.MLIR.IR.DenseElementsAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DenseElementsAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, elements)</span></span></code></pre></div><p>Creates a dense elements attribute with the given Shaped type and elements in the same context as the type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L423-L427" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.FlatSymbolRefAttribute-Tuple{String}" href="#Reactant.MLIR.IR.FlatSymbolRefAttribute-Tuple{String}"><span class="jlbinding">Reactant.MLIR.IR.FlatSymbolRefAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FlatSymbolRefAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, symbol)</span></span></code></pre></div><p>Creates a flat symbol reference attribute in the given context referencing a symbol identified by the given string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L351-L355" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Float8E4M3FN-Tuple{}" href="#Reactant.MLIR.IR.Float8E4M3FN-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.Float8E4M3FN</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float8E4M3FN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an f8E4M3FN type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L150-L154" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.Float8E5M2-Tuple{}" href="#Reactant.MLIR.IR.Float8E5M2-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.Float8E5M2</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float8E5M2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an f8E5M2 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L143-L147" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.FunctionType-Tuple{Any, Any}" href="#Reactant.MLIR.IR.FunctionType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.FunctionType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FunctionType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inputs, results; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a function type, mapping a list of input types to result types.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L653-L657" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.IdentityAffineMap-Tuple{Any}" href="#Reactant.MLIR.IR.IdentityAffineMap-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.IdentityAffineMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IdentityAffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ndims; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an affine map with &#39;ndims&#39; identity in the context. The affine map is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L67-L71" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.IndexType-Tuple{}" href="#Reactant.MLIR.IR.IndexType-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.IndexType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IndexType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an index type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L57-L61" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any, Any, Any}" href="#Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.MemRefType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MemRefType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, rank, shape, layout, memorySpace; location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), check</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a MemRef type with the given rank and shape, a potentially empty list of affine layout maps, the given memory space and element type, in the same context as element type. The type is owned by the context. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L510-L515" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any, Any}" href="#Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.MemRefType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MemRefType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, rank, shape, memorySpace; location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), check</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a MemRef type with the given rank, shape, memory space and element type in the same context as the element type. The type has no affine maps, i.e. represents a default row-major contiguous memref. The type is owned by the context. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L535-L541" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any}" href="#Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any}"><span class="jlbinding">Reactant.MLIR.IR.MemRefType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MemRefType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, memorySpace)</span></span></code></pre></div><p>Creates an Unranked MemRef type with the given element type and in the given memory space. The type is owned by the context of element type. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L556-L561" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.MinorIdentityAffineMap-Tuple{Any, Any}" href="#Reactant.MLIR.IR.MinorIdentityAffineMap-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.MinorIdentityAffineMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MinorIdentityAffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ndims, nresults; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an identity affine map on the most minor dimensions in the context. The affine map is owned by the context. The function asserts that the number of dimensions is greater or equal to the number of results.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L75-L80" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.OpaqueAttribute-Tuple{Any, Any, Any}" href="#Reactant.MLIR.IR.OpaqueAttribute-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.OpaqueAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpaqueAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dialectNamespace, dataLength, data, type; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an opaque attribute in the given context associated with the dialect identified by its namespace. The attribute contains opaque byte data of the specified length (data need not be null-terminated).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L234-L239" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.OpaqueType-Tuple{Any, Any}" href="#Reactant.MLIR.IR.OpaqueType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.OpaqueType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OpaqueType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dialectNamespace, typeData; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an opaque type in the given context associated with the dialect identified by its namespace. The type contains opaque byte data of the specified length (data need not be null-terminated).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L710-L714" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.PermutationAffineMap-Tuple{Any}" href="#Reactant.MLIR.IR.PermutationAffineMap-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.PermutationAffineMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PermutationAffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(permutation; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an affine map with a permutation expression and its size in the context. The permutation expression is a non-empty vector of integers. The elements of the permutation vector must be continuous from 0 and cannot be repeated (i.e. <code>[1,2,0]</code> is a valid permutation. <code>[2,0]</code> or <code>[1,1,2]</code> is an invalid invalid permutation). The affine map is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L86-L93" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.SymbolExpr-Tuple{Any}" href="#Reactant.MLIR.IR.SymbolExpr-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.SymbolExpr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SymbolExpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(position; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates an affine symbol expression with &#39;position&#39; in the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L84-L88" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.SymbolRefAttribute-Tuple{String, Vector{Reactant.MLIR.IR.Attribute}}" href="#Reactant.MLIR.IR.SymbolRefAttribute-Tuple{String, Vector{Reactant.MLIR.IR.Attribute}}"><span class="jlbinding">Reactant.MLIR.IR.SymbolRefAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SymbolRefAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbol, references; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a symbol reference attribute in the given context referencing a symbol identified by the given string inside a list of nested references. Each of the references in the list must not be nested.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L304-L309" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.TensorType" href="#Reactant.MLIR.IR.TensorType"><span class="jlbinding">Reactant.MLIR.IR.TensorType</span></a> <span class="VPBadge info jlObjectType jlFunction"><!--[-->Function<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TensorType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shape, elementType, encoding</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), check</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a tensor type of a fixed rank with the given shape, element type, and optional encoding in the same context as the element type. The type is owned by the context. Tensor types without any specific encoding field should assign <a href="./@ref"><code>mlirAttributeGetNull</code></a> to this parameter. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L423-L429" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.TensorType-Tuple{Any}" href="#Reactant.MLIR.IR.TensorType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.TensorType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TensorType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType)</span></span></code></pre></div><p>Creates an unranked tensor type with the given element type in the same context as the element type. The type is owned by the context. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L444-L449" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.UnitAttribute-Tuple{}" href="#Reactant.MLIR.IR.UnitAttribute-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.UnitAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UnitAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Creates a unit attribute in the given context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L397-L401" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.VectorType-Tuple{Any, Any, Any}" href="#Reactant.MLIR.IR.VectorType-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.VectorType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VectorType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rank, shape, elementType; location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), check</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Creates a vector type of the shape identified by its rank and dimensions, with the given element type in the same context as the element type. The type is owned by the context. If <code>check=true</code>, emits appropriate diagnostics on illegal arguments.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L397-L402" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.add_owned_pass!-Tuple{Reactant.MLIR.IR.OpPassManager, Any}" href="#Reactant.MLIR.IR.add_owned_pass!-Tuple{Reactant.MLIR.IR.OpPassManager, Any}"><span class="jlbinding">Reactant.MLIR.IR.add_owned_pass!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_owned_pass!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opPassManager, pass)</span></span></code></pre></div><p>Add a pass and transfer ownership to the provided <code>OpPassManager</code>. If the pass is not a generic operation pass or matching the type of the provided <code>OpPassManager</code>, a new <code>OpPassManager</code> is implicitly nested under the provided <code>OpPassManager</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Pass.jl#L149-L153" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.add_owned_pass!-Tuple{Reactant.MLIR.IR.PassManager, Any}" href="#Reactant.MLIR.IR.add_owned_pass!-Tuple{Reactant.MLIR.IR.PassManager, Any}"><span class="jlbinding">Reactant.MLIR.IR.add_owned_pass!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_owned_pass!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, pass)</span></span></code></pre></div><p>Add a pass and transfer ownership to the provided top-level <code>PassManager</code>. If the pass is not a generic operation pass or a <code>ModulePass</code>, a new <code>OpPassManager</code> is implicitly nested under the provided PassManager.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Pass.jl#L139-L143" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.add_pipeline!-Tuple{Reactant.MLIR.IR.OpPassManager, Any}" href="#Reactant.MLIR.IR.add_pipeline!-Tuple{Reactant.MLIR.IR.OpPassManager, Any}"><span class="jlbinding">Reactant.MLIR.IR.add_pipeline!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_pipeline!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, pipelineElements, callback, userData)</span></span></code></pre></div><p>Parse a sequence of textual MLIR pass pipeline elements and add them to the provided OpPassManager. If parsing fails an error message is reported using the provided callback.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Pass.jl#L181-L185" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.affinemap-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.affinemap-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.affinemap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">affinemap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the affine map of the given MemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L598-L602" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.argument-Tuple{Reactant.MLIR.IR.Block, Any}" href="#Reactant.MLIR.IR.argument-Tuple{Reactant.MLIR.IR.Block, Any}"><span class="jlbinding">Reactant.MLIR.IR.argument</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">argument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, i)</span></span></code></pre></div><p>Returns <code>i</code>-th argument of the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L70-L74" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.attr!-Tuple{Reactant.MLIR.IR.Operation, Any, Any}" href="#Reactant.MLIR.IR.attr!-Tuple{Reactant.MLIR.IR.Operation, Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.attr!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">attr!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name, attr)</span></span></code></pre></div><p>Sets an attribute by name, replacing the existing if it exists or adding a new one otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L202-L206" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.attr-Tuple{Reactant.MLIR.IR.Operation, AbstractString}" href="#Reactant.MLIR.IR.attr-Tuple{Reactant.MLIR.IR.Operation, AbstractString}"><span class="jlbinding">Reactant.MLIR.IR.attr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">attr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Returns an attribute attached to the operation given its name.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L189-L193" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.attr-Tuple{Reactant.MLIR.IR.Operation, Any}" href="#Reactant.MLIR.IR.attr-Tuple{Reactant.MLIR.IR.Operation, Any}"><span class="jlbinding">Reactant.MLIR.IR.attr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">attr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, i)</span></span></code></pre></div><p>Return <code>i</code>-th attribute of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L179-L183" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.bitwidth-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.bitwidth-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.bitwidth</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bitwidth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the bitwidth of an integer type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L132-L136" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.block-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.block-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.block</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the block that owns this operation, returning null if the operation is not owned.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L56-L60" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.block_arg_num-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.IR.block_arg_num-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.IR.block_arg_num</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">block_arg_num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the position of the value in the argument list of its block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Value.jl#L69-L73" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.block_owner-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.IR.block_owner-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.IR.block_owner</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">block_owner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the block in which this value is defined as an argument. Asserts if the value is not a block argument.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Value.jl#L35-L39" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.body-Tuple{Any}" href="#Reactant.MLIR.IR.body-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.body</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Gets the body of the module, i.e. the only block it contains.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Module.jl#L43-L47" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.compose-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineMap}" href="#Reactant.MLIR.IR.compose-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Reactant.MLIR.IR.compose</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, affineMap)</span></span></code></pre></div><p>Composes the given map with the given expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L27-L31" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.constraint-Tuple{Reactant.MLIR.IR.IntegerSet, Any}" href="#Reactant.MLIR.IR.constraint-Tuple{Reactant.MLIR.IR.IntegerSet, Any}"><span class="jlbinding">Reactant.MLIR.IR.constraint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetConstraint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, i)</span></span></code></pre></div><p>Returns <code>i</code>-th constraint of the set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L116-L120" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.context</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Gets the context that owns the affine expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L19-L23" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Reactant.MLIR.IR.context</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Gets the context that the given affine map was created with.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L34-L38" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.context</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the context that an attribute was created with.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L29-L33" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Identifier}" href="#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Identifier}"><span class="jlbinding">Reactant.MLIR.IR.context</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ident)</span></span></code></pre></div><p>Returns the context associated with this identifier</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Identifier.jl#L22-L26" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.IntegerSet}" href="#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.IntegerSet}"><span class="jlbinding">Reactant.MLIR.IR.context</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Gets the context in which the given integer set lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L60-L64" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Module}" href="#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Module}"><span class="jlbinding">Reactant.MLIR.IR.context</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Gets the context that a module was created with.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Module.jl#L36-L40" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.context</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the context this operation is associated with.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L28-L32" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.context</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the context that a type was created with.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L27-L31" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.data-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.data-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.data</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the raw data as a string reference. The data remains live as long as the context in which the attribute lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L253-L257" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.data-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.data-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.data</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueTypeGetData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the raw data as a string reference. The data remains live as long as the context in which the type lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L732-L736" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.delete!-Tuple{Reactant.MLIR.IR.SymbolTable, Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.delete!-Tuple{Reactant.MLIR.IR.SymbolTable, Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.delete!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">delete!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symboltable, operation)</span></span></code></pre></div><p>Removes the given operation from the symbol table and erases it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/SymbolTable.jl#L50-L54" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.dynsize-Tuple{}" href="#Reactant.MLIR.IR.dynsize-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.dynsize</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dynsize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the value indicating a dynamic size in a shaped type. Prefer <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.IR.isdynsize-Tuple{Any}"><code>isdynsize</code></a> to direct comparisons with this value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L375-L379" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.dynstrideoroffset-Tuple{}" href="#Reactant.MLIR.IR.dynstrideoroffset-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.dynstrideoroffset</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeGetDynamicStrideOrOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the value indicating a dynamic stride or offset in a shaped type. Prefer <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.IR.isdynstrideoroffset-Tuple{Any}"><code>isdynstrideoroffset</code></a> to direct comparisons with this value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L389-L393" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.enable_ir_printing!-Tuple{Any}" href="#Reactant.MLIR.IR.enable_ir_printing!-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.enable_ir_printing!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enable_ir_printing!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager)</span></span></code></pre></div><p>Enable mlir-print-ir-after-all.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Pass.jl#L38-L42" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.enable_verifier!" href="#Reactant.MLIR.IR.enable_verifier!"><span class="jlbinding">Reactant.MLIR.IR.enable_verifier!</span></a> <span class="VPBadge info jlObjectType jlFunction"><!--[-->Function<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">enable_verifier!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, enable)</span></span></code></pre></div><p>Enable / disable verify-each.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Pass.jl#L57-L61" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.encoding-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.encoding-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.encoding</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">encoding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the &#39;encoding&#39; attribute from the ranked tensor type, returning a <code>nothing</code> if none.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L498-L502" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.erase_argument!-Tuple{Any, Any}" href="#Reactant.MLIR.IR.erase_argument!-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.erase_argument!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">erase_argument!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, i)</span></span></code></pre></div><p>Erase argument <code>i</code> of the block. Returns the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L88-L92" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.failure-Tuple{}" href="#Reactant.MLIR.IR.failure-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.failure</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">failure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a logical result representing a failure.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/LogicalResult.jl#L21-L25" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.first_block-Tuple{Reactant.MLIR.IR.Region}" href="#Reactant.MLIR.IR.first_block-Tuple{Reactant.MLIR.IR.Region}"><span class="jlbinding">Reactant.MLIR.IR.first_block</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">first_block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region)</span></span></code></pre></div><p>Gets the first block in the region.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Region.jl#L73-L77" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.first_op-Tuple{Reactant.MLIR.IR.Block}" href="#Reactant.MLIR.IR.first_op-Tuple{Reactant.MLIR.IR.Block}"><span class="jlbinding">Reactant.MLIR.IR.first_op</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">first_op</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the first operation in the block or <code>nothing</code> if empty.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L101-L105" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.first_use-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.IR.first_use-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.IR.first_use</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">first_use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns an <code>OpOperand</code> representing the first use of the value, or a <code>nothing</code> if there are no uses.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/OpOperand.jl#L12-L16" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.flatsymbol-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.flatsymbol-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.flatsymbol</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flatsymbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the referenced symbol as a string reference. The data remains live as long as the context in which the attribute lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L359-L363" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.hasrank-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.hasrank-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.hasrank</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hasrank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given shaped type is ranked.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L325-L329" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.hasstaticshape-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.hasstaticshape-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.hasstaticshape</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hasstaticshape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given shaped type has a static shape.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L342-L346" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.input-Tuple{Reactant.MLIR.IR.Type, Any}" href="#Reactant.MLIR.IR.input-Tuple{Reactant.MLIR.IR.Type, Any}"><span class="jlbinding">Reactant.MLIR.IR.input</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, i)</span></span></code></pre></div><p>Returns the <code>i</code>-th input type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L689-L693" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.insert_after!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.insert_after!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.insert_after!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert_after!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, reference, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and inserts it after the (non-owned) reference operation in the given block. If the reference is null, prepends the operation. Otherwise, the reference must belong to the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L150-L154" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.insert_after!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}" href="#Reactant.MLIR.IR.insert_after!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}"><span class="jlbinding">Reactant.MLIR.IR.insert_after!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert_after!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, reference, block)</span></span></code></pre></div><p>Takes a block owned by the caller and inserts it after the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, prepends the block to the region.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Region.jl#L57-L61" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.insert_before!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.insert_before!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.insert_before!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert_before!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, reference, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and inserts it before the (non-owned) reference operation in the given block. If the reference is null, appends the operation. Otherwise, the reference must belong to the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L160-L164" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.insert_before!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}" href="#Reactant.MLIR.IR.insert_before!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}"><span class="jlbinding">Reactant.MLIR.IR.insert_before!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">insert_before!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, reference, block)</span></span></code></pre></div><p>Takes a block owned by the caller and inserts it before the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, appends the block to the region.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Region.jl#L65-L69" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.is_block_arg-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.IR.is_block_arg-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.IR.is_block_arg</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_block_arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns 1 if the value is a block argument, 0 otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Value.jl#L21-L25" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.is_op_res-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.IR.is_op_res-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.IR.is_op_res</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_op_res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns 1 if the value is an operation result, 0 otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Value.jl#L28-L32" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.is_pure_affine-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.is_pure_affine-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.is_pure_affine</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_pure_affine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a pure affine expression, i.e. mul, floordiv, ceildic, and mod is only allowed w.r.t constants.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L33-L37" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.is_registered-Tuple{Any}" href="#Reactant.MLIR.IR.is_registered-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.is_registered</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_registered</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name; context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Returns whether the given fully-qualified operation (i.e. &#39;dialect.operation&#39;) is registered with the context. This will return true if the dialect is loaded and the operation is registered within the dialect.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L275-L280" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.is_symbolic_or_constant-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.is_symbolic_or_constant-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.is_symbolic_or_constant</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_symbolic_or_constant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is made out of only symbols and constants.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L26-L30" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isadd-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.isadd-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.isadd</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isadd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an add expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L136-L140" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isaffinemap-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.isaffinemap-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.isaffinemap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isaffinemap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an affine map attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L50-L54" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isarray-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.isarray-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.isarray</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isarray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an array attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L71-L75" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isbf16-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isbf16-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isbf16</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isbf16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a bf16 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L274-L278" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isbinary-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.isbinary-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.isbinary</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isbinary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is binary.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L211-L215" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isbool-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.isbool-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.isbool</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isbool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a bool attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L196-L200" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isceildiv-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.isceildiv-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.isceildiv</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isceildiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an ceildiv expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L196-L200" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.iscomplex-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.iscomplex-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.iscomplex</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">iscomplex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Complex type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L310-L314" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isconstantexpr-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.isconstantexpr-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.isconstantexpr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isconstantexpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a constant expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L111-L115" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isconstrainteq-Tuple{Reactant.MLIR.IR.IntegerSet, Any}" href="#Reactant.MLIR.IR.isconstrainteq-Tuple{Reactant.MLIR.IR.IntegerSet, Any}"><span class="jlbinding">Reactant.MLIR.IR.isconstrainteq</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetIsConstraintEq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, i)</span></span></code></pre></div><p>Returns <code>true</code> of the <code>i</code>-th constraint of the set is an equality constraint, <code>false</code> otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L123-L127" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isdenseelements-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.isdenseelements-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.isdenseelements</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isdenseelements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a dense elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L414-L418" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isdict-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.isdict-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.isdict</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isdict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a dictionary attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L86-L90" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isdimexpr-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.isdimexpr-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.isdimexpr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isdimexpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a dimension expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L62-L66" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isdyndim-Tuple{Reactant.MLIR.IR.Type, Int64}" href="#Reactant.MLIR.IR.isdyndim-Tuple{Reactant.MLIR.IR.Type, Int64}"><span class="jlbinding">Reactant.MLIR.IR.isdyndim</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isdyndim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, i)</span></span></code></pre></div><p>Checks wither the <code>i</code>-th dimension of the given shaped type is dynamic.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L349-L353" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isdynsize-Tuple{Any}" href="#Reactant.MLIR.IR.isdynsize-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.isdynsize</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isdynsize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size)</span></span></code></pre></div><p>Checks whether the given value is used as a placeholder for dynamic sizes in shaped types.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L368-L372" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isdynstrideoroffset-Tuple{Any}" href="#Reactant.MLIR.IR.isdynstrideoroffset-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.isdynstrideoroffset</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeIsDynamicStrideOrOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val)</span></span></code></pre></div><p>Checks whether the given value is used as a placeholder for dynamic strides and offsets in shaped types.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L382-L386" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.iselements-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.iselements-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.iselements</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">iselements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L404-L408" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isempty-Tuple{Reactant.MLIR.IR.IntegerSet}" href="#Reactant.MLIR.IR.isempty-Tuple{Reactant.MLIR.IR.IntegerSet}"><span class="jlbinding">Reactant.MLIR.IR.isempty</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isempty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Checks whether the given set is a canonical empty set, e.g., the set returned by <a href="./@ref"><code>mlirIntegerSetEmptyGet</code></a>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L67-L71" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isf16-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isf16-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isf16</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f16 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L281-L285" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isf32-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isf32-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isf32</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f32 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L288-L292" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isf64-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isf64-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isf64</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f64 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L295-L299" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isf8e4m3b11fnuz-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isf8e4m3b11fnuz-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isf8e4m3b11fnuz</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf8e4m3b11fnuz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3B11FNUZ type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L253-L257" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isf8e4m3fn-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isf8e4m3fn-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isf8e4m3fn</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf8e4m3fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3FN type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L246-L250" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isf8e4m3fnuz-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isf8e4m3fnuz-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isf8e4m3fnuz</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf8e4m3fnuz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3FNUZ type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L267-L271" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isf8e5m2-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isf8e5m2-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isf8e5m2</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf8e5m2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E5M2 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L239-L243" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isf8e5m2fnuz-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isf8e5m2fnuz-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isf8e5m2fnuz</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isf8e5m2fnuz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E5M2FNUZ type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L260-L264" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isfailure-Tuple{Reactant.MLIR.IR.LogicalResult}" href="#Reactant.MLIR.IR.isfailure-Tuple{Reactant.MLIR.IR.LogicalResult}"><span class="jlbinding">Reactant.MLIR.IR.isfailure</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isfailure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res)</span></span></code></pre></div><p>Checks if the given logical result represents a failure.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/LogicalResult.jl#L35-L39" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isflatsymbolref-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.isflatsymbolref-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.isflatsymbolref</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isflatsymbolref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a flat symbol reference attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L344-L348" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isfloat-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.isfloat-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.isfloat</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isfloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a floating point attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L103-L107" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isfloordiv-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.isfloordiv-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.isfloordiv</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isfloordiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an floordiv expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L178-L182" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isfunction-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isfunction-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isfunction</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isfunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a function type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L646-L650" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isfunctionofdimexpr-Tuple{Reactant.MLIR.IR.AffineExpr, Any}" href="#Reactant.MLIR.IR.isfunctionofdimexpr-Tuple{Reactant.MLIR.IR.AffineExpr, Any}"><span class="jlbinding">Reactant.MLIR.IR.isfunctionofdimexpr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isfunctionofdimexpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, position)</span></span></code></pre></div><p>Checks whether the given affine expression involves AffineDimExpr &#39;position&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L54-L58" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isidentity-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Reactant.MLIR.IR.isidentity-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Reactant.MLIR.IR.isidentity</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isidentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is an identity affine map. The function asserts that the number of dimensions is greater or equal to the number of results.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L100-L104" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isindex-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isindex-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isindex</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isindex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an index type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L64-L68" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isinteger-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.isinteger-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.isinteger</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isinteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an integer attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L159-L163" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isinteger-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isinteger-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isinteger</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isinteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an integer type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L104-L108" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isintegerset-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.isintegerset-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.isintegerset</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isintegerset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an integer set attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L220-L224" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.ismemref-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.ismemref-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.ismemref</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ismemref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a MemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L574-L578" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isminoridentity-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Reactant.MLIR.IR.isminoridentity-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Reactant.MLIR.IR.isminoridentity</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isminoridentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is a minor identity affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L107-L111" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.ismod-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.ismod-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.ismod</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ismod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an mod expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L164-L168" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.ismul-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.ismul-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.ismul</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ismul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an mul expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L150-L154" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.ismultipleof-Tuple{Reactant.MLIR.IR.AffineExpr, Any}" href="#Reactant.MLIR.IR.ismultipleof-Tuple{Reactant.MLIR.IR.AffineExpr, Any}"><span class="jlbinding">Reactant.MLIR.IR.ismultipleof</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ismultipleof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, factor)</span></span></code></pre></div><p>Checks whether the given affine expression is a multiple of &#39;factor&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L47-L51" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isnone-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isnone-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isnone</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsANone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a None type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L49-L53" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isopaque-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.isopaque-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.isopaque</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isopaque</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an opaque attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L227-L231" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isopaque-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isopaque-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isopaque</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isopaque</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an opaque type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L718-L722" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isprojperm-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Reactant.MLIR.IR.isprojperm-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Reactant.MLIR.IR.isprojperm</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isprojperm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map represents a subset of a symbol-less permutation map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L173-L177" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isrankedtensor-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isrankedtensor-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isrankedtensor</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isrankedtensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a ranked tensor type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L484-L488" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isshaped-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isshaped-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isshaped</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isshaped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Shaped type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L318-L322" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.issigned-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.issigned-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.issigned</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given integer type is signed.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L111-L115" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.issignless-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.issignless-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.issignless</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issignless</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given integer type is signless.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L118-L122" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.issingleconstant-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Reactant.MLIR.IR.issingleconstant-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Reactant.MLIR.IR.issingleconstant</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issingleconstant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is a single result constant affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L121-L125" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.issparseelements-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.issparseelements-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.issparseelements</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issparseelements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a sparse elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L660-L664" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.issplat-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.issplat-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.issplat</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issplat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given dense elements attribute contains a single replicated value (splat).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L648-L652" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isstring-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.isstring-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.isstring</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isstring</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a string attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L263-L267" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.issuccess-Tuple{Reactant.MLIR.IR.LogicalResult}" href="#Reactant.MLIR.IR.issuccess-Tuple{Reactant.MLIR.IR.LogicalResult}"><span class="jlbinding">Reactant.MLIR.IR.issuccess</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issuccess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res)</span></span></code></pre></div><p>Checks if the given logical result represents a success.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/LogicalResult.jl#L28-L32" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.issymbolexpr-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.issymbolexpr-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.issymbolexpr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issymbolexpr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a symbol expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L77-L81" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.issymbolref-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.issymbolref-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.issymbolref</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">issymbolref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a symbol reference attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L297-L301" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.istensor-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.istensor-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.istensor</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">istensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Tensor type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L477-L481" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.istuple-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.istuple-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.istuple</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">istuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a tuple type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L638-L642" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.istype-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.istype-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.istype</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">istype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a type attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L369-L373" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isunit-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.isunit-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.isunit</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isunit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a unit attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L390-L394" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isunrankedmemref-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isunrankedmemref-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isunrankedmemref</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAUnrankedMemRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an UnrankedMemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L581-L585" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isunrankedtensor-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isunrankedtensor-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isunrankedtensor</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isunrankedtensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an unranked tensor type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L491-L495" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isunsigned-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isunsigned-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isunsigned</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isunsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given integer type is unsigned.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L125-L129" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.isvector-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.isvector-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.isvector</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isvector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Vector type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L415-L419" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.layout-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.layout-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.layout</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">layout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the layout of the given MemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L588-L592" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.leafref-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.leafref-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.leafref</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">leafref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the string reference to the leaf referenced symbol. The data remains live as long as the context in which the attribute lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L324-L328" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.lhs-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.lhs-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.lhs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the left hand side affine expression of the given affine binary operation expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L218-L222" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.location-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.location-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.location</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the location of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L35-L39" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.lookup-Tuple{Reactant.MLIR.IR.ExecutionEngine, String}" href="#Reactant.MLIR.IR.lookup-Tuple{Reactant.MLIR.IR.ExecutionEngine, String}"><span class="jlbinding">Reactant.MLIR.IR.lookup</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lookup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit, name)</span></span></code></pre></div><p>Lookup a native function in the execution engine by name, returns nullptr if the name can&#39;t be looked-up.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/ExecutionEngine.jl#L38-L42" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.lookup-Tuple{Reactant.MLIR.IR.SymbolTable, AbstractString}" href="#Reactant.MLIR.IR.lookup-Tuple{Reactant.MLIR.IR.SymbolTable, AbstractString}"><span class="jlbinding">Reactant.MLIR.IR.lookup</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lookup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symboltable, name)</span></span></code></pre></div><p>Looks up a symbol with the given name in the given symbol table and returns the operation that corresponds to the symbol. If the symbol cannot be found, returns a null operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/SymbolTable.jl#L22-L27" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.majorsubmap-Tuple{Reactant.MLIR.IR.AffineMap, Any}" href="#Reactant.MLIR.IR.majorsubmap-Tuple{Reactant.MLIR.IR.AffineMap, Any}"><span class="jlbinding">Reactant.MLIR.IR.majorsubmap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">majorsubmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, nresults)</span></span></code></pre></div><p>Returns the affine map consisting of the most major <code>nresults</code> results. Returns the null AffineMap if the <code>nresults</code> is equal to zero. Returns the <code>affineMap</code> if <code>nresults</code> is greater or equals to number of results of the given affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L195-L201" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.memspace-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.memspace-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.memspace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetMemorySpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the memory space of the given MemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L608-L612" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.minorsubmap-Tuple{Reactant.MLIR.IR.AffineMap, Any}" href="#Reactant.MLIR.IR.minorsubmap-Tuple{Reactant.MLIR.IR.AffineMap, Any}"><span class="jlbinding">Reactant.MLIR.IR.minorsubmap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">minorsubmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, nresults)</span></span></code></pre></div><p>Returns the affine map consisting of the most minor <code>nresults</code> results. Returns the null AffineMap if the <code>nresults</code> is equal to zero. Returns the <code>affineMap</code> if <code>nresults</code> is greater or equals to number of results of the given affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L205-L210" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.move_after!-Tuple{Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.move_after!-Tuple{Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.move_after!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">move_after!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, other)</span></span></code></pre></div><p>Moves the given operation immediately after the other operation in its parent block. The given operation may be owned by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L252-L256" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.move_before!-Tuple{Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.move_before!-Tuple{Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.move_before!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">move_before!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, other)</span></span></code></pre></div><p>Moves the given operation immediately before the other operation in its parent block. The given operation may be owner by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L262-L269" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.name-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.name-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.name</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the name of the operation as an identifier.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L49-L53" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.namespace-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.namespace-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.namespace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueAttrGetDialectNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the namespace of the dialect with which the given opaque attribute is associated. The namespace string is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L243-L247" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.namespace-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.namespace-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.namespace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueTypeGetDialectNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the namespace of the dialect with which the given opaque type is associated. The namespace string is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L725-L729" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.nargs-Tuple{Reactant.MLIR.IR.Block}" href="#Reactant.MLIR.IR.nargs-Tuple{Reactant.MLIR.IR.Block}"><span class="jlbinding">Reactant.MLIR.IR.nargs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nargs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the number of arguments of the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L63-L67" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.nattrs-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.nattrs-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.nattrs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nattrs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of attributes attached to the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L172-L176" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.nconstraints-Tuple{Reactant.MLIR.IR.IntegerSet}" href="#Reactant.MLIR.IR.nconstraints-Tuple{Reactant.MLIR.IR.IntegerSet}"><span class="jlbinding">Reactant.MLIR.IR.nconstraints</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nconstraints</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of constraints (equalities + inequalities) in the given set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L95-L99" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.nequalities-Tuple{Reactant.MLIR.IR.IntegerSet}" href="#Reactant.MLIR.IR.nequalities-Tuple{Reactant.MLIR.IR.IntegerSet}"><span class="jlbinding">Reactant.MLIR.IR.nequalities</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nequalities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of equalities in the given set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L102-L106" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.next-Tuple{Reactant.MLIR.IR.Block}" href="#Reactant.MLIR.IR.next-Tuple{Reactant.MLIR.IR.Block}"><span class="jlbinding">Reactant.MLIR.IR.next</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the block immediately following the given block in its parent region or <code>nothing</code> if last.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L52-L56" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.next-Tuple{Reactant.MLIR.IR.OpOperand}" href="#Reactant.MLIR.IR.next-Tuple{Reactant.MLIR.IR.OpOperand}"><span class="jlbinding">Reactant.MLIR.IR.next</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns an op operand representing the next use of the value, or <code>nothing</code> if there is no next use.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/OpOperand.jl#L37-L41" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.ninequalities-Tuple{Reactant.MLIR.IR.IntegerSet}" href="#Reactant.MLIR.IR.ninequalities-Tuple{Reactant.MLIR.IR.IntegerSet}"><span class="jlbinding">Reactant.MLIR.IR.ninequalities</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ninequalities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of inequalities in the given set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L109-L113" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Reactant.MLIR.IR.ninputs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ninputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of inputs (dimensions + symbols) of the given affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L166-L170" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.IntegerSet}" href="#Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.IntegerSet}"><span class="jlbinding">Reactant.MLIR.IR.ninputs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ninputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of inputs (dimensions + symbols) in the given set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L88-L92" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.ninputs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ninputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of input types.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L669-L673" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.nnestedrefs-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.nnestedrefs-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.nnestedrefs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nnestedrefs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the number of references nested in the given symbol reference attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L334-L338" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.noperands-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.noperands-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.noperands</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">noperands</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of operands of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L120-L124" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.nregions-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.nregions-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.nregions</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nregions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of regions attached to the given operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L85-L89" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Reactant.MLIR.IR.nresults</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nresults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of results of the given affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L152-L156" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.nresults</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nresults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of results of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L102-L106" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.nresults</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nresults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of result types.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L679-L683" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.nsuccessors-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.nsuccessors-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.nsuccessors</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nsuccessors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of successor blocks of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L155-L159" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.nsymbols-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Reactant.MLIR.IR.nsymbols-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Reactant.MLIR.IR.nsymbols</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nsymbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of symbols of the given affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L145-L149" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.nsymbols-Tuple{Reactant.MLIR.IR.IntegerSet}" href="#Reactant.MLIR.IR.nsymbols-Tuple{Reactant.MLIR.IR.IntegerSet}"><span class="jlbinding">Reactant.MLIR.IR.nsymbols</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nsymbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of symbols in the given set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IntegerSet.jl#L81-L85" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.op_owner-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.IR.op_owner-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.IR.op_owner</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">op_owner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns an operation that produced this value as its result. Asserts if the value is not an op result.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Value.jl#L45-L49" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.op_res_num-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.IR.op_res_num-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.IR.op_res_num</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">op_res_num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the position of the value in the list of results of the operation that produced it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Value.jl#L79-L83" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.operand" href="#Reactant.MLIR.IR.operand"><span class="jlbinding">Reactant.MLIR.IR.operand</span></a> <span class="VPBadge info jlObjectType jlFunction"><!--[-->Function<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">operand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, i)</span></span></code></pre></div><p>Returns <code>i</code>-th operand of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L127-L131" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.operand!-Tuple{Reactant.MLIR.IR.Operation, Any, Any}" href="#Reactant.MLIR.IR.operand!-Tuple{Reactant.MLIR.IR.Operation, Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.operand!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">operand!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, i, value)</span></span></code></pre></div><p>Sets the <code>i</code>-th operand of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L144-L148" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.operandindex-Tuple{Reactant.MLIR.IR.OpOperand}" href="#Reactant.MLIR.IR.operandindex-Tuple{Reactant.MLIR.IR.OpOperand}"><span class="jlbinding">Reactant.MLIR.IR.operandindex</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">operandindex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns the operand number of an op operand.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/OpOperand.jl#L30-L34" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.operands-Tuple{Any}" href="#Reactant.MLIR.IR.operands-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.operands</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">operands</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Return an array of all operands of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L137-L141" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.owner-Tuple{Reactant.MLIR.IR.OpOperand}" href="#Reactant.MLIR.IR.owner-Tuple{Reactant.MLIR.IR.OpOperand}"><span class="jlbinding">Reactant.MLIR.IR.owner</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">owner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns the owner operation of an op operand.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/OpOperand.jl#L23-L27" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.parent_op-Tuple{Reactant.MLIR.IR.Block}" href="#Reactant.MLIR.IR.parent_op-Tuple{Reactant.MLIR.IR.Block}"><span class="jlbinding">Reactant.MLIR.IR.parent_op</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parent_op</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the closest surrounding operation that contains this block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L36-L40" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.parent_op-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.parent_op-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.parent_op</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parent_op</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the operation that owns this operation, returning null if the operation is not owned.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L63-L67" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.parent_region-Tuple{Reactant.MLIR.IR.Block}" href="#Reactant.MLIR.IR.parent_region-Tuple{Reactant.MLIR.IR.Block}"><span class="jlbinding">Reactant.MLIR.IR.parent_region</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parent_region</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the region that contains this block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L43-L47" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.position-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.position-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.position</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">position</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the position of the given affine dimension expression, affine symbol expression or ...</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L92-L96" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.push_argument!-Tuple{Reactant.MLIR.IR.Block, Any}" href="#Reactant.MLIR.IR.push_argument!-Tuple{Reactant.MLIR.IR.Block, Any}"><span class="jlbinding">Reactant.MLIR.IR.push_argument!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">push_argument!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, type; location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Appends an argument of the specified type to the block. Returns the newly added argument.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L80-L84" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.region-Tuple{Reactant.MLIR.IR.Operation, Any}" href="#Reactant.MLIR.IR.region-Tuple{Reactant.MLIR.IR.Operation, Any}"><span class="jlbinding">Reactant.MLIR.IR.region</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">region</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, i)</span></span></code></pre></div><p>Returns <code>i</code>-th region attached to the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L92-L96" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.result" href="#Reactant.MLIR.IR.result"><span class="jlbinding">Reactant.MLIR.IR.result</span></a> <span class="VPBadge info jlObjectType jlFunction"><!--[-->Function<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, i)</span></span></code></pre></div><p>Returns <code>i</code>-th result of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L109-L113" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.result-2" href="#Reactant.MLIR.IR.result-2"><span class="jlbinding">Reactant.MLIR.IR.result</span></a> <span class="VPBadge info jlObjectType jlFunction"><!--[-->Function<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, i)</span></span></code></pre></div><p>Returns the <code>i</code>-th result type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L699-L703" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.result-Tuple{Reactant.MLIR.IR.AffineMap, Any}" href="#Reactant.MLIR.IR.result-Tuple{Reactant.MLIR.IR.AffineMap, Any}"><span class="jlbinding">Reactant.MLIR.IR.result</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, pos)</span></span></code></pre></div><p>Returns the result at the given position.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L159-L163" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.result-Tuple{Reactant.MLIR.IR.AffineMap}" href="#Reactant.MLIR.IR.result-Tuple{Reactant.MLIR.IR.AffineMap}"><span class="jlbinding">Reactant.MLIR.IR.result</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the constant result of the given affine map. The function asserts that the map has a single constant result.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L128-L132" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.rhs-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.rhs-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.rhs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rhs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the right hand side affine expression of the given affine binary operation expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L225-L229" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.rmattr!-Tuple{Reactant.MLIR.IR.Operation, Any}" href="#Reactant.MLIR.IR.rmattr!-Tuple{Reactant.MLIR.IR.Operation, Any}"><span class="jlbinding">Reactant.MLIR.IR.rmattr!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rmattr!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Removes an attribute by name. Returns false if the attribute was not found and true if removed.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L212-L216" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.rmfromparent!-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.rmfromparent!-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.rmfromparent!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rmfromparent!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Removes the given operation from its parent block. The operation is not destroyed. The ownership of the operation is transferred to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L71-L76" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.rootref-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.rootref-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.rootref</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rootref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the string reference to the root referenced symbol. The data remains live as long as the context in which the attribute lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L314-L318" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.run!-Tuple{Reactant.MLIR.IR.PassManager, Reactant.MLIR.IR.Module}" href="#Reactant.MLIR.IR.run!-Tuple{Reactant.MLIR.IR.PassManager, Reactant.MLIR.IR.Module}"><span class="jlbinding">Reactant.MLIR.IR.run!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">run!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Run the provided <code>passManager</code> on the given <code>module</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Pass.jl#L67-L71" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.submap-Tuple{Reactant.MLIR.IR.AffineMap, Vector{Int64}}" href="#Reactant.MLIR.IR.submap-Tuple{Reactant.MLIR.IR.AffineMap, Vector{Int64}}"><span class="jlbinding">Reactant.MLIR.IR.submap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">submap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, positions)</span></span></code></pre></div><p>Returns the affine map consisting of the <code>positions</code> subset.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L187-L191" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.success-Tuple{}" href="#Reactant.MLIR.IR.success-Tuple{}"><span class="jlbinding">Reactant.MLIR.IR.success</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">success</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a logical result representing a success.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/LogicalResult.jl#L14-L18" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.successor-Tuple{Reactant.MLIR.IR.Operation, Any}" href="#Reactant.MLIR.IR.successor-Tuple{Reactant.MLIR.IR.Operation, Any}"><span class="jlbinding">Reactant.MLIR.IR.successor</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">successor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, i)</span></span></code></pre></div><p>Returns <code>i</code>-th successor of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L162-L166" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.terminator-Tuple{Reactant.MLIR.IR.Block}" href="#Reactant.MLIR.IR.terminator-Tuple{Reactant.MLIR.IR.Block}"><span class="jlbinding">Reactant.MLIR.IR.terminator</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">terminator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the terminator operation in the block or <code>nothing</code> if no terminator.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Block.jl#L113-L117" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.type!-Tuple{Any, Any}" href="#Reactant.MLIR.IR.type!-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.IR.type!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_type!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, type)</span></span></code></pre></div><p>Sets the type of the block argument to the given type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Value.jl#L106-L110" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.type-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.type-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the type of this attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L36-L40" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.type-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.IR.type-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.IR.type</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the type of the value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Value.jl#L99-L103" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Attribute}" href="#Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Attribute}"><span class="jlbinding">Reactant.MLIR.IR.typeid</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">typeid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the type id of the attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Attribute.jl#L43-L47" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.typeid</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">typeid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the type id of the operation. Returns null if the operation does not have a registered operation description.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L42-L46" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Type}" href="#Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Type}"><span class="jlbinding">Reactant.MLIR.IR.typeid</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">typeid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the type ID of the type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Type.jl#L34-L38" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.value-Tuple{Reactant.MLIR.IR.AffineExpr}" href="#Reactant.MLIR.IR.value-Tuple{Reactant.MLIR.IR.AffineExpr}"><span class="jlbinding">Reactant.MLIR.IR.value</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the value of the given affine constant expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineExpr.jl#L126-L130" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.verify-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.verify-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.verify</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">verify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Verify the operation and return true if it passes, false if it fails.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/Operation.jl#L245-L249" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.verifyall-Tuple{Reactant.MLIR.IR.Operation}" href="#Reactant.MLIR.IR.verifyall-Tuple{Reactant.MLIR.IR.Operation}"><span class="jlbinding">Reactant.MLIR.IR.verifyall</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">verifyall</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(operation; debug</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Prints the operations which could not be verified.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/IR.jl#L115-L119" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.IR.@affinemap-Tuple{Any}" href="#Reactant.MLIR.IR.@affinemap-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.IR.@affinemap</span></a> <span class="VPBadge info jlObjectType jlMacro"><!--[-->Macro<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@affinemap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (d1, d2, d3, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[s1, s2, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (d0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d1, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Returns an affine map from the provided Julia expression. On the right hand side are allowed the following function calls:</p><ul><li>+, *, Ã·, %, fld, cld</li></ul><p>The rhs can only contains dimensions and symbols present on the left hand side or integer literals.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Reactant</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MLIR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> IR</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">julia</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> IR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">context!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(IR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           IR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@affinemap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (d1, d2)[s0] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (d1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s0, d2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       end</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MLIR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">IR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#= (d0, d1)[s0] -&gt; (d0 + s0, d1 mod 10) =#</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/IR/AffineMap.jl#L249-L267" target="_blank" rel="noreferrer">source</a><!--]--></span></details><h1 id="MLIR-C-API" tabindex="-1">MLIR C API <a class="header-anchor" href="#MLIR-C-API" aria-label="Permalink to &quot;MLIR C API {#MLIR-C-API}&quot;">â€‹</a></h1><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMAttributeRef" href="#Reactant.MLIR.API.LLVMAttributeRef"><span class="jlbinding">Reactant.MLIR.API.LLVMAttributeRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Used to represent an attributes.</p><p><strong>See also</strong></p><p>llvm::Attribute</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9018-L9023" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMBasicBlockRef" href="#Reactant.MLIR.API.LLVMBasicBlockRef"><span class="jlbinding">Reactant.MLIR.API.LLVMBasicBlockRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Represents a basic block of instructions in LLVM IR.</p><p>This models llvm::BasicBlock.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8931-L8935" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMBinaryRef" href="#Reactant.MLIR.API.LLVMBinaryRef"><span class="jlbinding">Reactant.MLIR.API.LLVMBinaryRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p><strong>See also</strong></p><p>llvm::object::Binary</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9060-L9063" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMBool" href="#Reactant.MLIR.API.LLVMBool"><span class="jlbinding">Reactant.MLIR.API.LLVMBool</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p><code>LLVMCSupportTypes Types and Enumerations</code></p><p>@{</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8876-L8880" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMBuilderRef" href="#Reactant.MLIR.API.LLVMBuilderRef"><span class="jlbinding">Reactant.MLIR.API.LLVMBuilderRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Represents an LLVM basic block builder.</p><p>This models llvm::IRBuilder.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8967-L8971" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMComdatRef" href="#Reactant.MLIR.API.LLVMComdatRef"><span class="jlbinding">Reactant.MLIR.API.LLVMComdatRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p><strong>See also</strong></p><p>llvm::Comdat</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9036-L9039" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMContextRef" href="#Reactant.MLIR.API.LLVMContextRef"><span class="jlbinding">Reactant.MLIR.API.LLVMContextRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>The top-level container for all LLVM global data. See the LLVMContext class.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8895-L8897" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMDIBuilderRef" href="#Reactant.MLIR.API.LLVMDIBuilderRef"><span class="jlbinding">Reactant.MLIR.API.LLVMDIBuilderRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Represents an LLVM debug info builder.</p><p>This models llvm::DIBuilder.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8976-L8980" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMDbgRecordRef" href="#Reactant.MLIR.API.LLVMDbgRecordRef"><span class="jlbinding">Reactant.MLIR.API.LLVMDbgRecordRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p><strong>See also</strong></p><p>llvm::DbgRecord</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9068-L9071" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMDiagnosticInfoRef" href="#Reactant.MLIR.API.LLVMDiagnosticInfoRef"><span class="jlbinding">Reactant.MLIR.API.LLVMDiagnosticInfoRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p><strong>See also</strong></p><p>llvm::DiagnosticInfo</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9028-L9031" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMJITEventListenerRef" href="#Reactant.MLIR.API.LLVMJITEventListenerRef"><span class="jlbinding">Reactant.MLIR.API.LLVMJITEventListenerRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p><strong>See also</strong></p><p>llvm::JITEventListener</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9052-L9055" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMMemoryBufferRef" href="#Reactant.MLIR.API.LLVMMemoryBufferRef"><span class="jlbinding">Reactant.MLIR.API.LLVMMemoryBufferRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Used to pass regions of memory through LLVM interfaces.</p><p><strong>See also</strong></p><p>llvm::MemoryBuffer</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8885-L8890" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMMetadataRef" href="#Reactant.MLIR.API.LLVMMetadataRef"><span class="jlbinding">Reactant.MLIR.API.LLVMMetadataRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Represents an LLVM Metadata.</p><p>This models llvm::Metadata.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8940-L8944" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMModuleFlagEntry" href="#Reactant.MLIR.API.LLVMModuleFlagEntry"><span class="jlbinding">Reactant.MLIR.API.LLVMModuleFlagEntry</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p><strong>See also</strong></p><p>llvm::Module::ModuleFlagEntry</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9044-L9047" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMModuleProviderRef" href="#Reactant.MLIR.API.LLVMModuleProviderRef"><span class="jlbinding">Reactant.MLIR.API.LLVMModuleProviderRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Interface used to provide a module to JIT or interpreter. This is now just a synonym for llvm::Module, but we have to keep using the different type to keep binary compatibility.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8985-L8987" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMModuleRef" href="#Reactant.MLIR.API.LLVMModuleRef"><span class="jlbinding">Reactant.MLIR.API.LLVMModuleRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>The top-level container for all other LLVM Intermediate Representation (IR) objects.</p><p><strong>See also</strong></p><p>llvm::Module</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8902-L8907" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMNamedMDNodeRef" href="#Reactant.MLIR.API.LLVMNamedMDNodeRef"><span class="jlbinding">Reactant.MLIR.API.LLVMNamedMDNodeRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Represents an LLVM Named Metadata Node.</p><p>This models llvm::NamedMDNode.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8949-L8953" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMOperandBundleRef" href="#Reactant.MLIR.API.LLVMOperandBundleRef"><span class="jlbinding">Reactant.MLIR.API.LLVMOperandBundleRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p><strong>See also</strong></p><p>llvm::OperandBundleDef</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9010-L9013" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMPassManagerRef" href="#Reactant.MLIR.API.LLVMPassManagerRef"><span class="jlbinding">Reactant.MLIR.API.LLVMPassManagerRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p><strong>See also</strong></p><p>llvm::PassManagerBase</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8992-L8995" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMTypeRef" href="#Reactant.MLIR.API.LLVMTypeRef"><span class="jlbinding">Reactant.MLIR.API.LLVMTypeRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Each value in the LLVM IR has a type, an <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.LLVMTypeRef"><code>LLVMTypeRef</code></a>.</p><p><strong>See also</strong></p><p>llvm::Type</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8912-L8917" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMUseRef" href="#Reactant.MLIR.API.LLVMUseRef"><span class="jlbinding">Reactant.MLIR.API.LLVMUseRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Used to get the users and usees of a Value.</p><p><strong>See also</strong></p><p>llvm::Use</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9000-L9005" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMValueMetadataEntry" href="#Reactant.MLIR.API.LLVMValueMetadataEntry"><span class="jlbinding">Reactant.MLIR.API.LLVMValueMetadataEntry</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Represents an entry in a Global Object&#39;s metadata attachments.</p><p>This models std::pair&lt;unsigned, MDNode *&gt;</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8958-L8962" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMValueRef" href="#Reactant.MLIR.API.LLVMValueRef"><span class="jlbinding">Reactant.MLIR.API.LLVMValueRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Represents an individual value in LLVM IR.</p><p>This models llvm::Value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8922-L8926" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirDiagnostic" href="#Reactant.MLIR.API.MlirDiagnostic"><span class="jlbinding">Reactant.MLIR.API.MlirDiagnostic</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirDiagnostic</span></span></code></pre></div><p>An opaque reference to a diagnostic, always owned by the diagnostics engine (context). Must not be stored outside of the diagnostic handler.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5876-L5880" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirDiagnosticHandler" href="#Reactant.MLIR.API.MlirDiagnosticHandler"><span class="jlbinding">Reactant.MLIR.API.MlirDiagnosticHandler</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Diagnostic handler type. Accepts a reference to a diagnostic, which is only guaranteed to be live during the call. The handler is passed the <code>userData</code> that was provided when the handler was attached to a context. If the handler processed the diagnostic completely, it is expected to return success. Otherwise, it is expected to return failure to indicate that other handlers should attempt to process the diagnostic.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5903-L5905" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirDiagnosticHandlerID" href="#Reactant.MLIR.API.MlirDiagnosticHandlerID"><span class="jlbinding">Reactant.MLIR.API.MlirDiagnosticHandlerID</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Opaque identifier of a diagnostic handler, useful to detach a handler.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5897-L5899" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirDiagnosticSeverity" href="#Reactant.MLIR.API.MlirDiagnosticSeverity"><span class="jlbinding">Reactant.MLIR.API.MlirDiagnosticSeverity</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirDiagnosticSeverity</span></span></code></pre></div><p>Severity of a diagnostic.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5885-L5889" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirExternalPassCallbacks" href="#Reactant.MLIR.API.MlirExternalPassCallbacks"><span class="jlbinding">Reactant.MLIR.API.MlirExternalPassCallbacks</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirExternalPassCallbacks</span></span></code></pre></div><p>Structure of external <a href="./@ref"><code>MlirPass</code></a> callbacks. All callbacks are required to be set unless otherwise specified.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Field</th><th style="text-align:left;">Note</th></tr></thead><tbody><tr><td style="text-align:left;">construct</td><td style="text-align:left;">This callback is called from the pass is created. This is analogous to a C++ pass constructor.</td></tr><tr><td style="text-align:left;">destruct</td><td style="text-align:left;">This callback is called when the pass is destroyed This is analogous to a C++ pass destructor.</td></tr><tr><td style="text-align:left;">initialize</td><td style="text-align:left;">This callback is optional. The callback is called before the pass is run, allowing a chance to initialize any complex state necessary for running the pass. See Pass::initialize(MLIRContext *).</td></tr><tr><td style="text-align:left;">clone</td><td style="text-align:left;">This callback is called when the pass is cloned. See Pass::clonePass().</td></tr><tr><td style="text-align:left;">run</td><td style="text-align:left;">This callback is called when the pass is run. See Pass::runOnOperation().</td></tr></tbody></table><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8336-L8348" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirLlvmThreadPool" href="#Reactant.MLIR.API.MlirLlvmThreadPool"><span class="jlbinding">Reactant.MLIR.API.MlirLlvmThreadPool</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirLlvmThreadPool</span></span></code></pre></div><p>Re-export llvm::ThreadPool so as to avoid including the LLVM C API directly.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L48-L52" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirLogicalResult" href="#Reactant.MLIR.API.MlirLogicalResult"><span class="jlbinding">Reactant.MLIR.API.MlirLogicalResult</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirLogicalResult</span></span></code></pre></div><p>A logical result value, essentially a boolean with named states. LLVM convention for using boolean values to designate success or failure of an operation is a moving target, so MLIR opted for an explicit class. Instances of <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.MlirLogicalResult"><code>MlirLogicalResult</code></a> must only be inspected using the associated functions.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L115-L119" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirNamedAttribute" href="#Reactant.MLIR.API.MlirNamedAttribute"><span class="jlbinding">Reactant.MLIR.API.MlirNamedAttribute</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirNamedAttribute</span></span></code></pre></div><p>Named MLIR attribute.</p><p>A named attribute is essentially a (name, attribute) pair where the name is a string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L311-L317" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirOperationState" href="#Reactant.MLIR.API.MlirOperationState"><span class="jlbinding">Reactant.MLIR.API.MlirOperationState</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirOperationState</span></span></code></pre></div><p>An auxiliary class for constructing operations.</p><p>This class contains all the information necessary to construct the operation. It owns the MlirRegions it has pointers to and does not own anything else. By default, the state can be constructed from a name and location, the latter being also used to access the context, and has no other components. These components can be added progressively until the operation is constructed. Users are not expected to rely on the internals of this class and should use mlirOperationState* functions instead.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L799-L805" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirOperationWalkCallback" href="#Reactant.MLIR.API.MlirOperationWalkCallback"><span class="jlbinding">Reactant.MLIR.API.MlirOperationWalkCallback</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Operation walker type. The handler is passed an (opaque) reference to an operation and a pointer to a <code>userData</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1524-L1526" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirShapedTypeComponentsCallback" href="#Reactant.MLIR.API.MlirShapedTypeComponentsCallback"><span class="jlbinding">Reactant.MLIR.API.MlirShapedTypeComponentsCallback</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>These callbacks are used to return multiple shaped type components from functions while transferring ownership to the caller. The first argument is the has rank boolean followed by the the rank and a pointer to the shape (if applicable). The next argument is the element type, then the attribute. The last argument is an opaque pointer forwarded to the callback by the caller. This callback will be called potentially multiple times for each shaped type components.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8101-L8103" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirSparseTensorLevelType" href="#Reactant.MLIR.API.MlirSparseTensorLevelType"><span class="jlbinding">Reactant.MLIR.API.MlirSparseTensorLevelType</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>Dimension level types (and properties) that define sparse tensors. See the documentation in SparseTensorAttrDefs.td for their meaning.</p><p>These correspond to SparseTensorEncodingAttr::LevelType in the C++ API. If updating, keep them in sync and update the static_assert in the impl file.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7585-L7589" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirStringCallback" href="#Reactant.MLIR.API.MlirStringCallback"><span class="jlbinding">Reactant.MLIR.API.MlirStringCallback</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>A callback for returning string references.</p><p>This function is called back by the functions that need to return a reference to the portion of the string with the following arguments: - an <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.MlirStringRef"><code>MlirStringRef</code></a> representing the current portion of the string - a pointer to user data forwarded from the printing call.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L108-L112" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirStringRef" href="#Reactant.MLIR.API.MlirStringRef"><span class="jlbinding">Reactant.MLIR.API.MlirStringRef</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirStringRef</span></span></code></pre></div><p>A pointer to a sized fragment of a string, not necessarily null-terminated. Does not own the underlying string. This is equivalent to llvm::StringRef.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Field</th><th style="text-align:left;">Note</th></tr></thead><tbody><tr><td style="text-align:left;">data</td><td style="text-align:left;">Pointer to the first symbol.</td></tr><tr><td style="text-align:left;">length</td><td style="text-align:left;">Length of the fragment.</td></tr></tbody></table><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L65-L74" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirTypesCallback" href="#Reactant.MLIR.API.MlirTypesCallback"><span class="jlbinding">Reactant.MLIR.API.MlirTypesCallback</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><p>These callbacks are used to return multiple types from functions while transferring ownership to the caller. The first argument is the number of consecutive elements pointed to by the second argument. The third argument is an opaque pointer forwarded to the callback by the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8053-L8055" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirWalkOrder" href="#Reactant.MLIR.API.MlirWalkOrder"><span class="jlbinding">Reactant.MLIR.API.MlirWalkOrder</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirWalkOrder</span></span></code></pre></div><p>Traversal order for operation walk.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1513-L1517" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.MlirWalkResult" href="#Reactant.MLIR.API.MlirWalkResult"><span class="jlbinding">Reactant.MLIR.API.MlirWalkResult</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MlirWalkResult</span></span></code></pre></div><p>Operation walk result.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1502-L1506" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMAddSymbol-Tuple{Any, Any}" href="#Reactant.MLIR.API.LLVMAddSymbol-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.LLVMAddSymbol</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LLVMAddSymbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbolName, symbolValue)</span></span></code></pre></div><p>This functions permanently adds the symbol <code>symbolName</code> with the value <code>symbolValue</code>. These symbols are searched before any libraries.</p><p><strong>See also</strong></p><p>sys::DynamicLibrary::AddSymbol()</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9112-L9119" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMLoadLibraryPermanently-Tuple{Any}" href="#Reactant.MLIR.API.LLVMLoadLibraryPermanently-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.LLVMLoadLibraryPermanently</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LLVMLoadLibraryPermanently</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Filename)</span></span></code></pre></div><p>This function permanently loads the dynamic library at the given path. It is safe to call this function multiple times for the same library.</p><p><strong>See also</strong></p><p>sys::DynamicLibrary::LoadLibraryPermanently()</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9074-L9081" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMParseCommandLineOptions-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.LLVMParseCommandLineOptions-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.LLVMParseCommandLineOptions</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LLVMParseCommandLineOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(argc, argv, Overview)</span></span></code></pre></div><p>This function parses the given arguments using the LLVM command line parser. Note that the only stable thing about this function is its signature; you cannot rely on any particular set of command line arguments being interpreted the same way across LLVM versions.</p><p><strong>See also</strong></p><p>llvm:ðŸ†‘:ParseCommandLineOptions()</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9086-L9093" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.LLVMSearchForAddressOfSymbol-Tuple{Any}" href="#Reactant.MLIR.API.LLVMSearchForAddressOfSymbol-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.LLVMSearchForAddressOfSymbol</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LLVMSearchForAddressOfSymbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbolName)</span></span></code></pre></div><p>This function will search through all previously loaded dynamic libraries for the symbol <code>symbolName</code>. If it is found, the address of that symbol is returned. If not, null is returned.</p><p><strong>See also</strong></p><p>sys::DynamicLibrary::SearchForAddressOfSymbol()</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9100-L9107" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineAddExprGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineAddExprGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineAddExprGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineAddExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine add expression with &#39;lhs&#39; and &#39;rhs&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2583-L2587" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineBinaryOpExprGetLHS-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineBinaryOpExprGetLHS-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineBinaryOpExprGetLHS</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineBinaryOpExprGetLHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the left hand side affine expression of the given affine binary operation expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2683-L2687" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineBinaryOpExprGetRHS-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineBinaryOpExprGetRHS-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineBinaryOpExprGetRHS</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineBinaryOpExprGetRHS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the right hand side affine expression of the given affine binary operation expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2692-L2696" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineCeilDivExprGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineCeilDivExprGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineCeilDivExprGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineCeilDivExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine ceildiv expression with &#39;lhs&#39; and &#39;rhs&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2663-L2667" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineConstantExprGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineConstantExprGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineConstantExprGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineConstantExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, constant)</span></span></code></pre></div><p>Creates an affine constant expression with &#39;constant&#39; in the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2554-L2558" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineConstantExprGetValue-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineConstantExprGetValue-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineConstantExprGetValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineConstantExprGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the value of the given affine constant expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2565-L2569" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineDimExprGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineDimExprGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineDimExprGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineDimExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, position)</span></span></code></pre></div><p>Creates an affine dimension expression with &#39;position&#39; in the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2498-L2502" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineDimExprGetPosition-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineDimExprGetPosition-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineDimExprGetPosition</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineDimExprGetPosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the position of the given affine dimension expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2507-L2511" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprCompose-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineExprCompose-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprCompose</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprCompose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, affineMap)</span></span></code></pre></div><p>Composes the given map with the given expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2478-L2482" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprDump-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprDump-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprDump</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Prints the affine expression to the standard error stream.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2416-L2420" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineExprEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Returns <code>true</code> if the two affine expressions are equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2387-L2391" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprGetContext-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprGetContext-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprGetContext</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Gets the context that owns the affine expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2378-L2382" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprGetLargestKnownDivisor-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprGetLargestKnownDivisor-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprGetLargestKnownDivisor</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprGetLargestKnownDivisor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the greatest known integral divisor of this affine expression. The result is always positive.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2443-L2447" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsAAdd-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprIsAAdd-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsAAdd</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsAAdd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an add expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2574-L2578" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsABinary-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprIsABinary-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsABinary</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsABinary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is binary.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2674-L2678" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsACeilDiv-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprIsACeilDiv-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsACeilDiv</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsACeilDiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an ceildiv expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2654-L2658" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsAConstant-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprIsAConstant-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsAConstant</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsAConstant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a constant expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2545-L2549" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsADim-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprIsADim-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsADim</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsADim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a dimension expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2489-L2493" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsAFloorDiv-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprIsAFloorDiv-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsAFloorDiv</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsAFloorDiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an floordiv expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2634-L2638" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsAMod-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprIsAMod-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsAMod</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsAMod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an mod expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2614-L2618" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsAMul-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprIsAMul-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsAMul</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsAMul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is an mul expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2594-L2598" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsASymbol-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprIsASymbol-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsASymbol</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsASymbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a symbol expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2516-L2520" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsFunctionOfDim-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineExprIsFunctionOfDim-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsFunctionOfDim</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsFunctionOfDim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, position)</span></span></code></pre></div><p>Checks whether the given affine expression involves AffineDimExpr &#39;position&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2463-L2467" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsMultipleOf-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineExprIsMultipleOf-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsMultipleOf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsMultipleOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, factor)</span></span></code></pre></div><p>Checks whether the given affine expression is a multiple of &#39;factor&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2452-L2456" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns <code>true</code> if the given affine expression is a null expression. Note constant zero is not a null expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2396-L2400" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsPureAffine-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprIsPureAffine-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsPureAffine</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsPureAffine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is a pure affine expression, i.e. mul, floordiv, ceildic, and mod is only allowed w.r.t constants.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2434-L2438" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprIsSymbolicOrConstant-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineExprIsSymbolicOrConstant-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprIsSymbolicOrConstant</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprIsSymbolicOrConstant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Checks whether the given affine expression is made out of only symbols and constants.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2425-L2429" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineExprPrint-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirAffineExprPrint-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineExprPrint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineExprPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr, callback, userData)</span></span></code></pre></div><p>Prints an affine expression by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2405-L2409" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineFloorDivExprGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineFloorDivExprGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineFloorDivExprGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineFloorDivExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine floordiv expression with &#39;lhs&#39; and &#39;rhs&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2643-L2647" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapAttrGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapAttrGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(map)</span></span></code></pre></div><p>Creates an affine map attribute wrapping the given map. The attribute belongs to the same context as the affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3201-L3205" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirAffineMapAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an AffineMap attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3219-L3223" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapAttrGetValue-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapAttrGetValue-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapAttrGetValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the affine map wrapped in the given affine map attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3210-L3214" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapCompressUnusedSymbols-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirAffineMapCompressUnusedSymbols-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapCompressUnusedSymbols</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapCompressUnusedSymbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMaps, size, result, populateResult)</span></span></code></pre></div><p>Returns the simplified affine map resulting from dropping the symbols that do not appear in any of the individual maps in <code>affineMaps</code>. Asserts that all maps in <code>affineMaps</code> are normalized to the same number of dims and symbols. Takes a callback <code>populateResult</code> to fill the <code>res</code> container with value <code>m</code> at entry <code>idx</code>. This allows returning without worrying about ownership considerations.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2985-L2989" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapConstantGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineMapConstantGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapConstantGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapConstantGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, val)</span></span></code></pre></div><p>Creates a single constant result affine map in the context. The affine map is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2783-L2787" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapDump-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapDump-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapDump</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Prints the affine map to the standard error stream.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2739-L2743" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapEmptyGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapEmptyGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapEmptyGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapEmptyGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a zero result affine map with no dimensions or symbols in the context. The affine map is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2748-L2752" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineMapEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a1, a2)</span></span></code></pre></div><p>Checks if two affine maps are equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2719-L2723" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapGet-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirAffineMapGet-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, dimCount, symbolCount, nAffineExprs, affineExprs)</span></span></code></pre></div><p>Creates an affine map with results defined by the given list of affine expressions. The map resulting map also has the requested number of input dimensions and symbols, regardless of them being used in the results.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2768-L2772" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapGetContext-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapGetContext-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapGetContext</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Gets the context that the given affine map was created with</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2701-L2705" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapGetMajorSubMap-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineMapGetMajorSubMap-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapGetMajorSubMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetMajorSubMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, numResults)</span></span></code></pre></div><p>Returns the affine map consisting of the most major <code>numResults</code> results. Returns the null AffineMap if the <code>numResults</code> is equal to zero. Returns the <code>affineMap</code> if <code>numResults</code> is greater or equals to number of results of the given affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2946-L2950" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapGetMinorSubMap-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineMapGetMinorSubMap-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapGetMinorSubMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetMinorSubMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, numResults)</span></span></code></pre></div><p>Returns the affine map consisting of the most minor <code>numResults</code> results. Returns the null AffineMap if the <code>numResults</code> is equal to zero. Returns the <code>affineMap</code> if <code>numResults</code> is greater or equals to number of results of the given affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2957-L2961" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapGetNumDims-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapGetNumDims-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapGetNumDims</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetNumDims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of dimensions of the given affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2870-L2874" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapGetNumInputs-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapGetNumInputs-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapGetNumInputs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetNumInputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of inputs (dimensions + symbols) of the given affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2908-L2912" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapGetNumResults-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapGetNumResults-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapGetNumResults</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetNumResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of results of the given affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2888-L2892" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapGetNumSymbols-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapGetNumSymbols-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapGetNumSymbols</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetNumSymbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the number of symbols of the given affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2879-L2883" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapGetResult-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineMapGetResult-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapGetResult</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, pos)</span></span></code></pre></div><p>Returns the result at the given position.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2897-L2901" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapGetSingleConstantResult-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapGetSingleConstantResult-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapGetSingleConstantResult</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetSingleConstantResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Returns the constant result of the given affine map. The function asserts that the map has a single constant result.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2861-L2865" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapGetSubMap-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirAffineMapGetSubMap-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapGetSubMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapGetSubMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, size, resultPos)</span></span></code></pre></div><p>Returns the affine map consisting of the <code>resultPos</code> subset.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2935-L2939" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapIsEmpty-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapIsEmpty-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapIsEmpty</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is an empty affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2843-L2847" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapIsIdentity-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapIsIdentity-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapIsIdentity</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsIdentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is an identity affine map. The function asserts that the number of dimensions is greater or equal to the number of results.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2825-L2829" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapIsMinorIdentity-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapIsMinorIdentity-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapIsMinorIdentity</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsMinorIdentity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is a minor identity affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2834-L2838" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether an affine map is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2710-L2714" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapIsPermutation-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapIsPermutation-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapIsPermutation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsPermutation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map represents a symbol-less permutation map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2926-L2930" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapIsProjectedPermutation-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapIsProjectedPermutation-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapIsProjectedPermutation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsProjectedPermutation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map represents a subset of a symbol-less permutation map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2917-L2921" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapIsSingleConstant-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineMapIsSingleConstant-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapIsSingleConstant</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapIsSingleConstant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap)</span></span></code></pre></div><p>Checks whether the given affine map is a single result constant affine map.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2852-L2856" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapMinorIdentityGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirAffineMapMinorIdentityGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapMinorIdentityGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapMinorIdentityGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, dims, results)</span></span></code></pre></div><p>Creates an identity affine map on the most minor dimensions in the context. The affine map is owned by the context. The function asserts that the number of dimensions is greater or equal to the number of results.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2803-L2807" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapMultiDimIdentityGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineMapMultiDimIdentityGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapMultiDimIdentityGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapMultiDimIdentityGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, numDims)</span></span></code></pre></div><p>Creates an affine map with &#39;numDims&#39; identity in the context. The affine map is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2792-L2796" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapPermutationGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirAffineMapPermutationGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapPermutationGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapPermutationGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, size, permutation)</span></span></code></pre></div><p>Creates an affine map with a permutation expression and its size in the context. The permutation expression is a non-empty vector of integers. The elements of the permutation vector must be continuous from 0 and cannot be repeated (i.e. <code>[1,2,0]</code> is a valid permutation. <code>[2,0]</code> or <code>[1,1,2]</code> is an invalid permutation.) The affine map is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2814-L2818" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapPrint-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirAffineMapPrint-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapPrint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, callback, userData)</span></span></code></pre></div><p>Prints an affine map by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2728-L2732" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapReplace-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirAffineMapReplace-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapReplace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapReplace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineMap, expression, replacement, numResultDims, numResultSyms)</span></span></code></pre></div><p>Apply AffineExpr::replace(<code>map</code>) to each of the results and return a new new AffineMap with the new results and the specified number of dims and symbols.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2968-L2972" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMapZeroResultGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirAffineMapZeroResultGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMapZeroResultGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMapZeroResultGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, dimCount, symbolCount)</span></span></code></pre></div><p>Creates a zero result affine map of the given dimensions and symbols in the context. The affine map is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2757-L2761" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineModExprGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineModExprGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineModExprGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineModExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine mod expression with &#39;lhs&#39; and &#39;rhs&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2623-L2627" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineMulExprGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineMulExprGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineMulExprGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineMulExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lhs, rhs)</span></span></code></pre></div><p>Creates an affine mul expression with &#39;lhs&#39; and &#39;rhs&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2603-L2607" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineSymbolExprGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAffineSymbolExprGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineSymbolExprGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineSymbolExprGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, position)</span></span></code></pre></div><p>Creates an affine symbol expression with &#39;position&#39; in the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2525-L2529" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAffineSymbolExprGetPosition-Tuple{Any}" href="#Reactant.MLIR.API.mlirAffineSymbolExprGetPosition-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAffineSymbolExprGetPosition</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAffineSymbolExprGetPosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(affineExpr)</span></span></code></pre></div><p>Returns the position of the given affine symbol expression.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2536-L2540" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAnyQuantizedTypeGet-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirAnyQuantizedTypeGet-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAnyQuantizedTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAnyQuantizedTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, storageType, expressedType, storageTypeMin, storageTypeMax)</span></span></code></pre></div><p>Creates an instance of AnyQuantizedType with the given parameters in the same context as <code>storageType</code> and returns it. The instance is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7366-L7370" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirArrayAttrGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirArrayAttrGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirArrayAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirArrayAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, numElements, elements)</span></span></code></pre></div><p>Creates an array element containing the given list of elements in the given context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3237-L3241" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirArrayAttrGetElement-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirArrayAttrGetElement-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirArrayAttrGetElement</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirArrayAttrGetElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, pos)</span></span></code></pre></div><p>Returns pos-th element stored in the given array attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3257-L3261" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirArrayAttrGetNumElements-Tuple{Any}" href="#Reactant.MLIR.API.mlirArrayAttrGetNumElements-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirArrayAttrGetNumElements</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirArrayAttrGetNumElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the number of elements stored in the given array attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3248-L3252" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirArrayAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirArrayAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirArrayAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirArrayAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Array attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3266-L3270" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAsmStateCreateForOperation-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAsmStateCreateForOperation-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAsmStateCreateForOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAsmStateCreateForOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, flags)</span></span></code></pre></div><p>Creates new AsmState, as with AsmState the IR should not be mutated in-between using this state. Must be freed with a call to <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirAsmStateDestroy-Tuple{Any}"><code>mlirAsmStateDestroy</code></a>().</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L879-L883" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAsmStateCreateForValue-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAsmStateCreateForValue-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAsmStateCreateForValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAsmStateCreateForValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, flags)</span></span></code></pre></div><p>Creates new AsmState from value. Must be freed with a call to <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirAsmStateDestroy-Tuple{Any}"><code>mlirAsmStateDestroy</code></a>().</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L890-L894" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAsmStateDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirAsmStateDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAsmStateDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAsmStateDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state)</span></span></code></pre></div><p>Destroys printing flags created with mlirAsmStateCreate.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L901-L905" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeDump-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeDump-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeDump</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Prints the attribute to the standard error stream.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2213-L2217" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAttributeEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a1, a2)</span></span></code></pre></div><p>Checks if two attributes are equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2193-L2197" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeGetContext-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeGetContext-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeGetContext</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the context that an attribute was created with.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2148-L2152" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeGetDialect-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeGetDialect-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeGetDialect</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeGetDialect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the dialect of the attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2175-L2179" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeGetNull-Tuple{}" href="#Reactant.MLIR.API.mlirAttributeGetNull-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeGetNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeGetNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns an empty attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3179-L3183" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeGetType-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeGetType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeGetType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeGetType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the type of this attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2157-L2161" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeGetTypeID-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeGetTypeID-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Gets the type id of the attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2166-L2170" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsAAffineMap-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsAAffineMap-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsAAffineMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAAffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an affine map attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3192-L3196" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsAArray-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsAArray-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsAArray</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an array attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3228-L3232" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsABool-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsABool-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsABool</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsABool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a bool attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3438-L3442" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsADenseBoolArray-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsADenseBoolArray-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsADenseBoolArray</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsADenseBoolArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a dense array attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3812-L3816" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsADenseElements-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsADenseElements-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsADenseElements</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsADenseElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a dense elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3934-L3938" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsADictionary-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsADictionary-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsADictionary</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsADictionary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a dictionary attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3275-L3279" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsAElements-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsAElements-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsAElements</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3768-L3772" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsAFlatSymbolRef-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsAFlatSymbolRef-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsAFlatSymbolRef</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAFlatSymbolRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a flat symbol reference attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3676-L3680" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsAFloat-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsAFloat-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsAFloat</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a floating point attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3335-L3339" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsAInteger-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsAInteger-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsAInteger</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an integer attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3384-L3388" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsAIntegerSet-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsAIntegerSet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsAIntegerSet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAIntegerSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an integer set attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3465-L3469" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsAOpaque-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsAOpaque-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsAOpaque</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAOpaque</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is an opaque attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3501-L3505" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsASparseElements-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsASparseElements-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsASparseElements</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsASparseElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a sparse elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4524-L4528" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsASparseTensorEncodingAttr-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsASparseTensorEncodingAttr-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsASparseTensorEncodingAttr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsASparseTensorEncodingAttr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a <code>sparse\_tensor.encoding</code> attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7607-L7611" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsAString-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsAString-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsAString</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a string attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3552-L3556" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsASymbolRef-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsASymbolRef-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsASymbolRef</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsASymbolRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a symbol reference attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3597-L3601" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsAType-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsAType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsAType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a type attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3705-L3709" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsAUnit-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsAUnit-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsAUnit</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsAUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given attribute is a unit attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3741-L3745" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirAttributeIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether an attribute is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2184-L2188" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributeParseGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirAttributeParseGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributeParseGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributeParseGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, attr)</span></span></code></pre></div><p>Parses an attribute. The attribute is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2137-L2141" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirAttributePrint-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirAttributePrint-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirAttributePrint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirAttributePrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, callback, userData)</span></span></code></pre></div><p>Prints an attribute by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2202-L2206" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBF16TypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirBF16TypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBF16TypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBF16TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a bf16 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5043-L5047" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBFloat16TypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirBFloat16TypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirBFloat16TypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBFloat16TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an BFloat16 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5025-L5029" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockAddArgument-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirBlockAddArgument-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockAddArgument</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockAddArgument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, type, loc)</span></span></code></pre></div><p>Appends an argument of the specified type to the block. Returns the newly added argument.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1802-L1806" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockAppendOwnedOperation-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirBlockAppendOwnedOperation-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockAppendOwnedOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockAppendOwnedOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and appends it to the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1749-L1753" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockArgumentGetArgNumber-Tuple{Any}" href="#Reactant.MLIR.API.mlirBlockArgumentGetArgNumber-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockArgumentGetArgNumber</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockArgumentGetArgNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the position of the value in the argument list of its block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1898-L1902" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockArgumentGetOwner-Tuple{Any}" href="#Reactant.MLIR.API.mlirBlockArgumentGetOwner-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockArgumentGetOwner</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockArgumentGetOwner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the block in which this value is defined as an argument. Asserts if the value is not a block argument.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1889-L1893" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockArgumentSetType-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirBlockArgumentSetType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockArgumentSetType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockArgumentSetType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, type)</span></span></code></pre></div><p>Sets the type of the block argument to the given type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1907-L1911" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockCreate-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirBlockCreate-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nArgs, args, locs)</span></span></code></pre></div><p>Creates a new empty block with the given argument types and transfers ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1657-L1661" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirBlockDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Takes a block owned by the caller and destroys it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1668-L1672" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockDetach-Tuple{Any}" href="#Reactant.MLIR.API.mlirBlockDetach-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockDetach</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockDetach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Detach a block from the owning region and assume ownership.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1677-L1681" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirBlockEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, other)</span></span></code></pre></div><p>Checks whether two blocks handles point to the same block. This does not perform deep comparison.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1695-L1699" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockEraseArgument-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirBlockEraseArgument-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockEraseArgument</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockEraseArgument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, index)</span></span></code></pre></div><p>Erase the argument at &#39;index&#39; and remove it from the argument list.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1813-L1817" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockGetArgument-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirBlockGetArgument-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockGetArgument</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetArgument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th argument of the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1833-L1837" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockGetFirstOperation-Tuple{Any}" href="#Reactant.MLIR.API.mlirBlockGetFirstOperation-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockGetFirstOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetFirstOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the first operation in the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1731-L1735" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockGetNextInRegion-Tuple{Any}" href="#Reactant.MLIR.API.mlirBlockGetNextInRegion-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockGetNextInRegion</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetNextInRegion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the block immediately following the given block in its parent region.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1722-L1726" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockGetNumArguments-Tuple{Any}" href="#Reactant.MLIR.API.mlirBlockGetNumArguments-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockGetNumArguments</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetNumArguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the number of arguments of the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1793-L1797" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockGetParentOperation-Tuple{Any}" href="#Reactant.MLIR.API.mlirBlockGetParentOperation-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockGetParentOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetParentOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1)</span></span></code></pre></div><p>Returns the closest surrounding operation that contains this block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1704-L1708" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockGetParentRegion-Tuple{Any}" href="#Reactant.MLIR.API.mlirBlockGetParentRegion-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockGetParentRegion</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetParentRegion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the region that contains this block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1713-L1717" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockGetTerminator-Tuple{Any}" href="#Reactant.MLIR.API.mlirBlockGetTerminator-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockGetTerminator</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockGetTerminator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Returns the terminator operation in the block or null if no terminator.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1740-L1744" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockInsertArgument-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirBlockInsertArgument-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockInsertArgument</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockInsertArgument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, pos, type, loc)</span></span></code></pre></div><p>Inserts an argument of the specified type at a specified index to the block. Returns the newly added argument.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1822-L1826" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockInsertOwnedOperation-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirBlockInsertOwnedOperation-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockInsertOwnedOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockInsertOwnedOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, pos, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and inserts it as <code>pos</code> to the block. This is an expensive operation that scans the block linearly, prefer insertBefore/After instead.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1760-L1764" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockInsertOwnedOperationAfter-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirBlockInsertOwnedOperationAfter-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockInsertOwnedOperationAfter</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockInsertOwnedOperationAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, reference, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and inserts it after the (non-owned) reference operation in the given block. If the reference is null, prepends the operation. Otherwise, the reference must belong to the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1771-L1775" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockInsertOwnedOperationBefore-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirBlockInsertOwnedOperationBefore-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockInsertOwnedOperationBefore</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockInsertOwnedOperationBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, reference, operation)</span></span></code></pre></div><p>Takes an operation owned by the caller and inserts it before the (non-owned) reference operation in the given block. If the reference is null, appends the operation. Otherwise, the reference must belong to the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1782-L1786" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirBlockIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block)</span></span></code></pre></div><p>Checks whether a block is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1686-L1690" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBlockPrint-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirBlockPrint-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBlockPrint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBlockPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(block, callback, userData)</span></span></code></pre></div><p>Prints a block by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1842-L1846" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBoolAttrGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirBoolAttrGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBoolAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBoolAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, value)</span></span></code></pre></div><p>Creates a bool attribute in the given context with the given value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3447-L3451" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBoolAttrGetValue-Tuple{Any}" href="#Reactant.MLIR.API.mlirBoolAttrGetValue-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBoolAttrGetValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBoolAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given bool attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3456-L3460" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBytecodeWriterConfigCreate-Tuple{}" href="#Reactant.MLIR.API.mlirBytecodeWriterConfigCreate-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirBytecodeWriterConfigCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBytecodeWriterConfigCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates new printing flags with defaults, intended for customization. Must be freed with a call to <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirBytecodeWriterConfigDestroy-Tuple{Any}"><code>mlirBytecodeWriterConfigDestroy</code></a>().</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L997-L1001" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBytecodeWriterConfigDesiredEmitVersion-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirBytecodeWriterConfigDesiredEmitVersion-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBytecodeWriterConfigDesiredEmitVersion</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBytecodeWriterConfigDesiredEmitVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, version)</span></span></code></pre></div><p>Sets the version to emit in the writer config.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1015-L1019" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirBytecodeWriterConfigDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirBytecodeWriterConfigDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirBytecodeWriterConfigDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirBytecodeWriterConfigDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(config)</span></span></code></pre></div><p>Destroys printing flags created with <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirBytecodeWriterConfigCreate-Tuple{}"><code>mlirBytecodeWriterConfigCreate</code></a>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1006-L1010" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirCalibratedQuantizedTypeGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirCalibratedQuantizedTypeGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirCalibratedQuantizedTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirCalibratedQuantizedTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(expressedType, min, max)</span></span></code></pre></div><p>Creates an instance of CalibratedQuantizedType with the given parameters in the same context as <code>expressedType</code> and returns it. The instance is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7536-L7540" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMax-Tuple{Any}" href="#Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMax-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMax</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirCalibratedQuantizedTypeGetMax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the max value of the given calibrated quantized type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7556-L7560" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMin-Tuple{Any}" href="#Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMin-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMin</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirCalibratedQuantizedTypeGetMin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the min value of the given calibrated quantized type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7547-L7551" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirComplexTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirComplexTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirComplexTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirComplexTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType)</span></span></code></pre></div><p>Creates a complex type with the given element type in the same context as the element type. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5205-L5209" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirComplexTypeGetElementType-Tuple{Any}" href="#Reactant.MLIR.API.mlirComplexTypeGetElementType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirComplexTypeGetElementType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirComplexTypeGetElementType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the element type of the given complex type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5214-L5218" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirComplexTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirComplexTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirComplexTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirComplexTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Complex type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5187-L5191" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextAppendDialectRegistry-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirContextAppendDialectRegistry-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextAppendDialectRegistry</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextAppendDialectRegistry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, registry)</span></span></code></pre></div><p>Append the contents of the given dialect registry to the registry associated with the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L408-L412" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextAttachDiagnosticHandler-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirContextAttachDiagnosticHandler-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextAttachDiagnosticHandler</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextAttachDiagnosticHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, handler, userData, deleteUserData)</span></span></code></pre></div><p>Attaches the diagnostic handler to the context. Handlers are invoked in the reverse order of attachment until one of them processes the diagnostic completely. When a handler is invoked it is passed the <code>userData</code> that was provided when it was attached. If non-NULL, <code>deleteUserData</code> is called once the system no longer needs to call the handler (for instance after the handler is detached or the context is destroyed). Returns an identifier that can be used to detach the handler.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5959-L5963" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextCreate-Tuple{}" href="#Reactant.MLIR.API.mlirContextCreate-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirContextCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates an MLIR context and transfers its ownership to the caller. This sets the default multithreading option (enabled).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L323-L327" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextCreateWithRegistry-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirContextCreateWithRegistry-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextCreateWithRegistry</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextCreateWithRegistry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(registry, threadingEnabled)</span></span></code></pre></div><p>Creates an MLIR context, setting the multithreading setting explicitly and pre-loading the dialects from the provided DialectRegistry.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L341-L345" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextCreateWithThreading-Tuple{Any}" href="#Reactant.MLIR.API.mlirContextCreateWithThreading-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextCreateWithThreading</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextCreateWithThreading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(threadingEnabled)</span></span></code></pre></div><p>Creates an MLIR context with an explicit setting of the multithreading setting and transfers its ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L332-L336" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirContextDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Takes an MLIR context owned by the caller and destroys it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L370-L374" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextDetachDiagnosticHandler-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirContextDetachDiagnosticHandler-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextDetachDiagnosticHandler</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextDetachDiagnosticHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, id)</span></span></code></pre></div><p>Detaches an attached diagnostic handler from the context given its identifier.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5973-L5977" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextEnableMultithreading-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirContextEnableMultithreading-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextEnableMultithreading</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextEnableMultithreading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, enable)</span></span></code></pre></div><p>Set threading mode (must be set to false to mlir-print-ir-after-all).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L439-L443" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirContextEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx1, ctx2)</span></span></code></pre></div><p>Checks if two contexts are equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L352-L356" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextGetAllowUnregisteredDialects-Tuple{Any}" href="#Reactant.MLIR.API.mlirContextGetAllowUnregisteredDialects-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextGetAllowUnregisteredDialects</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextGetAllowUnregisteredDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Returns whether the context allows unregistered dialects.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L390-L394" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextGetNumLoadedDialects-Tuple{Any}" href="#Reactant.MLIR.API.mlirContextGetNumLoadedDialects-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextGetNumLoadedDialects</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextGetNumLoadedDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Returns the number of dialects loaded by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L419-L423" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextGetNumRegisteredDialects-Tuple{Any}" href="#Reactant.MLIR.API.mlirContextGetNumRegisteredDialects-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextGetNumRegisteredDialects</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextGetNumRegisteredDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Returns the number of dialects registered with the given context. A registered dialect will be loaded if needed by the parser.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L399-L403" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextGetOrLoadDialect-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirContextGetOrLoadDialect-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextGetOrLoadDialect</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextGetOrLoadDialect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, name)</span></span></code></pre></div><p>Gets the dialect instance owned by the given context using the dialect namespace to identify it, loads (i.e., constructs the instance of) the dialect if necessary. If the dialect is not registered with the context, returns null. Use mlirContextLoad&lt;Name&gt;Dialect to load an unregistered dialect.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L428-L432" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirContextIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Checks whether a context is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L361-L365" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextIsRegisteredOperation-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirContextIsRegisteredOperation-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextIsRegisteredOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextIsRegisteredOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, name)</span></span></code></pre></div><p>Returns whether the given fully-qualified operation (i.e. &#39;dialect.operation&#39;) is registered with the context. This will return true if the dialect is loaded and the operation is registered within the dialect.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L457-L461" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextLoadAllAvailableDialects-Tuple{Any}" href="#Reactant.MLIR.API.mlirContextLoadAllAvailableDialects-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextLoadAllAvailableDialects</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextLoadAllAvailableDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Eagerly loads all available dialects registered with a context, making them available for use for IR construction.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L448-L452" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextSetAllowUnregisteredDialects-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirContextSetAllowUnregisteredDialects-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextSetAllowUnregisteredDialects</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextSetAllowUnregisteredDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, allow)</span></span></code></pre></div><p>Sets whether unregistered dialects are allowed in this context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L379-L383" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirContextSetThreadPool-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirContextSetThreadPool-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirContextSetThreadPool</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirContextSetThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, threadPool)</span></span></code></pre></div><p>Sets the thread pool of the context explicitly, enabling multithreading in the process. This API should be used to avoid re-creating thread pools in long-running applications that perform multiple compilations, see the C++ documentation for MLIRContext for details.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L468-L472" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirCreateExternalPass-NTuple{9, Any}" href="#Reactant.MLIR.API.mlirCreateExternalPass-NTuple{9, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirCreateExternalPass</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirCreateExternalPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passID, name, argument, description, opName, nDependentDialects, dependentDialects, callbacks, userData)</span></span></code></pre></div><p>Creates an external <a href="./@ref"><code>MlirPass</code></a> that calls the supplied <code>callbacks</code> using the supplied <code>userData</code>. If <code>opName</code> is empty, the pass is a generic operation pass. Otherwise it is an operation pass specific to the specified pass name.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8357-L8361" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseArrayGetNumElements-Tuple{Any}" href="#Reactant.MLIR.API.mlirDenseArrayGetNumElements-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseArrayGetNumElements</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseArrayGetNumElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Get the size of a dense array.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3892-L3896" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseBoolArrayGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirDenseBoolArrayGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseBoolArrayGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseBoolArrayGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, size, values)</span></span></code></pre></div><p>Create a dense array attribute with the given elements.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3845-L3849" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseBoolArrayGetElement-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirDenseBoolArrayGetElement-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseBoolArrayGetElement</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseBoolArrayGetElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, pos)</span></span></code></pre></div><p>Get an element of a dense array.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3901-L3905" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseBoolResourceElementsAttrGetValue-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirDenseBoolResourceElementsAttrGetValue-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseBoolResourceElementsAttrGetValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseBoolResourceElementsAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, pos)</span></span></code></pre></div><p>Returns the pos-th value (flat contiguous indexing) of a specific type contained by the given dense resource elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4453-L4457" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseElementsAttrBoolGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirDenseElementsAttrBoolGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseElementsAttrBoolGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrBoolGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, numElements, elements)</span></span></code></pre></div><p>Creates a dense elements attribute with the given shaped type from elements of a specific type. Expects the element type of the shaped type to match the data element type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4051-L4055" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseElementsAttrGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirDenseElementsAttrGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseElementsAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, numElements, elements)</span></span></code></pre></div><p>Creates a dense elements attribute with the given Shaped type and elements in the same context as the type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3960-L3964" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseElementsAttrGetBoolValue-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirDenseElementsAttrGetBoolValue-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseElementsAttrGetBoolValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrGetBoolValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, pos)</span></span></code></pre></div><p>Returns the pos-th value (flat contiguous indexing) of a specific type contained by the given dense elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4216-L4220" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseElementsAttrGetRawData-Tuple{Any}" href="#Reactant.MLIR.API.mlirDenseElementsAttrGetRawData-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseElementsAttrGetRawData</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrGetRawData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the raw data of the given dense elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4299-L4303" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseElementsAttrGetSplatValue-Tuple{Any}" href="#Reactant.MLIR.API.mlirDenseElementsAttrGetSplatValue-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseElementsAttrGetSplatValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrGetSplatValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the single replicated value (splat) of a specific type contained by the given dense elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4165-L4169" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseElementsAttrIsSplat-Tuple{Any}" href="#Reactant.MLIR.API.mlirDenseElementsAttrIsSplat-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseElementsAttrIsSplat</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrIsSplat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Checks whether the given dense elements attribute contains a single replicated value (splat).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4156-L4160" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseElementsAttrRawBufferGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirDenseElementsAttrRawBufferGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseElementsAttrRawBufferGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrRawBufferGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, rawBufferSize, rawBuffer)</span></span></code></pre></div><p>Creates a dense elements attribute with the given Shaped type and elements populated from a packed, row-major opaque buffer of contents.</p><p>The format of the raw buffer is a densely packed array of values that can be bitcast to the storage format of the element type specified. Types that are not byte aligned will be: - For bitwidth &gt; 1: Rounded up to the next byte. - For bitwidth = 1: Packed into 8bit bytes with bits corresponding to the linear order of the shape type from MSB to LSB, padded to on the right.</p><p>A raw buffer of a single element (or for 1-bit, a byte of value 0 or 255) will be interpreted as a splat. User code should be prepared for additional, conformant patterns to be identified as splats in the future.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3971-L3979" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseElementsAttrReshapeGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirDenseElementsAttrReshapeGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseElementsAttrReshapeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrReshapeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, shapedType)</span></span></code></pre></div><p>Creates a dense elements attribute that has the same data as the given dense elements attribute and a different shaped type. The new type must have the same total number of elements.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4145-L4149" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseElementsAttrSplatGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirDenseElementsAttrSplatGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseElementsAttrSplatGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrSplatGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, element)</span></span></code></pre></div><p>Creates a dense elements attribute with the given Shaped type containing a single replicated element (splat).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3986-L3990" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseElementsAttrStringGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirDenseElementsAttrStringGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseElementsAttrStringGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseElementsAttrStringGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, numElements, strs)</span></span></code></pre></div><p>Creates a dense elements attribute with the given shaped type from string elements.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4134-L4138" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDenseIntOrFPElementsAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirDenseIntOrFPElementsAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirDenseIntOrFPElementsAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDenseIntOrFPElementsAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an DenseIntOrFPElements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3951-L3955" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDiagnosticGetLocation-Tuple{Any}" href="#Reactant.MLIR.API.mlirDiagnosticGetLocation-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDiagnosticGetLocation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDiagnosticGetLocation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diagnostic)</span></span></code></pre></div><p>Returns the location at which the diagnostic is reported.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5919-L5923" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDiagnosticGetNote-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirDiagnosticGetNote-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDiagnosticGetNote</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDiagnosticGetNote</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diagnostic, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th note attached to the diagnostic. Expects <code>pos</code> to be a valid zero-based index into the list of notes.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5948-L5952" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDiagnosticGetNumNotes-Tuple{Any}" href="#Reactant.MLIR.API.mlirDiagnosticGetNumNotes-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDiagnosticGetNumNotes</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDiagnosticGetNumNotes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diagnostic)</span></span></code></pre></div><p>Returns the number of notes attached to the diagnostic.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5939-L5943" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDiagnosticGetSeverity-Tuple{Any}" href="#Reactant.MLIR.API.mlirDiagnosticGetSeverity-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDiagnosticGetSeverity</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDiagnosticGetSeverity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diagnostic)</span></span></code></pre></div><p>Returns the severity of the diagnostic.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5928-L5932" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDiagnosticPrint-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirDiagnosticPrint-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDiagnosticPrint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDiagnosticPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diagnostic, callback, userData)</span></span></code></pre></div><p>Prints a diagnostic using the provided callback.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5908-L5912" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDialectEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirDialectEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDialectEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dialect1, dialect2)</span></span></code></pre></div><p>Checks if two dialects that belong to the same context are equal. Dialects from different contexts will not compare equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L497-L501" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDialectGetContext-Tuple{Any}" href="#Reactant.MLIR.API.mlirDialectGetContext-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDialectGetContext</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dialect)</span></span></code></pre></div><p>Returns the context that owns the dialect.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L479-L483" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDialectGetNamespace-Tuple{Any}" href="#Reactant.MLIR.API.mlirDialectGetNamespace-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDialectGetNamespace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectGetNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dialect)</span></span></code></pre></div><p>Returns the namespace of the given dialect.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L506-L510" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDialectHandleGetNamespace-Tuple{Any}" href="#Reactant.MLIR.API.mlirDialectHandleGetNamespace-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDialectHandleGetNamespace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectHandleGetNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1)</span></span></code></pre></div><p>Returns the namespace associated with the provided dialect handle.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L515-L519" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDialectHandleInsertDialect-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirDialectHandleInsertDialect-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDialectHandleInsertDialect</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectHandleInsertDialect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1, arg2)</span></span></code></pre></div><p>Inserts the dialect associated with the provided dialect handle into the provided dialect registry</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L524-L528" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDialectHandleLoadDialect-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirDialectHandleLoadDialect-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDialectHandleLoadDialect</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectHandleLoadDialect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1, arg2)</span></span></code></pre></div><p>Loads the dialect associated with the provided dialect handle.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L546-L550" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDialectHandleRegisterDialect-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirDialectHandleRegisterDialect-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDialectHandleRegisterDialect</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectHandleRegisterDialect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1, arg2)</span></span></code></pre></div><p>Registers the dialect associated with the provided dialect handle.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L535-L539" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDialectIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirDialectIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDialectIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dialect)</span></span></code></pre></div><p>Checks if the dialect is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L488-L492" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDialectRegistryCreate-Tuple{}" href="#Reactant.MLIR.API.mlirDialectRegistryCreate-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirDialectRegistryCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectRegistryCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a dialect registry and transfers its ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L557-L561" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDialectRegistryDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirDialectRegistryDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDialectRegistryDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectRegistryDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(registry)</span></span></code></pre></div><p>Takes a dialect registry owned by the caller and destroys it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L575-L579" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDialectRegistryIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirDialectRegistryIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDialectRegistryIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDialectRegistryIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(registry)</span></span></code></pre></div><p>Checks if the dialect registry is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L566-L570" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDictionaryAttrGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirDictionaryAttrGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDictionaryAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDictionaryAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, numElements, elements)</span></span></code></pre></div><p>Creates a dictionary attribute containing the given list of elements in the provided context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3284-L3288" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDictionaryAttrGetElement-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirDictionaryAttrGetElement-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDictionaryAttrGetElement</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDictionaryAttrGetElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, pos)</span></span></code></pre></div><p>Returns pos-th element of the given dictionary attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3304-L3308" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDictionaryAttrGetElementByName-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirDictionaryAttrGetElementByName-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDictionaryAttrGetElementByName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDictionaryAttrGetElementByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, name)</span></span></code></pre></div><p>Returns the dictionary attribute element with the given name or NULL if the given name does not exist in the dictionary.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3315-L3319" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDictionaryAttrGetNumElements-Tuple{Any}" href="#Reactant.MLIR.API.mlirDictionaryAttrGetNumElements-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDictionaryAttrGetNumElements</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDictionaryAttrGetNumElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the number of attributes contained in a dictionary attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3295-L3299" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDictionaryAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirDictionaryAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirDictionaryAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDictionaryAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a Dictionary attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3326-L3330" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirDisctinctAttrCreate-Tuple{Any}" href="#Reactant.MLIR.API.mlirDisctinctAttrCreate-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirDisctinctAttrCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirDisctinctAttrCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(referencedAttr)</span></span></code></pre></div><p>Creates a DisctinctAttr with the referenced attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3667-L3671" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirElementsAttrGetNumElements-Tuple{Any}" href="#Reactant.MLIR.API.mlirElementsAttrGetNumElements-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirElementsAttrGetNumElements</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirElementsAttrGetNumElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Gets the total number of elements in the given elements attribute. In order to iterate over the attribute, obtain its type, which must be a statically shaped type and use its sizes to build a multi-dimensional index.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3799-L3803" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirElementsAttrGetValue-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirElementsAttrGetValue-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirElementsAttrGetValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirElementsAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, rank, idxs)</span></span></code></pre></div><p>Returns the element at the given rank-dimensional index.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3777-L3781" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirElementsAttrIsValidIndex-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirElementsAttrIsValidIndex-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirElementsAttrIsValidIndex</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirElementsAttrIsValidIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, rank, idxs)</span></span></code></pre></div><p>Checks whether the given rank-dimensional index is valid in the given elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3788-L3792" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirEmitError-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirEmitError-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirEmitError</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirEmitError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location, message)</span></span></code></pre></div><p>Emits an error at the given location through the diagnostics engine. Used for testing purposes.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5984-L5988" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirEnableGlobalDebug-Tuple{Any}" href="#Reactant.MLIR.API.mlirEnableGlobalDebug-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirEnableGlobalDebug</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirEnableGlobalDebug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(enable)</span></span></code></pre></div><p>Sets the global debugging flag.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5831-L5835" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirExecutionEngineCreate-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirExecutionEngineCreate-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirExecutionEngineCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, optLevel, numPaths, sharedLibPaths, enableObjectDump)</span></span></code></pre></div><p>Creates an ExecutionEngine for the provided ModuleOp. The ModuleOp is expected to be &quot;translatable&quot; to LLVM IR (only contains operations in dialects that implement the <code>LLVMTranslationDialectInterface</code>). The module ownership stays with the client and can be destroyed as soon as the call returns. <code>optLevel</code> is the optimization level to be used for transformation and code generation. LLVM passes at <code>optLevel</code> are run before code generation. The number and array of paths corresponding to shared libraries that will be loaded are specified via <code>numPaths</code> and <code>sharedLibPaths</code> respectively. TODO: figure out other options.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7933-L7937" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirExecutionEngineDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirExecutionEngineDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirExecutionEngineDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit)</span></span></code></pre></div><p>Destroy an ExecutionEngine instance.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7948-L7952" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirExecutionEngineDumpToObjectFile-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirExecutionEngineDumpToObjectFile-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirExecutionEngineDumpToObjectFile</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineDumpToObjectFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit, fileName)</span></span></code></pre></div><p>Dump as an object in <code>fileName</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8010-L8014" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirExecutionEngineInvokePacked-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirExecutionEngineInvokePacked-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirExecutionEngineInvokePacked</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineInvokePacked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit, name, arguments)</span></span></code></pre></div><p>Invoke a native function in the execution engine by name with the arguments and result of the invoked function passed as an array of pointers. The function must have been tagged with the <code>llvm.emit\_c\_interface</code> attribute. Returns a failure if the execution fails for any reason (the function name can&#39;t be resolved for instance).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7966-L7970" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirExecutionEngineIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirExecutionEngineIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirExecutionEngineIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit)</span></span></code></pre></div><p>Checks whether an execution engine is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7957-L7961" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirExecutionEngineLookup-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirExecutionEngineLookup-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirExecutionEngineLookup</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineLookup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit, name)</span></span></code></pre></div><p>Lookup a native function in the execution engine by name, returns nullptr if the name can&#39;t be looked-up.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7988-L7992" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirExecutionEngineLookupPacked-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirExecutionEngineLookupPacked-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirExecutionEngineLookupPacked</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineLookupPacked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit, name)</span></span></code></pre></div><p>Lookup the wrapper of the native function in the execution engine with the given name, returns nullptr if the function can&#39;t be looked-up.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7977-L7981" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirExecutionEngineRegisterSymbol-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirExecutionEngineRegisterSymbol-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirExecutionEngineRegisterSymbol</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExecutionEngineRegisterSymbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jit, name, sym)</span></span></code></pre></div><p>Register a symbol with the jit: this symbol will be accessible to the jitted code.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7999-L8003" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirExternalPassSignalFailure-Tuple{Any}" href="#Reactant.MLIR.API.mlirExternalPassSignalFailure-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirExternalPassSignalFailure</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirExternalPassSignalFailure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pass)</span></span></code></pre></div><p>This signals that the pass has failed. This is only valid to call during the <code>run</code> callback of <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.MlirExternalPassCallbacks"><code>MlirExternalPassCallbacks</code></a>. See Pass::signalPassFailure().</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8386-L8390" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirF16TypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirF16TypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirF16TypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirF16TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f16 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5070-L5074" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirF32TypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirF32TypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirF32TypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirF32TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f32 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5097-L5101" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirF64TypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirF64TypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirF64TypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirF64TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a f64 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5124-L5128" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFlatSymbolRefAttrGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirFlatSymbolRefAttrGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFlatSymbolRefAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFlatSymbolRefAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, symbol)</span></span></code></pre></div><p>Creates a flat symbol reference attribute in the given context referencing a symbol identified by the given string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3685-L3689" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFlatSymbolRefAttrGetValue-Tuple{Any}" href="#Reactant.MLIR.API.mlirFlatSymbolRefAttrGetValue-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFlatSymbolRefAttrGetValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFlatSymbolRefAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the referenced symbol as a string reference. The data remains live as long as the context in which the attribute lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3696-L3700" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat16TypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat16TypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat16TypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat16TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float16 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5052-L5056" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat32TypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat32TypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat32TypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat32TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float32 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5079-L5083" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat4E2M1FNTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloat4E2M1FNTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat4E2M1FNTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat4E2M1FNTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f4E2M1FN type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4746-L4750" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat4E2M1FNTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat4E2M1FNTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat4E2M1FNTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat4E2M1FNTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float4E2M1FN type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4728-L4732" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat64TypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat64TypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat64TypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat64TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float64 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5106-L5110" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat6E2M3FNTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloat6E2M3FNTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat6E2M3FNTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat6E2M3FNTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f6E2M3FN type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4773-L4777" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat6E2M3FNTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat6E2M3FNTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat6E2M3FNTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat6E2M3FNTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float6E2M3FN type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4755-L4759" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat6E3M2FNTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloat6E3M2FNTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat6E3M2FNTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat6E3M2FNTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f6E3M2FN type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4800-L4804" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat6E3M2FNTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat6E3M2FNTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat6E3M2FNTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat6E3M2FNTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float6E3M2FN type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4782-L4786" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E3M4TypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloat8E3M4TypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E3M4TypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E3M4TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E3M4 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4989-L4993" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E3M4TypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat8E3M4TypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E3M4TypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E3M4TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E3M4 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4971-L4975" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3B11FNUZTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E4M3B11FNUZ type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4962-L4966" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3B11FNUZTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E4M3B11FNUZ type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4944-L4948" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E4M3FNTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloat8E4M3FNTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E4M3FNTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3FNTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E4M3FN type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4881-L4885" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E4M3FNTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat8E4M3FNTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E4M3FNTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3FNTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E4M3FN type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4863-L4867" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3FNUZTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E4M3FNUZ type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4935-L4939" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3FNUZTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E4M3FNUZ type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4917-L4921" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E4M3TypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloat8E4M3TypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E4M3TypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E4M3 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4854-L4858" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E4M3TypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat8E4M3TypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E4M3TypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E4M3TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E4M3 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4836-L4840" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E5M2FNUZTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E5M2FNUZ type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4908-L4912" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E5M2FNUZTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E5M2FNUZ type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4890-L4894" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E5M2TypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloat8E5M2TypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E5M2TypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E5M2TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E5M2 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4827-L4831" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E5M2TypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat8E5M2TypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E5M2TypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E5M2TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E5M2 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4809-L4813" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E8M0FNUTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloat8E8M0FNUTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E8M0FNUTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E8M0FNUTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an f8E8M0FNU type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5016-L5020" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloat8E8M0FNUTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloat8E8M0FNUTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloat8E8M0FNUTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloat8E8M0FNUTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Float8E8M0FNU type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4998-L5002" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloatAttrDoubleGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirFloatAttrDoubleGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloatAttrDoubleGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloatAttrDoubleGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, type, value)</span></span></code></pre></div><p>Creates a floating point attribute in the given context with the given double value and double-precision FP semantics.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3344-L3348" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloatAttrDoubleGetChecked-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirFloatAttrDoubleGetChecked-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloatAttrDoubleGetChecked</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloatAttrDoubleGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, type, value)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirFloatAttrDoubleGet-Tuple{Any, Any, Any}"><code>mlirFloatAttrDoubleGet</code></a>&quot;, but if the type is not valid for a construction of a FloatAttr, returns a null <a href="./@ref"><code>MlirAttribute</code></a>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3355-L3359" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloatAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloatAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloatAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloatAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a Float attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3375-L3379" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloatAttrGetValueDouble-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloatAttrGetValueDouble-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloatAttrGetValueDouble</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloatAttrGetValueDouble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given floating point attribute, interpreting the value as double.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3366-L3370" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloatTF32TypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFloatTF32TypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFloatTF32TypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloatTF32TypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a TF32 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5133-L5137" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFloatTypeGetWidth-Tuple{Any}" href="#Reactant.MLIR.API.mlirFloatTypeGetWidth-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFloatTypeGetWidth</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFloatTypeGetWidth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the bitwidth of a floating-point type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4719-L4723" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFreezeRewritePattern-Tuple{Any}" href="#Reactant.MLIR.API.mlirFreezeRewritePattern-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFreezeRewritePattern</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFreezeRewritePattern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>FrozenRewritePatternSet API</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8853-L8857" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFuncSetArgAttr-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirFuncSetArgAttr-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFuncSetArgAttr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFuncSetArgAttr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos, name, attr)</span></span></code></pre></div><p>Sets the argument attribute &#39;name&#39; of an argument at index &#39;pos&#39;. Asserts that the operation is a FuncOp.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6151-L6155" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFunctionTypeGet-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirFunctionTypeGet-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFunctionTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFunctionTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, numInputs, inputs, numResults, results)</span></span></code></pre></div><p>Creates a function type, mapping a list of input types to result types.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5733-L5737" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFunctionTypeGetInput-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirFunctionTypeGetInput-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFunctionTypeGetInput</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFunctionTypeGetInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns the pos-th input type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5766-L5770" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFunctionTypeGetNumInputs-Tuple{Any}" href="#Reactant.MLIR.API.mlirFunctionTypeGetNumInputs-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFunctionTypeGetNumInputs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFunctionTypeGetNumInputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of input types.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5748-L5752" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFunctionTypeGetNumResults-Tuple{Any}" href="#Reactant.MLIR.API.mlirFunctionTypeGetNumResults-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFunctionTypeGetNumResults</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFunctionTypeGetNumResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of result types.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5757-L5761" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFunctionTypeGetResult-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirFunctionTypeGetResult-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirFunctionTypeGetResult</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFunctionTypeGetResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns the pos-th result type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5775-L5779" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirFunctionTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirFunctionTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirFunctionTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirFunctionTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Function type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5715-L5719" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIRRewriterCreate-Tuple{Any}" href="#Reactant.MLIR.API.mlirIRRewriterCreate-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIRRewriterCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIRRewriterCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Create an IRRewriter and transfer ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8826-L8830" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIRRewriterCreateFromOp-Tuple{Any}" href="#Reactant.MLIR.API.mlirIRRewriterCreateFromOp-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIRRewriterCreateFromOp</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIRRewriterCreateFromOp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Create an IRRewriter and transfer ownership to the caller. Additionally set the insertion point before the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8835-L8839" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIRRewriterDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirIRRewriterDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIRRewriterDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIRRewriterDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter)</span></span></code></pre></div><p>Takes an IRRewriter owned by the caller and destroys it. It is the responsibility of the user to only pass an IRRewriter class.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8844-L8848" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIdentifierEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirIdentifierEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIdentifierEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIdentifierEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ident, other)</span></span></code></pre></div><p>Checks whether two identifiers are the same.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2253-L2257" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIdentifierGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirIdentifierGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIdentifierGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIdentifierGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, str)</span></span></code></pre></div><p>Gets an identifier with the given string value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2233-L2237" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIdentifierGetContext-Tuple{Any}" href="#Reactant.MLIR.API.mlirIdentifierGetContext-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIdentifierGetContext</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIdentifierGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg1)</span></span></code></pre></div><p>Returns the context associated with this identifier</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2244-L2248" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIdentifierStr-Tuple{Any}" href="#Reactant.MLIR.API.mlirIdentifierStr-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIdentifierStr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIdentifierStr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ident)</span></span></code></pre></div><p>Gets the string value of the identifier.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2262-L2266" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIndexTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirIndexTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIndexTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIndexTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an index type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4701-L4705" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIndexTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirIndexTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirIndexTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIndexTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Index type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4683-L4687" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceInferReturnTypes-NTuple{11, Any}" href="#Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceInferReturnTypes-NTuple{11, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceInferReturnTypes</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirInferShapedTypeOpInterfaceInferReturnTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opName, context, location, nOperands, operands, attributes, properties, nRegions, regions, callback, userData)</span></span></code></pre></div><p>Infers the return shaped type components of the operation. Calls <code>callback</code> with the types of inferred arguments on success. Returns failure otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8106-L8110" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirInferShapedTypeOpInterfaceTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the interface TypeID of the InferShapedTypeOpInterface.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8091-L8095" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirInferTypeOpInterfaceInferReturnTypes-NTuple{11, Any}" href="#Reactant.MLIR.API.mlirInferTypeOpInterfaceInferReturnTypes-NTuple{11, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirInferTypeOpInterfaceInferReturnTypes</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirInferTypeOpInterfaceInferReturnTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opName, context, location, nOperands, operands, attributes, properties, nRegions, regions, callback, userData)</span></span></code></pre></div><p>Infers the return types of the operation identified by its canonical given the arguments that will be supplied to its generic builder. Calls <code>callback</code> with the types of inferred arguments, potentially several times, on success. Returns failure otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8058-L8062" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirInferTypeOpInterfaceTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirInferTypeOpInterfaceTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirInferTypeOpInterfaceTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirInferTypeOpInterfaceTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the interface TypeID of the InferTypeOpInterface.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8043-L8047" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerAttrGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirIntegerAttrGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, value)</span></span></code></pre></div><p>Creates an integer attribute of the given type with the given integer value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3393-L3397" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirIntegerAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Integer attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3429-L3433" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerAttrGetValueInt-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerAttrGetValueInt-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerAttrGetValueInt</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerAttrGetValueInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given integer attribute, assuming the value is of signless type and fits into a signed 64-bit integer.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3402-L3406" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerAttrGetValueSInt-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerAttrGetValueSInt-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerAttrGetValueSInt</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerAttrGetValueSInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given integer attribute, assuming the value is of signed type and fits into a signed 64-bit integer.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3411-L3415" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerAttrGetValueUInt-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerAttrGetValueUInt-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerAttrGetValueUInt</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerAttrGetValueUInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the value stored in the given integer attribute, assuming the value is of unsigned type and fits into an unsigned 64-bit integer.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3420-L3424" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetAttrGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerSetAttrGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Creates an integer set attribute wrapping the given set. The attribute belongs to the same context as the integer set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3474-L3478" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirIntegerSetAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an IntegerSet attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3492-L3496" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetAttrGetValue-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerSetAttrGetValue-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetAttrGetValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the integer set wrapped in the given integer set attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3483-L3487" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetDump-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerSetDump-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetDump</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Prints an integer set to the standard error stream.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3041-L3045" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetEmptyGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirIntegerSetEmptyGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetEmptyGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetEmptyGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, numDims, numSymbols)</span></span></code></pre></div><p>Gets or creates a new canonically empty integer set with the give number of dimensions and symbols in the given context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3050-L3054" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirIntegerSetEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s1, s2)</span></span></code></pre></div><p>Checks if two integer set objects are equal. This is a &quot;shallow&quot; comparison of two objects. Only the sets with some small number of constraints are uniqued and compare equal here. Set objects that represent the same integer set with different constraints may be considered non-equal by this check. Set difference followed by an (expensive) emptiness check should be used to check equivalence of the underlying integer sets.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3021-L3025" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetGet-NTuple{6, Any}" href="#Reactant.MLIR.API.mlirIntegerSetGet-NTuple{6, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, numDims, numSymbols, numConstraints, constraints, eqFlags)</span></span></code></pre></div><p>Gets or creates a new integer set in the given context. The set is defined by a list of affine constraints, with the given number of input dimensions and symbols, which are treated as either equalities (eqFlags is 1) or inequalities (eqFlags is 0). Both <code>constraints</code> and <code>eqFlags</code> are expected to point to at least <code>numConstraint</code> consecutive values.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3061-L3065" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetGetConstraint-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirIntegerSetGetConstraint-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetGetConstraint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetConstraint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th constraint of the set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3159-L3163" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetGetContext-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerSetGetContext-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetGetContext</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Gets the context in which the given integer set lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3003-L3007" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetGetNumConstraints-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerSetGetNumConstraints-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetGetNumConstraints</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetNumConstraints</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of constraints (equalities + inequalities) in the given set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3132-L3136" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetGetNumDims-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerSetGetNumDims-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetGetNumDims</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetNumDims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of dimensions in the given set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3105-L3109" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetGetNumEqualities-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerSetGetNumEqualities-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetGetNumEqualities</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetNumEqualities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of equalities in the given set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3141-L3145" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetGetNumInequalities-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerSetGetNumInequalities-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetGetNumInequalities</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetNumInequalities</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of inequalities in the given set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3150-L3154" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetGetNumInputs-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerSetGetNumInputs-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetGetNumInputs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetNumInputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of inputs (dimensions + symbols) in the given set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3123-L3127" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetGetNumSymbols-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerSetGetNumSymbols-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetGetNumSymbols</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetGetNumSymbols</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Returns the number of symbols in the given set.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3114-L3118" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetIsCanonicalEmpty-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerSetIsCanonicalEmpty-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetIsCanonicalEmpty</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetIsCanonicalEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Checks whether the given set is a canonical empty set, e.g., the set returned by <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirIntegerSetEmptyGet-Tuple{Any, Any, Any}"><code>mlirIntegerSetEmptyGet</code></a>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3096-L3100" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetIsConstraintEq-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirIntegerSetIsConstraintEq-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetIsConstraintEq</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetIsConstraintEq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, pos)</span></span></code></pre></div><p>Returns <code>true</code> of the <code>pos</code>-th constraint of the set is an equality constraint, <code>false</code> otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3170-L3174" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerSetIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set)</span></span></code></pre></div><p>Checks whether an integer set is a null object.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3012-L3016" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetPrint-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirIntegerSetPrint-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetPrint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, callback, userData)</span></span></code></pre></div><p>Prints an integer set by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3030-L3034" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerSetReplaceGet-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirIntegerSetReplaceGet-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerSetReplaceGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerSetReplaceGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set, dimReplacements, symbolReplacements, numResultDims, numResultSymbols)</span></span></code></pre></div><p>Gets or creates a new integer set in which the values and dimensions of the given set are replaced with the given affine expressions. <code>dimReplacements</code> and <code>symbolReplacements</code> are expected to point to at least as many consecutive expressions as the given set has dimensions and symbols, respectively. The new set will have <code>numResultDims</code> and <code>numResultSymbols</code> dimensions and symbols, respectively.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3079-L3083" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerTypeGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirIntegerTypeGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, bitwidth)</span></span></code></pre></div><p>Creates a signless integer type of the given bitwidth in the context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4620-L4624" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirIntegerTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Integer type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4602-L4606" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerTypeGetWidth-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerTypeGetWidth-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerTypeGetWidth</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeGetWidth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the bitwidth of an integer type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4647-L4651" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerTypeIsSigned-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerTypeIsSigned-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerTypeIsSigned</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeIsSigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given integer type is signed.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4665-L4669" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerTypeIsSignless-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerTypeIsSignless-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerTypeIsSignless</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeIsSignless</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given integer type is signless.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4656-L4660" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerTypeIsUnsigned-Tuple{Any}" href="#Reactant.MLIR.API.mlirIntegerTypeIsUnsigned-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerTypeIsUnsigned</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeIsUnsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given integer type is unsigned.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4674-L4678" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerTypeSignedGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirIntegerTypeSignedGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerTypeSignedGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeSignedGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, bitwidth)</span></span></code></pre></div><p>Creates a signed integer type of the given bitwidth in the context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4629-L4633" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIntegerTypeUnsignedGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirIntegerTypeUnsignedGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIntegerTypeUnsignedGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIntegerTypeUnsignedGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, bitwidth)</span></span></code></pre></div><p>Creates an unsigned integer type of the given bitwidth in the context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4638-L4642" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIsCurrentDebugType-Tuple{Any}" href="#Reactant.MLIR.API.mlirIsCurrentDebugType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirIsCurrentDebugType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIsCurrentDebugType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks if <code>type</code> is set as the current debug type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5867-L5871" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirIsGlobalDebugEnabled-Tuple{}" href="#Reactant.MLIR.API.mlirIsGlobalDebugEnabled-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirIsGlobalDebugEnabled</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirIsGlobalDebugEnabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Retuns <code>true</code> if the global debugging flag is set, false otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5840-L5844" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMArrayTypeGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirLLVMArrayTypeGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMArrayTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMArrayTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, numElements)</span></span></code></pre></div><p>Creates an llvm.array type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6294-L6298" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMArrayTypeGetElementType-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMArrayTypeGetElementType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMArrayTypeGetElementType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMArrayTypeGetElementType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the element type of the llvm.array type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6303-L6307" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMCConvAttrGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirLLVMCConvAttrGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMCConvAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMCConvAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, cconv)</span></span></code></pre></div><p>Creates a LLVM CConv attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6536-L6540" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMComdatAttrGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirLLVMComdatAttrGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMComdatAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMComdatAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, comdat)</span></span></code></pre></div><p>Creates a LLVM Comdat attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6555-L6559" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDIAnnotationAttrGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirLLVMDIAnnotationAttrGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDIAnnotationAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIAnnotationAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, name, value)</span></span></code></pre></div><p>Creates a LLVM DIAnnotation attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6935-L6939" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDIBasicTypeAttrGet-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirLLVMDIBasicTypeAttrGet-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDIBasicTypeAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIBasicTypeAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, tag, name, sizeInBits, encoding)</span></span></code></pre></div><p>Creates a LLVM DIBasicType attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6645-L6649" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDICompileUnitAttrGet-NTuple{8, Any}" href="#Reactant.MLIR.API.mlirLLVMDICompileUnitAttrGet-NTuple{8, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDICompileUnitAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDICompileUnitAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, id, sourceLanguage, file, producer, isOptimized, emissionKind, nameTableKind)</span></span></code></pre></div><p>Creates a LLVM DICompileUnit attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6805-L6809" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGet-NTuple{18, Any}" href="#Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGet-NTuple{18, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDICompositeTypeAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, recId, isRecSelf, tag, name, file, line, scope, baseType, flags, sizeInBits, alignInBits, nElements, elements, dataLocation, rank, allocated, associated)</span></span></code></pre></div><p>Creates a LLVM DICompositeType attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6669-L6673" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGetRecSelf-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGetRecSelf-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGetRecSelf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDICompositeTypeAttrGetRecSelf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(recId)</span></span></code></pre></div><p>Creates a self-referencing LLVM DICompositeType attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6660-L6664" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGet-NTuple{9, Any}" href="#Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGet-NTuple{9, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIDerivedTypeAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, tag, name, baseType, sizeInBits, alignInBits, offsetInBits, dwarfAddressSpace, extraData)</span></span></code></pre></div><p>Creates a LLVM DIDerivedType attribute. Note that <code>dwarfAddressSpace</code> is an optional field, where <a href="./@ref"><code>MLIR_CAPI_DWARF_ADDRESS_SPACE_NULL</code></a> indicates null and non-negative values indicate a value present.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6716-L6720" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGetBaseType-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGetBaseType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGetBaseType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIDerivedTypeAttrGetBaseType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diDerivedType)</span></span></code></pre></div><p>Gets the base type from a LLVM DIDerivedType attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6769-L6773" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDIExpressionAttrGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirLLVMDIExpressionAttrGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDIExpressionAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIExpressionAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, nOperations, operations)</span></span></code></pre></div><p>Creates a LLVM DIExpression attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6611-L6615" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDIExpressionElemAttrGet-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirLLVMDIExpressionElemAttrGet-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDIExpressionElemAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIExpressionElemAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, opcode, nArguments, arguments)</span></span></code></pre></div><p>Creates a LLVM DIExpressionElem attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6600-L6604" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDIFileAttrGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirLLVMDIFileAttrGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDIFileAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIFileAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, name, directory)</span></span></code></pre></div><p>Creates a LLVM DIFileAttr attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6780-L6784" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDIFlagsAttrGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirLLVMDIFlagsAttrGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDIFlagsAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIFlagsAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, value)</span></span></code></pre></div><p>Creates a LLVM DIFlags attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6825-L6829" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDIImportedEntityAttrGet-NTuple{9, Any}" href="#Reactant.MLIR.API.mlirLLVMDIImportedEntityAttrGet-NTuple{9, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDIImportedEntityAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIImportedEntityAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, tag, scope, entity, file, line, name, nElements, elements)</span></span></code></pre></div><p>Creates a LLVM DIImportedEntityAttr attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7043-L7047" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDILexicalBlockAttrGet-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirLLVMDILexicalBlockAttrGet-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDILexicalBlockAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDILexicalBlockAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, scope, file, line, column)</span></span></code></pre></div><p>Creates a LLVM DILexicalBlock attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6834-L6838" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDILexicalBlockFileAttrGet-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirLLVMDILexicalBlockFileAttrGet-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDILexicalBlockFileAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDILexicalBlockFileAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, scope, file, discriminator)</span></span></code></pre></div><p>Creates a LLVM DILexicalBlockFile attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6849-L6853" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDILocalVariableAttrGet-NTuple{9, Any}" href="#Reactant.MLIR.API.mlirLLVMDILocalVariableAttrGet-NTuple{9, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDILocalVariableAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDILocalVariableAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, scope, name, diFile, line, arg, alignInBits, diType, flags)</span></span></code></pre></div><p>Creates a LLVM DILocalVariableAttr attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6860-L6864" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDIModuleAttrGet-NTuple{9, Any}" href="#Reactant.MLIR.API.mlirLLVMDIModuleAttrGet-NTuple{9, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDIModuleAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIModuleAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, file, scope, name, configMacros, includePath, apinotes, line, isDecl)</span></span></code></pre></div><p>Creates a LLVM DIModuleAttr attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7022-L7026" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDIModuleAttrGetScope-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMDIModuleAttrGetScope-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDIModuleAttrGetScope</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDIModuleAttrGetScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diModule)</span></span></code></pre></div><p>Gets the scope of this DIModuleAttr.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7064-L7068" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDINullTypeAttrGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMDINullTypeAttrGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDINullTypeAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDINullTypeAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a LLVM DINullType attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6591-L6595" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDISubprogramAttrGet-NTuple{17, Any}" href="#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGet-NTuple{17, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDISubprogramAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, recId, isRecSelf, id, compileUnit, scope, name, linkageName, file, line, scopeLine, subprogramFlags, type, nRetainedNodes, retainedNodes, nAnnotations, annotations)</span></span></code></pre></div><p>Creates a LLVM DISubprogramAttr attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6890-L6894" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetCompileUnit-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetCompileUnit-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetCompileUnit</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetCompileUnit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diSubprogram)</span></span></code></pre></div><p>Gets the compile unit from this DISubprogram.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6975-L6979" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetFile-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetFile-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetFile</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diSubprogram)</span></span></code></pre></div><p>Gets the file from this DISubprogramAttr.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6986-L6990" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetLine-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetLine-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetLine</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetLine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diSubprogram)</span></span></code></pre></div><p>Gets the line from this DISubprogramAttr.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6957-L6961" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetRecSelf-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetRecSelf-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetRecSelf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetRecSelf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(recId)</span></span></code></pre></div><p>Creates a self-referencing LLVM DISubprogramAttr attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6881-L6885" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScope-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScope-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScope</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diSubprogram)</span></span></code></pre></div><p>Gets the scope from this DISubprogramAttr.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6946-L6950" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScopeLine-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScopeLine-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScopeLine</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetScopeLine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diSubprogram)</span></span></code></pre></div><p>Gets the scope line from this DISubprogram.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6966-L6970" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetType-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubprogramAttrGetType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diSubprogram)</span></span></code></pre></div><p>Gets the type from this DISubprogramAttr.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6997-L7001" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMDISubroutineTypeAttrGet-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirLLVMDISubroutineTypeAttrGet-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMDISubroutineTypeAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMDISubroutineTypeAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, callingConvention, nTypes, types)</span></span></code></pre></div><p>Creates a LLVM DISubroutineTypeAttr attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7008-L7012" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMFunctionTypeGet-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirLLVMFunctionTypeGet-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMFunctionTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMFunctionTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resultType, nArgumentTypes, argumentTypes, isVarArg)</span></span></code></pre></div><p>Creates an llvm.func type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6312-L6316" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMFunctionTypeGetInput-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirLLVMFunctionTypeGetInput-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMFunctionTypeGetInput</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMFunctionTypeGetInput</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns the pos-th input type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6335-L6339" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMFunctionTypeGetNumInputs-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMFunctionTypeGetNumInputs-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMFunctionTypeGetNumInputs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMFunctionTypeGetNumInputs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of input types.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6326-L6330" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMFunctionTypeGetReturnType-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMFunctionTypeGetReturnType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMFunctionTypeGetReturnType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMFunctionTypeGetReturnType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the return type of the function type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6344-L6348" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMLinkageAttrGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirLLVMLinkageAttrGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMLinkageAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMLinkageAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, linkage)</span></span></code></pre></div><p>Creates a LLVM Linkage attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6580-L6584" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMPointerTypeGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirLLVMPointerTypeGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMPointerTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMPointerTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, addressSpace)</span></span></code></pre></div><p>Creates an llvm.ptr type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6258-L6262" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMPointerTypeGetAddressSpace-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMPointerTypeGetAddressSpace-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMPointerTypeGetAddressSpace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMPointerTypeGetAddressSpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pointerType)</span></span></code></pre></div><p>Returns address space of llvm.ptr</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6276-L6280" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMStructTypeGetElementType-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirLLVMStructTypeGetElementType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMStructTypeGetElementType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeGetElementType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, position)</span></span></code></pre></div><p>Returns the <code>positions</code>-th field of the struct. Asserts if the struct is opaque, not yet initialized or if the position is out of range.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6380-L6384" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMStructTypeGetIdentifier-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMStructTypeGetIdentifier-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMStructTypeGetIdentifier</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeGetIdentifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the identifier of the identified struct. Asserts that the struct is identified, i.e., not literal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6400-L6404" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMStructTypeGetNumElementTypes-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMStructTypeGetNumElementTypes-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMStructTypeGetNumElementTypes</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeGetNumElementTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of fields in the struct. Asserts if the struct is opaque or not yet initialized.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6371-L6375" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeIdentifiedGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, name)</span></span></code></pre></div><p>Creates an LLVM identified struct type with no body. If a struct type with this name already exists in the context, returns that type. Use <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedNewGet-NTuple{5, Any}"><code>mlirLLVMStructTypeIdentifiedNewGet</code></a> to create a fresh struct type, potentially renaming it. The body should be set separatelty by calling <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirLLVMStructTypeSetBody-NTuple{4, Any}"><code>mlirLLVMStructTypeSetBody</code></a>, if it isn&#39;t set already.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6440-L6444" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedNewGet-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedNewGet-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedNewGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeIdentifiedNewGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, name, nFieldTypes, fieldTypes, isPacked)</span></span></code></pre></div><p>Creates an LLVM identified struct type with no body and a name starting with the given prefix. If a struct with the exact name as the given prefix already exists, appends an unspecified suffix to the name so that the name is unique in context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6451-L6455" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMStructTypeIsLiteral-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMStructTypeIsLiteral-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMStructTypeIsLiteral</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeIsLiteral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the type is a literal (unnamed) LLVM struct type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6362-L6366" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMStructTypeIsOpaque-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMStructTypeIsOpaque-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMStructTypeIsOpaque</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeIsOpaque</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> is the struct is explicitly opaque (will not have a body) or uninitialized (will eventually have a body).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6409-L6413" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMStructTypeIsPacked-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMStructTypeIsPacked-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMStructTypeIsPacked</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeIsPacked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the struct is packed.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6391-L6395" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMStructTypeLiteralGet-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirLLVMStructTypeLiteralGet-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMStructTypeLiteralGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeLiteralGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, nFieldTypes, fieldTypes, isPacked)</span></span></code></pre></div><p>Creates an LLVM literal (unnamed) struct type. This may assert if the fields have types not compatible with the LLVM dialect. For a graceful failure, use the checked version.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6418-L6422" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMStructTypeLiteralGetChecked-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirLLVMStructTypeLiteralGetChecked-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMStructTypeLiteralGetChecked</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeLiteralGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, nFieldTypes, fieldTypes, isPacked)</span></span></code></pre></div><p>Creates an LLVM literal (unnamed) struct type if possible. Emits a diagnostic at the given location and returns null otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6429-L6433" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMStructTypeSetBody-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirLLVMStructTypeSetBody-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMStructTypeSetBody</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMStructTypeSetBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(structType, nFieldTypes, fieldTypes, isPacked)</span></span></code></pre></div><p>Sets the body of the identified struct if it hasn&#39;t been set yet. Returns whether the operation was successful.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6472-L6476" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLLVMVoidTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirLLVMVoidTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLLVMVoidTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLLVMVoidTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates an llmv.void type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6285-L6289" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLinalgFillBuiltinNamedOpRegion-Tuple{Any}" href="#Reactant.MLIR.API.mlirLinalgFillBuiltinNamedOpRegion-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLinalgFillBuiltinNamedOpRegion</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLinalgFillBuiltinNamedOpRegion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mlirOp)</span></span></code></pre></div><p>Apply the special region builder for the builtin named Linalg op. Assert that <code>mlirOp</code> is a builtin named Linalg op.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7073-L7077" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLlvmThreadPoolCreate-Tuple{}" href="#Reactant.MLIR.API.mlirLlvmThreadPoolCreate-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirLlvmThreadPoolCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLlvmThreadPoolCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Create an LLVM thread pool. This is reexported here to avoid directly pulling in the LLVM headers directly.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L160-L164" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLlvmThreadPoolDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirLlvmThreadPoolDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLlvmThreadPoolDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLlvmThreadPoolDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pool)</span></span></code></pre></div><p>Destroy an LLVM thread pool.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L169-L173" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLoadIRDLDialects-Tuple{Any}" href="#Reactant.MLIR.API.mlirLoadIRDLDialects-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLoadIRDLDialects</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLoadIRDLDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module)</span></span></code></pre></div><p>Loads all IRDL dialects in the provided module, registering the dialects in the module&#39;s associated context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6241-L6245" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLocationCallSiteGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirLocationCallSiteGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLocationCallSiteGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationCallSiteGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callee, caller)</span></span></code></pre></div><p>Creates a call site location with a callee and a caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L631-L635" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLocationEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirLocationEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLocationEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(l1, l2)</span></span></code></pre></div><p>Checks if two locations are equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L694-L698" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLocationFileLineColGet-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirLocationFileLineColGet-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLocationFileLineColGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFileLineColGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, filename, line, col)</span></span></code></pre></div><p>Creates an File/Line/Column location owned by the given context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L602-L606" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLocationFileLineColRangeGet-NTuple{6, Any}" href="#Reactant.MLIR.API.mlirLocationFileLineColRangeGet-NTuple{6, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLocationFileLineColRangeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFileLineColRangeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, filename, start_line, start_col, end_line, end_col)</span></span></code></pre></div><p>Creates an File/Line/Column range location owned by the given context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L613-L617" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLocationFromAttribute-Tuple{Any}" href="#Reactant.MLIR.API.mlirLocationFromAttribute-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLocationFromAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFromAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attribute)</span></span></code></pre></div><p>Creates a location from a location attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L593-L597" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLocationFusedGet-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirLocationFusedGet-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLocationFusedGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationFusedGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, nLocations, locations, metadata)</span></span></code></pre></div><p>Creates a fused location with an array of locations and metadata.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L642-L646" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLocationGetAttribute-Tuple{Any}" href="#Reactant.MLIR.API.mlirLocationGetAttribute-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLocationGetAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationGetAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Returns the underlying location attribute of this location.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L584-L588" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLocationGetContext-Tuple{Any}" href="#Reactant.MLIR.API.mlirLocationGetContext-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLocationGetContext</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Gets the context that a location was created with.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L676-L680" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLocationIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirLocationIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLocationIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Checks if the location is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L685-L689" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLocationNameGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirLocationNameGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLocationNameGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationNameGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, name, childLoc)</span></span></code></pre></div><p>Creates a name location owned by the given context. Providing null location for childLoc is allowed and if childLoc is null location, then the behavior is the same as having unknown child location.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L656-L660" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLocationPrint-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirLocationPrint-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLocationPrint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location, callback, userData)</span></span></code></pre></div><p>Prints a location by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L703-L707" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLocationUnknownGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirLocationUnknownGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLocationUnknownGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLocationUnknownGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Creates a location with unknown position owned by the given context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L667-L671" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLogicalResultFailure-Tuple{}" href="#Reactant.MLIR.API.mlirLogicalResultFailure-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirLogicalResultFailure</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLogicalResultFailure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a logical result representing a failure.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L151-L155" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLogicalResultIsFailure-Tuple{Any}" href="#Reactant.MLIR.API.mlirLogicalResultIsFailure-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLogicalResultIsFailure</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLogicalResultIsFailure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res)</span></span></code></pre></div><p>Checks if the given logical result represents a failure.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L133-L137" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLogicalResultIsSuccess-Tuple{Any}" href="#Reactant.MLIR.API.mlirLogicalResultIsSuccess-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirLogicalResultIsSuccess</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLogicalResultIsSuccess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res)</span></span></code></pre></div><p>Checks if the given logical result represents a success.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L124-L128" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirLogicalResultSuccess-Tuple{}" href="#Reactant.MLIR.API.mlirLogicalResultSuccess-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirLogicalResultSuccess</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirLogicalResultSuccess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a logical result representing a success.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L142-L146" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirMemRefTypeContiguousGet-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirMemRefTypeContiguousGet-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirMemRefTypeContiguousGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeContiguousGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, rank, shape, memorySpace)</span></span></code></pre></div><p>Creates a MemRef type with the given rank, shape, memory space and element type in the same context as the element type. The type has no affine maps, i.e. represents a default row-major contiguous memref. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5573-L5577" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirMemRefTypeContiguousGetChecked-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirMemRefTypeContiguousGetChecked-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirMemRefTypeContiguousGetChecked</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeContiguousGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, elementType, rank, shape, memorySpace)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirMemRefTypeContiguousGet-NTuple{4, Any}"><code>mlirMemRefTypeContiguousGet</code></a>&quot; but returns a nullptr wrapping <a href="./@ref"><code>MlirType</code></a> on illegal arguments, emitting appropriate diagnostics.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5584-L5588" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirMemRefTypeGet-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirMemRefTypeGet-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirMemRefTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, rank, shape, layout, memorySpace)</span></span></code></pre></div><p>Creates a MemRef type with the given rank and shape, a potentially empty list of affine layout maps, the given memory space and element type, in the same context as element type. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5542-L5546" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirMemRefTypeGetAffineMap-Tuple{Any}" href="#Reactant.MLIR.API.mlirMemRefTypeGetAffineMap-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirMemRefTypeGetAffineMap</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetAffineMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the affine map of the given MemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5630-L5634" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirMemRefTypeGetChecked-NTuple{6, Any}" href="#Reactant.MLIR.API.mlirMemRefTypeGetChecked-NTuple{6, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirMemRefTypeGetChecked</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, elementType, rank, shape, layout, memorySpace)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirMemRefTypeGet-NTuple{5, Any}"><code>mlirMemRefTypeGet</code></a>&quot; but returns a nullptr-wrapping <a href="./@ref"><code>MlirType</code></a> o illegal arguments, emitting appropriate diagnostics.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5557-L5561" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirMemRefTypeGetLayout-Tuple{Any}" href="#Reactant.MLIR.API.mlirMemRefTypeGetLayout-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirMemRefTypeGetLayout</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetLayout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the layout of the given MemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5621-L5625" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirMemRefTypeGetMemorySpace-Tuple{Any}" href="#Reactant.MLIR.API.mlirMemRefTypeGetMemorySpace-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirMemRefTypeGetMemorySpace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetMemorySpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the memory space of the given MemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5639-L5643" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirMemRefTypeGetStridesAndOffset-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirMemRefTypeGetStridesAndOffset-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirMemRefTypeGetStridesAndOffset</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetStridesAndOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, strides, offset)</span></span></code></pre></div><p>Returns the strides of the MemRef if the layout map is in strided form. Both strides and offset are out params. strides must point to pre-allocated memory of length equal to the rank of the memref.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5648-L5652" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirMemRefTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirMemRefTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirMemRefTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMemRefTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an MemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5506-L5510" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirMergeSymbolsIntoFromClone-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirMergeSymbolsIntoFromClone-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirMergeSymbolsIntoFromClone</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirMergeSymbolsIntoFromClone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, other)</span></span></code></pre></div><p>Merge the symbols from <code>other</code> into <code>target</code>, potentially renaming them to avoid conflicts. Private symbols may be renamed during the merge, public symbols must have at most one declaration. A name conflict in public symbols is reported as an error before returning a failure.</p><p>Note that this clones the <code>other</code> operation unlike the C++ counterpart that takes ownership.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7912-L7918" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirModuleCreateEmpty-Tuple{Any}" href="#Reactant.MLIR.API.mlirModuleCreateEmpty-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirModuleCreateEmpty</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleCreateEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location)</span></span></code></pre></div><p>Creates a new, empty module and transfers ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L714-L718" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirModuleCreateParse-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirModuleCreateParse-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirModuleCreateParse</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleCreateParse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, _module)</span></span></code></pre></div><p>Parses a module from the string and transfers ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L723-L727" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirModuleCreateParseFromFile-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirModuleCreateParseFromFile-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirModuleCreateParseFromFile</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleCreateParseFromFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, fileName)</span></span></code></pre></div><p>Parses a module from file and transfers ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L734-L738" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirModuleDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirModuleDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirModuleDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module)</span></span></code></pre></div><p>Takes a module owned by the caller and deletes it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L772-L776" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirModuleFromOperation-Tuple{Any}" href="#Reactant.MLIR.API.mlirModuleFromOperation-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirModuleFromOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleFromOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Views the generic operation as a module. The returned module is null when the input operation was not a ModuleOp.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L790-L794" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirModuleGetBody-Tuple{Any}" href="#Reactant.MLIR.API.mlirModuleGetBody-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirModuleGetBody</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleGetBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module)</span></span></code></pre></div><p>Gets the body of the module, i.e. the only block it contains.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L754-L758" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirModuleGetContext-Tuple{Any}" href="#Reactant.MLIR.API.mlirModuleGetContext-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirModuleGetContext</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module)</span></span></code></pre></div><p>Gets the context that a module was created with.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L745-L749" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirModuleGetOperation-Tuple{Any}" href="#Reactant.MLIR.API.mlirModuleGetOperation-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirModuleGetOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleGetOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module)</span></span></code></pre></div><p>Views the module as a generic operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L781-L785" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirModuleIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirModuleIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirModuleIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirModuleIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module)</span></span></code></pre></div><p>Checks whether a module is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L763-L767" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirNamedAttributeGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirNamedAttributeGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirNamedAttributeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirNamedAttributeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name, attr)</span></span></code></pre></div><p>Associates an attribute with the name. Takes ownership of neither.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2222-L2226" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirNoneTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirNoneTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirNoneTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirNoneTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a None type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5178-L5182" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirNoneTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirNoneTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirNoneTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirNoneTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an None type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5160-L5164" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpOperandGetNextUse-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpOperandGetNextUse-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpOperandGetNextUse</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpOperandGetNextUse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns an op operand representing the next use of the value, or a null op operand if there is no next use.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2054-L2058" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpOperandGetOperandNumber-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpOperandGetOperandNumber-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpOperandGetOperandNumber</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpOperandGetOperandNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns the operand number of an op operand.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2045-L2049" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpOperandGetOwner-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpOperandGetOwner-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpOperandGetOwner</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpOperandGetOwner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns the owner operation of an op operand.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2036-L2040" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpOperandGetValue-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpOperandGetValue-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpOperandGetValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpOperandGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns the value of an op operand.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2027-L2031" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpOperandIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpOperandIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpOperandIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpOperandIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opOperand)</span></span></code></pre></div><p>Returns whether the op operand is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2018-L2022" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpPassManagerAddOwnedPass-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOpPassManagerAddOwnedPass-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpPassManagerAddOwnedPass</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPassManagerAddOwnedPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, pass)</span></span></code></pre></div><p>Add a pass and transfer ownership to the provided mlirOpPassManager. If the pass is not a generic operation pass or matching the type of the provided PassManager, a new OpPassManager is implicitly nested under the provided PassManager.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8286-L8290" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpPassManagerAddPipeline-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirOpPassManagerAddPipeline-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpPassManagerAddPipeline</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPassManagerAddPipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, pipelineElements, callback, userData)</span></span></code></pre></div><p>Parse a sequence of textual MLIR pass pipeline elements and add them to the provided OpPassManager. If parsing fails an error message is reported using the provided callback.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8297-L8301" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpPassManagerGetNestedUnder-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOpPassManagerGetNestedUnder-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpPassManagerGetNestedUnder</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPassManagerGetNestedUnder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, operationName)</span></span></code></pre></div><p>Nest an OpPassManager under the provided OpPassManager, the nested passmanager will only run on operations matching the provided name. The returned OpPassManager will be destroyed when the parent is destroyed.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8264-L8268" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpPrintingFlagsAssumeVerified-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpPrintingFlagsAssumeVerified-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpPrintingFlagsAssumeVerified</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsAssumeVerified</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags)</span></span></code></pre></div><p>Do not verify the operation when using custom operation printers.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L979-L983" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpPrintingFlagsCreate-Tuple{}" href="#Reactant.MLIR.API.mlirOpPrintingFlagsCreate-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirOpPrintingFlagsCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates new printing flags with defaults, intended for customization. Must be freed with a call to <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOpPrintingFlagsDestroy-Tuple{Any}"><code>mlirOpPrintingFlagsDestroy</code></a>().</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L910-L914" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpPrintingFlagsDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpPrintingFlagsDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpPrintingFlagsDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags)</span></span></code></pre></div><p>Destroys printing flags created with <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOpPrintingFlagsCreate-Tuple{}"><code>mlirOpPrintingFlagsCreate</code></a>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L919-L923" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeElementsAttrs-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeElementsAttrs-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeElementsAttrs</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsElideLargeElementsAttrs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, largeElementLimit)</span></span></code></pre></div><p>Enables the elision of large elements attributes by printing a lexically valid but otherwise meaningless form instead of the element data. The <code>largeElementLimit</code> is used to configure what is considered to be a &quot;large&quot; ElementsAttr by providing an upper limit to the number of elements.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L928-L932" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeResourceString-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeResourceString-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeResourceString</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsElideLargeResourceString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, largeResourceLimit)</span></span></code></pre></div><p>Enables the elision of large resources strings by omitting them from the <code>dialect_resources</code> section. The <code>largeResourceLimit</code> is used to configure what is considered to be a &quot;large&quot; resource by providing an upper limit to the string size.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L939-L943" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpPrintingFlagsEnableDebugInfo-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOpPrintingFlagsEnableDebugInfo-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpPrintingFlagsEnableDebugInfo</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsEnableDebugInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, enable, prettyForm)</span></span></code></pre></div><p>Enable or disable printing of debug information (based on <code>enable</code>). If &#39;prettyForm&#39; is set to true, debug information is printed in a more readable &#39;pretty&#39; form. Note: The IR generated with &#39;prettyForm&#39; is not parsable.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L950-L954" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpPrintingFlagsPrintGenericOpForm-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpPrintingFlagsPrintGenericOpForm-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpPrintingFlagsPrintGenericOpForm</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsPrintGenericOpForm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags)</span></span></code></pre></div><p>Always print operations in the generic form.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L961-L965" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpPrintingFlagsSkipRegions-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpPrintingFlagsSkipRegions-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpPrintingFlagsSkipRegions</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsSkipRegions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags)</span></span></code></pre></div><p>Skip printing regions.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L988-L992" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpPrintingFlagsUseLocalScope-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpPrintingFlagsUseLocalScope-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpPrintingFlagsUseLocalScope</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpPrintingFlagsUseLocalScope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags)</span></span></code></pre></div><p>Use local scope when printing the operation. This allows for using the printer in a more localized and thread-safe setting, but may not necessarily be identical to what the IR will look like when dumping the full module.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L970-L974" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpResultGetOwner-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpResultGetOwner-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpResultGetOwner</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpResultGetOwner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns an operation that produced this value as its result. Asserts if the value is not an op result.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1916-L1920" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpResultGetResultNumber-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpResultGetResultNumber-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpResultGetResultNumber</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpResultGetResultNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the position of the value in the list of results of the operation that produced it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1925-L1929" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpaqueAttrGet-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirOpaqueAttrGet-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpaqueAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, dialectNamespace, dataLength, data, type)</span></span></code></pre></div><p>Creates an opaque attribute in the given context associated with the dialect identified by its namespace. The attribute contains opaque byte data of the specified length (data need not be null-terminated).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3510-L3514" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpaqueAttrGetData-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpaqueAttrGetData-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpaqueAttrGetData</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueAttrGetData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the raw data as a string reference. The data remains live as long as the context in which the attribute lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3534-L3538" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpaqueAttrGetDialectNamespace-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpaqueAttrGetDialectNamespace-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpaqueAttrGetDialectNamespace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueAttrGetDialectNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the namespace of the dialect with which the given opaque attribute is associated. The namespace string is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3525-L3529" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpaqueAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirOpaqueAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirOpaqueAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Opaque attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3543-L3547" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpaqueTypeGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOpaqueTypeGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpaqueTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, dialectNamespace, typeData)</span></span></code></pre></div><p>Creates an opaque type in the given context associated with the dialect identified by its namespace. The type contains opaque byte data of the specified length (data need not be null-terminated).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5802-L5806" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpaqueTypeGetData-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpaqueTypeGetData-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpaqueTypeGetData</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueTypeGetData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the raw data as a string reference. The data remains live as long as the context in which the type lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5822-L5826" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpaqueTypeGetDialectNamespace-Tuple{Any}" href="#Reactant.MLIR.API.mlirOpaqueTypeGetDialectNamespace-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOpaqueTypeGetDialectNamespace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueTypeGetDialectNamespace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the namespace of the dialect with which the given opaque type is associated. The namespace string is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5813-L5817" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOpaqueTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirOpaqueTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirOpaqueTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOpaqueTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Opaque type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5784-L5788" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationClone-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationClone-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationClone</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationClone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Creates a deep copy of an operation. The operation is not inserted and ownership is transferred to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1050-L1054" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationCreate-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationCreate-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state)</span></span></code></pre></div><p>Creates an operation and transfers ownership to the caller. Note that caller owned child objects are transferred in this call and must not be further used. Particularly, this applies to any regions added to the state (the implementation may invalidate any such pointers).</p><p>This call can fail under the following conditions, in which case, it will return a null operation and emit diagnostics: - Result type inference is enabled and cannot be performed.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1026-L1032" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationCreateParse-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOperationCreateParse-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationCreateParse</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationCreateParse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, sourceStr, sourceName)</span></span></code></pre></div><p>Parses an operation, giving ownership to the caller. If parsing fails a null operation will be returned, and an error diagnostic emitted.</p><p><code>sourceStr</code> may be either the text assembly format, or binary bytecode format. <code>sourceName</code> is used as the file name of the source; any IR without locations will get a <code>FileLineColLoc</code> location with <code>sourceName</code> as the file name.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1037-L1043" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Takes an operation owned by the caller and destroys it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1059-L1063" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationDump-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationDump-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationDump</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Prints an operation to stderr.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1466-L1470" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, other)</span></span></code></pre></div><p>Checks whether two operation handles point to the same operation. This does not perform deep comparison.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1086-L1090" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetAttribute-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationGetAttribute-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos)</span></span></code></pre></div><p>Return <code>pos</code>-th attribute of the operation. Deprecated, please use <code>mlirOperationGetInherentAttribute</code> or <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationGetDiscardableAttribute-Tuple{Any, Any}"><code>mlirOperationGetDiscardableAttribute</code></a>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1358-L1362" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetAttributeByName-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationGetAttributeByName-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetAttributeByName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Returns an attribute attached to the operation given its name. Deprecated, please use <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationGetInherentAttributeByName-Tuple{Any, Any}"><code>mlirOperationGetInherentAttributeByName</code></a> or <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationGetDiscardableAttributeByName-Tuple{Any, Any}"><code>mlirOperationGetDiscardableAttributeByName</code></a>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1369-L1373" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetBlock-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetBlock-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetBlock</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the block that owns this operation, returning null if the operation is not owned.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1131-L1135" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetContext-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetContext-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetContext</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the context this operation is associated with</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1095-L1099" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetDiscardableAttribute-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationGetDiscardableAttribute-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetDiscardableAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetDiscardableAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos)</span></span></code></pre></div><p>Return <code>pos</code>-th discardable attribute of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1305-L1309" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetDiscardableAttributeByName-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationGetDiscardableAttributeByName-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetDiscardableAttributeByName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetDiscardableAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Returns a discardable attribute attached to the operation given its name.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1316-L1320" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetFirstRegion-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetFirstRegion-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetFirstRegion</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetFirstRegion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns first region attached to the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1630-L1634" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetInherentAttributeByName-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationGetInherentAttributeByName-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetInherentAttributeByName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetInherentAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Returns an inherent attribute attached to the operation given its name.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1274-L1278" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetLocation-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetLocation-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetLocation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetLocation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the location of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1104-L1108" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetName-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetName-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the name of the operation as an identifier.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1122-L1126" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetNextInBlock-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetNextInBlock-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetNextInBlock</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNextInBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns an operation immediately following the given operation it its enclosing block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1167-L1171" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetNumAttributes-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetNumAttributes-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetNumAttributes</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNumAttributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of attributes attached to the operation. Deprecated, please use <code>mlirOperationGetNumInherentAttributes</code> or <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationGetNumDiscardableAttributes-Tuple{Any}"><code>mlirOperationGetNumDiscardableAttributes</code></a>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1349-L1353" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetNumDiscardableAttributes-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetNumDiscardableAttributes-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetNumDiscardableAttributes</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNumDiscardableAttributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of discardable attributes attached to the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1296-L1300" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetNumOperands-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetNumOperands-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetNumOperands</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNumOperands</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of operands of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1176-L1180" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetNumRegions-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetNumRegions-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetNumRegions</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNumRegions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of regions attached to the given operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1149-L1153" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetNumResults-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetNumResults-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetNumResults</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNumResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of results of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1216-L1220" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetNumSuccessors-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetNumSuccessors-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetNumSuccessors</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetNumSuccessors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Returns the number of successor blocks of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1234-L1238" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetOperand-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationGetOperand-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetOperand</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetOperand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th operand of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1185-L1189" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetParentOperation-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetParentOperation-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetParentOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetParentOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the operation that owns this operation, returning null if the operation is not owned.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1140-L1144" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetRegion-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationGetRegion-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetRegion</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetRegion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th region attached to the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1158-L1162" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetResult-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationGetResult-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetResult</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th result of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1225-L1229" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetSuccessor-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationGetSuccessor-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetSuccessor</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetSuccessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th successor of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1243-L1247" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationGetTypeID-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationGetTypeID-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Gets the type id of the operation. Returns null if the operation does not have a registered operation description.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1113-L1117" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationHasInherentAttributeByName-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationHasInherentAttributeByName-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationHasInherentAttributeByName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationHasInherentAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Returns true if this operation defines an inherent attribute with this name. Note: the attribute can be optional, so <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationGetInherentAttributeByName-Tuple{Any, Any}"><code>mlirOperationGetInherentAttributeByName</code></a> can still return a null attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1263-L1267" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationImplementsInterface-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationImplementsInterface-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationImplementsInterface</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationImplementsInterface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(operation, interfaceTypeID)</span></span></code></pre></div><p>Returns <code>true</code> if the given operation implements an interface identified by its TypeID.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8021-L8025" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationImplementsInterfaceStatic-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOperationImplementsInterfaceStatic-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationImplementsInterfaceStatic</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationImplementsInterfaceStatic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(operationName, context, interfaceTypeID)</span></span></code></pre></div><p>Returns <code>true</code> if the operation identified by its canonical string name implements the interface identified by its TypeID in the given context. Note that interfaces may be attached to operations in some contexts and not others.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8032-L8036" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Checks whether the underlying operation is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1077-L1081" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationMoveAfter-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationMoveAfter-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationMoveAfter</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationMoveAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, other)</span></span></code></pre></div><p>Moves the given operation immediately after the other operation in its parent block. The given operation may be owned by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1484-L1488" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationMoveBefore-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationMoveBefore-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationMoveBefore</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationMoveBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, other)</span></span></code></pre></div><p>Moves the given operation immediately before the other operation in its parent block. The given operation may be owner by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1493-L1497" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationPrint-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOperationPrint-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationPrint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationPrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, callback, userData)</span></span></code></pre></div><p>Prints an operation by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1402-L1406" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationPrintWithFlags-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirOperationPrintWithFlags-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationPrintWithFlags</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationPrintWithFlags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, flags, callback, userData)</span></span></code></pre></div><p>Same as <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationPrint-Tuple{Any, Any, Any}"><code>mlirOperationPrint</code></a> but accepts flags controlling the printing behavior.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1413-L1417" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationPrintWithState-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirOperationPrintWithState-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationPrintWithState</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationPrintWithState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, state, callback, userData)</span></span></code></pre></div><p>Same as <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationPrint-Tuple{Any, Any, Any}"><code>mlirOperationPrint</code></a> but accepts AsmState controlling the printing behavior as well as caching computed names.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1427-L1431" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationRemoveAttributeByName-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationRemoveAttributeByName-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationRemoveAttributeByName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationRemoveAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Removes an attribute by name. Returns false if the attribute was not found and true if removed. Deprecated, please use <code>mlirOperationRemoveInherentAttributeByName</code> or <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationRemoveDiscardableAttributeByName-Tuple{Any, Any}"><code>mlirOperationRemoveDiscardableAttributeByName</code></a>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1391-L1395" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationRemoveDiscardableAttributeByName-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationRemoveDiscardableAttributeByName-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationRemoveDiscardableAttributeByName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationRemoveDiscardableAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name)</span></span></code></pre></div><p>Removes a discardable attribute by name. Returns false if the attribute was not found and true if removed.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1338-L1342" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationRemoveFromParent-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationRemoveFromParent-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationRemoveFromParent</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationRemoveFromParent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Removes the given operation from its parent block. The operation is not destroyed. The ownership of the operation is transferred to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1068-L1072" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationSetAttributeByName-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOperationSetAttributeByName-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationSetAttributeByName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name, attr)</span></span></code></pre></div><p>Sets an attribute by name, replacing the existing if it exists or adding a new one otherwise. Deprecated, please use <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationSetInherentAttributeByName-Tuple{Any, Any, Any}"><code>mlirOperationSetInherentAttributeByName</code></a> or <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationSetDiscardableAttributeByName-Tuple{Any, Any, Any}"><code>mlirOperationSetDiscardableAttributeByName</code></a>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1380-L1384" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationSetDiscardableAttributeByName-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOperationSetDiscardableAttributeByName-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationSetDiscardableAttributeByName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetDiscardableAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name, attr)</span></span></code></pre></div><p>Sets a discardable attribute by name, replacing the existing if it exists or adding a new one otherwise. The new <code>attr</code> Attribute is not allowed to be null, use <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationRemoveDiscardableAttributeByName-Tuple{Any, Any}"><code>mlirOperationRemoveDiscardableAttributeByName</code></a> to remove an Attribute instead.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1327-L1331" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationSetInherentAttributeByName-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOperationSetInherentAttributeByName-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationSetInherentAttributeByName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetInherentAttributeByName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, name, attr)</span></span></code></pre></div><p>Sets an inherent attribute by name, replacing the existing if it exists. This has no effect if &quot;name&quot; does not match an inherent attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1285-L1289" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationSetOperand-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOperationSetOperand-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationSetOperand</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetOperand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos, newValue)</span></span></code></pre></div><p>Sets the <code>pos</code>-th operand of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1194-L1198" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationSetOperands-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOperationSetOperands-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationSetOperands</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetOperands</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, nOperands, operands)</span></span></code></pre></div><p>Replaces the operands of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1205-L1209" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationSetSuccessor-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOperationSetSuccessor-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationSetSuccessor</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationSetSuccessor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, pos, block)</span></span></code></pre></div><p>Set <code>pos</code>-th successor of the operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1252-L1256" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationStateAddResults-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOperationStateAddResults-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationStateAddResults</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationStateAddResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state, n, results)</span></span></code></pre></div><p>Adds a list of components to the operation state.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L833-L837" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationStateEnableResultTypeInference-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationStateEnableResultTypeInference-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationStateEnableResultTypeInference</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationStateEnableResultTypeInference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state)</span></span></code></pre></div><p>Enables result type inference for the operation under construction. If enabled, then the caller must not have called <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationStateAddResults-Tuple{Any, Any, Any}"><code>mlirOperationStateAddResults</code></a>(). Note that if enabled, the <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationCreate-Tuple{Any}"><code>mlirOperationCreate</code></a>() call is failable: it will return a null operation on inference failure and will emit diagnostics.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L868-L872" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationStateGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirOperationStateGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationStateGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationStateGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name, loc)</span></span></code></pre></div><p>Constructs an operation state from a name and a location.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L822-L826" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationVerify-Tuple{Any}" href="#Reactant.MLIR.API.mlirOperationVerify-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationVerify</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationVerify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op)</span></span></code></pre></div><p>Verify the operation and return true if it passes, false if it fails.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1475-L1479" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationWalk-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirOperationWalk-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationWalk</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationWalk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, callback, userData, walkOrder)</span></span></code></pre></div><p>Walks operation <code>op</code> in <code>walkOrder</code> and calls <code>callback</code> on that operation. <code>*userData</code> is passed to the callback as well and can be used to tunnel some context or other data into the callback.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1529-L1533" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationWriteBytecode-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirOperationWriteBytecode-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationWriteBytecode</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationWriteBytecode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, callback, userData)</span></span></code></pre></div><p>Same as <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationPrint-Tuple{Any, Any, Any}"><code>mlirOperationPrint</code></a> but writing the bytecode format.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1441-L1445" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirOperationWriteBytecodeWithConfig-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirOperationWriteBytecodeWithConfig-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirOperationWriteBytecodeWithConfig</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirOperationWriteBytecodeWithConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(op, config, callback, userData)</span></span></code></pre></div><p>Same as <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirOperationWriteBytecode-Tuple{Any, Any, Any}"><code>mlirOperationWriteBytecode</code></a> but with writer config and returns failure only if desired bytecode could not be honored.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1452-L1456" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirParsePassPipeline-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirParsePassPipeline-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirParsePassPipeline</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirParsePassPipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, pipeline, callback, userData)</span></span></code></pre></div><p>Parse a textual MLIR pass pipeline and assign it to the provided OpPassManager. If parsing fails an error message is reported using the provided callback.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8322-L8326" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirPassManagerAddOwnedPass-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirPassManagerAddOwnedPass-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirPassManagerAddOwnedPass</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerAddOwnedPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, pass)</span></span></code></pre></div><p>Add a pass and transfer ownership to the provided top-level mlirPassManager. If the pass is not a generic operation pass or a ModulePass, a new OpPassManager is implicitly nested under the provided PassManager.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8275-L8279" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirPassManagerCreate-Tuple{Any}" href="#Reactant.MLIR.API.mlirPassManagerCreate-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirPassManagerCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Create a new top-level PassManager with the default anchor.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8155-L8159" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirPassManagerCreateOnOperation-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirPassManagerCreateOnOperation-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirPassManagerCreateOnOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerCreateOnOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, anchorOp)</span></span></code></pre></div><p>Create a new top-level PassManager anchored on <code>anchorOp</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8164-L8168" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirPassManagerDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirPassManagerDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirPassManagerDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager)</span></span></code></pre></div><p>Destroy the provided PassManager.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8175-L8179" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirPassManagerEnableIRPrinting-NTuple{8, Any}" href="#Reactant.MLIR.API.mlirPassManagerEnableIRPrinting-NTuple{8, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirPassManagerEnableIRPrinting</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerEnableIRPrinting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, printBeforeAll, printAfterAll, printModuleScope, printAfterOnlyOnChange, printAfterOnlyOnFailure, flags, treePrintingPath)</span></span></code></pre></div><p>Enable IR printing. The treePrintingPath argument is an optional path to a directory where the dumps will be produced. If it isn&#39;t provided then dumps are produced to stderr.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8215-L8219" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirPassManagerEnableVerifier-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirPassManagerEnableVerifier-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirPassManagerEnableVerifier</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerEnableVerifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, enable)</span></span></code></pre></div><p>Enable / disable verify-each.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8242-L8246" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirPassManagerGetAsOpPassManager-Tuple{Any}" href="#Reactant.MLIR.API.mlirPassManagerGetAsOpPassManager-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirPassManagerGetAsOpPassManager</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerGetAsOpPassManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager)</span></span></code></pre></div><p>Cast a top-level PassManager to a generic OpPassManager.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8193-L8197" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirPassManagerGetNestedUnder-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirPassManagerGetNestedUnder-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirPassManagerGetNestedUnder</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerGetNestedUnder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, operationName)</span></span></code></pre></div><p>Nest an OpPassManager under the top-level PassManager, the nested passmanager will only run on operations matching the provided name. The returned OpPassManager will be destroyed when the parent is destroyed. To further nest more OpPassManager under the newly returned one, see <code>mlirOpPassManagerNest</code> below.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8253-L8257" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirPassManagerIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirPassManagerIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirPassManagerIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager)</span></span></code></pre></div><p>Checks if a PassManager is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8184-L8188" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirPassManagerRunOnOp-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirPassManagerRunOnOp-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirPassManagerRunOnOp</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPassManagerRunOnOp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, op)</span></span></code></pre></div><p>Run the provided <code>passManager</code> on the given <code>op</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8204-L8208" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirPrintPassPipeline-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirPrintPassPipeline-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirPrintPassPipeline</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirPrintPassPipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(passManager, callback, userData)</span></span></code></pre></div><p>Print a textual MLIR pass pipeline by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8311-L8315" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeCastExpressedToStorageType-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeCastExpressedToStorageType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeCastExpressedToStorageType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeCastExpressedToStorageType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, candidate)</span></span></code></pre></div><p>Casts from a type based on the expressed type of the given quantized type to equivalent type based on storage type of the same quantized type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7346-L7350" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeCastFromExpressedType-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeCastFromExpressedType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeCastFromExpressedType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeCastFromExpressedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, candidate)</span></span></code></pre></div><p>Casts from a type based on the expressed type of the given type to a corresponding type based on the given type. Returns a null type if the cast is not valid.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7326-L7330" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeCastFromStorageType-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeCastFromStorageType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeCastFromStorageType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeCastFromStorageType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, candidate)</span></span></code></pre></div><p>Casts from a type based on the storage type of the given type to a corresponding type based on the given type. Returns a null type if the cast is not valid.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7306-L7310" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeCastToExpressedType-Tuple{Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeCastToExpressedType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeCastToExpressedType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeCastToExpressedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Casts from a type based on a quantized type to a corresponding typed based on the expressed type. Returns a null type if the cast is not valid.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7337-L7341" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeCastToStorageType-Tuple{Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeCastToStorageType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeCastToStorageType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeCastToStorageType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Casts from a type based on a quantized type to a corresponding typed based on the storage type. Returns a null type if the cast is not valid.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7317-L7321" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMaximumForInteger-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMaximumForInteger-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMaximumForInteger</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetDefaultMaximumForInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(isSigned, integralWidth)</span></span></code></pre></div><p>Returns the maximum possible value stored by a quantized type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7212-L7216" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMinimumForInteger-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMinimumForInteger-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMinimumForInteger</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetDefaultMinimumForInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(isSigned, integralWidth)</span></span></code></pre></div><p>Returns the minimum possible value stored by a quantized type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7201-L7205" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeGetExpressedType-Tuple{Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeGetExpressedType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeGetExpressedType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetExpressedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the original type approximated by the given quantized type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7223-L7227" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeGetFlags-Tuple{Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeGetFlags-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeGetFlags</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetFlags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the flags associated with the given quantized type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7232-L7236" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeGetQuantizedElementType-Tuple{Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeGetQuantizedElementType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeGetQuantizedElementType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetQuantizedElementType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the element type of the given quantized type as another quantized type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7297-L7301" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeGetSignedFlag-Tuple{}" href="#Reactant.MLIR.API.mlirQuantizedTypeGetSignedFlag-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeGetSignedFlag</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetSignedFlag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the bit flag used to indicate signedness of a quantized type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7192-L7196" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeGetStorageType-Tuple{Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeGetStorageType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeGetStorageType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetStorageType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the underlying type used to store the values.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7250-L7254" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeIntegralWidth-Tuple{Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeIntegralWidth-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeIntegralWidth</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetStorageTypeIntegralWidth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the integral bitwidth that the storage type of the given quantized type can represent exactly.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7277-L7281" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMax-Tuple{Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMax-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMax</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetStorageTypeMax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the maximum value that the storage type of the given quantized type can take.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7268-L7272" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMin-Tuple{Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMin-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMin</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeGetStorageTypeMin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the minimum value that the storage type of the given quantized type can take.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7259-L7263" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeIsCompatibleExpressedType-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeIsCompatibleExpressedType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeIsCompatibleExpressedType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeIsCompatibleExpressedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, candidate)</span></span></code></pre></div><p>Returns <code>true</code> if the <code>candidate</code> type is compatible with the given quantized <code>type</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7286-L7290" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirQuantizedTypeIsSigned-Tuple{Any}" href="#Reactant.MLIR.API.mlirQuantizedTypeIsSigned-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirQuantizedTypeIsSigned</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirQuantizedTypeIsSigned</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is signed, <code>false</code> otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7241-L7245" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRankedTensorTypeGet-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirRankedTensorTypeGet-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRankedTensorTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRankedTensorTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rank, shape, elementType, encoding)</span></span></code></pre></div><p>Creates a tensor type of a fixed rank with the given shape, element type, and optional encoding in the same context as the element type. The type is owned by the context. Tensor types without any specific encoding field should assign <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirAttributeGetNull-Tuple{}"><code>mlirAttributeGetNull</code></a>() to this parameter.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5451-L5455" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRankedTensorTypeGetChecked-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirRankedTensorTypeGetChecked-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRankedTensorTypeGetChecked</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRankedTensorTypeGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, rank, shape, elementType, encoding)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirRankedTensorTypeGet-NTuple{4, Any}"><code>mlirRankedTensorTypeGet</code></a>&quot; but returns a nullptr wrapping <a href="./@ref"><code>MlirType</code></a> on illegal arguments, emitting appropriate diagnostics.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5462-L5466" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRankedTensorTypeGetEncoding-Tuple{Any}" href="#Reactant.MLIR.API.mlirRankedTensorTypeGetEncoding-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRankedTensorTypeGetEncoding</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRankedTensorTypeGetEncoding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the &#39;encoding&#39; attribute from the ranked tensor type, returning a null attribute if none.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5477-L5481" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRankedTensorTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirRankedTensorTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirRankedTensorTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRankedTensorTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an RankedTensor type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5415-L5419" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegionAppendOwnedBlock-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRegionAppendOwnedBlock-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRegionAppendOwnedBlock</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionAppendOwnedBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, block)</span></span></code></pre></div><p>Takes a block owned by the caller and appends it to the given region.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1588-L1592" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegionCreate-Tuple{}" href="#Reactant.MLIR.API.mlirRegionCreate-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirRegionCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a new empty region and transfers ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1543-L1547" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegionDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirRegionDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRegionDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region)</span></span></code></pre></div><p>Takes a region owned by the caller and destroys it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1552-L1556" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegionEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRegionEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRegionEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, other)</span></span></code></pre></div><p>Checks whether two region handles point to the same region. This does not perform deep comparison.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1570-L1574" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegionGetFirstBlock-Tuple{Any}" href="#Reactant.MLIR.API.mlirRegionGetFirstBlock-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRegionGetFirstBlock</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionGetFirstBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region)</span></span></code></pre></div><p>Gets the first block in the region.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1579-L1583" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegionGetNextInOperation-Tuple{Any}" href="#Reactant.MLIR.API.mlirRegionGetNextInOperation-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRegionGetNextInOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionGetNextInOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region)</span></span></code></pre></div><p>Returns the region immediately following the given region in its parent operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1639-L1643" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegionInsertOwnedBlock-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirRegionInsertOwnedBlock-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRegionInsertOwnedBlock</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionInsertOwnedBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, pos, block)</span></span></code></pre></div><p>Takes a block owned by the caller and inserts it at <code>pos</code> to the given region. This is an expensive operation that linearly scans the region, prefer insertAfter/Before instead.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1597-L1601" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegionInsertOwnedBlockAfter-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirRegionInsertOwnedBlockAfter-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRegionInsertOwnedBlockAfter</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionInsertOwnedBlockAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, reference, block)</span></span></code></pre></div><p>Takes a block owned by the caller and inserts it after the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, prepends the block to the region.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1608-L1612" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegionInsertOwnedBlockBefore-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirRegionInsertOwnedBlockBefore-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRegionInsertOwnedBlockBefore</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionInsertOwnedBlockBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region, reference, block)</span></span></code></pre></div><p>Takes a block owned by the caller and inserts it before the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, appends the block to the region.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1619-L1623" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegionIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirRegionIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRegionIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(region)</span></span></code></pre></div><p>Checks whether a region is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1561-L1565" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegionTakeBody-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRegionTakeBody-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRegionTakeBody</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegionTakeBody</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, source)</span></span></code></pre></div><p>Moves the entire content of the source region to the target region.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1648-L1652" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegisterAllDialects-Tuple{Any}" href="#Reactant.MLIR.API.mlirRegisterAllDialects-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRegisterAllDialects</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegisterAllDialects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(registry)</span></span></code></pre></div><p>Appends all upstream dialects and extensions to the dialect registry.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8395-L8399" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegisterAllLLVMTranslations-Tuple{Any}" href="#Reactant.MLIR.API.mlirRegisterAllLLVMTranslations-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRegisterAllLLVMTranslations</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegisterAllLLVMTranslations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context)</span></span></code></pre></div><p>Register all translations to LLVM IR for dialects that can support it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8404-L8408" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRegisterAllPasses-Tuple{}" href="#Reactant.MLIR.API.mlirRegisterAllPasses-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirRegisterAllPasses</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRegisterAllPasses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Register all compiler passes of MLIR.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8413-L8417" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseCancelOpModification-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseCancelOpModification-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseCancelOpModification</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseCancelOpModification</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>This method cancels a pending in-place modification. This can only be called on operations that were provided to a call to <code>startOpModification</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8737-L8741" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseClearInsertionPoint-Tuple{Any}" href="#Reactant.MLIR.API.mlirRewriterBaseClearInsertionPoint-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseClearInsertionPoint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseClearInsertionPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter)</span></span></code></pre></div><p>Reset the insertion point to no location. Creating an operation without a set insertion point is an error, but this can still be useful when the current insertion point a builder refers to is being removed.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8447-L8451" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseClone-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseClone-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseClone</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseClone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>Creates a deep copy of the specified operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8557-L8561" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseCloneRegionBefore-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseCloneRegionBefore-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseCloneRegionBefore</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseCloneRegionBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, region, before)</span></span></code></pre></div><p>Clone the blocks that belong to &quot;region&quot; before the given position in another region &quot;parent&quot;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8579-L8583" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseCloneWithoutRegions-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseCloneWithoutRegions-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseCloneWithoutRegions</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseCloneWithoutRegions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>Creates a deep copy of this operation but keep the operation regions empty.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8568-L8572" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseCreateBlockBefore-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseCreateBlockBefore-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseCreateBlockBefore</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseCreateBlockBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, insertBefore, nArgTypes, argTypes, locations)</span></span></code></pre></div><p>Add new block with &#39;argTypes&#39; arguments and set the insertion point to the end of it. The block is placed before &#39;insertBefore&#39;. <code>locs</code> contains the locations of the inserted arguments, and should match the size of <code>argTypes</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8529-L8533" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseEraseBlock-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseEraseBlock-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseEraseBlock</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseEraseBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, block)</span></span></code></pre></div><p>Erases a block along with all operations inside it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8637-L8641" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseEraseOp-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseEraseOp-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseEraseOp</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseEraseOp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>Erases an operation that is known to have no uses.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8626-L8630" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseFinalizeOpModification-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseFinalizeOpModification-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseFinalizeOpModification</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseFinalizeOpModification</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>This method is used to signal the end of an in-place modification of the given operation. This can only be called on operations that were provided to a call to <code>startOpModification</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8726-L8730" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseGetBlock-Tuple{Any}" href="#Reactant.MLIR.API.mlirRewriterBaseGetBlock-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseGetBlock</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseGetBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter)</span></span></code></pre></div><p>Returns the current block of the rewriter.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8520-L8524" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseGetContext-Tuple{Any}" href="#Reactant.MLIR.API.mlirRewriterBaseGetContext-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseGetContext</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter)</span></span></code></pre></div><p>Get the MLIR context referenced by the rewriter.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8438-L8442" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseGetInsertionBlock-Tuple{Any}" href="#Reactant.MLIR.API.mlirRewriterBaseGetInsertionBlock-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseGetInsertionBlock</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseGetInsertionBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter)</span></span></code></pre></div><p>Return the block the current insertion point belongs to. Note that the insertion point is not necessarily the end of the block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8511-L8515" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseInlineBlockBefore-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseInlineBlockBefore-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseInlineBlockBefore</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseInlineBlockBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, source, op, nArgValues, argValues)</span></span></code></pre></div><p>Inline the operations of block &#39;source&#39; before the operation &#39;op&#39;. The source block will be deleted and must have no uses. &#39;argValues&#39; is used to replace the block arguments of &#39;source&#39;</p><p>The source block must have no successors. Otherwise, the resulting IR would have unreachable operations.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8648-L8654" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseInlineRegionBefore-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseInlineRegionBefore-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseInlineRegionBefore</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseInlineRegionBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, region, before)</span></span></code></pre></div><p>Move the blocks that belong to &quot;region&quot; before the given position in another region &quot;parent&quot;. The two regions must be different. The caller is responsible for creating or updating the operation transferring flow of control to the region and passing it the correct block arguments.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8590-L8594" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseInsert-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseInsert-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseInsert</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseInsert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>Insert the given operation at the current insertion point and return it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8546-L8550" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseMergeBlocks-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseMergeBlocks-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseMergeBlocks</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseMergeBlocks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, source, dest, nArgValues, argValues)</span></span></code></pre></div><p>Inline the operations of block &#39;source&#39; into the end of block &#39;dest&#39;. The source block will be deleted and must have no uses. &#39;argValues&#39; is used to replace the block arguments of &#39;source&#39;</p><p>The dest block must have no successors. Otherwise, the resulting IR would have unreachable operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8665-L8671" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseMoveBlockBefore-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseMoveBlockBefore-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseMoveBlockBefore</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseMoveBlockBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, block, existingBlock)</span></span></code></pre></div><p>Unlink this block and insert it right before <code>existingBlock</code>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8704-L8708" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseMoveOpAfter-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseMoveOpAfter-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseMoveOpAfter</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseMoveOpAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op, existingOp)</span></span></code></pre></div><p>Unlink this operation from its current block and insert it right after <code>existingOp</code> which may be in the same or another block in the same function.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8693-L8697" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseMoveOpBefore-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseMoveOpBefore-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseMoveOpBefore</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseMoveOpBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op, existingOp)</span></span></code></pre></div><p>Unlink this operation from its current block and insert it right before <code>existingOp</code> which may be in the same or another block in the same function.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8682-L8686" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseReplaceAllOpUsesWithOperation-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseReplaceAllOpUsesWithOperation-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseReplaceAllOpUsesWithOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceAllOpUsesWithOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, from, to)</span></span></code></pre></div><p>Find uses of <code>from</code> and replace them with <code>to</code>. Also notify the listener about every in-place op modification (for every use that was replaced) and that the <code>from</code> operation is about to be replaced.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8784-L8788" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseReplaceAllOpUsesWithValueRange-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseReplaceAllOpUsesWithValueRange-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseReplaceAllOpUsesWithValueRange</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceAllOpUsesWithValueRange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, from, nTo, to)</span></span></code></pre></div><p>Find uses of <code>from</code> and replace them with <code>to</code>. Also notify the listener about every in-place op modification (for every use that was replaced) and that the <code>from</code> operation is about to be replaced.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8773-L8777" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseReplaceAllUsesExcept-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseReplaceAllUsesExcept-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseReplaceAllUsesExcept</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceAllUsesExcept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, from, to, exceptedUser)</span></span></code></pre></div><p>Find uses of <code>from</code> and replace them with <code>to</code> except if the user is <code>exceptedUser</code>. Also notify the listener about every in-place op modification (for every use that was replaced).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8812-L8816" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseReplaceAllUsesWith-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseReplaceAllUsesWith-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseReplaceAllUsesWith</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceAllUsesWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, from, to)</span></span></code></pre></div><p>Find uses of <code>from</code> and replace them with <code>to</code>. Also notify the listener about every in-place op modification (for every use that was replaced).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8748-L8752" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseReplaceAllValueRangeUsesWith-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseReplaceAllValueRangeUsesWith-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseReplaceAllValueRangeUsesWith</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceAllValueRangeUsesWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, nValues, from, to)</span></span></code></pre></div><p>Find uses of <code>from</code> and replace them with <code>to</code>. Also notify the listener about every in-place op modification (for every use that was replaced).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8759-L8763" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseReplaceOpUsesWithinBlock-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseReplaceOpUsesWithinBlock-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseReplaceOpUsesWithinBlock</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceOpUsesWithinBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op, nNewValues, newValues, block)</span></span></code></pre></div><p>Find uses of <code>from</code> within <code>block</code> and replace them with <code>to</code>. Also notify the listener about every in-place op modification (for every use that was replaced). The optional <code>allUsesReplaced</code> flag is set to &quot;true&quot; if all uses were replaced.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8795-L8799" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseReplaceOpWithOperation-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseReplaceOpWithOperation-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseReplaceOpWithOperation</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceOpWithOperation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op, newOp)</span></span></code></pre></div><p>Replace the results of the given (original) operation with the specified new op (replacement). The result types of the two ops must match. The original op is erased.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8615-L8619" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseReplaceOpWithValues-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseReplaceOpWithValues-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseReplaceOpWithValues</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseReplaceOpWithValues</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op, nValues, values)</span></span></code></pre></div><p>Replace the results of the given (original) operation with the specified list of values (replacements). The result types of the given op and the replacements must match. The original op is erased.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8601-L8605" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointAfter-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointAfter-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointAfter</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseSetInsertionPointAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>Sets the insertion point to the node after the specified operation, which will cause subsequent insertions to go right after it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8467-L8471" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointAfterValue-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointAfterValue-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointAfterValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseSetInsertionPointAfterValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, value)</span></span></code></pre></div><p>Sets the insertion point to the node after the specified value. If value has a defining operation, sets the insertion point to the node after such defining operation. This will cause subsequent insertions to go right after it. Otherwise, value is a BlockArgument. Sets the insertion point to the start of its block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8478-L8482" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointBefore-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointBefore-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointBefore</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseSetInsertionPointBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>Sets the insertion point to the specified operation, which will cause subsequent insertions to go right before it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8456-L8460" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointToEnd-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointToEnd-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointToEnd</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseSetInsertionPointToEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, block)</span></span></code></pre></div><p>Sets the insertion point to the end of the specified block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8500-L8504" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointToStart-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointToStart-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseSetInsertionPointToStart</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseSetInsertionPointToStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, block)</span></span></code></pre></div><p>Sets the insertion point to the start of the specified block.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8489-L8493" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirRewriterBaseStartOpModification-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirRewriterBaseStartOpModification-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirRewriterBaseStartOpModification</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirRewriterBaseStartOpModification</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rewriter, op)</span></span></code></pre></div><p>This method is used to notify the rewriter that an in-place operation modification is about to happen. A call to this function <em>must</em> be followed by a call to either <code>finalizeOpModification</code> or <code>cancelOpModification</code>. This is a minor efficiency win (it avoids creating a new operation and removing the old one) but also often allows simpler code in the client.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L8715-L8719" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSetGlobalDebugType-Tuple{Any}" href="#Reactant.MLIR.API.mlirSetGlobalDebugType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSetGlobalDebugType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSetGlobalDebugType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Sets the current debug type, similarly to <code>-debug-only=type</code> in the command-line tools. Note that global debug should be enabled for any output to be produced.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5849-L5853" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSetGlobalDebugTypes-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirSetGlobalDebugTypes-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSetGlobalDebugTypes</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSetGlobalDebugTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(types, n)</span></span></code></pre></div><p>Sets multiple current debug types, similarly to `-debug-only=type1,type2&quot; in the command-line tools. Note that global debug should be enabled for any output to be produced.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5858-L5862" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirShapedTypeGetDimSize-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirShapedTypeGetDimSize-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirShapedTypeGetDimSize</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeGetDimSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, dim)</span></span></code></pre></div><p>Returns the dim-th dimension of the given ranked shaped type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5277-L5281" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirShapedTypeGetDynamicSize-Tuple{}" href="#Reactant.MLIR.API.mlirShapedTypeGetDynamicSize-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirShapedTypeGetDynamicSize</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeGetDynamicSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the value indicating a dynamic size in a shaped type. Prefer <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirShapedTypeIsDynamicSize-Tuple{Any}"><code>mlirShapedTypeIsDynamicSize</code></a> to direct comparisons with this value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5295-L5299" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirShapedTypeGetDynamicStrideOrOffset-Tuple{}" href="#Reactant.MLIR.API.mlirShapedTypeGetDynamicStrideOrOffset-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirShapedTypeGetDynamicStrideOrOffset</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeGetDynamicStrideOrOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the value indicating a dynamic stride or offset in a shaped type. Prefer <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirShapedTypeGetDynamicStrideOrOffset-Tuple{}"><code>mlirShapedTypeGetDynamicStrideOrOffset</code></a> to direct comparisons with this value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5313-L5317" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirShapedTypeGetElementType-Tuple{Any}" href="#Reactant.MLIR.API.mlirShapedTypeGetElementType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirShapedTypeGetElementType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeGetElementType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the element type of the shaped type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5232-L5236" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirShapedTypeGetRank-Tuple{Any}" href="#Reactant.MLIR.API.mlirShapedTypeGetRank-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirShapedTypeGetRank</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeGetRank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the rank of the given ranked shaped type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5250-L5254" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirShapedTypeHasRank-Tuple{Any}" href="#Reactant.MLIR.API.mlirShapedTypeHasRank-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirShapedTypeHasRank</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeHasRank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given shaped type is ranked.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5241-L5245" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirShapedTypeHasStaticShape-Tuple{Any}" href="#Reactant.MLIR.API.mlirShapedTypeHasStaticShape-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirShapedTypeHasStaticShape</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeHasStaticShape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given shaped type has a static shape.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5259-L5263" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirShapedTypeIsDynamicDim-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirShapedTypeIsDynamicDim-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirShapedTypeIsDynamicDim</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeIsDynamicDim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, dim)</span></span></code></pre></div><p>Checks wither the dim-th dimension of the given shaped type is dynamic.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5268-L5272" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirShapedTypeIsDynamicSize-Tuple{Any}" href="#Reactant.MLIR.API.mlirShapedTypeIsDynamicSize-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirShapedTypeIsDynamicSize</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeIsDynamicSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size)</span></span></code></pre></div><p>Checks whether the given value is used as a placeholder for dynamic sizes in shaped types.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5286-L5290" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirShapedTypeIsDynamicStrideOrOffset-Tuple{Any}" href="#Reactant.MLIR.API.mlirShapedTypeIsDynamicStrideOrOffset-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirShapedTypeIsDynamicStrideOrOffset</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirShapedTypeIsDynamicStrideOrOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val)</span></span></code></pre></div><p>Checks whether the given value is used as a placeholder for dynamic strides and offsets in shaped types.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5304-L5308" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseElementsAttrGetIndices-Tuple{Any}" href="#Reactant.MLIR.API.mlirSparseElementsAttrGetIndices-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseElementsAttrGetIndices</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseElementsAttrGetIndices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the dense elements attribute containing 64-bit integer indices of non-null elements in the given sparse elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4544-L4548" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseElementsAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirSparseElementsAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseElementsAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseElementsAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a SparseElements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4562-L4566" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseElementsAttrGetValues-Tuple{Any}" href="#Reactant.MLIR.API.mlirSparseElementsAttrGetValues-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseElementsAttrGetValues</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseElementsAttrGetValues</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the dense elements attribute containing the non-null elements in the given sparse elements attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4553-L4557" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseElementsAttribute-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirSparseElementsAttribute-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseElementsAttribute</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseElementsAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, denseIndices, denseValues)</span></span></code></pre></div><p>Creates a sparse elements attribute of the given shape from a list of indices and a list of associated values. Both lists are expected to be dense elements attributes with the same number of elements. The list of indices is expected to contain 64-bit integers. The attribute is created in the same context as the type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4533-L4537" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseTensorEncodingAttrGet-NTuple{9, Any}" href="#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGet-NTuple{9, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseTensorEncodingAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, lvlRank, lvlTypes, dimToLvl, lvlTodim, posWidth, crdWidth, explicitVal, implicitVal)</span></span></code></pre></div><p>Creates a <code>sparse\_tensor.encoding</code> attribute with the given parameters.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7616-L7620" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetCrdWidth-Tuple{Any}" href="#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetCrdWidth-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetCrdWidth</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetCrdWidth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the coordinate bitwidth of the <code>sparse\_tensor.encoding</code> attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7699-L7703" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetDimToLvl-Tuple{Any}" href="#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetDimToLvl-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetDimToLvl</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetDimToLvl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the dimension-to-level mapping of the <code>sparse\_tensor.encoding</code> attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7668-L7672" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetExplicitVal-Tuple{Any}" href="#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetExplicitVal-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetExplicitVal</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetExplicitVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the explicit value of the <code>sparse\_tensor.encoding</code> attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7708-L7712" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetImplicitVal-Tuple{Any}" href="#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetImplicitVal-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetImplicitVal</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetImplicitVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the implicit value of the <code>sparse\_tensor.encoding</code> attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7719-L7723" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlFmt-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlFmt-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlFmt</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetLvlFmt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, lvl)</span></span></code></pre></div><p>Returns a specified level-format of the <code>sparse\_tensor.encoding</code> attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7657-L7661" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlToDim-Tuple{Any}" href="#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlToDim-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlToDim</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetLvlToDim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the level-to-dimension mapping of the <code>sparse\_tensor.encoding</code> attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7679-L7683" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlType-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetLvlType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, lvl)</span></span></code></pre></div><p>Returns a specified level-type of the <code>sparse\_tensor.encoding</code> attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7646-L7650" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetPosWidth-Tuple{Any}" href="#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetPosWidth-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetPosWidth</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingAttrGetPosWidth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the position bitwidth of the <code>sparse\_tensor.encoding</code> attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7690-L7694" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSparseTensorEncodingGetLvlRank-Tuple{Any}" href="#Reactant.MLIR.API.mlirSparseTensorEncodingGetLvlRank-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSparseTensorEncodingGetLvlRank</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSparseTensorEncodingGetLvlRank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the level-rank of the <code>sparse\_tensor.encoding</code> attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7637-L7641" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirStridedLayoutAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirStridedLayoutAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirStridedLayoutAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStridedLayoutAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a StridedLayout attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4593-L4597" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirStringAttrGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirStringAttrGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirStringAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, str)</span></span></code></pre></div><p>Creates a string attribute in the given context containing the given string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3561-L3565" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirStringAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirStringAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirStringAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a String attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3588-L3592" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirStringAttrGetValue-Tuple{Any}" href="#Reactant.MLIR.API.mlirStringAttrGetValue-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirStringAttrGetValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the attribute values as a string reference. The data remains live as long as the context in which the attribute lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3579-L3583" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirStringAttrTypedGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirStringAttrTypedGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirStringAttrTypedGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringAttrTypedGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, str)</span></span></code></pre></div><p>Creates a string attribute in the given context containing the given string. Additionally, the attribute has the given type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3570-L3574" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirStringRefCreate-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirStringRefCreate-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirStringRefCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringRefCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str, length)</span></span></code></pre></div><p>Constructs a string reference from the pointer and length. The pointer need not reference to a null-terminated string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L80-L84" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirStringRefCreateFromCString-Tuple{Any}" href="#Reactant.MLIR.API.mlirStringRefCreateFromCString-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirStringRefCreateFromCString</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringRefCreateFromCString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str)</span></span></code></pre></div><p>Constructs a string reference from a null-terminated C string. Prefer <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirStringRefCreate-Tuple{Any, Any}"><code>mlirStringRefCreate</code></a> if the length of the string is known.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L89-L93" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirStringRefEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirStringRefEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirStringRefEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirStringRefEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(string, other)</span></span></code></pre></div><p>Returns true if two string references are equal, false otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L98-L102" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolRefAttrGet-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirSymbolRefAttrGet-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolRefAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolRefAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, symbol, numReferences, references)</span></span></code></pre></div><p>Creates a symbol reference attribute in the given context referencing a symbol identified by the given string inside a list of nested references. Each of the references in the list must not be nested.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3606-L3610" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolRefAttrGetLeafReference-Tuple{Any}" href="#Reactant.MLIR.API.mlirSymbolRefAttrGetLeafReference-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolRefAttrGetLeafReference</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolRefAttrGetLeafReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the string reference to the leaf referenced symbol. The data remains live as long as the context in which the attribute lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3629-L3633" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolRefAttrGetNestedReference-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirSymbolRefAttrGetNestedReference-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolRefAttrGetNestedReference</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolRefAttrGetNestedReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr, pos)</span></span></code></pre></div><p>Returns pos-th reference nested in the given symbol reference attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3647-L3651" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolRefAttrGetNumNestedReferences-Tuple{Any}" href="#Reactant.MLIR.API.mlirSymbolRefAttrGetNumNestedReferences-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolRefAttrGetNumNestedReferences</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolRefAttrGetNumNestedReferences</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the number of references nested in the given symbol reference attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3638-L3642" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolRefAttrGetRootReference-Tuple{Any}" href="#Reactant.MLIR.API.mlirSymbolRefAttrGetRootReference-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolRefAttrGetRootReference</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolRefAttrGetRootReference</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the string reference to the root referenced symbol. The data remains live as long as the context in which the attribute lives.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3620-L3624" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolRefAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirSymbolRefAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolRefAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolRefAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an SymbolRef attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3658-L3662" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolTableCreate-Tuple{Any}" href="#Reactant.MLIR.API.mlirSymbolTableCreate-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolTableCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(operation)</span></span></code></pre></div><p>Creates a symbol table for the given operation. If the operation does not have the SymbolTable trait, returns a null symbol table.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2289-L2293" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolTableDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirSymbolTableDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolTableDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbolTable)</span></span></code></pre></div><p>Destroys the symbol table created with <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirSymbolTableCreate-Tuple{Any}"><code>mlirSymbolTableCreate</code></a>. This does not affect the operations in the table.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2307-L2311" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolTableErase-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirSymbolTableErase-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolTableErase</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableErase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbolTable, operation)</span></span></code></pre></div><p>Removes the given operation from the symbol table and erases it.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2338-L2342" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolTableGetSymbolAttributeName-Tuple{}" href="#Reactant.MLIR.API.mlirSymbolTableGetSymbolAttributeName-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolTableGetSymbolAttributeName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableGetSymbolAttributeName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the name of the attribute used to store symbol names compatible with symbol tables.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2271-L2275" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolTableGetVisibilityAttributeName-Tuple{}" href="#Reactant.MLIR.API.mlirSymbolTableGetVisibilityAttributeName-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolTableGetVisibilityAttributeName</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableGetVisibilityAttributeName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the name of the attribute used to store symbol visibility.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2280-L2284" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolTableInsert-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirSymbolTableInsert-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolTableInsert</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableInsert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbolTable, operation)</span></span></code></pre></div><p>Inserts the given operation into the given symbol table. The operation must have the symbol trait. If the symbol table already has a symbol with the same name, renames the symbol being inserted to ensure name uniqueness. Note that this does not move the operation itself into the block of the symbol table operation, this should be done separately. Returns the name of the symbol after insertion.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2327-L2331" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolTableIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirSymbolTableIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolTableIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbolTable)</span></span></code></pre></div><p>Returns true if the symbol table is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2298-L2302" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolTableLookup-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirSymbolTableLookup-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolTableLookup</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableLookup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbolTable, name)</span></span></code></pre></div><p>Looks up a symbol with the given name in the given symbol table and returns the operation that corresponds to the symbol. If the symbol cannot be found, returns a null operation.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2316-L2320" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolTableReplaceAllSymbolUses-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirSymbolTableReplaceAllSymbolUses-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolTableReplaceAllSymbolUses</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableReplaceAllSymbolUses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldSymbol, newSymbol, from)</span></span></code></pre></div><p>Attempt to replace all uses that are nested within the given operation of the given symbol &#39;oldSymbol&#39; with the provided &#39;newSymbol&#39;. This does not traverse into nested symbol tables. Will fail atomically if there are any unknown operations that may be potential symbol tables.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2349-L2353" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirSymbolTableWalkSymbolTables-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirSymbolTableWalkSymbolTables-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirSymbolTableWalkSymbolTables</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirSymbolTableWalkSymbolTables</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(from, allSymUsesVisible, callback, userData)</span></span></code></pre></div><p>Walks all symbol table operations nested within, and including, <code>op</code>. For each symbol table operation, the provided callback is invoked with the op and a boolean signifying if the symbols within that symbol table can be treated as if all uses within the IR are visible to the caller. <code>allSymUsesVisible</code> identifies whether all of the symbol uses of symbols within <code>op</code> are visible.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2360-L2364" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTF32TypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirTF32TypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTF32TypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTF32TypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a TF32 type in the given context. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5151-L5155" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTransformApplyNamedSequence-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirTransformApplyNamedSequence-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTransformApplyNamedSequence</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformApplyNamedSequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(payload, transformRoot, transformModule, transformOptions)</span></span></code></pre></div><p>Applies the transformation script starting at the given transform root operation to the given payload operation. The module containing the transform root as well as the transform options should be provided. The transform operation must implement TransformOpInterface and the module must be a ModuleOp. Returns the status of the application.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7896-L7900" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTransformOptionsCreate-Tuple{}" href="#Reactant.MLIR.API.mlirTransformOptionsCreate-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirTransformOptionsCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformOptionsCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a default-initialized transform options object.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7834-L7838" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTransformOptionsDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirTransformOptionsDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTransformOptionsDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformOptionsDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transformOptions)</span></span></code></pre></div><p>Destroys a transform options object previously created by <a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirTransformOptionsCreate-Tuple{}"><code>mlirTransformOptionsCreate</code></a>.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7887-L7891" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTransformOptionsEnableExpensiveChecks-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirTransformOptionsEnableExpensiveChecks-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTransformOptionsEnableExpensiveChecks</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformOptionsEnableExpensiveChecks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transformOptions, enable)</span></span></code></pre></div><p>Enables or disables expensive checks in transform options.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7843-L7847" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTransformOptionsEnforceSingleTopLevelTransformOp-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirTransformOptionsEnforceSingleTopLevelTransformOp-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTransformOptionsEnforceSingleTopLevelTransformOp</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformOptionsEnforceSingleTopLevelTransformOp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transformOptions, enable)</span></span></code></pre></div><p>Enables or disables the enforcement of the top-level transform op being single in transform options.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7865-L7869" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTransformOptionsGetEnforceSingleTopLevelTransformOp-Tuple{Any}" href="#Reactant.MLIR.API.mlirTransformOptionsGetEnforceSingleTopLevelTransformOp-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTransformOptionsGetEnforceSingleTopLevelTransformOp</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformOptionsGetEnforceSingleTopLevelTransformOp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transformOptions)</span></span></code></pre></div><p>Returns true if the enforcement of the top-level transform op being single is enabled in transform options.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7876-L7880" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTransformOptionsGetExpensiveChecksEnabled-Tuple{Any}" href="#Reactant.MLIR.API.mlirTransformOptionsGetExpensiveChecksEnabled-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTransformOptionsGetExpensiveChecksEnabled</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTransformOptionsGetExpensiveChecksEnabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transformOptions)</span></span></code></pre></div><p>Returns true if expensive checks are enabled in transform options.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7854-L7858" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTranslateModuleToLLVMIR-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirTranslateModuleToLLVMIR-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTranslateModuleToLLVMIR</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTranslateModuleToLLVMIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_module, context)</span></span></code></pre></div><p>Translate operation that satisfies LLVM dialect module requirements into an LLVM IR module living in the given context. This translates operations from any dilalect that has a registered implementation of LLVMTranslationDialectInterface.</p><p><strong>Returns</strong></p><p>the generated LLVM IR Module from the translated MLIR module, it is owned by the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9124-L9131" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTupleTypeGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirTupleTypeGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTupleTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTupleTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, numElements, elements)</span></span></code></pre></div><p>Creates a tuple type that consists of the given list of elemental types. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5686-L5690" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTupleTypeGetNumTypes-Tuple{Any}" href="#Reactant.MLIR.API.mlirTupleTypeGetNumTypes-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTupleTypeGetNumTypes</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTupleTypeGetNumTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of types contained in a tuple.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5697-L5701" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTupleTypeGetType-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirTupleTypeGetType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTupleTypeGetType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTupleTypeGetType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns the pos-th type in the tuple type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5706-L5710" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTupleTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirTupleTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirTupleTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTupleTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Tuple type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5668-L5672" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeAttrGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeAttrGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Creates a type attribute wrapping the given type in the same context as the type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3714-L3718" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirTypeAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a Type attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3732-L3736" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeAttrGetValue-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeAttrGetValue-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeAttrGetValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeAttrGetValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(attr)</span></span></code></pre></div><p>Returns the type stored in the given type attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3723-L3727" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeDump-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeDump-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeDump</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Prints the type to the standard error stream.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2128-L2132" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirTypeEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(t1, t2)</span></span></code></pre></div><p>Checks if two types are equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2108-L2112" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorCreate-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorCreate-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeFromLLVMIRTranslatorCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Create an LLVM::TypeFromLLVMIRTranslator and transfer ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9142-L9146" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeFromLLVMIRTranslatorDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(translator)</span></span></code></pre></div><p>Takes an LLVM::TypeFromLLVMIRTranslator owned by the caller and destroys it. It is the responsibility of the user to only pass an LLVM::TypeFromLLVMIRTranslator class.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9153-L9157" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorTranslateType-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorTranslateType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeFromLLVMIRTranslatorTranslateType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeFromLLVMIRTranslatorTranslateType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(translator, llvmType)</span></span></code></pre></div><p>Translates the given LLVM IR type to the MLIR LLVM dialect.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9164-L9168" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeGetContext-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeGetContext-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeGetContext</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeGetContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the context that a type was created with.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2072-L2076" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeGetDialect-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeGetDialect-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeGetDialect</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeGetDialect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the dialect a type belongs to.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2090-L2094" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeGetTypeID-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeGetTypeID-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Gets the type ID of the type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2081-L2085" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIDAllocatorAllocateTypeID-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIDAllocatorAllocateTypeID-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIDAllocatorAllocateTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDAllocatorAllocateTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allocator)</span></span></code></pre></div><p>Allocates a type id that is valid for the lifetime of the allocator</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L232-L236" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIDAllocatorCreate-Tuple{}" href="#Reactant.MLIR.API.mlirTypeIDAllocatorCreate-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIDAllocatorCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDAllocatorCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Creates a type id allocator for dynamic type id creation</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L214-L218" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIDAllocatorDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIDAllocatorDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIDAllocatorDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDAllocatorDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(allocator)</span></span></code></pre></div><p>Deallocates the allocator and all allocated type ids</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L223-L227" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIDCreate-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIDCreate-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIDCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ptr)</span></span></code></pre></div><p><code>ptr</code> must be 8 byte aligned and unique to a type valid for the duration of the returned type id&#39;s usage</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L178-L182" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIDEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirTypeIDEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIDEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(typeID1, typeID2)</span></span></code></pre></div><p>Checks if two type ids are equal.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L196-L200" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIDHashValue-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIDHashValue-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIDHashValue</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDHashValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(typeID)</span></span></code></pre></div><p>Returns the hash value of the type id.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L205-L209" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIDIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIDIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIDIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIDIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(typeID)</span></span></code></pre></div><p>Checks whether a type id is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L187-L191" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAAnyQuantizedType-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAAnyQuantizedType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAAnyQuantizedType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAAnyQuantizedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is an AnyQuantizedType.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7357-L7361" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsABF16-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsABF16-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsABF16</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsABF16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a bf16 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5034-L5038" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsACalibratedQuantizedType-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsACalibratedQuantizedType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsACalibratedQuantizedType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsACalibratedQuantizedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is a CalibratedQuantizedType.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7527-L7531" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAComplex-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAComplex-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAComplex</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAComplex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Complex type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5196-L5200" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAF16-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAF16-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAF16</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAF16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f16 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5061-L5065" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAF32-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAF32-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAF32</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAF32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f32 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5088-L5092" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAF64-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAF64-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAF64</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAF64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f64 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5115-L5119" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFloat-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFloat-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFloat</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a floating-point type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4710-L4714" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFloat4E2M1FN-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFloat4E2M1FN-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFloat4E2M1FN</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat4E2M1FN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f4E2M1FN type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4737-L4741" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFloat6E2M3FN-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFloat6E2M3FN-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFloat6E2M3FN</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat6E2M3FN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f6E2M3FN type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4764-L4768" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFloat6E3M2FN-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFloat6E3M2FN-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFloat6E3M2FN</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat6E3M2FN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f6E3M2FN type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4791-L4795" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFloat8E3M4-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFloat8E3M4-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFloat8E3M4</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E3M4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E3M4 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4980-L4984" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFloat8E4M3-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFloat8E4M3-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFloat8E4M3</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E4M3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4845-L4849" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFloat8E4M3B11FNUZ-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFloat8E4M3B11FNUZ-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFloat8E4M3B11FNUZ</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E4M3B11FNUZ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3B11FNUZ type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4953-L4957" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FN-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FN-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FN</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E4M3FN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3FN type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4872-L4876" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FNUZ-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FNUZ-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FNUZ</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E4M3FNUZ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E4M3FNUZ type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4926-L4930" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFloat8E5M2-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFloat8E5M2-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFloat8E5M2</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E5M2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E5M2 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4818-L4822" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFloat8E5M2FNUZ-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFloat8E5M2FNUZ-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFloat8E5M2FNUZ</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E5M2FNUZ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E5M2FNUZ type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4899-L4903" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFloat8E8M0FNU-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFloat8E8M0FNU-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFloat8E8M0FNU</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFloat8E8M0FNU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an f8E8M0FNU type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5007-L5011" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAFunction-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAFunction-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAFunction</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a function type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5724-L5728" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAIndex-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAIndex-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAIndex</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an index type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4692-L4696" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAInteger-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAInteger-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAInteger</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an integer type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4611-L4615" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsALLVMPointerType-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsALLVMPointerType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsALLVMPointerType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsALLVMPointerType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the type is an LLVM dialect pointer type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6267-L6271" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsALLVMStructType-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsALLVMStructType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsALLVMStructType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsALLVMStructType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the type is an LLVM dialect struct type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L6353-L6357" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAMemRef-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAMemRef-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAMemRef</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAMemRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a MemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5515-L5519" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsANone-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsANone-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsANone</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsANone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a None type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5169-L5173" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAOpaque-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAOpaque-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAOpaque</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAOpaque</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an opaque type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5793-L5797" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAQuantizedType-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAQuantizedType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAQuantizedType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAQuantizedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is a quantization dialect type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7183-L7187" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsARankedTensor-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsARankedTensor-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsARankedTensor</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsARankedTensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a ranked tensor type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5424-L5428" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAShaped-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAShaped-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAShaped</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAShaped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Shaped type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5223-L5227" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsATF32-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsATF32-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsATF32</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsATF32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an TF32 type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5142-L5146" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsATensor-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsATensor-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsATensor</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsATensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Tensor type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5406-L5410" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsATuple-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsATuple-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsATuple</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsATuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a tuple type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5677-L5681" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAUniformQuantizedPerAxisType-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAUniformQuantizedPerAxisType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAUniformQuantizedPerAxisType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAUniformQuantizedPerAxisType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is a UniformQuantizedPerAxisType.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7438-L7442" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAUniformQuantizedType-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAUniformQuantizedType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAUniformQuantizedType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAUniformQuantizedType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given type is a UniformQuantizedType.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7383-L7387" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAUnrankedMemRef-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAUnrankedMemRef-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAUnrankedMemRef</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAUnrankedMemRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an UnrankedMemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5533-L5537" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAUnrankedTensor-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAUnrankedTensor-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAUnrankedTensor</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAUnrankedTensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is an unranked tensor type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5442-L5446" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsAVector-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsAVector-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsAVector</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsAVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given type is a Vector type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5331-L5335" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether a type is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2099-L2103" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeParseGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirTypeParseGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeParseGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeParseGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, type)</span></span></code></pre></div><p>Parses a type. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2063-L2067" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypePrint-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirTypePrint-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypePrint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypePrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, callback, userData)</span></span></code></pre></div><p>Prints a location by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2117-L2121" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorCreate-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorCreate-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorCreate</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeToLLVMIRTranslatorCreate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Create an LLVM::TypeToLLVMIRTranslator and transfer ownership to the caller.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9179-L9183" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorDestroy-Tuple{Any}" href="#Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorDestroy-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorDestroy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeToLLVMIRTranslatorDestroy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(translator)</span></span></code></pre></div><p>Takes an LLVM::TypeToLLVMIRTranslator owned by the caller and destroys it. It is the responsibility of the user to only pass an LLVM::TypeToLLVMIRTranslator class.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9190-L9194" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorTranslateType-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorTranslateType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirTypeToLLVMIRTranslatorTranslateType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirTypeToLLVMIRTranslatorTranslateType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(translator, mlirType)</span></span></code></pre></div><p>Translates the given MLIR LLVM dialect to the LLVM IR type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L9201-L9205" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGet-NTuple{9, Any}" href="#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGet-NTuple{9, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedPerAxisTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, storageType, expressedType, nDims, scales, zeroPoints, quantizedDimension, storageTypeMin, storageTypeMax)</span></span></code></pre></div><p>Creates an instance of UniformQuantizedPerAxisType with the given parameters in the same context as <code>storageType</code> and returns it. <code>scales</code> and <code>zeroPoints</code> point to <code>nDims</code> number of elements. The instance is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7447-L7451" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetNumDims-Tuple{Any}" href="#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetNumDims-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetNumDims</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedPerAxisTypeGetNumDims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the number of axes in the given quantized per-axis type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7476-L7480" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetQuantizedDimension-Tuple{Any}" href="#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetQuantizedDimension-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetQuantizedDimension</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedPerAxisTypeGetQuantizedDimension</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the index of the quantized dimension in the given quantized per-axis type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7507-L7511" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetScale-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetScale-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetScale</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedPerAxisTypeGetScale</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th scale of the given quantized per-axis type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7485-L7489" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetZeroPoint-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetZeroPoint-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetZeroPoint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedPerAxisTypeGetZeroPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, pos)</span></span></code></pre></div><p>Returns <code>pos</code>-th zero point of the given quantized per-axis type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7496-L7500" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeIsFixedPoint-Tuple{Any}" href="#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeIsFixedPoint-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeIsFixedPoint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedPerAxisTypeIsFixedPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given uniform quantized per-axis type is fixed-point.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7518-L7522" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUniformQuantizedTypeGet-NTuple{7, Any}" href="#Reactant.MLIR.API.mlirUniformQuantizedTypeGet-NTuple{7, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUniformQuantizedTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flags, storageType, expressedType, scale, zeroPoint, storageTypeMin, storageTypeMax)</span></span></code></pre></div><p>Creates an instance of UniformQuantizedType with the given parameters in the same context as <code>storageType</code> and returns it. The instance is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7392-L7396" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUniformQuantizedTypeGetScale-Tuple{Any}" href="#Reactant.MLIR.API.mlirUniformQuantizedTypeGetScale-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUniformQuantizedTypeGetScale</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedTypeGetScale</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the scale of the given uniform quantized type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7411-L7415" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUniformQuantizedTypeGetZeroPoint-Tuple{Any}" href="#Reactant.MLIR.API.mlirUniformQuantizedTypeGetZeroPoint-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUniformQuantizedTypeGetZeroPoint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedTypeGetZeroPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the zero point of the given uniform quantized type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7420-L7424" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUniformQuantizedTypeIsFixedPoint-Tuple{Any}" href="#Reactant.MLIR.API.mlirUniformQuantizedTypeIsFixedPoint-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUniformQuantizedTypeIsFixedPoint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUniformQuantizedTypeIsFixedPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns <code>true</code> if the given uniform quantized type is fixed-point.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L7429-L7433" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUnitAttrGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirUnitAttrGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUnitAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnitAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx)</span></span></code></pre></div><p>Creates a unit attribute in the given context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3750-L3754" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUnitAttrGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirUnitAttrGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirUnitAttrGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnitAttrGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of a Unit attribute.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L3759-L3763" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUnmanagedDenseResourceElementsAttrGet-NTuple{8, Any}" href="#Reactant.MLIR.API.mlirUnmanagedDenseResourceElementsAttrGet-NTuple{8, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUnmanagedDenseResourceElementsAttrGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnmanagedDenseResourceElementsAttrGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shapedType, name, data, dataLength, dataAlignment, dataIsMutable, deleter, userData)</span></span></code></pre></div><p>Unlike the typed accessors below, constructs the attribute with a raw data buffer and no type/alignment checking. Use a more strongly typed accessor if possible. If dataIsMutable is false, then an immutable AsmResourceBlob will be created and that passed data contents will be treated as const. If the deleter is non NULL, then it will be called when the data buffer can no longer be accessed (passing userData to it).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L4312-L4316" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUnrankedMemRefTypeGet-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirUnrankedMemRefTypeGet-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUnrankedMemRefTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedMemRefTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType, memorySpace)</span></span></code></pre></div><p>Creates an Unranked MemRef type with the given element type and in the given memory space. The type is owned by the context of element type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5599-L5603" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUnrankedMemRefTypeGetChecked-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirUnrankedMemRefTypeGetChecked-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUnrankedMemRefTypeGetChecked</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedMemRefTypeGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, elementType, memorySpace)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirUnrankedMemRefTypeGet-Tuple{Any, Any}"><code>mlirUnrankedMemRefTypeGet</code></a>&quot; but returns a nullptr wrapping <a href="./@ref"><code>MlirType</code></a> on illegal arguments, emitting appropriate diagnostics.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5610-L5614" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUnrankedMemRefTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirUnrankedMemRefTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirUnrankedMemRefTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedMemRefTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an UnrankedMemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5524-L5528" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUnrankedMemrefGetMemorySpace-Tuple{Any}" href="#Reactant.MLIR.API.mlirUnrankedMemrefGetMemorySpace-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUnrankedMemrefGetMemorySpace</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedMemrefGetMemorySpace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Returns the memory spcae of the given Unranked MemRef type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5659-L5663" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUnrankedTensorTypeGet-Tuple{Any}" href="#Reactant.MLIR.API.mlirUnrankedTensorTypeGet-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUnrankedTensorTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedTensorTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(elementType)</span></span></code></pre></div><p>Creates an unranked tensor type with the given element type in the same context as the element type. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5486-L5490" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUnrankedTensorTypeGetChecked-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirUnrankedTensorTypeGetChecked-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirUnrankedTensorTypeGetChecked</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedTensorTypeGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, elementType)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirUnrankedTensorTypeGet-Tuple{Any}"><code>mlirUnrankedTensorTypeGet</code></a>&quot; but returns a nullptr wrapping <a href="./@ref"><code>MlirType</code></a> on illegal arguments, emitting appropriate diagnostics.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5495-L5499" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirUnrankedTensorTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirUnrankedTensorTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirUnrankedTensorTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirUnrankedTensorTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an UnrankedTensor type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5433-L5437" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirValueDump-Tuple{Any}" href="#Reactant.MLIR.API.mlirValueDump-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirValueDump</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueDump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Prints the value to the standard error stream.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1952-L1956" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirValueEqual-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirValueEqual-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirValueEqual</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value1, value2)</span></span></code></pre></div><p>Returns 1 if two values are equal, 0 otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1862-L1866" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirValueGetFirstUse-Tuple{Any}" href="#Reactant.MLIR.API.mlirValueGetFirstUse-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirValueGetFirstUse</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueGetFirstUse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns an op operand representing the first use of the value, or a null op operand if there are no uses.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1986-L1990" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirValueGetType-Tuple{Any}" href="#Reactant.MLIR.API.mlirValueGetType-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirValueGetType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueGetType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns the type of the value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1934-L1938" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirValueIsABlockArgument-Tuple{Any}" href="#Reactant.MLIR.API.mlirValueIsABlockArgument-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirValueIsABlockArgument</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueIsABlockArgument</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns 1 if the value is a block argument, 0 otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1871-L1875" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirValueIsAOpResult-Tuple{Any}" href="#Reactant.MLIR.API.mlirValueIsAOpResult-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirValueIsAOpResult</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueIsAOpResult</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns 1 if the value is an operation result, 0 otherwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1880-L1884" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirValueIsNull-Tuple{Any}" href="#Reactant.MLIR.API.mlirValueIsNull-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirValueIsNull</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueIsNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span></code></pre></div><p>Returns whether the value is null.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1853-L1857" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirValuePrint-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirValuePrint-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirValuePrint</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValuePrint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, callback, userData)</span></span></code></pre></div><p>Prints a value by sending chunks of the string representation and forwarding <code>userData to</code>callback`. Note that the callback may be called several times with consecutive chunks of the string.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1961-L1965" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirValuePrintAsOperand-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirValuePrintAsOperand-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirValuePrintAsOperand</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValuePrintAsOperand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, state, callback, userData)</span></span></code></pre></div><p>Prints a value as an operand (i.e., the ValueID).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1972-L1976" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirValueReplaceAllUsesExcept-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirValueReplaceAllUsesExcept-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirValueReplaceAllUsesExcept</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueReplaceAllUsesExcept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(of, with, numExceptions, exceptions)</span></span></code></pre></div><p>Replace all uses of &#39;of&#39; value with &#39;with&#39; value, updating anything in the IR that uses &#39;of&#39; to use &#39;with&#39; instead, except if the user is listed in &#39;exceptions&#39;. The &#39;exceptions&#39; parameter is an array of <a href="./@ref"><code>MlirOperation</code></a> pointers with a length of &#39;numExceptions&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L2004-L2008" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirValueReplaceAllUsesOfWith-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirValueReplaceAllUsesOfWith-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirValueReplaceAllUsesOfWith</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueReplaceAllUsesOfWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(of, with)</span></span></code></pre></div><p>Replace all uses of &#39;of&#39; value with the &#39;with&#39; value, updating anything in the IR that uses &#39;of&#39; to use the other value instead. When this returns there are zero uses of &#39;of&#39;.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1995-L1999" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirValueSetType-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirValueSetType-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirValueSetType</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirValueSetType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, type)</span></span></code></pre></div><p>Set the type of the value.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L1943-L1947" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirVectorTypeGet-Tuple{Any, Any, Any}" href="#Reactant.MLIR.API.mlirVectorTypeGet-Tuple{Any, Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirVectorTypeGet</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rank, shape, elementType)</span></span></code></pre></div><p>Creates a vector type of the shape identified by its rank and dimensions, with the given element type in the same context as the element type. The type is owned by the context.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5340-L5344" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirVectorTypeGetChecked-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirVectorTypeGetChecked-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirVectorTypeGetChecked</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeGetChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, rank, shape, elementType)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirVectorTypeGet-Tuple{Any, Any, Any}"><code>mlirVectorTypeGet</code></a>&quot; but returns a nullptr wrapping <a href="./@ref"><code>MlirType</code></a> on illegal arguments, emitting appropriate diagnostics.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5351-L5355" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirVectorTypeGetScalable-NTuple{4, Any}" href="#Reactant.MLIR.API.mlirVectorTypeGetScalable-NTuple{4, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirVectorTypeGetScalable</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeGetScalable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rank, shape, scalable, elementType)</span></span></code></pre></div><p>Creates a scalable vector type with the shape identified by its rank and dimensions. A subset of dimensions may be marked as scalable via the corresponding flag list, which is expected to have as many entries as the rank of the vector. The vector is created in the same context as the element type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5362-L5366" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirVectorTypeGetScalableChecked-NTuple{5, Any}" href="#Reactant.MLIR.API.mlirVectorTypeGetScalableChecked-NTuple{5, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirVectorTypeGetScalableChecked</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeGetScalableChecked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loc, rank, shape, scalable, elementType)</span></span></code></pre></div><p>Same as &quot;<a href="/Reactant.jl/v0.2.45/api/mlirc#Reactant.MLIR.API.mlirVectorTypeGetScalable-NTuple{4, Any}"><code>mlirVectorTypeGetScalable</code></a>&quot; but returns a nullptr wrapping <a href="./@ref"><code>MlirType</code></a> on illegal arguments, emitting appropriate diagnostics.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5373-L5377" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirVectorTypeGetTypeID-Tuple{}" href="#Reactant.MLIR.API.mlirVectorTypeGetTypeID-Tuple{}"><span class="jlbinding">Reactant.MLIR.API.mlirVectorTypeGetTypeID</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeGetTypeID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns the typeID of an Vector type.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5322-L5326" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirVectorTypeIsDimScalable-Tuple{Any, Any}" href="#Reactant.MLIR.API.mlirVectorTypeIsDimScalable-Tuple{Any, Any}"><span class="jlbinding">Reactant.MLIR.API.mlirVectorTypeIsDimScalable</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeIsDimScalable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, dim)</span></span></code></pre></div><p>Checks whether the &quot;dim&quot;-th dimension of the given vector is scalable.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5397-L5401" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.API.mlirVectorTypeIsScalable-Tuple{Any}" href="#Reactant.MLIR.API.mlirVectorTypeIsScalable-Tuple{Any}"><span class="jlbinding">Reactant.MLIR.API.mlirVectorTypeIsScalable</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mlirVectorTypeIsScalable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type)</span></span></code></pre></div><p>Checks whether the given vector type is scalable, i.e., has at least one scalable dimension.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/3997b3110fbdcfceb2e7d333ff27f5856b298d10/src/mlir/libMLIR_h.jl#L5388-L5392" target="_blank" rel="noreferrer">source</a><!--]--></span></details><h1 id="Other-Functions" tabindex="-1">Other Functions <a class="header-anchor" href="#Other-Functions" aria-label="Permalink to &quot;Other Functions {#Other-Functions}&quot;">â€‹</a></h1></div></div></main><footer class="VPDocFooter" data-v-83890dd9 data-v-4f9813fa><!--[--><!--]--><div class="edit-info" data-v-4f9813fa><div class="edit-link" data-v-4f9813fa><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/EnzymeAD/Reactant.jl/edit/main/docs/src/api/mlirc.md" target="_blank" rel="noreferrer" data-v-4f9813fa><!--[--><span class="vpi-square-pen edit-link-icon" data-v-4f9813fa></span> Edit this page on GitHub<!--]--></a></div><!----></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-4f9813fa><span class="visually-hidden" id="doc-footer-aria-label" data-v-4f9813fa>Pager</span><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link prev" href="/Reactant.jl/v0.2.45/api/dialects/vhlo" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Previous page</span><span class="title" data-v-4f9813fa>VHLO</span><!--]--></a></div><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link next" href="/Reactant.jl/v0.2.45/api/xla" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Next page</span><span class="title" data-v-4f9813fa>XLA</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-a9a9e638 data-v-c970a860><div class="container" data-v-c970a860><p class="message" data-v-c970a860>Made with <a href="https://documenter.juliadocs.org/stable/" target="_blank"><strong>Documenter.jl</strong></a>, <a href="https://vitepress.dev" target="_blank"><strong>VitePress</strong></a> and <a href="https://luxdl.github.io/DocumenterVitepress.jl/stable" target="_blank"><strong>DocumenterVitepress.jl</strong></a><br>Released under the MIT License. Powered by the <a href="https://www.julialang.org">Julia Programming Language</a>.<br></p><p class="copyright" data-v-c970a860>Â© Copyright 2025 Reactant Development Team.</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"api_api.md\":\"DkUtECt3\",\"api_dialects_affine.md\":\"Dm5ya7QR\",\"api_dialects_arith.md\":\"B_DjBnPA\",\"api_dialects_builtin.md\":\"C7nHLGig\",\"api_dialects_chlo.md\":\"79qH1rar\",\"api_dialects_enzyme.md\":\"cj7qk_GR\",\"api_dialects_enzymexla.md\":\"Brzxk03G\",\"api_dialects_func.md\":\"C4VBcVUM\",\"api_dialects_gpu.md\":\"CETpVleP\",\"api_dialects_llvm.md\":\"CZW4tXYy\",\"api_dialects_memref.md\":\"wmRcTPnx\",\"api_dialects_mpi.md\":\"DTlAbCfy\",\"api_dialects_nvvm.md\":\"D-GvsDWK\",\"api_dialects_shardy.md\":\"DBeyO7qn\",\"api_dialects_stablehlo.md\":\"BFs4pf38\",\"api_dialects_tpu.md\":\"DEREjAUq\",\"api_dialects_triton.md\":\"HPGaZ_6U\",\"api_dialects_vhlo.md\":\"DIzCzEW8\",\"api_internal.md\":\"Cp4z-Udr\",\"api_mlirc.md\":\"DRIeB_pG\",\"api_ops.md\":\"Cfg80GG1\",\"api_sharding.md\":\"CXhMtHn_\",\"api_xla.md\":\"BJisfwZi\",\"index.md\":\"BMmys4FA\",\"introduction_configuration.md\":\"BWSxVVC4\",\"introduction_index.md\":\"rRb6xU4M\",\"tutorials_index.md\":\"BQQG2QR1\",\"tutorials_local-build.md\":\"Kzf7AARr\",\"tutorials_multihost.md\":\"P9Ci_drm\",\"tutorials_profiling.md\":\"Do5R8R9f\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Reactant.jl\",\"description\":\"Documentation for Reactant.jl\",\"base\":\"/Reactant.jl/v0.2.45/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"outline\":\"deep\",\"logo\":{\"light\":\"/logo.svg\",\"dark\":\"/logo.svg\"},\"search\":{\"provider\":\"local\",\"options\":{\"detailedView\":true}},\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Getting Started\",\"items\":[{\"text\":\"Introduction\",\"link\":\"/introduction\"},{\"text\":\"Configuration\",\"link\":\"/introduction/configuration\"}]},{\"text\":\"Benchmarks\",\"link\":\"https://enzymead.github.io/Reactant.jl/benchmarks/\"},{\"text\":\"Tutorials\",\"items\":[{\"text\":\"Overview\",\"link\":\"/tutorials/\"},{\"text\":\"Profiling\",\"link\":\"/tutorials/profiling\"},{\"text\":\"Distributed\",\"link\":\"/tutorials/multihost\"},{\"text\":\"Local build\",\"link\":\"/tutorials/local-build\"}]},{\"text\":\"API\",\"items\":[{\"text\":\"Core Reactant API\",\"link\":\"/api/api\"},{\"text\":\"Sharding\",\"link\":\"/api/sharding\"},{\"text\":\"Ops\",\"link\":\"/api/ops\"},{\"text\":\"MLIR Dialects\",\"items\":[{\"text\":\"ArithOps\",\"link\":\"/api/dialects/arith\"},{\"text\":\"Affine\",\"link\":\"/api/dialects/affine\"},{\"text\":\"Builtin\",\"link\":\"/api/dialects/builtin\"},{\"text\":\"Chlo\",\"link\":\"/api/dialects/chlo\"},{\"text\":\"Enzyme\",\"link\":\"/api/dialects/enzyme\"},{\"text\":\"EnzymeXLA\",\"link\":\"/api/dialects/enzymexla\"},{\"text\":\"Func\",\"link\":\"/api/dialects/func\"},{\"text\":\"GPU\",\"link\":\"/api/dialects/gpu\"},{\"text\":\"LLVM\",\"link\":\"/api/dialects/llvm\"},{\"text\":\"MPI\",\"link\":\"/api/dialects/mpi\"},{\"text\":\"MemRef\",\"link\":\"/api/dialects/memref\"},{\"text\":\"NVVM\",\"link\":\"/api/dialects/nvvm\"},{\"text\":\"Shardy\",\"link\":\"/api/dialects/shardy\"},{\"text\":\"StableHLO\",\"link\":\"/api/dialects/stablehlo\"},{\"text\":\"Triton\",\"link\":\"/api/dialects/triton\"},{\"text\":\"TPU\",\"link\":\"/api/dialects/tpu\"},{\"text\":\"VHLO\",\"link\":\"/api/dialects/vhlo\"}]},{\"text\":\"Low-Level API\",\"items\":[{\"text\":\"MLIR API\",\"link\":\"/api/mlirc\"},{\"text\":\"XLA\",\"link\":\"/api/xla\"}]},{\"text\":\"Internal API\",\"link\":\"/api/internal\"}]},{\"component\":\"VersionPicker\"}],\"sidebar\":{\"/introduction/\":{\"text\":\"Getting Started\",\"collapsed\":false,\"items\":[{\"text\":\"Introduction\",\"link\":\"/introduction\"},{\"text\":\"Configuration\",\"link\":\"/introduction/configuration\"}]},\"/tutorials/\":{\"text\":\"Tutorials\",\"collapsed\":false,\"items\":[{\"text\":\"Overview\",\"link\":\"/tutorials/\"},{\"text\":\"Profiling\",\"link\":\"/tutorials/profiling\"},{\"text\":\"Distributed\",\"link\":\"/tutorials/multihost\"},{\"text\":\"Local build\",\"link\":\"/tutorials/local-build\"}]},\"/api/\":{\"text\":\"API Reference\",\"collapsed\":false,\"items\":[{\"text\":\"Reactant API\",\"link\":\"/api/api\"},{\"text\":\"Sharding\",\"link\":\"/api/sharding\"},{\"text\":\"Ops\",\"link\":\"/api/ops\"},{\"text\":\"MLIR Dialects\",\"collapsed\":false,\"items\":[{\"text\":\"ArithOps\",\"link\":\"/api/dialects/arith\"},{\"text\":\"Affine\",\"link\":\"/api/dialects/affine\"},{\"text\":\"Builtin\",\"link\":\"/api/dialects/builtin\"},{\"text\":\"Chlo\",\"link\":\"/api/dialects/chlo\"},{\"text\":\"Enzyme\",\"link\":\"/api/dialects/enzyme\"},{\"text\":\"EnzymeXLA\",\"link\":\"/api/dialects/enzymexla\"},{\"text\":\"Func\",\"link\":\"/api/dialects/func\"},{\"text\":\"GPU\",\"link\":\"/api/dialects/gpu\"},{\"text\":\"LLVM\",\"link\":\"/api/dialects/llvm\"},{\"text\":\"MPI\",\"link\":\"/api/dialects/mpi\"},{\"text\":\"MemRef\",\"link\":\"/api/dialects/memref\"},{\"text\":\"NVVM\",\"link\":\"/api/dialects/nvvm\"},{\"text\":\"Shardy\",\"link\":\"/api/dialects/shardy\"},{\"text\":\"StableHLO\",\"link\":\"/api/dialects/stablehlo\"},{\"text\":\"Triton\",\"link\":\"/api/dialects/triton\"},{\"text\":\"TPU\",\"link\":\"/api/dialects/tpu\"},{\"text\":\"VHLO\",\"link\":\"/api/dialects/vhlo\"}]},{\"text\":\"Low-Level API\",\"collapsed\":false,\"items\":[{\"text\":\"MLIR API\",\"link\":\"/api/mlirc\"},{\"text\":\"XLA\",\"link\":\"/api/xla\"}]},{\"text\":\"Internal API\",\"link\":\"/api/internal\"}]}},\"editLink\":{\"pattern\":\"https://github.com/EnzymeAD/Reactant.jl/edit/main/docs/src/:path\",\"text\":\"Edit this page on GitHub\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/EnzymeAD/Reactant.jl\"},{\"icon\":\"slack\",\"link\":\"https://julialang.org/slack/\"}],\"footer\":{\"message\":\"Made with <a href=\\\"https://documenter.juliadocs.org/stable/\\\" target=\\\"_blank\\\"><strong>Documenter.jl</strong></a>, <a href=\\\"https://vitepress.dev\\\" target=\\\"_blank\\\"><strong>VitePress</strong></a> and <a href=\\\"https://luxdl.github.io/DocumenterVitepress.jl/stable\\\" target=\\\"_blank\\\"><strong>DocumenterVitepress.jl</strong></a><br>Released under the MIT License. Powered by the <a href=\\\"https://www.julialang.org\\\">Julia Programming Language</a>.<br>\",\"copyright\":\"Â© Copyright 2025 Reactant Development Team.\"},\"lastUpdated\":{\"text\":\"Updated at\",\"formatOptions\":{\"dateStyle\":\"full\",\"timeStyle\":\"medium\"}}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>