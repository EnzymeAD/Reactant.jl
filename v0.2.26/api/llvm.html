<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>LLVM Dialect | Reactant.jl</title>
    <meta name="description" content="Documentation for Reactant.jl">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/Reactant.jl/v0.2.26/assets/style.BEe2KRyQ.css" as="style">
    <link rel="preload stylesheet" href="/Reactant.jl/v0.2.26/vp-icons.css" as="style">
    
    <script type="module" src="/Reactant.jl/v0.2.26/assets/app.BXiRq6Ve.js"></script>
    <link rel="preload" href="/Reactant.jl/v0.2.26/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Reactant.jl/v0.2.26/assets/chunks/theme.CatQVpZZ.js">
    <link rel="modulepreload" href="/Reactant.jl/v0.2.26/assets/chunks/framework.Cy-rUO9w.js">
    <link rel="modulepreload" href="/Reactant.jl/v0.2.26/assets/api_llvm.md.DqQxqqTo.lean.js">
    <link rel="icon" href="REPLACE_ME_DOCUMENTER_VITEPRESS_FAVICON">
    <script src="/versions.js"></script>
    <script src="/Reactant.jl/v0.2.26/siteinfo.js"></script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-a9a9e638><!--[--><!--]--><!--[--><span tabindex="-1" data-v-492508fc></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-492508fc>Skip to content</a><!--]--><!----><header class="VPNav" data-v-a9a9e638 data-v-f1e365da><div class="VPNavBar" data-v-f1e365da data-v-822684d1><div class="wrapper" data-v-822684d1><div class="container" data-v-822684d1><div class="title" data-v-822684d1><div class="VPNavBarTitle has-sidebar" data-v-822684d1 data-v-0f4f798b><a class="title" href="/Reactant.jl/v0.2.26/" data-v-0f4f798b><!--[--><!--]--><!--[--><!--[--><!--[--><img class="VPImage dark logo" src="/Reactant.jl/v0.2.26/logo.svg" alt data-v-35a7d0b8><!--]--><!--[--><img class="VPImage light logo" src="/Reactant.jl/v0.2.26/logo.svg" alt data-v-35a7d0b8><!--]--><!--]--><!--]--><span data-v-0f4f798b>Reactant.jl</span><!--[--><!--]--></a></div></div><div class="content" data-v-822684d1><div class="content-body" data-v-822684d1><!--[--><!--]--><div class="VPNavBarSearch search" data-v-822684d1><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-822684d1 data-v-e6d46098><span id="main-nav-aria-label" class="visually-hidden" data-v-e6d46098> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Reactant.jl/v0.2.26/" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Home</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>Getting Started</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/introduction" data-v-acbfed09><!--[--><span data-v-acbfed09>Introduction</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/introduction/configuration" data-v-acbfed09><!--[--><span data-v-acbfed09>Configuration</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link vp-external-link-icon VPNavBarMenuLink" href="https://enzymead.github.io/Reactant.jl/benchmarks/" target="_blank" rel="noreferrer" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Benchmarks</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>Tutorials</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/tutorials/" data-v-acbfed09><!--[--><span data-v-acbfed09>Overview</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/tutorials/profiling" data-v-acbfed09><!--[--><span data-v-acbfed09>Profiling</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>API</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/api" data-v-acbfed09><!--[--><span data-v-acbfed09>Core Reactant API</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/sharding" data-v-acbfed09><!--[--><span data-v-acbfed09>Sharding</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/ops" data-v-acbfed09><!--[--><span data-v-acbfed09>Ops</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuGroup" data-v-7dd3104a data-v-48c802d0><p class="title" data-v-48c802d0>MLIR Dialects</p><!--[--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/arith" data-v-acbfed09><!--[--><span data-v-acbfed09>ArithOps</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/affine" data-v-acbfed09><!--[--><span data-v-acbfed09>Affine</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/builtin" data-v-acbfed09><!--[--><span data-v-acbfed09>Builtin</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/chlo" data-v-acbfed09><!--[--><span data-v-acbfed09>Chlo</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/enzyme" data-v-acbfed09><!--[--><span data-v-acbfed09>Enzyme</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/func" data-v-acbfed09><!--[--><span data-v-acbfed09>Func</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/stablehlo" data-v-acbfed09><!--[--><span data-v-acbfed09>StableHLO</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/vhlo" data-v-acbfed09><!--[--><span data-v-acbfed09>VHLO</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/gpu" data-v-acbfed09><!--[--><span data-v-acbfed09>GPU</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link active" href="/Reactant.jl/v0.2.26/api/llvm" data-v-acbfed09><!--[--><span data-v-acbfed09>LLVM</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/nvvm" data-v-acbfed09><!--[--><span data-v-acbfed09>NVVM</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/tpu" data-v-acbfed09><!--[--><span data-v-acbfed09>TPU</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/triton" data-v-acbfed09><!--[--><span data-v-acbfed09>Triton</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/shardy" data-v-acbfed09><!--[--><span data-v-acbfed09>Shardy</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/mpi" data-v-acbfed09><!--[--><span data-v-acbfed09>MPI</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-7dd3104a data-v-48c802d0><p class="title" data-v-48c802d0>Low-Level API</p><!--[--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/mlirc" data-v-acbfed09><!--[--><span data-v-acbfed09>MLIR API</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/xla" data-v-acbfed09><!--[--><span data-v-acbfed09>XLA</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/v0.2.26/api/internal" data-v-acbfed09><!--[--><span data-v-acbfed09>Internal API</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><!----><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-822684d1 data-v-af096f4a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-af096f4a data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-822684d1 data-v-164c457f data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/EnzymeAD/Reactant.jl" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-github"></span></a><a class="VPSocialLink no-icon" href="https://julialang.org/slack/" aria-label="slack" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-slack"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-822684d1 data-v-925effce data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-04f5c5e9><span class="vpi-more-horizontal icon" data-v-04f5c5e9></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><!----><!--[--><!--[--><!----><div class="group" data-v-925effce><div class="item appearance" data-v-925effce><p class="label" data-v-925effce>Appearance</p><div class="appearance-action" data-v-925effce><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-925effce data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div></div></div><div class="group" data-v-925effce><div class="item social-links" data-v-925effce><div class="VPSocialLinks social-links-list" data-v-925effce data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/EnzymeAD/Reactant.jl" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-github"></span></a><a class="VPSocialLink no-icon" href="https://julialang.org/slack/" aria-label="slack" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-slack"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-822684d1 data-v-5dea55bf><span class="container" data-v-5dea55bf><span class="top" data-v-5dea55bf></span><span class="middle" data-v-5dea55bf></span><span class="bottom" data-v-5dea55bf></span></span></button></div></div></div></div><div class="divider" data-v-822684d1><div class="divider-line" data-v-822684d1></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-a9a9e638 data-v-070ab83d><div class="container" data-v-070ab83d><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-070ab83d><span class="vpi-align-left menu-icon" data-v-070ab83d></span><span class="menu-text" data-v-070ab83d>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-070ab83d data-v-168ddf5d><button data-v-168ddf5d>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-a9a9e638 data-v-18756405><div class="curtain" data-v-18756405></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-18756405><span class="visually-hidden" id="sidebar-aria-label" data-v-18756405> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0" data-v-9e426adc data-v-a4b0d9bf><!----><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/api" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Reactant API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/sharding" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Sharding</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/ops" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Ops</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0 collapsible has-active" data-v-9e426adc data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h2 class="text" data-v-a4b0d9bf>MLIR Dialects</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/arith" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>ArithOps</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/affine" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Affine</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/builtin" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Builtin</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/chlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Chlo</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/enzyme" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Enzyme</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/func" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Func</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/stablehlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>StableHLO</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/vhlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>VHLO</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/gpu" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>GPU</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/llvm" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>LLVM</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/nvvm" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>NVVM</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/tpu" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>TPU</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/triton" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Triton</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/shardy" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Shardy</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/mpi" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MPI</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0 collapsible" data-v-9e426adc data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h2 class="text" data-v-a4b0d9bf>Low-Level API</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/mlirc" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MLIR API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/xla" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>XLA</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0" data-v-9e426adc data-v-a4b0d9bf><!----><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/v0.2.26/api/internal" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Internal API</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-a9a9e638 data-v-91765379><div class="VPDoc has-sidebar has-aside" data-v-91765379 data-v-83890dd9><!--[--><!--]--><div class="container" data-v-83890dd9><div class="aside" data-v-83890dd9><div class="aside-curtain" data-v-83890dd9></div><div class="aside-container" data-v-83890dd9><div class="aside-content" data-v-83890dd9><div class="VPDocAside" data-v-83890dd9 data-v-6d7b3c46><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-6d7b3c46 data-v-b38bf2ff><div class="content" data-v-b38bf2ff><div class="outline-marker" data-v-b38bf2ff></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-b38bf2ff>On this page</div><ul class="VPDocOutlineItem root" data-v-b38bf2ff data-v-3f927ebe><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-6d7b3c46></div><!--[--><!--[--><!--[--><!--[--><!--[--><br><h2> Trusted by </h2><a class="enjoyer" href="https://lux.csail.mit.edu/" target="_blank"><img width="32" height="32" src="https://raw.githubusercontent.com/LuxDL/Lux.jl/refs/heads/main/assets/lux-logo.svg"><span><p class="extra-info">Scientific Computing</p><p class="heading">Lux.jl</p><p class="extra-info">Machine Learning</p></span></a><a class="enjoyer" href="https://bsc-quantic.github.io/Tenet.jl/stable/" target="_blank"><img width="32" height="32" src="https://raw.githubusercontent.com/bsc-quantic/Tenet.jl/refs/heads/master/docs/src/assets/logo.svg"><span><p class="extra-info">Quantum Simulation</p><p class="heading">Tenet.jl</p><p class="extra-info">Tensor Networks</p></span></a><!--]--><!--]--><!--]--><!--]--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-83890dd9><div class="content-container" data-v-83890dd9><!--[--><!--]--><main class="main" data-v-83890dd9><div style="position:relative;" class="vp-doc _Reactant_jl_v0_2_26_api_llvm" data-v-83890dd9><div><h1 id="LLVM-Dialect" tabindex="-1">LLVM Dialect <a class="header-anchor" href="#LLVM-Dialect" aria-label="Permalink to &quot;LLVM Dialect {#LLVM-Dialect}&quot;">​</a></h1><p>Refer to the <a href="https://mlir.llvm.org/docs/Dialects/LLVM/" target="_blank" rel="noreferrer">official documentation</a> for more details.</p><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.call-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.llvm.call-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.call</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>call</code></p><p>In LLVM IR, functions may return either 0 or 1 value. LLVM IR dialect implements this behavior by providing a variadic <code>call</code> operation for 0- and 1-result functions. Even though MLIR supports multi-result functions, LLVM IR dialect disallows them.</p><p>The <code>call</code> instruction supports both direct and indirect calls. Direct calls start with a function name (<code>@</code>-prefixed) and indirect calls start with an SSA value (<code>%</code>-prefixed). The direct callee, if present, is stored as a function attribute <code>callee</code>. For indirect calls, the callee is of <code>!llvm.ptr</code> type and is stored as the first value in <code>callee_operands</code>. If and only if the callee is a variadic function, the <code>var_callee_type</code> attribute must carry the variadic LLVM function type. The trailing type list contains the optional indirect callee type and the MLIR function type, which differs from the LLVM function type that uses an explicit void type to model functions that do not return a value.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Direct call without arguments and with one result.</span></span>
<span class="line"><span>%0 = llvm.call @foo() : () -&gt; (f32)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Direct call with arguments and without a result.</span></span>
<span class="line"><span>llvm.call @bar(%0) : (f32) -&gt; ()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Indirect call with an argument and without a result.</span></span>
<span class="line"><span>%1 = llvm.mlir.addressof @foo : !llvm.ptr</span></span>
<span class="line"><span>llvm.call %1(%0) : !llvm.ptr, (f32) -&gt; ()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Direct variadic call.</span></span>
<span class="line"><span>llvm.call @printf(%0, %1) vararg(!llvm.func&lt;i32 (ptr, ...)&gt;) : (!llvm.ptr, i32) -&gt; i32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Indirect variadic call</span></span>
<span class="line"><span>llvm.call %1(%0) vararg(!llvm.func&lt;void (...)&gt;) : !llvm.ptr, (i32) -&gt; ()</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L446-L484" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.call_intrinsic-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.llvm.call_intrinsic-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.call_intrinsic</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>call_intrinsic</code></p><p>Call the specified llvm intrinsic. If the intrinsic is overloaded, use the MLIR function type of this op to determine which intrinsic to call.</p><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L404-L409" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.comdat-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.comdat-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.comdat</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>comdat</code></p><p>Provides access to object file COMDAT section/group functionality.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>llvm.comdat @__llvm_comdat {</span></span>
<span class="line"><span>  llvm.comdat_selector @any any</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>llvm.mlir.global internal constant @has_any_comdat(1 : i64) comdat(@__llvm_comdat::@any) : i64</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L558-L570" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.comdat_selector-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.comdat_selector-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.comdat_selector</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>comdat_selector</code></p><p>Provides access to object file COMDAT section/group functionality.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>llvm.comdat @__llvm_comdat {</span></span>
<span class="line"><span>  llvm.comdat_selector @any any</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>llvm.mlir.global internal constant @has_any_comdat(1 : i64) comdat(@__llvm_comdat::@any) : i64</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L590-L602" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.func-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.func-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.func</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>func</code></p><p>MLIR functions are defined by an operation that is not built into the IR itself. The LLVM dialect provides an <code>llvm.func</code> operation to define functions compatible with LLVM IR. These functions have LLVM dialect function type but use MLIR syntax to express it. They are required to have exactly one result type. LLVM function operation is intended to capture additional properties of LLVM functions, such as linkage and calling convention, that may be modeled differently by the built-in MLIR function.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// The type of @bar is !llvm&lt;&quot;i64 (i64)&quot;&gt;</span></span>
<span class="line"><span>llvm.func @bar(%arg0: i64) -&gt; i64 {</span></span>
<span class="line"><span>  llvm.return %arg0 : i64</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Type type of @foo is !llvm&lt;&quot;void (i64)&quot;&gt;</span></span>
<span class="line"><span>// !llvm.void type is omitted</span></span>
<span class="line"><span>llvm.func @foo(%arg0: i64) {</span></span>
<span class="line"><span>  llvm.return</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// A function with `internal` linkage.</span></span>
<span class="line"><span>llvm.func internal @internal_func() {</span></span>
<span class="line"><span>  llvm.return</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L1579-L1607" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.getelementptr-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.llvm.getelementptr-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.getelementptr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>getelementptr</code></p><p>This operation mirrors LLVM IRs &#39;getelementptr&#39; operation that is used to perform pointer arithmetic.</p><p>Like in LLVM IR, it is possible to use both constants as well as SSA values as indices. In the case of indexing within a structure, it is required to either use constant indices directly, or supply a constant SSA value.</p><p>An optional &#39;inbounds&#39; attribute specifies the low-level pointer arithmetic overflow behavior that LLVM uses after lowering the operation to LLVM IR.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// GEP with an SSA value offset</span></span>
<span class="line"><span>%0 = llvm.getelementptr %1[%2] : (!llvm.ptr, i64) -&gt; !llvm.ptr, f32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// GEP with a constant offset and the inbounds attribute set</span></span>
<span class="line"><span>%0 = llvm.getelementptr inbounds %1[3] : (!llvm.ptr) -&gt; !llvm.ptr, f32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// GEP with constant offsets into a structure</span></span>
<span class="line"><span>%0 = llvm.getelementptr %1[0, 1]</span></span>
<span class="line"><span>   : (!llvm.ptr) -&gt; !llvm.ptr, !llvm.struct&lt;(i32, f32)&gt;</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L1078-L1104" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.inline_asm-Tuple{Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.llvm.inline_asm-Tuple{Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.inline_asm</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>inline_asm</code></p><p>The InlineAsmOp mirrors the underlying LLVM semantics with a notable exception: the embedded <code>asm_string</code> is not allowed to define or reference any symbol or any global variable: only the operands of the op may be read, written, or referenced. Attempting to define or reference any symbol or any global behavior is considered undefined behavior at this time.</p><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L1398-L1407" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.linker_options-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.linker_options-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.linker_options</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>linker_options</code></p><p>Pass the given options to the linker when the resulting object file is linked. This is used extensively on Windows to determine the C runtime that the object files should link against.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Link against the MSVC static threaded CRT.</span></span>
<span class="line"><span>llvm.linker_options [&quot;/DEFAULTLIB:&quot;, &quot;libcmt&quot;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Link against aarch64 compiler-rt builtins</span></span>
<span class="line"><span>llvm.linker_options [&quot;-l&quot;, &quot;clang_rt.builtins-aarch64&quot;]</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L1807-L1822" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.load-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.llvm.load-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.load</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>load</code></p><p>The <code>load</code> operation is used to read from memory. A load may be marked as atomic, volatile, and/or nontemporal, and takes a number of optional attributes that specify aliasing information.</p><p>An atomic load only supports a limited set of pointer, integer, and floating point types, and requires an explicit alignment.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// A volatile load of a float variable.</span></span>
<span class="line"><span>%0 = llvm.load volatile %ptr : !llvm.ptr -&gt; f32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// A nontemporal load of a float variable.</span></span>
<span class="line"><span>%0 = llvm.load %ptr {nontemporal} : !llvm.ptr -&gt; f32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// An atomic load of an integer variable.</span></span>
<span class="line"><span>%0 = llvm.load %ptr atomic monotonic {alignment = 8 : i64}</span></span>
<span class="line"><span>    : !llvm.ptr -&gt; i64</span></span></code></pre></div><p>See the following link for more details: <a href="https://llvm.org/docs/LangRef.html#load-instruction" target="_blank" rel="noreferrer">https://llvm.org/docs/LangRef.html#load-instruction</a></p><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L1842-L1867" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.mlir_addressof-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.mlir_addressof-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.mlir_addressof</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mlir_addressof</code></p><p>Creates an SSA value containing a pointer to a global value (function, variable or alias). The global value can be defined after its first referenced. If the global value is a constant, storing into it is not allowed.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>func @foo() {</span></span>
<span class="line"><span>  // Get the address of a global variable.</span></span>
<span class="line"><span>  %0 = llvm.mlir.addressof @const : !llvm.ptr</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // Use it as a regular pointer.</span></span>
<span class="line"><span>  %1 = llvm.load %0 : !llvm.ptr -&gt; i32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // Get the address of a function.</span></span>
<span class="line"><span>  %2 = llvm.mlir.addressof @foo : !llvm.ptr</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // The function address can be used for indirect calls.</span></span>
<span class="line"><span>  llvm.call %2() : !llvm.ptr, () -&gt; ()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // Get the address of an aliased global.</span></span>
<span class="line"><span>  %3 = llvm.mlir.addressof @const_alias : !llvm.ptr</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Define the global.</span></span>
<span class="line"><span>llvm.mlir.global @const(42 : i32) : i32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Define an alias.</span></span>
<span class="line"><span>llvm.mlir.alias @const_alias : i32 {</span></span>
<span class="line"><span>  %0 = llvm.mlir.addressof @const : !llvm.ptr</span></span>
<span class="line"><span>  llvm.return %0 : !llvm.ptr</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L84-L121" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.mlir_alias-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.mlir_alias-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.mlir_alias</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mlir_alias</code></p><p><code>llvm.mlir.alias</code> is a top level operation that defines a global alias for global variables and functions. The operation is always initialized by using a initializer region which could be a direct map to another global value or contain some address computation on top of it.</p><p>It uses a symbol for its value, which will be uniqued by the module with respect to other symbols in it.</p><p>Similarly to functions and globals, they can also have a linkage attribute. This attribute is placed between <code>llvm.mlir.alias</code> and the symbol name. If the attribute is omitted, <code>external</code> linkage is assumed by default.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Global alias use @-identifiers.</span></span>
<span class="line"><span>llvm.mlir.alias external @foo_alias {addr_space = 0 : i32} : !llvm.ptr {</span></span>
<span class="line"><span>  %0 = llvm.mlir.addressof @some_function : !llvm.ptr</span></span>
<span class="line"><span>  llvm.return %0 : !llvm.ptr</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// More complex initialization.</span></span>
<span class="line"><span>llvm.mlir.alias linkonce_odr hidden @glob</span></span>
<span class="line"><span>{addr_space = 0 : i32, dso_local} : !llvm.array&lt;32 x i32&gt; {</span></span>
<span class="line"><span>  %0 = llvm.mlir.constant(1234 : i64) : i64</span></span>
<span class="line"><span>  %1 = llvm.mlir.addressof @glob.private : !llvm.ptr</span></span>
<span class="line"><span>  %2 = llvm.ptrtoint %1 : !llvm.ptr to i64</span></span>
<span class="line"><span>  %3 = llvm.add %2, %0 : i64</span></span>
<span class="line"><span>  %4 = llvm.inttoptr %3 : i64 to !llvm.ptr</span></span>
<span class="line"><span>  llvm.return %4 : !llvm.ptr</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L141-L176" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.mlir_constant-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.mlir_constant-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.mlir_constant</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mlir_constant</code></p><p>Unlike LLVM IR, MLIR does not have first-class constant values. Therefore, all constants must be created as SSA values before being used in other operations. <code>llvm.mlir.constant</code> creates such values for scalars, vectors, strings, and structs. It has a mandatory <code>value</code> attribute whose type depends on the type of the constant value. The type of the constant value must correspond to the attribute type converted to LLVM IR type.</p><p>When creating constant scalars, the <code>value</code> attribute must be either an integer attribute or a floating point attribute. The type of the attribute may be omitted for <code>i64</code> and <code>f64</code> types that are implied.</p><p>When creating constant vectors, the <code>value</code> attribute must be either an array attribute, a dense attribute, or a sparse attribute that contains integers or floats. The number of elements in the result vector must match the number of elements in the attribute.</p><p>When creating constant strings, the <code>value</code> attribute must be a string attribute. The type of the constant must be an LLVM array of <code>i8</code>s, and the length of the array must match the length of the attribute.</p><p>When creating constant structs, the <code>value</code> attribute must be an array attribute that contains integers or floats. The type of the constant must be an LLVM struct type. The number of fields in the struct must match the number of elements in the attribute, and the type of each LLVM struct field must correspond to the type of the corresponding attribute element converted to LLVM IR.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Integer constant, internal i32 is mandatory</span></span>
<span class="line"><span>%0 = llvm.mlir.constant(42 : i32) : i32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// It&#39;s okay to omit i64.</span></span>
<span class="line"><span>%1 = llvm.mlir.constant(42) : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Floating point constant.</span></span>
<span class="line"><span>%2 = llvm.mlir.constant(42.0 : f32) : f32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Splat dense vector constant.</span></span>
<span class="line"><span>%3 = llvm.mlir.constant(dense&lt;1.0&gt; : vector&lt;4xf32&gt;) : vector&lt;4xf32&gt;</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L660-L705" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.mlir_global-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.mlir_global-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.mlir_global</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mlir_global</code></p><p>Since MLIR allows for arbitrary operations to be present at the top level, global variables are defined using the <code>llvm.mlir.global</code> operation. Both global constants and variables can be defined, and the value may also be initialized in both cases.</p><p>There are two forms of initialization syntax. Simple constants that can be represented as MLIR attributes can be given in-line:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>llvm.mlir.global @variable(32.0 : f32) : f32</span></span></code></pre></div><p>This initialization and type syntax is similar to <code>llvm.mlir.constant</code> and may use two types: one for MLIR attribute and another for the LLVM value. These types must be compatible.</p><p>More complex constants that cannot be represented as MLIR attributes can be given in an initializer region:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// This global is initialized with the equivalent of:</span></span>
<span class="line"><span>//   i32* getelementptr (i32* @g2, i32 2)</span></span>
<span class="line"><span>llvm.mlir.global constant @int_gep() : !llvm.ptr {</span></span>
<span class="line"><span>  %0 = llvm.mlir.addressof @g2 : !llvm.ptr</span></span>
<span class="line"><span>  %1 = llvm.mlir.constant(2 : i32) : i32</span></span>
<span class="line"><span>  %2 = llvm.getelementptr %0[%1]</span></span>
<span class="line"><span>     : (!llvm.ptr, i32) -&gt; !llvm.ptr, i32</span></span>
<span class="line"><span>  // The initializer region must end with `llvm.return`.</span></span>
<span class="line"><span>  llvm.return %2 : !llvm.ptr</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Only one of the initializer attribute or initializer region may be provided.</p><p><code>llvm.mlir.global</code> must appear at top-level of the enclosing module. It uses an @-identifier for its value, which will be uniqued by the module with respect to other @-identifiers in it.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Global values use @-identifiers.</span></span>
<span class="line"><span>llvm.mlir.global constant @cst(42 : i32) : i32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Non-constant values must also be initialized.</span></span>
<span class="line"><span>llvm.mlir.global @variable(32.0 : f32) : f32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Strings are expected to be of wrapped LLVM i8 array type and do not</span></span>
<span class="line"><span>// automatically include the trailing zero.</span></span>
<span class="line"><span>llvm.mlir.global @string(&quot;abc&quot;) : !llvm.array&lt;3 x i8&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// For strings globals, the trailing type may be omitted.</span></span>
<span class="line"><span>llvm.mlir.global constant @no_trailing_type(&quot;foo bar&quot;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// A complex initializer is constructed with an initializer region.</span></span>
<span class="line"><span>llvm.mlir.global constant @int_gep() : !llvm.ptr {</span></span>
<span class="line"><span>  %0 = llvm.mlir.addressof @g2 : !llvm.ptr</span></span>
<span class="line"><span>  %1 = llvm.mlir.constant(2 : i32) : i32</span></span>
<span class="line"><span>  %2 = llvm.getelementptr %0[%1]</span></span>
<span class="line"><span>     : (!llvm.ptr, i32) -&gt; !llvm.ptr, i32</span></span>
<span class="line"><span>  llvm.return %2 : !llvm.ptr</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Similarly to functions, globals have a linkage attribute. In the custom syntax, this attribute is placed between <code>llvm.mlir.global</code> and the optional <code>constant</code> keyword. If the attribute is omitted, <code>external</code> linkage is assumed by default.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// A constant with internal linkage will not participate in linking.</span></span>
<span class="line"><span>llvm.mlir.global internal constant @cst(42 : i32) : i32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// By default, &quot;external&quot; linkage is assumed and the global participates in</span></span>
<span class="line"><span>// symbol resolution at link-time.</span></span>
<span class="line"><span>llvm.mlir.global @glob(0 : f32) : f32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Alignment is optional</span></span>
<span class="line"><span>llvm.mlir.global private constant @y(dense&lt;1.0&gt; : tensor&lt;8xf32&gt;) : !llvm.array&lt;8 x f32&gt;</span></span></code></pre></div><p>Like global variables in LLVM IR, globals can have an (optional) alignment attribute using keyword <code>alignment</code>. The integer value of the alignment must be a positive integer that is a power of 2.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Alignment is optional</span></span>
<span class="line"><span>llvm.mlir.global private constant @y(dense&lt;1.0&gt; : tensor&lt;8xf32&gt;) { alignment = 32 : i64 } : !llvm.array&lt;8 x f32&gt;</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L1219-L1315" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.mlir_global_ctors-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.mlir_global_ctors-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.mlir_global_ctors</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mlir_global_ctors</code></p><p>Specifies a list of constructor functions and priorities. The functions referenced by this array will be called in ascending order of priority (i.e. lowest first) when the module is loaded. The order of functions with the same priority is not defined. This operation is translated to LLVM&#39;s global_ctors global variable. The initializer functions are run at load time. The <code>data</code> field present in LLVM&#39;s global_ctors variable is not modeled here.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>llvm.mlir.global_ctors {@ctor}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>llvm.func @ctor() {</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>  llvm.return</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L1136-L1157" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.mlir_global_dtors-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.mlir_global_dtors-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.mlir_global_dtors</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mlir_global_dtors</code></p><p>Specifies a list of destructor functions and priorities. The functions referenced by this array will be called in descending order of priority (i.e. highest first) when the module is unloaded. The order of functions with the same priority is not defined. This operation is translated to LLVM&#39;s global_dtors global variable. The <code>data</code> field present in LLVM&#39;s global_dtors variable is not modeled here.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>llvm.func @dtor() {</span></span>
<span class="line"><span>  llvm.return</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>llvm.mlir.global_dtors {@dtor}</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L1179-L1197" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.mlir_none-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.mlir_none-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.mlir_none</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mlir_none</code></p><p>Unlike LLVM IR, MLIR does not have first-class token values. They must be explicitly created as SSA values using <code>llvm.mlir.none</code>. This operation has no operands or attributes, and returns a none token value of a wrapped LLVM IR pointer type.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = llvm.mlir.none : !llvm.token</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L1939-L1952" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.mlir_poison-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.mlir_poison-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.mlir_poison</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mlir_poison</code></p><p>Unlike LLVM IR, MLIR does not have first-class poison values. Such values must be created as SSA values using <code>llvm.mlir.poison</code>. This operation has no operands or attributes. It creates a poison value of the specified LLVM IR dialect type.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Create a poison value for a structure with a 32-bit integer followed</span></span>
<span class="line"><span>// by a float.</span></span>
<span class="line"><span>%0 = llvm.mlir.poison : !llvm.struct&lt;(i32, f32)&gt;</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L2000-L2015" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.mlir_undef-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.mlir_undef-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.mlir_undef</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mlir_undef</code></p><p>Unlike LLVM IR, MLIR does not have first-class undefined values. Such values must be created as SSA values using <code>llvm.mlir.undef</code>. This operation has no operands or attributes. It creates an undefined value of the specified LLVM IR dialect type.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Create a structure with a 32-bit integer followed by a float.</span></span>
<span class="line"><span>%0 = llvm.mlir.undef : !llvm.struct&lt;(i32, f32)&gt;</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L2470-L2484" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.mlir_zero-Tuple{}" href="#Reactant.MLIR.Dialects.llvm.mlir_zero-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.mlir_zero</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mlir_zero</code></p><p>Unlike LLVM IR, MLIR does not have first-class zero-initialized values. Such values must be created as SSA values using <code>llvm.mlir.zero</code>. This operation has no operands or attributes. It creates a zero-initialized value of the specified LLVM IR dialect type.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Create a zero-initialized value for a structure with a 32-bit integer</span></span>
<span class="line"><span>// followed by a float.</span></span>
<span class="line"><span>%0 = llvm.mlir.zero : !llvm.struct&lt;(i32, f32)&gt;</span></span></code></pre></div><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L2584-L2599" target="_blank" rel="noreferrer">source</a></p></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.llvm.store-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.llvm.store-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.llvm.store</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>store</code></p><p>The <code>store</code> operation is used to write to memory. A store may be marked as atomic, volatile, and/or nontemporal, and takes a number of optional attributes that specify aliasing information.</p><p>An atomic store only supports a limited set of pointer, integer, and floating point types, and requires an explicit alignment.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// A volatile store of a float variable.</span></span>
<span class="line"><span>llvm.store volatile %val, %ptr : f32, !llvm.ptr</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// A nontemporal store of a float variable.</span></span>
<span class="line"><span>llvm.store %val, %ptr {nontemporal} : f32, !llvm.ptr</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// An atomic store of an integer variable.</span></span>
<span class="line"><span>llvm.store %val, %ptr atomic monotonic {alignment = 8 : i64}</span></span>
<span class="line"><span>    : i64, !llvm.ptr</span></span></code></pre></div><p>See the following link for more details: <a href="https://llvm.org/docs/LangRef.html#store-instruction" target="_blank" rel="noreferrer">https://llvm.org/docs/LangRef.html#store-instruction</a></p><p><a href="https://github.com/EnzymeAD/Reactant.jl/blob/168069865d39794c1a7c6305135b53660c8844d9/src/mlir/Dialects/Llvm.jl#L2250-L2275" target="_blank" rel="noreferrer">source</a></p></details></div></div></main><footer class="VPDocFooter" data-v-83890dd9 data-v-4f9813fa><!--[--><!--]--><div class="edit-info" data-v-4f9813fa><div class="edit-link" data-v-4f9813fa><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/EnzymeAD/Reactant.jl/edit/main/docs/src/api/llvm.md" target="_blank" rel="noreferrer" data-v-4f9813fa><!--[--><span class="vpi-square-pen edit-link-icon" data-v-4f9813fa></span> Edit this page on GitHub<!--]--></a></div><!----></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-4f9813fa><span class="visually-hidden" id="doc-footer-aria-label" data-v-4f9813fa>Pager</span><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link prev" href="/Reactant.jl/v0.2.26/api/gpu" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Previous page</span><span class="title" data-v-4f9813fa>GPU</span><!--]--></a></div><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link next" href="/Reactant.jl/v0.2.26/api/nvvm" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Next page</span><span class="title" data-v-4f9813fa>NVVM</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-a9a9e638 data-v-c970a860><div class="container" data-v-c970a860><p class="message" data-v-c970a860>Made with <a href="https://documenter.juliadocs.org/stable/" target="_blank"><strong>Documenter.jl</strong></a>, <a href="https://vitepress.dev" target="_blank"><strong>VitePress</strong></a> and <a href="https://luxdl.github.io/DocumenterVitepress.jl/stable" target="_blank"><strong>DocumenterVitepress.jl</strong></a><br>Released under the MIT License. Powered by the <a href="https://www.julialang.org">Julia Programming Language</a>.<br></p><p class="copyright" data-v-c970a860>© Copyright 2025 Reactant Development Team.</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"api_affine.md\":\"DWXCedIN\",\"api_api.md\":\"wwKZNrPk\",\"api_arith.md\":\"BF1BF2rA\",\"api_builtin.md\":\"Cofr7W3N\",\"api_chlo.md\":\"BeanbnSZ\",\"api_enzyme.md\":\"uTdac6wU\",\"api_func.md\":\"CiR2N6Eg\",\"api_gpu.md\":\"DXR2gsPD\",\"api_internal.md\":\"DE67lRdB\",\"api_llvm.md\":\"DqQxqqTo\",\"api_mlirc.md\":\"DHXKzGvO\",\"api_mpi.md\":\"DVdNKPME\",\"api_nvvm.md\":\"CGFSZf2l\",\"api_ops.md\":\"Cdou3Sbv\",\"api_sharding.md\":\"DyFIl0L_\",\"api_shardy.md\":\"BGHb1EmW\",\"api_stablehlo.md\":\"ipoN-Wsv\",\"api_tpu.md\":\"C65GEura\",\"api_triton.md\":\"BGa1sv7n\",\"api_vhlo.md\":\"Bz9Av-7X\",\"api_xla.md\":\"WHoh84DX\",\"index.md\":\"DUWCq9mc\",\"introduction_configuration.md\":\"hSv42ysa\",\"introduction_index.md\":\"D55pVRBP\",\"tutorials_index.md\":\"BZOCWa9m\",\"tutorials_profiling.md\":\"BfxBdFc0\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Reactant.jl\",\"description\":\"Documentation for Reactant.jl\",\"base\":\"/Reactant.jl/v0.2.26/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"outline\":\"deep\",\"logo\":{\"light\":\"/logo.svg\",\"dark\":\"/logo.svg\"},\"search\":{\"provider\":\"local\",\"options\":{\"detailedView\":true}},\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Getting Started\",\"items\":[{\"text\":\"Introduction\",\"link\":\"/introduction\"},{\"text\":\"Configuration\",\"link\":\"/introduction/configuration\"}]},{\"text\":\"Benchmarks\",\"link\":\"https://enzymead.github.io/Reactant.jl/benchmarks/\"},{\"text\":\"Tutorials\",\"items\":[{\"text\":\"Overview\",\"link\":\"/tutorials/\"},{\"text\":\"Profiling\",\"link\":\"/tutorials/profiling\"}]},{\"text\":\"API\",\"items\":[{\"text\":\"Core Reactant API\",\"link\":\"/api/api\"},{\"text\":\"Sharding\",\"link\":\"/api/sharding\"},{\"text\":\"Ops\",\"link\":\"/api/ops\"},{\"text\":\"MLIR Dialects\",\"items\":[{\"text\":\"ArithOps\",\"link\":\"/api/arith\"},{\"text\":\"Affine\",\"link\":\"/api/affine\"},{\"text\":\"Builtin\",\"link\":\"/api/builtin\"},{\"text\":\"Chlo\",\"link\":\"/api/chlo\"},{\"text\":\"Enzyme\",\"link\":\"/api/enzyme\"},{\"text\":\"Func\",\"link\":\"/api/func\"},{\"text\":\"StableHLO\",\"link\":\"/api/stablehlo\"},{\"text\":\"VHLO\",\"link\":\"/api/vhlo\"},{\"text\":\"GPU\",\"link\":\"/api/gpu\"},{\"text\":\"LLVM\",\"link\":\"/api/llvm\"},{\"text\":\"NVVM\",\"link\":\"/api/nvvm\"},{\"text\":\"TPU\",\"link\":\"/api/tpu\"},{\"text\":\"Triton\",\"link\":\"/api/triton\"},{\"text\":\"Shardy\",\"link\":\"/api/shardy\"},{\"text\":\"MPI\",\"link\":\"/api/mpi\"}]},{\"text\":\"Low-Level API\",\"items\":[{\"text\":\"MLIR API\",\"link\":\"/api/mlirc\"},{\"text\":\"XLA\",\"link\":\"/api/xla\"}]},{\"text\":\"Internal API\",\"link\":\"/api/internal\"}]},{\"component\":\"VersionPicker\"}],\"sidebar\":{\"/introduction/\":{\"text\":\"Getting Started\",\"collapsed\":false,\"items\":[{\"text\":\"Introduction\",\"link\":\"/introduction\"},{\"text\":\"Configuration\",\"link\":\"/introduction/configuration\"}]},\"/tutorials/\":{\"text\":\"Tutorials\",\"collapsed\":false,\"items\":[{\"text\":\"Overview\",\"link\":\"/tutorials/\"},{\"text\":\"Profiling\",\"link\":\"/tutorials/profiling\"}]},\"/api/\":{\"text\":\"API Reference\",\"collapsed\":false,\"items\":[{\"text\":\"Reactant API\",\"link\":\"/api/api\"},{\"text\":\"Sharding\",\"link\":\"/api/sharding\"},{\"text\":\"Ops\",\"link\":\"/api/ops\"},{\"text\":\"MLIR Dialects\",\"collapsed\":false,\"items\":[{\"text\":\"ArithOps\",\"link\":\"/api/arith\"},{\"text\":\"Affine\",\"link\":\"/api/affine\"},{\"text\":\"Builtin\",\"link\":\"/api/builtin\"},{\"text\":\"Chlo\",\"link\":\"/api/chlo\"},{\"text\":\"Enzyme\",\"link\":\"/api/enzyme\"},{\"text\":\"Func\",\"link\":\"/api/func\"},{\"text\":\"StableHLO\",\"link\":\"/api/stablehlo\"},{\"text\":\"VHLO\",\"link\":\"/api/vhlo\"},{\"text\":\"GPU\",\"link\":\"/api/gpu\"},{\"text\":\"LLVM\",\"link\":\"/api/llvm\"},{\"text\":\"NVVM\",\"link\":\"/api/nvvm\"},{\"text\":\"TPU\",\"link\":\"/api/tpu\"},{\"text\":\"Triton\",\"link\":\"/api/triton\"},{\"text\":\"Shardy\",\"link\":\"/api/shardy\"},{\"text\":\"MPI\",\"link\":\"/api/mpi\"}]},{\"text\":\"Low-Level API\",\"collapsed\":false,\"items\":[{\"text\":\"MLIR API\",\"link\":\"/api/mlirc\"},{\"text\":\"XLA\",\"link\":\"/api/xla\"}]},{\"text\":\"Internal API\",\"link\":\"/api/internal\"}]}},\"editLink\":{\"pattern\":\"https://github.com/EnzymeAD/Reactant.jl/edit/main/docs/src/:path\",\"text\":\"Edit this page on GitHub\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/EnzymeAD/Reactant.jl\"},{\"icon\":\"slack\",\"link\":\"https://julialang.org/slack/\"}],\"footer\":{\"message\":\"Made with <a href=\\\"https://documenter.juliadocs.org/stable/\\\" target=\\\"_blank\\\"><strong>Documenter.jl</strong></a>, <a href=\\\"https://vitepress.dev\\\" target=\\\"_blank\\\"><strong>VitePress</strong></a> and <a href=\\\"https://luxdl.github.io/DocumenterVitepress.jl/stable\\\" target=\\\"_blank\\\"><strong>DocumenterVitepress.jl</strong></a><br>Released under the MIT License. Powered by the <a href=\\\"https://www.julialang.org\\\">Julia Programming Language</a>.<br>\",\"copyright\":\"© Copyright 2025 Reactant Development Team.\"},\"lastUpdated\":{\"text\":\"Updated at\",\"formatOptions\":{\"dateStyle\":\"full\",\"timeStyle\":\"medium\"}}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>