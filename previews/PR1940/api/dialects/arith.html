<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Arithmetic Dialect | Reactant.jl</title>
    <meta name="description" content="Documentation for Reactant.jl">
    <meta name="generator" content="VitePress v1.6.4">
    <link rel="preload stylesheet" href="/Reactant.jl/previews/PR1940/assets/style.0jY5ywin.css" as="style">
    <link rel="preload stylesheet" href="/Reactant.jl/previews/PR1940/vp-icons.css" as="style">
    
    <script type="module" src="/Reactant.jl/previews/PR1940/assets/app.E6wvhYDQ.js"></script>
    <link rel="preload" href="/Reactant.jl/previews/PR1940/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Reactant.jl/previews/PR1940/assets/chunks/theme.W1H_rZOy.js">
    <link rel="modulepreload" href="/Reactant.jl/previews/PR1940/assets/chunks/framework.CL3Cizav.js">
    <link rel="modulepreload" href="/Reactant.jl/previews/PR1940/assets/api_dialects_arith.md.CGHlqyuw.lean.js">
    <link rel="icon" href="/Reactant.jl/previews/PR1940/favicon.ico">
    <script src="/versions.js"></script>
    <script src="/Reactant.jl/previews/PR1940/siteinfo.js"></script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-a9a9e638><!--[--><!--]--><!--[--><span tabindex="-1" data-v-492508fc></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-492508fc>Skip to content</a><!--]--><!----><header class="VPNav" data-v-a9a9e638 data-v-f1e365da><div class="VPNavBar" data-v-f1e365da data-v-822684d1><div class="wrapper" data-v-822684d1><div class="container" data-v-822684d1><div class="title" data-v-822684d1><div class="VPNavBarTitle has-sidebar" data-v-822684d1 data-v-0f4f798b><a class="title" href="/Reactant.jl/previews/PR1940/" data-v-0f4f798b><!--[--><!--]--><!--[--><!--[--><!--[--><img class="VPImage dark logo" src="/Reactant.jl/previews/PR1940/logo.svg" alt data-v-35a7d0b8><!--]--><!--[--><img class="VPImage light logo" src="/Reactant.jl/previews/PR1940/logo.svg" alt data-v-35a7d0b8><!--]--><!--]--><!--]--><span data-v-0f4f798b>Reactant.jl</span><!--[--><!--]--></a></div></div><div class="content" data-v-822684d1><div class="content-body" data-v-822684d1><!--[--><!--]--><div class="VPNavBarSearch search" data-v-822684d1><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-822684d1 data-v-e6d46098><span id="main-nav-aria-label" class="visually-hidden" data-v-e6d46098> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Reactant.jl/previews/PR1940/" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Home</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>Getting Started</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/introduction" data-v-acbfed09><!--[--><span data-v-acbfed09>Introduction</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/introduction/configuration" data-v-acbfed09><!--[--><span data-v-acbfed09>Configuration</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/introduction/FAQs" data-v-acbfed09><!--[--><span data-v-acbfed09>FAQs</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link vp-external-link-icon VPNavBarMenuLink" href="https://enzymead.github.io/Reactant.jl/benchmarks/" target="_blank" rel="noreferrer" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Benchmarks</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>Tutorials</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/tutorials/" data-v-acbfed09><!--[--><span data-v-acbfed09>Overview</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/tutorials/partial-evaluation" data-v-acbfed09><!--[--><span data-v-acbfed09>Partial Evaluation</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/tutorials/control-flow" data-v-acbfed09><!--[--><span data-v-acbfed09>Control Flow</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/tutorials/automatic-differentiation" data-v-acbfed09><!--[--><span data-v-acbfed09>Automatic Differentiation</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/tutorials/sharding" data-v-acbfed09><!--[--><span data-v-acbfed09>Sharding</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/tutorials/profiling" data-v-acbfed09><!--[--><span data-v-acbfed09>Profiling</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/tutorials/multihost" data-v-acbfed09><!--[--><span data-v-acbfed09>Multi-Host Environments</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/tutorials/local-build" data-v-acbfed09><!--[--><span data-v-acbfed09>Local build</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/tutorials/persistent_compile_cache" data-v-acbfed09><!--[--><span data-v-acbfed09>Persistent Compilation Cache</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>API</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/api" data-v-acbfed09><!--[--><span data-v-acbfed09>Core Reactant API</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/sharding" data-v-acbfed09><!--[--><span data-v-acbfed09>Sharding</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/serialization" data-v-acbfed09><!--[--><span data-v-acbfed09>Serialization</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/ops" data-v-acbfed09><!--[--><span data-v-acbfed09>Ops</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/config" data-v-acbfed09><!--[--><span data-v-acbfed09>Configuration</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuGroup" data-v-7dd3104a data-v-48c802d0><p class="title" data-v-48c802d0>MLIR Dialects</p><!--[--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link active" href="/Reactant.jl/previews/PR1940/api/dialects/arith" data-v-acbfed09><!--[--><span data-v-acbfed09>ArithOps</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/affine" data-v-acbfed09><!--[--><span data-v-acbfed09>Affine</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/builtin" data-v-acbfed09><!--[--><span data-v-acbfed09>Builtin</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/chlo" data-v-acbfed09><!--[--><span data-v-acbfed09>Chlo</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/enzyme" data-v-acbfed09><!--[--><span data-v-acbfed09>Enzyme</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/enzymexla" data-v-acbfed09><!--[--><span data-v-acbfed09>EnzymeXLA</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/func" data-v-acbfed09><!--[--><span data-v-acbfed09>Func</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/gpu" data-v-acbfed09><!--[--><span data-v-acbfed09>GPU</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/llvm" data-v-acbfed09><!--[--><span data-v-acbfed09>LLVM</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/mpi" data-v-acbfed09><!--[--><span data-v-acbfed09>MPI</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/memref" data-v-acbfed09><!--[--><span data-v-acbfed09>MemRef</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/mosaicgpu" data-v-acbfed09><!--[--><span data-v-acbfed09>Mosaic GPU</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/nvvm" data-v-acbfed09><!--[--><span data-v-acbfed09>NVVM</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/shardy" data-v-acbfed09><!--[--><span data-v-acbfed09>Shardy</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/sparsetensor" data-v-acbfed09><!--[--><span data-v-acbfed09>SparseTensor</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/stablehlo" data-v-acbfed09><!--[--><span data-v-acbfed09>StableHLO</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/triton" data-v-acbfed09><!--[--><span data-v-acbfed09>Triton</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/tritonext" data-v-acbfed09><!--[--><span data-v-acbfed09>TritonExt</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/tpu" data-v-acbfed09><!--[--><span data-v-acbfed09>TPU</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/dialects/vhlo" data-v-acbfed09><!--[--><span data-v-acbfed09>VHLO</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-7dd3104a data-v-48c802d0><p class="title" data-v-48c802d0>Low-Level API</p><!--[--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/mlirc" data-v-acbfed09><!--[--><span data-v-acbfed09>MLIR API</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/xla" data-v-acbfed09><!--[--><span data-v-acbfed09>XLA</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1940/api/internal" data-v-acbfed09><!--[--><span data-v-acbfed09>Internal API</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><!----><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-822684d1 data-v-af096f4a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-af096f4a data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-822684d1 data-v-164c457f data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://julialang.org/slack/" aria-label="slack" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-slack"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-822684d1 data-v-925effce data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-04f5c5e9><span class="vpi-more-horizontal icon" data-v-04f5c5e9></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><!----><!--[--><!--[--><!----><div class="group" data-v-925effce><div class="item appearance" data-v-925effce><p class="label" data-v-925effce>Appearance</p><div class="appearance-action" data-v-925effce><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-925effce data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div></div></div><div class="group" data-v-925effce><div class="item social-links" data-v-925effce><div class="VPSocialLinks social-links-list" data-v-925effce data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://julialang.org/slack/" aria-label="slack" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-slack"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--[--><!--[--><!--[--><a target="_blank" data-decoration="★" title="263 GitHub stars" href="https://github.com/EnzymeAD/Reactant.jl" data-v-b4d08338><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align:middle;margin-right:0.25rem;margin-left:0.5rem;" data-v-b4d08338><path d="M12 .297C5.375.297 0 5.673 0 12.3c0 5.292 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577 0-.285-.01-1.04-.015-2.04-3.338.727-4.042-1.61-4.042-1.61-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.807 1.305 3.493.997.107-.774.42-1.305.762-1.605-2.665-.3-5.467-1.333-5.467-5.931 0-1.31.47-2.382 1.236-3.222-.123-.303-.535-1.52.117-3.166 0 0 1.01-.323 3.31 1.23.96-.267 1.98-.4 3-.405 1.02.005 2.04.138 3 .405 2.3-1.553 3.31-1.23 3.31-1.23.653 1.646.24 2.863.117 3.166.765.84 1.236 1.912 1.236 3.222 0 4.61-2.807 5.625-5.477 5.921.43.372.823 1.102.823 2.222 0 1.606-.015 2.902-.015 3.293 0 .32.192.693.8.577C20.565 22.1 24 17.588 24 12.297 24 5.673 18.627.297 12 .297z" data-v-b4d08338></path></svg><span data-v-b4d08338>0.3k</span></a><a class="mobile" target="_blank" title="263 GitHub stars" href="https://github.com/EnzymeAD/Reactant.jl" data-v-b4d08338><svg xmlns="http://www.w3.org/2000/svg" width="21" height="21" viewBox="0 0 21 21" fill="none" data-v-b4d08338><path d="M19.625 5.60534C18.7083 4.03477 17.4649 2.79135 15.8945 1.87479C14.3238 0.958185 12.6091 0.5 10.7492 0.5C8.88947 0.5 7.17422 0.958325 5.60388 1.87479C4.0333 2.7913 2.78997 4.03477 1.87332 5.60534C0.956814 7.17587 0.498535 8.89089 0.498535 10.7504C0.498535 12.984 1.15021 14.9926 2.4539 16.7766C3.75744 18.5607 5.44142 19.7952 7.50571 20.4803C7.746 20.5249 7.92388 20.4936 8.03954 20.387C8.15524 20.2804 8.21302 20.1467 8.21302 19.9868C8.21302 19.9601 8.21073 19.7199 8.20629 19.266C8.20171 18.8122 8.19956 18.4162 8.19956 18.0783L7.89256 18.1315C7.69682 18.1673 7.44989 18.1825 7.15178 18.1782C6.8538 18.174 6.54446 18.1428 6.22419 18.0847C5.90377 18.0272 5.60575 17.8937 5.32988 17.6846C5.05416 17.4755 4.85842 17.2018 4.74272 16.8639L4.60925 16.5568C4.52029 16.3523 4.38023 16.1251 4.18888 15.8761C3.99754 15.6269 3.80405 15.458 3.60831 15.369L3.51486 15.3021C3.45259 15.2577 3.39481 15.204 3.34138 15.1418C3.28799 15.0796 3.24802 15.0173 3.22132 14.955C3.19458 14.8926 3.21674 14.8414 3.28804 14.8012C3.35933 14.761 3.48817 14.7416 3.67512 14.7416L3.94196 14.7814C4.11993 14.8171 4.34007 14.9236 4.60266 15.1017C4.86511 15.2796 5.08085 15.5109 5.24994 15.7956C5.4547 16.1605 5.7014 16.4385 5.99072 16.6299C6.27982 16.8212 6.5713 16.9167 6.86488 16.9167C7.15846 16.9167 7.41203 16.8945 7.62567 16.8502C7.83908 16.8057 8.0393 16.7388 8.22625 16.6499C8.30633 16.0535 8.52437 15.5953 8.88017 15.275C8.37304 15.2217 7.9171 15.1414 7.51212 15.0347C7.10736 14.9278 6.6891 14.7544 6.25761 14.5139C5.82589 14.2738 5.46774 13.9756 5.18309 13.6198C4.89839 13.2639 4.66474 12.7966 4.48247 12.2183C4.3001 11.6399 4.20889 10.9726 4.20889 10.2163C4.20889 9.13941 4.56044 8.22304 5.26341 7.46665C4.93411 6.65705 4.96519 5.74947 5.35676 4.744C5.61482 4.66382 5.9975 4.72399 6.50463 4.92412C7.01186 5.12434 7.38323 5.29587 7.61912 5.43808C7.85502 5.58024 8.04402 5.70071 8.18642 5.79842C9.01411 5.56715 9.86825 5.45149 10.7491 5.45149C11.6299 5.45149 12.4843 5.56715 13.312 5.79842L13.8192 5.47823C14.166 5.26459 14.5756 5.06881 15.0469 4.89083C15.5185 4.71295 15.8791 4.66396 16.1284 4.74414C16.5286 5.74966 16.5643 6.65719 16.2349 7.46679C16.9378 8.22318 17.2895 9.13978 17.2895 10.2164C17.2895 10.9727 17.198 11.6421 17.0159 12.225C16.8336 12.808 16.5979 13.2749 16.3088 13.6265C16.0194 13.9781 15.659 14.274 15.2275 14.5141C14.7959 14.7544 14.3775 14.9278 13.9728 15.0347C13.5678 15.1415 13.1119 15.2219 12.6047 15.2752C13.0673 15.6755 13.2986 16.3073 13.2986 17.1704V19.9864C13.2986 20.1464 13.3542 20.2799 13.4656 20.3867C13.5768 20.4932 13.7524 20.5246 13.9927 20.4799C16.0573 19.7949 17.7413 18.5603 19.0448 16.7762C20.3481 14.9922 21 12.9837 21 10.75C20.9996 8.89075 20.541 7.17587 19.625 5.60534Z" fill="currentColor" data-v-b4d08338></path></svg></a><!--]--><div class="VPFlyout VPNolebaseEnhancedReadabilitiesMenu VPNolebaseEnhancedReadabilitiesMenuFlyout" aria-label="Enhanced Readability" role="menuitem" data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><span class="i-icon-park-outline:book-open option-icon" data-v-04f5c5e9></span><!----><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><!----><!--[--><!--]--></div></div></div><!--]--><!--]--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-822684d1 data-v-5dea55bf><span class="container" data-v-5dea55bf><span class="top" data-v-5dea55bf></span><span class="middle" data-v-5dea55bf></span><span class="bottom" data-v-5dea55bf></span></span></button></div></div></div></div><div class="divider" data-v-822684d1><div class="divider-line" data-v-822684d1></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-a9a9e638 data-v-070ab83d><div class="container" data-v-070ab83d><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-070ab83d><span class="vpi-align-left menu-icon" data-v-070ab83d></span><span class="menu-text" data-v-070ab83d>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-070ab83d data-v-168ddf5d><button data-v-168ddf5d>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-a9a9e638 data-v-18756405><div class="curtain" data-v-18756405></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-18756405><span class="visually-hidden" id="sidebar-aria-label" data-v-18756405> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0 collapsible has-active" data-v-9e426adc data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h2 class="text" data-v-a4b0d9bf>API Reference</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/api" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Reactant API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/sharding" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Sharding</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/serialization" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Serialization</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/ops" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Ops</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/config" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Configuration</p><!--]--></a><!----></div><!----></div><section class="VPSidebarItem level-1 collapsible has-active" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h3 class="text" data-v-a4b0d9bf>MLIR Dialects</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/arith" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>ArithOps</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/affine" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Affine</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/builtin" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Builtin</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/chlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Chlo</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/enzyme" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Enzyme</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/enzymexla" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>EnzymeXLA</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/func" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Func</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/gpu" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>GPU</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/llvm" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>LLVM</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/mpi" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MPI</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/memref" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MemRef</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/mosaicgpu" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Mosaic GPU</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/nvvm" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>NVVM</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/shardy" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Shardy</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/sparsetensor" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>SparseTensor</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/stablehlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>StableHLO</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/triton" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Triton</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/tritonext" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>TritonExt</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/tpu" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>TPU</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/dialects/vhlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>VHLO</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 collapsible" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h3 class="text" data-v-a4b0d9bf>Low-Level API</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/mlirc" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MLIR API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/xla" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>XLA</p><!--]--></a><!----></div><!----></div><!--]--></div></section><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1940/api/internal" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Internal API</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-a9a9e638 data-v-91765379><div class="VPDoc has-sidebar has-aside" data-v-91765379 data-v-83890dd9><!--[--><!--]--><div class="container" data-v-83890dd9><div class="aside" data-v-83890dd9><div class="aside-curtain" data-v-83890dd9></div><div class="aside-container" data-v-83890dd9><div class="aside-content" data-v-83890dd9><div class="VPDocAside" data-v-83890dd9 data-v-6d7b3c46><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-6d7b3c46 data-v-b38bf2ff><div class="content" data-v-b38bf2ff><div class="outline-marker" data-v-b38bf2ff></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-b38bf2ff>On this page</div><ul class="VPDocOutlineItem root" data-v-b38bf2ff data-v-3f927ebe><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-6d7b3c46></div><!--[--><!--[--><!--[--><!--[--><!--[--><br><h2> Trusted by </h2><a class="enjoyer" href="https://lux.csail.mit.edu/" target="_blank"><img width="32" height="32" src="https://raw.githubusercontent.com/LuxDL/Lux.jl/refs/heads/main/assets/lux-logo.svg"><span><p class="extra-info">Scientific Computing</p><p class="heading">Lux.jl</p><p class="extra-info">Machine Learning</p></span></a><a class="enjoyer" href="https://bsc-quantic.github.io/Tenet.jl/stable/" target="_blank"><img width="32" height="32" src="https://raw.githubusercontent.com/bsc-quantic/Tenet.jl/refs/heads/master/docs/src/assets/logo.svg"><span><p class="extra-info">Quantum Simulation</p><p class="heading">Tenet.jl</p><p class="extra-info">Tensor Networks</p></span></a><!--]--><!--]--><!--]--><!--]--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-83890dd9><div class="content-container" data-v-83890dd9><!--[--><!--]--><main class="main" data-v-83890dd9><div style="position:relative;" class="vp-doc _Reactant_jl_previews_PR1940_api_dialects_arith" data-v-83890dd9><div><h1 id="Arithmetic-Dialect" tabindex="-1">Arithmetic Dialect <a class="header-anchor" href="#Arithmetic-Dialect" aria-label="Permalink to &quot;Arithmetic Dialect {#Arithmetic-Dialect}&quot;">​</a></h1><p>Refer to the <a href="https://mlir.llvm.org/docs/Dialects/ArithOps/" target="_blank" rel="noreferrer">official documentation</a> for more details.</p><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.addf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.addf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.addf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>addf</code></p><p>The <code>addf</code> operation takes two operands and returns one result, each of these is required to be the same type. This type may be a floating point scalar type, a vector whose element type is a floating point type, or a floating point tensor.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar addition.</span></span>
<span class="line"><span>%a = arith.addf %b, %c : f64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector addition, e.g. for Intel SSE.</span></span>
<span class="line"><span>%f = arith.addf %g, %h : vector&lt;4xf32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor addition.</span></span>
<span class="line"><span>%x = arith.addf %y, %z : tensor&lt;4x?xbf16&gt;</span></span></code></pre></div><p>TODO: In the distant future, this will accept optional attributes for fast math, contraction, rounding mode, and other controls.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L16-L39" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.addi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.addi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.addi</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>addi</code></p><p>Performs N-bit addition on the operands. The operands are interpreted as unsigned bitvectors. The result is represented by a bitvector containing the mathematical value of the addition modulo 2^n, where <code>n</code> is the bitwidth. Because <code>arith</code> integers use a two&#39;s complement representation, this operation is applicable on both signed and unsigned integer operands.</p><p>The <code>addi</code> operation takes two operands and returns one result, each of these is required to be the same type. This type may be an integer scalar type, a vector whose element type is integer, or a tensor of integers.</p><p>This op supports <code>nuw</code>/<code>nsw</code> overflow flags which stands for &quot;No Unsigned Wrap&quot; and &quot;No Signed Wrap&quot;, respectively. If the <code>nuw</code> and/or <code>nsw</code> flags are present, and an unsigned/signed overflow occurs (respectively), the result is poison.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar addition.</span></span>
<span class="line"><span>%a = arith.addi %b, %c : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Scalar addition with overflow flags.</span></span>
<span class="line"><span>%a = arith.addi %b, %c overflow&lt;nsw, nuw&gt; : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector element-wise addition.</span></span>
<span class="line"><span>%f = arith.addi %g, %h : vector&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise addition.</span></span>
<span class="line"><span>%x = arith.addi %y, %z : tensor&lt;4x?xi8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L67-L100" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.addui_extended-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.addui_extended-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.addui_extended</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>addui_extended</code></p><p>Performs (N+1)-bit addition on zero-extended operands. Returns two results: the N-bit sum (same type as both operands), and the overflow bit (boolean-like), where <code>1</code> indicates unsigned addition overflow, while <code>0</code> indicates no overflow.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar addition.</span></span>
<span class="line"><span>%sum, %overflow = arith.addui_extended %b, %c : i64, i1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Vector element-wise addition.</span></span>
<span class="line"><span>%d:2 = arith.addui_extended %e, %f : vector&lt;4xi32&gt;, vector&lt;4xi1&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise addition.</span></span>
<span class="line"><span>%x:2 = arith.addui_extended %y, %z : tensor&lt;4x?xi8&gt;, tensor&lt;4x?xi1&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L129-L149" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.andi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.andi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.andi</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>andi</code></p><p>The <code>andi</code> operation takes two operands and returns one result, each of these is required to be the same type. This type may be an integer scalar type, a vector whose element type is integer, or a tensor of integers. It has no standard attributes.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar integer bitwise and.</span></span>
<span class="line"><span>%a = arith.andi %b, %c : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector element-wise bitwise integer and.</span></span>
<span class="line"><span>%f = arith.andi %g, %h : vector&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise bitwise integer and.</span></span>
<span class="line"><span>%x = arith.andi %y, %z : tensor&lt;4x?xi8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L171-L191" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.bitcast-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.bitcast-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.bitcast</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>bitcast</code></p><p>Bitcast an integer or floating point value to an integer or floating point value of equal bit width. When operating on vectors, casts elementwise.</p><p>Note that this implements a logical bitcast independent of target endianness. This allows constant folding without target information and is consitent with the bitcast constant folders in LLVM (see <a href="https://github.com/llvm/llvm-project/blob/18c19414eb/llvm/lib/IR/ConstantFold.cpp#L168" target="_blank" rel="noreferrer">https://github.com/llvm/llvm-project/blob/18c19414eb/llvm/lib/IR/ConstantFold.cpp#L168</a>) For targets where the source and target type have the same endianness (which is the standard), this cast will also change no bits at runtime, but it may still require an operation, for example if the machine has different floating point and integer register files. For targets that have a different endianness for the source and target types (e.g. float is big-endian and integer is little-endian) a proper lowering would add operations to swap the order of words in addition to the bitcast.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L214-L231" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.ceildivsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.ceildivsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.ceildivsi</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>ceildivsi</code></p><p>Signed integer division. Rounds towards positive infinity, i.e. <code>7 / -2 = -3</code>.</p><p>Divison by zero, or signed division overflow (minimum value divided by -1) is undefined behavior. When applied to <code>vector</code> and <code>tensor</code> values, the behavior is undefined if <em>any</em> of its elements are divided by zero or has a signed division overflow.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar signed integer division.</span></span>
<span class="line"><span>%a = arith.ceildivsi %b, %c : i64</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L251-L267" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.ceildivui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.ceildivui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.ceildivui</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>ceildivui</code></p><p>Unsigned integer division. Rounds towards positive infinity. Treats the leading bit as the most significant, i.e. for <code>i16</code> given two&#39;s complement representation, <code>6 / -2 = 6 / (2^16 - 2) = 1</code>.</p><p>Division by zero is undefined behavior. When applied to <code>vector</code> and <code>tensor</code> values, the behavior is undefined if <em>any</em> elements are divided by zero.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar unsigned integer division.</span></span>
<span class="line"><span>%a = arith.ceildivui %b, %c : i64</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L290-L307" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.cmpf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.cmpf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.cmpf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>cmpf</code></p><p>The <code>cmpf</code> operation compares its two operands according to the float comparison rules and the predicate specified by the respective attribute. The predicate defines the type of comparison: (un)orderedness, (in)equality and signed less/greater than (or equal to) as well as predicates that are always true or false. The operands must have the same type, and this type must be a float type, or a vector or tensor thereof. The result is an i1, or a vector/tensor thereof having the same shape as the inputs. Unlike cmpi, the operands are always treated as signed. The u prefix indicates <em>unordered</em> comparison, not unsigned comparison, so &quot;une&quot; means unordered or not equal. For the sake of readability by humans, custom assembly form for the operation uses a string-typed attribute for the predicate. The value of this attribute corresponds to lower-cased name of the predicate constant, e.g., &quot;one&quot; means &quot;ordered not equal&quot;. The string representation of the attribute is merely a syntactic sugar and is converted to an integer attribute by the parser.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%r1 = arith.cmpf oeq, %0, %1 : f32</span></span>
<span class="line"><span>%r2 = arith.cmpf ult, %0, %1 : tensor&lt;42x42xf64&gt;</span></span>
<span class="line"><span>%r3 = &quot;arith.cmpf&quot;(%0, %1) {predicate: 0} : (f8, f8) -&gt; i1</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L330-L356" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.cmpi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.cmpi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.cmpi</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>cmpi</code></p><p>The <code>cmpi</code> operation is a generic comparison for integer-like types. Its two arguments can be integers, vectors or tensors thereof as long as their types match. The operation produces an i1 for the former case, a vector or a tensor of i1 with the same shape as inputs in the other cases.</p><p>Its first argument is an attribute that defines which type of comparison is performed. The following comparisons are supported:</p><ul><li><p>equal (mnemonic: <code>&quot;eq&quot;</code>; integer value: <code>0</code>)</p></li><li><p>not equal (mnemonic: <code>&quot;ne&quot;</code>; integer value: <code>1</code>)</p></li><li><p>signed less than (mnemonic: <code>&quot;slt&quot;</code>; integer value: <code>2</code>)</p></li><li><p>signed less than or equal (mnemonic: <code>&quot;sle&quot;</code>; integer value: <code>3</code>)</p></li><li><p>signed greater than (mnemonic: <code>&quot;sgt&quot;</code>; integer value: <code>4</code>)</p></li><li><p>signed greater than or equal (mnemonic: <code>&quot;sge&quot;</code>; integer value: <code>5</code>)</p></li><li><p>unsigned less than (mnemonic: <code>&quot;ult&quot;</code>; integer value: <code>6</code>)</p></li><li><p>unsigned less than or equal (mnemonic: <code>&quot;ule&quot;</code>; integer value: <code>7</code>)</p></li><li><p>unsigned greater than (mnemonic: <code>&quot;ugt&quot;</code>; integer value: <code>8</code>)</p></li><li><p>unsigned greater than or equal (mnemonic: <code>&quot;uge&quot;</code>; integer value: <code>9</code>)</p></li></ul><p>The result is <code>1</code> if the comparison is true and <code>0</code> otherwise. For vector or tensor operands, the comparison is performed elementwise and the element of the result indicates whether the comparison is true for the operand elements with the same indices as those of the result.</p><p>Note: while the custom assembly form uses strings, the actual underlying attribute has integer type (or rather enum class in C++ code) as seen from the generic assembly form. String literals are used to improve readability of the IR by humans.</p><p>This operation only applies to integer-like operands, but not floats. The main reason being that comparison operations have diverging sets of attributes: integers require sign specification while floats require various floating point-related particularities, e.g., <code>-ffast-math</code> behavior, IEEE754 compliance, etc (<a href="./../Rationale/Rationale#splitting-floating-point-vs-integer-operations">rationale</a>). The type of comparison is specified as attribute to avoid introducing ten similar operations, taking into account that they are often implemented using the same operation downstream (<a href="./../Rationale/Rationale#specifying-comparison-kind-as-attribute">rationale</a>). The separation between signed and unsigned order comparisons is necessary because of integers being signless. The comparison operation must know how to interpret values with the foremost bit being set: negatives in two&#39;s complement or large positives (<a href="./../Rationale/Rationale#specifying-sign-in-integer-comparison-operations">rationale</a>).</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Custom form of scalar &quot;signed less than&quot; comparison.</span></span>
<span class="line"><span>%x = arith.cmpi slt, %lhs, %rhs : i32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Generic form of the same operation.</span></span>
<span class="line"><span>%x = &quot;arith.cmpi&quot;(%lhs, %rhs) {predicate = 2 : i64} : (i32, i32) -&gt; i1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Custom form of vector equality comparison.</span></span>
<span class="line"><span>%x = arith.cmpi eq, %lhs, %rhs : vector&lt;4xi64&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Generic form of the same operation.</span></span>
<span class="line"><span>%x = &quot;arith.cmpi&quot;(%lhs, %rhs) {predicate = 0 : i64}</span></span>
<span class="line"><span>    : (vector&lt;4xi64&gt;, vector&lt;4xi64&gt;) -&gt; vector&lt;4xi1&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L385-L449" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.constant-Tuple{}" href="#Reactant.MLIR.Dialects.arith.constant-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.constant</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>constant</code></p><p>The <code>constant</code> operation produces an SSA value equal to some integer or floating-point constant specified by an attribute. This is the way MLIR forms simple integer and floating point constants.</p><p><strong>Example</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Integer constant</span></span>
<span class="line"><span>%1 = arith.constant 42 : i32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Equivalent generic form</span></span>
<span class="line"><span>%1 = &quot;arith.constant&quot;() {value = 42 : i32} : () -&gt; i32</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L476-L492" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.divsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.divsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.divsi</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>divsi</code></p><p>Signed integer division. Rounds towards zero. Treats the leading bit as sign, i.e. <code>6 / -2 = -3</code>.</p><p>Divison by zero, or signed division overflow (minimum value divided by -1) is undefined behavior. When applied to <code>vector</code> and <code>tensor</code> values, the behavior is undefined if <em>any</em> of its elements are divided by zero or has a signed division overflow.</p><p>If the <code>exact</code> attribute is present, the result value is poison if <code>lhs</code> is not a multiple of <code>rhs</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar signed integer division.</span></span>
<span class="line"><span>%a = arith.divsi %b, %c : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Scalar signed integer division where %b is known to be a multiple of %c.</span></span>
<span class="line"><span>%a = arith.divsi %b, %c exact : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector element-wise division.</span></span>
<span class="line"><span>%f = arith.divsi %g, %h : vector&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise integer division.</span></span>
<span class="line"><span>%x = arith.divsi %y, %z : tensor&lt;4x?xi8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L540-L569" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.divui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.divui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.divui</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>divui</code></p><p>Unsigned integer division. Rounds towards zero. Treats the leading bit as the most significant, i.e. for <code>i16</code> given two&#39;s complement representation, <code>6 / -2 = 6 / (2^16 - 2) = 0</code>.</p><p>Division by zero is undefined behavior. When applied to <code>vector</code> and <code>tensor</code> values, the behavior is undefined if <em>any</em> elements are divided by zero.</p><p>If the <code>exact</code> attribute is present, the result value is poison if <code>lhs</code> is not a multiple of <code>rhs</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar unsigned integer division.</span></span>
<span class="line"><span>%a = arith.divui %b, %c : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Scalar unsigned integer division where %b is known to be a multiple of %c.</span></span>
<span class="line"><span>%a = arith.divui %b, %c exact : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector element-wise division.</span></span>
<span class="line"><span>%f = arith.divui %g, %h : vector&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise integer division.</span></span>
<span class="line"><span>%x = arith.divui %y, %z : tensor&lt;4x?xi8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L597-L626" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.extf-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.extf-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.extf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>extf</code></p><p>Cast a floating-point value to a larger floating-point-typed value. The destination type must to be strictly wider than the source type. When operating on vectors, casts elementwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L654-L660" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.extsi-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.extsi-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.extsi</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>extsi</code></p><p>The integer sign extension operation takes an integer input of width M and an integer destination type of width N. The destination bit-width must be larger than the input bit-width (N &gt; M). The top-most (N - M) bits of the output are filled with copies of the most-significant bit of the input.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = arith.constant 5 : i3</span><span>      // %1 is 0b101</span></span>
<span class="line"><span>%2 = arith.extsi %1 : i3 to i6</span><span>  // %2 is 0b111101</span></span>
<span class="line"><span>%3 = arith.constant 2 : i3</span><span>      // %3 is 0b010</span></span>
<span class="line"><span>%4 = arith.extsi %3 : i3 to i6</span><span>  // %4 is 0b000010</span></span>
<span class="line"><span></span></span>
<span class="line"><span>%5 = arith.extsi %0 : vector&lt;2 x i32&gt; to vector&lt;2 x i64&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L681-L700" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.extui-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.extui-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.extui</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>extui</code></p><p>The integer zero extension operation takes an integer input of width M and an integer destination type of width N. The destination bit-width must be larger than the input bit-width (N &gt; M). The top-most (N - M) bits of the output are filled with zeros.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  %1 = arith.constant 5 : i3</span><span>      // %1 is 0b101</span></span>
<span class="line"><span>  %2 = arith.extui %1 : i3 to i6</span><span>  // %2 is 0b000101</span></span>
<span class="line"><span>  %3 = arith.constant 2 : i3</span><span>      // %3 is 0b010</span></span>
<span class="line"><span>  %4 = arith.extui %3 : i3 to i6</span><span>  // %4 is 0b000010</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  %5 = arith.extui %0 : vector&lt;2 x i32&gt; to vector&lt;2 x i64&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L720-L738" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.floordivsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.floordivsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.floordivsi</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>floordivsi</code></p><p>Signed integer division. Rounds towards negative infinity, i.e. <code>5 / -2 = -3</code>.</p><p>Divison by zero, or signed division overflow (minimum value divided by -1) is undefined behavior. When applied to <code>vector</code> and <code>tensor</code> values, the behavior is undefined if <em>any</em> of its elements are divided by zero or has a signed division overflow.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar signed integer division.</span></span>
<span class="line"><span>%a = arith.floordivsi %b, %c : i64</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L810-L827" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.fptosi-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.fptosi-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.fptosi</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>fptosi</code></p><p>Cast from a value interpreted as floating-point to the nearest (rounding towards zero) signed integer value. When operating on vectors, casts elementwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L758-L764" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.fptoui-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.fptoui-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.fptoui</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>fptoui</code></p><p>Cast from a value interpreted as floating-point to the nearest (rounding towards zero) unsigned integer value. When operating on vectors, casts elementwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L784-L790" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.index_cast-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.index_cast-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.index_cast</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>index_cast</code></p><p>Casts between scalar or vector integers and corresponding &#39;index&#39; scalar or vectors. Index is an integer of platform-specific bit width. If casting to a wider integer, the value is sign-extended. If casting to a narrower integer, the value is truncated.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L850-L857" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.index_castui-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.index_castui-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.index_castui</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>index_castui</code></p><p>Casts between scalar or vector integers and corresponding &#39;index&#39; scalar or vectors. Index is an integer of platform-specific bit width. If casting to a wider integer, the value is zero-extended. If casting to a narrower integer, the value is truncated.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L877-L884" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.maximumf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.maximumf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.maximumf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>maximumf</code></p><p>Returns the maximum of the two arguments, treating -0.0 as less than +0.0. If one of the arguments is NaN, then the result is also NaN.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar floating-point maximum.</span></span>
<span class="line"><span>%a = arith.maximumf %b, %c : f64</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L989-L1001" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.maxnumf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.maxnumf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.maxnumf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>maxnumf</code></p><p>Returns the maximum of the two arguments. If the arguments are -0.0 and +0.0, then the result is either of them. If one of the arguments is NaN, then the result is the other argument.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar floating-point maximum.</span></span>
<span class="line"><span>%a = arith.maxnumf %b, %c : f64</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L904-L917" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.minimumf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.minimumf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.minimumf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>minimumf</code></p><p>Returns the minimum of the two arguments, treating -0.0 as less than +0.0. If one of the arguments is NaN, then the result is also NaN.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar floating-point minimum.</span></span>
<span class="line"><span>%a = arith.minimumf %b, %c : f64</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1114-L1126" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.minnumf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.minnumf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.minnumf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>minnumf</code></p><p>Returns the minimum of the two arguments. If the arguments are -0.0 and +0.0, then the result is either of them. If one of the arguments is NaN, then the result is the other argument.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar floating-point minimum.</span></span>
<span class="line"><span>%a = arith.minnumf %b, %c : f64</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1029-L1042" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.mulf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.mulf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.mulf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mulf</code></p><p>The <code>mulf</code> operation takes two operands and returns one result, each of these is required to be the same type. This type may be a floating point scalar type, a vector whose element type is a floating point type, or a floating point tensor.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar multiplication.</span></span>
<span class="line"><span>%a = arith.mulf %b, %c : f64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD pointwise vector multiplication, e.g. for Intel SSE.</span></span>
<span class="line"><span>%f = arith.mulf %g, %h : vector&lt;4xf32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor pointwise multiplication.</span></span>
<span class="line"><span>%x = arith.mulf %y, %z : tensor&lt;4x?xbf16&gt;</span></span></code></pre></div><p>TODO: In the distant future, this will accept optional attributes for fast math, contraction, rounding mode, and other controls.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1154-L1177" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.muli-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.muli-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.muli</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>muli</code></p><p>Performs N-bit multiplication on the operands. The operands are interpreted as unsigned bitvectors. The result is represented by a bitvector containing the mathematical value of the multiplication modulo 2^n, where <code>n</code> is the bitwidth. Because <code>arith</code> integers use a two&#39;s complement representation, this operation is applicable on both signed and unsigned integer operands.</p><p>The <code>muli</code> operation takes two operands and returns one result, each of these is required to be the same type. This type may be an integer scalar type, a vector whose element type is integer, or a tensor of integers.</p><p>This op supports <code>nuw</code>/<code>nsw</code> overflow flags which stands for &quot;No Unsigned Wrap&quot; and &quot;No Signed Wrap&quot;, respectively. If the <code>nuw</code> and/or <code>nsw</code> flags are present, and an unsigned/signed overflow occurs (respectively), the result is poison.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar multiplication.</span></span>
<span class="line"><span>%a = arith.muli %b, %c : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Scalar multiplication with overflow flags.</span></span>
<span class="line"><span>%a = arith.muli %b, %c overflow&lt;nsw, nuw&gt; : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector element-wise multiplication.</span></span>
<span class="line"><span>%f = arith.muli %g, %h : vector&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise multiplication.</span></span>
<span class="line"><span>%x = arith.muli %y, %z : tensor&lt;4x?xi8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1205-L1238" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.mulsi_extended-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.mulsi_extended-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.mulsi_extended</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mulsi_extended</code></p><p>Performs (2*N)-bit multiplication on sign-extended operands. Returns two N-bit results: the low and the high halves of the product. The low half has the same value as the result of regular multiplication <code>arith.muli</code> with the same operands.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar multiplication.</span></span>
<span class="line"><span>%low, %high = arith.mulsi_extended %a, %b : i32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Vector element-wise multiplication.</span></span>
<span class="line"><span>%c:2 = arith.mulsi_extended %d, %e : vector&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise multiplication.</span></span>
<span class="line"><span>%x:2 = arith.mulsi_extended %y, %z : tensor&lt;4x?xi8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1267-L1287" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.mului_extended-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.mului_extended-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.mului_extended</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>mului_extended</code></p><p>Performs (2*N)-bit multiplication on zero-extended operands. Returns two N-bit results: the low and the high halves of the product. The low half has the same value as the result of regular multiplication <code>arith.muli</code> with the same operands.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar multiplication.</span></span>
<span class="line"><span>%low, %high = arith.mului_extended %a, %b : i32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Vector element-wise multiplication.</span></span>
<span class="line"><span>%c:2 = arith.mului_extended %d, %e : vector&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise multiplication.</span></span>
<span class="line"><span>%x:2 = arith.mului_extended %y, %z : tensor&lt;4x?xi8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1315-L1335" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.negf-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.negf-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.negf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>negf</code></p><p>The <code>negf</code> operation computes the negation of a given value. It takes one operand and returns one result of the same type. This type may be a float scalar type, a vector whose element type is float, or a tensor of floats. It has no standard attributes.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar negation value.</span></span>
<span class="line"><span>%a = arith.negf %b : f64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector element-wise negation value.</span></span>
<span class="line"><span>%f = arith.negf %g : vector&lt;4xf32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise negation value.</span></span>
<span class="line"><span>%x = arith.negf %y : tensor&lt;4x?xf8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1363-L1383" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.ori-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.ori-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.ori</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>ori</code></p><p>The <code>ori</code> operation takes two operands and returns one result, each of these is required to be the same type. This type may be an integer scalar type, a vector whose element type is integer, or a tensor of integers. It has no standard attributes.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar integer bitwise or.</span></span>
<span class="line"><span>%a = arith.ori %b, %c : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector element-wise bitwise integer or.</span></span>
<span class="line"><span>%f = arith.ori %g, %h : vector&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise bitwise integer or.</span></span>
<span class="line"><span>%x = arith.ori %y, %z : tensor&lt;4x?xi8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1410-L1430" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.remf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.remf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.remf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>remf</code></p><p>Returns the floating point division remainder. The remainder has the same sign as the dividend (lhs operand).</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1453-L1458" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.remsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.remsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.remsi</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>remsi</code></p><p>Signed integer division remainder. Treats the leading bit as sign, i.e. <code>6 % -2 = 0</code>.</p><p>Division by zero is undefined behavior. When applied to <code>vector</code> and <code>tensor</code> values, the behavior is undefined if <em>any</em> elements are divided by zero.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar signed integer division remainder.</span></span>
<span class="line"><span>%a = arith.remsi %b, %c : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector element-wise division remainder.</span></span>
<span class="line"><span>%f = arith.remsi %g, %h : vector&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise integer division remainder.</span></span>
<span class="line"><span>%x = arith.remsi %y, %z : tensor&lt;4x?xi8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1486-L1508" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.remui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.remui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.remui</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>remui</code></p><p>Unsigned integer division remainder. Treats the leading bit as the most significant, i.e. for <code>i16</code>, <code>6 % -2 = 6 % (2^16 - 2) = 6</code>.</p><p>Division by zero is undefined behavior. When applied to <code>vector</code> and <code>tensor</code> values, the behavior is undefined if <em>any</em> elements are divided by zero.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar unsigned integer division remainder.</span></span>
<span class="line"><span>%a = arith.remui %b, %c : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector element-wise division remainder.</span></span>
<span class="line"><span>%f = arith.remui %g, %h : vector&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise integer division remainder.</span></span>
<span class="line"><span>%x = arith.remui %y, %z : tensor&lt;4x?xi8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1531-L1553" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.scaling_extf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.scaling_extf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.scaling_extf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>scaling_extf</code></p><p>This operation upcasts input floating-point values using provided scale values. It expects both scales and the input operand to be of the same shape, making the operation elementwise. Scales are usually calculated per block following the OCP MXFP spec as described in <a href="https://arxiv.org/abs/2310.10537" target="_blank" rel="noreferrer">https://arxiv.org/abs/2310.10537</a>.</p><p>If scales are calculated per block where blockSize != 1, then scales may require broadcasting to make this operation elementwise. For example, let&#39;s say the input is of shape <code>&lt;dim1 x dim2 x ... dimN&gt;</code>. Given blockSize != 1 and assuming quantization happens on the last axis, the input can be reshaped to <code>&lt;dim1 x dim2 x ... (dimN/blockSize) x blockSize&gt;</code>. Scales will be calculated per block on the last axis. Therefore, scales will be of shape <code>&lt;dim1 x dim2 x ... (dimN/blockSize) x 1&gt;</code>. Scales could also be of some other shape as long as it is broadcast compatible with the input, e.g., <code>&lt;1 x 1 x ... (dimN/blockSize) x 1&gt;</code>.</p><p>In this example, before calling into <code>arith.scaling_extf</code>, scales must be broadcasted to <code>&lt;dim1 x dim2 x dim3 ... (dimN/blockSize) x blockSize&gt;</code>. Note that there could be multiple quantization axes. Internally, <code>arith.scaling_extf</code> would perform the following:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Cast scale to result type.</span></span>
<span class="line"><span>%0 = arith.truncf %1 : f32 to f8E8M0FNU</span></span>
<span class="line"><span>%1 = arith.extf %0 : f8E8M0FNU to f16</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Cast input to result type.</span></span>
<span class="line"><span>%2 = arith.extf %3 : f4E2M1FN to f16</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Perform scaling</span></span>
<span class="line"><span>%3 = arith.mulf %2, %1 : f16</span></span></code></pre></div><p>It propagates NaN values. Therefore, if either scale or the input element contains NaN, then the output element value will also be a NaN.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Upcast from f4E2M1FN to f32.</span></span>
<span class="line"><span>%a = arith.scaling_extf %b, %c : f4E2M1FN, f8E8M0FNU to f32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Element-wise upcast with broadcast (blockSize = 32).</span></span>
<span class="line"><span>%f = vector.broadcast %g : vector&lt;1xf8E8M0FNU&gt; to vector&lt;32xf8E8M0FNU&gt;</span></span>
<span class="line"><span>%h = arith.scaling_extf %i, %f : vector&lt;32xf4E2M1FN&gt;, vector&lt;32xf8E8M0FNU&gt; to vector&lt;32xbf16&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1603-L1650" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.scaling_truncf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.scaling_truncf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.scaling_truncf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>scaling_truncf</code></p><p>This operation downcasts input using the provided scale values. It expects both scales and the input operand to be of the same shape and, therefore, makes the operation elementwise. Scales are usually calculated per block following the OCP MXFP spec as described in <a href="https://arxiv.org/abs/2310.10537" target="_blank" rel="noreferrer">https://arxiv.org/abs/2310.10537</a>. Users are required to normalize and clamp the scales as necessary before calling passing them to this operation. OCP MXFP spec also does the flushing of denorms on the input operand, which should be handled during lowering by passing appropriate fastMath flag to this operation.</p><p>If scales are calculated per block where blockSize != 1, scales may require broadcasting to make this operation elementwise. For example, let&#39;s say the input is of shape <code>&lt;dim1 x dim2 x ... dimN&gt;</code>. Given blockSize != 1 and assuming quantization happens on the last axis, the input can be reshaped to <code>&lt;dim1 x dim2 x ... (dimN/blockSize) x blockSize&gt;</code>. Scales will be calculated per block on the last axis. Therefore, scales will be of shape <code>&lt;dim1 x dim2 x ... (dimN/blockSize) x 1&gt;</code>. Scales could also be of some other shape as long as it is broadcast compatible with the input, e.g., <code>&lt;1 x 1 x ... (dimN/blockSize) x 1&gt;</code>.</p><p>In this example, before calling into <code>arith.scaling_truncf</code>, scales must be broadcasted to <code>&lt;dim1 x dim2 x dim3 ... (dimN/blockSize) x blockSize&gt;</code>. Note that there could be multiple quantization axes. Internally, <code>arith.scaling_truncf</code> would perform the following:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Cast scale to input type.</span></span>
<span class="line"><span>%0 = arith.truncf %1 : f32 to f8E8M0FNU</span></span>
<span class="line"><span>%1 = arith.extf %0 : f8E8M0FNU to f16</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Perform scaling.</span></span>
<span class="line"><span>%3 = arith.divf %2, %1 : f16</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Cast to result type.</span></span>
<span class="line"><span>%4 = arith.truncf %3 : f16 to f4E2M1FN</span></span></code></pre></div><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Downcast from f32 to f4E2M1FN.</span></span>
<span class="line"><span>%a = arith.scaling_truncf %b, %c : f32, f8E8M0FNU to f4E2M1FN</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Element-wise downcast with broadcast (blockSize = 32).</span></span>
<span class="line"><span>%f = vector.broadcast %g : vector&lt;1xf8E8M0FNU&gt; to vector&lt;32xf8E8M0FNU&gt;</span></span>
<span class="line"><span>%h = arith.scaling_truncf %i, %f : vector&lt;32xbf16&gt;, vector&lt;32xf8E8M0FNU&gt; to vector&lt;32xf4E2M1FN&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1673-L1722" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.select</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>select</code></p><p>The <code>arith.select</code> operation chooses one value based on a binary condition supplied as its first operand.</p><p>If the value of the first operand (the condition) is <code>1</code>, then the second operand is returned, and the third operand is ignored, even if it was poison.</p><p>If the value of the first operand (the condition) is <code>0</code>, then the third operand is returned, and the second operand is ignored, even if it was poison.</p><p>If the value of the first operand (the condition) is poison, then the operation returns poison.</p><p>The operation applies to vectors and tensors elementwise given the <em>shape</em> of all operands is identical. The choice is made for each element individually based on the value at the same position as the element in the condition operand. If an i1 is provided as the condition, the entire vector or tensor is chosen.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Custom form of scalar selection.</span></span>
<span class="line"><span>%x = arith.select %cond, %true, %false : i32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Generic form of the same operation.</span></span>
<span class="line"><span>%x = &quot;arith.select&quot;(%cond, %true, %false) : (i1, i32, i32) -&gt; i32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Element-wise vector selection.</span></span>
<span class="line"><span>%vx = arith.select %vcond, %vtrue, %vfalse : vector&lt;42xi1&gt;, vector&lt;42xf32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Full vector selection.</span></span>
<span class="line"><span>%vx = arith.select %cond, %vtrue, %vfalse : vector&lt;42xf32&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L2169-L2205" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.shli-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.shli-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.shli</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>shli</code></p><p>The <code>shli</code> operation shifts the integer value of the first operand to the left by the integer value of the second operand. The second operand is interpreted as unsigned. The low order bits are filled with zeros. If the value of the second operand is greater or equal than the bitwidth of the first operand, then the operation returns poison.</p><p>This op supports <code>nuw</code>/<code>nsw</code> overflow flags which stands for &quot;No Unsigned Wrap&quot; and &quot;No Signed Wrap&quot;, respectively. If the <code>nuw</code> and/or <code>nsw</code> flags are present, and an unsigned/signed overflow occurs (respectively), the result is poison.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = arith.constant 5 : i8</span><span>  // %1 is 0b00000101</span></span>
<span class="line"><span>%2 = arith.constant 3 : i8</span></span>
<span class="line"><span>%3 = arith.shli %1, %2 : i8</span><span> // %3 is 0b00101000</span></span>
<span class="line"><span>%4 = arith.shli %1, %2 overflow&lt;nsw, nuw&gt; : i8</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1752-L1774" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.shrsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.shrsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.shrsi</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>shrsi</code></p><p>The <code>shrsi</code> operation shifts an integer value of the first operand to the right by the value of the second operand. The first operand is interpreted as signed, and the second operand is interpreter as unsigned. The high order bits in the output are filled with copies of the most-significant bit of the shifted value (which means that the sign of the value is preserved). If the value of the second operand is greater or equal than bitwidth of the first operand, then the operation returns poison.</p><p>If the <code>exact</code> attribute is present, the result value of shrsi is a poison value if any of the bits shifted out are non-zero.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = arith.constant 160 : i8</span><span>         // %1 is 0b10100000</span></span>
<span class="line"><span>%2 = arith.constant 3 : i8</span></span>
<span class="line"><span>%3 = arith.shrsi %1, %2 exact : i8</span><span>   // %3 is 0b11110100</span></span>
<span class="line"><span>%4 = arith.constant 98 : i8</span><span>          // %4 is 0b01100010</span></span>
<span class="line"><span>%5 = arith.shrsi %4, %2 : i8</span><span>         // %5 is 0b00001100</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1803-L1826" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.shrui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.shrui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.shrui</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>shrui</code></p><p>The <code>shrui</code> operation shifts an integer value of the first operand to the right by the value of the second operand. The first operand is interpreted as unsigned, and the second operand is interpreted as unsigned. The high order bits are always filled with zeros. If the value of the second operand is greater or equal than the bitwidth of the first operand, then the operation returns poison.</p><p>If the <code>exact</code> attribute is present, the result value of shrui is a poison value if any of the bits shifted out are non-zero.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = arith.constant 160 : i8</span><span>        // %1 is 0b10100000</span></span>
<span class="line"><span>%2 = arith.constant 3 : i8</span></span>
<span class="line"><span>%3 = arith.constant 6 : i8</span></span>
<span class="line"><span>%4 = arith.shrui %1, %2 exact : i8</span><span>  // %4 is 0b00010100</span></span>
<span class="line"><span>%5 = arith.shrui %1, %3 : i8</span><span>        // %3 is 0b00000010</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1854-L1875" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.sitofp-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.sitofp-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.sitofp</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>sitofp</code></p><p>Cast from a value interpreted as a signed integer to the corresponding floating-point value. If the value cannot be exactly represented, it is rounded using the default rounding mode. When operating on vectors, casts elementwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1576-L1583" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.subf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.subf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.subf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>subf</code></p><p>The <code>subf</code> operation takes two operands and returns one result, each of these is required to be the same type. This type may be a floating point scalar type, a vector whose element type is a floating point type, or a floating point tensor.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar subtraction.</span></span>
<span class="line"><span>%a = arith.subf %b, %c : f64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector subtraction, e.g. for Intel SSE.</span></span>
<span class="line"><span>%f = arith.subf %g, %h : vector&lt;4xf32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor subtraction.</span></span>
<span class="line"><span>%x = arith.subf %y, %z : tensor&lt;4x?xbf16&gt;</span></span></code></pre></div><p>TODO: In the distant future, this will accept optional attributes for fast math, contraction, rounding mode, and other controls.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1903-L1926" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.subi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.subi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.subi</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>subi</code></p><p>Performs N-bit subtraction on the operands. The operands are interpreted as unsigned bitvectors. The result is represented by a bitvector containing the mathematical value of the subtraction modulo 2^n, where <code>n</code> is the bitwidth. Because <code>arith</code> integers use a two&#39;s complement representation, this operation is applicable on both signed and unsigned integer operands.</p><p>The <code>subi</code> operation takes two operands and returns one result, each of these is required to be the same type. This type may be an integer scalar type, a vector whose element type is integer, or a tensor of integers.</p><p>This op supports <code>nuw</code>/<code>nsw</code> overflow flags which stands for &quot;No Unsigned Wrap&quot; and &quot;No Signed Wrap&quot;, respectively. If the <code>nuw</code> and/or <code>nsw</code> flags are present, and an unsigned/signed overflow occurs (respectively), the result is poison.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar subtraction.</span></span>
<span class="line"><span>%a = arith.subi %b, %c : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Scalar subtraction with overflow flags.</span></span>
<span class="line"><span>%a = arith.subi %b, %c overflow&lt;nsw, nuw&gt; : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector element-wise subtraction.</span></span>
<span class="line"><span>%f = arith.subi %g, %h : vector&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise subtraction.</span></span>
<span class="line"><span>%x = arith.subi %y, %z : tensor&lt;4x?xi8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L1954-L1987" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.truncf-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.truncf-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.truncf</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>truncf</code></p><p>Truncate a floating-point value to a smaller floating-point-typed value. The destination type must be strictly narrower than the source type. If the value cannot be exactly represented, it is rounded using the provided rounding mode or the default one if no rounding mode is provided. When operating on vectors, casts elementwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L2016-L2024" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.trunci-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.trunci-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.trunci</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>trunci</code></p><p>The integer truncation operation takes an integer input of width M and an integer destination type of width N. The destination bit-width must be smaller than the input bit-width (N &lt; M). The top-most (N - M) bits of the input are discarded.</p><p>This op supports <code>nuw</code>/<code>nsw</code> overflow flags which stands for &quot;No Unsigned Wrap&quot; and &quot;No Signed Wrap&quot;, respectively. If the nuw keyword is present, and any of the truncated bits are non-zero, the result is a poison value. If the nsw keyword is present, and any of the truncated bits are not the same as the top bit of the truncation result, the result is a poison value.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  // Scalar truncation.</span></span>
<span class="line"><span>  %1 = arith.constant 21 : i5</span><span>     // %1 is 0b10101</span></span>
<span class="line"><span>  %2 = arith.trunci %1 : i5 to i4</span><span> // %2 is 0b0101</span></span>
<span class="line"><span>  %3 = arith.trunci %1 : i5 to i3</span><span> // %3 is 0b101</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // Vector truncation.</span></span>
<span class="line"><span>  %4 = arith.trunci %0 : vector&lt;2 x i32&gt; to vector&lt;2 x i16&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // Scalar truncation with overflow flags.</span></span>
<span class="line"><span>  %5 = arith.trunci %a overflow&lt;nsw, nuw&gt; : i32 to i16</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L2049-L2077" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.uitofp-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.uitofp-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.uitofp</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>uitofp</code></p><p>Cast from a value interpreted as unsigned integer to the corresponding floating-point value. If the value cannot be exactly represented, it is rounded using the default rounding mode. When operating on vectors, casts elementwise.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L2099-L2106" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.arith.xori-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.arith.xori-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.arith.xori</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>xori</code></p><p>The <code>xori</code> operation takes two operands and returns one result, each of these is required to be the same type. This type may be an integer scalar type, a vector whose element type is integer, or a tensor of integers. It has no standard attributes.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Scalar integer bitwise xor.</span></span>
<span class="line"><span>%a = arith.xori %b, %c : i64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// SIMD vector element-wise bitwise integer xor.</span></span>
<span class="line"><span>%f = arith.xori %g, %h : vector&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Tensor element-wise bitwise integer xor.</span></span>
<span class="line"><span>%x = arith.xori %y, %z : tensor&lt;4x?xi8&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/f68243d29e2a4a39e47ecd95c8b030978eccfbfb/src/mlir/Dialects/Arith.jl#L2126-L2146" target="_blank" rel="noreferrer">source</a><!--]--></span></details></div></div></main><footer class="VPDocFooter" data-v-83890dd9 data-v-4f9813fa><!--[--><!--]--><div class="edit-info" data-v-4f9813fa><div class="edit-link" data-v-4f9813fa><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/EnzymeAD/Reactant.jl/edit/main/docs/src/api/dialects/arith.md" target="_blank" rel="noreferrer" data-v-4f9813fa><!--[--><span class="vpi-square-pen edit-link-icon" data-v-4f9813fa></span> Edit this page on GitHub<!--]--></a></div><!----></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-4f9813fa><span class="visually-hidden" id="doc-footer-aria-label" data-v-4f9813fa>Pager</span><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link prev" href="/Reactant.jl/previews/PR1940/api/config" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Previous page</span><span class="title" data-v-4f9813fa>Configuration</span><!--]--></a></div><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link next" href="/Reactant.jl/previews/PR1940/api/dialects/affine" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Next page</span><span class="title" data-v-4f9813fa>Affine</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-a9a9e638 data-v-c970a860><div class="container" data-v-c970a860><p class="message" data-v-c970a860>Made with <a href="https://documenter.juliadocs.org/stable/" target="_blank"><strong>Documenter.jl</strong></a>, <a href="https://vitepress.dev" target="_blank"><strong>VitePress</strong></a> and <a href="https://luxdl.github.io/DocumenterVitepress.jl/stable" target="_blank"><strong>DocumenterVitepress.jl</strong></a><br>Released under the MIT License. Powered by the <a href="https://www.julialang.org">Julia Programming Language</a>.<br></p><p class="copyright" data-v-c970a860>© Copyright 2025 Reactant Development Team.</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"api_api.md\":\"Bgb0vsKF\",\"api_config.md\":\"D-Vbl39i\",\"api_dialects_affine.md\":\"BQzKrlnw\",\"api_dialects_arith.md\":\"CGHlqyuw\",\"api_dialects_builtin.md\":\"CLS8SHw1\",\"api_dialects_chlo.md\":\"BmfCd-YF\",\"api_dialects_enzyme.md\":\"CEsSI23P\",\"api_dialects_enzymexla.md\":\"C3LD6UnM\",\"api_dialects_func.md\":\"CWNkc6Qe\",\"api_dialects_gpu.md\":\"EZU6SD0c\",\"api_dialects_llvm.md\":\"Bj08ScsR\",\"api_dialects_memref.md\":\"B9pmQQCx\",\"api_dialects_mosaicgpu.md\":\"D9Zemf9k\",\"api_dialects_mpi.md\":\"B70OY1r5\",\"api_dialects_nvvm.md\":\"BGtKWP80\",\"api_dialects_shardy.md\":\"CyLzewyg\",\"api_dialects_sparsetensor.md\":\"yom2TLYM\",\"api_dialects_stablehlo.md\":\"xZ0KOj-O\",\"api_dialects_tpu.md\":\"D8yDDNKe\",\"api_dialects_triton.md\":\"BXXZ6jp-\",\"api_dialects_tritonext.md\":\"C7FHDplb\",\"api_dialects_vhlo.md\":\"C0MGYrRV\",\"api_internal.md\":\"C-KCvwXS\",\"api_mlirc.md\":\"2KuxT35x\",\"api_ops.md\":\"amQdss-Y\",\"api_serialization.md\":\"IywUZ08L\",\"api_sharding.md\":\"BMSt8ETB\",\"api_xla.md\":\"BOG4nquZ\",\"index.md\":\"CQZc12Oy\",\"introduction_configuration.md\":\"Cstxxqfn\",\"introduction_faqs.md\":\"BpJD1Rxu\",\"introduction_index.md\":\"qBof7Vu7\",\"tutorials_automatic-differentiation.md\":\"DdaMOKIJ\",\"tutorials_control-flow.md\":\"oqFMsiZy\",\"tutorials_index.md\":\"B8lUPivI\",\"tutorials_local-build.md\":\"BMB-OZLc\",\"tutorials_multihost.md\":\"ImNd0t82\",\"tutorials_partial-evaluation.md\":\"B1tgel8_\",\"tutorials_persistent_compile_cache.md\":\"C5JQN76T\",\"tutorials_profiling.md\":\"EPIob-cW\",\"tutorials_sharding.md\":\"Dw3Xk_rV\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Reactant.jl\",\"description\":\"Documentation for Reactant.jl\",\"base\":\"/Reactant.jl/previews/PR1940/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"outline\":\"deep\",\"logo\":{\"light\":\"/logo.svg\",\"dark\":\"/logo.svg\"},\"search\":{\"provider\":\"local\",\"options\":{\"detailedView\":true}},\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Getting Started\",\"items\":[{\"text\":\"Introduction\",\"link\":\"/introduction\"},{\"text\":\"Configuration\",\"link\":\"/introduction/configuration\"},{\"text\":\"FAQs\",\"link\":\"/introduction/FAQs\"}]},{\"text\":\"Benchmarks\",\"link\":\"https://enzymead.github.io/Reactant.jl/benchmarks/\"},{\"text\":\"Tutorials\",\"items\":[{\"text\":\"Overview\",\"link\":\"/tutorials/\"},{\"text\":\"Partial Evaluation\",\"link\":\"/tutorials/partial-evaluation\"},{\"text\":\"Control Flow\",\"link\":\"/tutorials/control-flow\"},{\"text\":\"Automatic Differentiation\",\"link\":\"/tutorials/automatic-differentiation\"},{\"text\":\"Sharding\",\"link\":\"/tutorials/sharding\"},{\"text\":\"Profiling\",\"link\":\"/tutorials/profiling\"},{\"text\":\"Multi-Host Environments\",\"link\":\"/tutorials/multihost\"},{\"text\":\"Local build\",\"link\":\"/tutorials/local-build\"},{\"text\":\"Persistent Compilation Cache\",\"link\":\"/tutorials/persistent_compile_cache\"}]},{\"text\":\"API\",\"items\":[{\"text\":\"Core Reactant API\",\"link\":\"/api/api\"},{\"text\":\"Sharding\",\"link\":\"/api/sharding\"},{\"text\":\"Serialization\",\"link\":\"/api/serialization\"},{\"text\":\"Ops\",\"link\":\"/api/ops\"},{\"text\":\"Configuration\",\"link\":\"/api/config\"},{\"text\":\"MLIR Dialects\",\"items\":[{\"text\":\"ArithOps\",\"link\":\"/api/dialects/arith\"},{\"text\":\"Affine\",\"link\":\"/api/dialects/affine\"},{\"text\":\"Builtin\",\"link\":\"/api/dialects/builtin\"},{\"text\":\"Chlo\",\"link\":\"/api/dialects/chlo\"},{\"text\":\"Enzyme\",\"link\":\"/api/dialects/enzyme\"},{\"text\":\"EnzymeXLA\",\"link\":\"/api/dialects/enzymexla\"},{\"text\":\"Func\",\"link\":\"/api/dialects/func\"},{\"text\":\"GPU\",\"link\":\"/api/dialects/gpu\"},{\"text\":\"LLVM\",\"link\":\"/api/dialects/llvm\"},{\"text\":\"MPI\",\"link\":\"/api/dialects/mpi\"},{\"text\":\"MemRef\",\"link\":\"/api/dialects/memref\"},{\"text\":\"Mosaic GPU\",\"link\":\"/api/dialects/mosaicgpu\"},{\"text\":\"NVVM\",\"link\":\"/api/dialects/nvvm\"},{\"text\":\"Shardy\",\"link\":\"/api/dialects/shardy\"},{\"text\":\"SparseTensor\",\"link\":\"/api/dialects/sparsetensor\"},{\"text\":\"StableHLO\",\"link\":\"/api/dialects/stablehlo\"},{\"text\":\"Triton\",\"link\":\"/api/dialects/triton\"},{\"text\":\"TritonExt\",\"link\":\"/api/dialects/tritonext\"},{\"text\":\"TPU\",\"link\":\"/api/dialects/tpu\"},{\"text\":\"VHLO\",\"link\":\"/api/dialects/vhlo\"}]},{\"text\":\"Low-Level API\",\"items\":[{\"text\":\"MLIR API\",\"link\":\"/api/mlirc\"},{\"text\":\"XLA\",\"link\":\"/api/xla\"}]},{\"text\":\"Internal API\",\"link\":\"/api/internal\"}]},{\"component\":\"VersionPicker\"}],\"sidebar\":{\"/introduction/\":[{\"text\":\"Getting Started\",\"collapsed\":false,\"items\":[{\"text\":\"Introduction\",\"link\":\"/introduction\"},{\"text\":\"Configuration\",\"link\":\"/introduction/configuration\"},{\"text\":\"FAQs\",\"link\":\"/introduction/FAQs\"}]}],\"/tutorials/\":[{\"text\":\"Tutorials\",\"collapsed\":false,\"items\":[{\"text\":\"Overview\",\"link\":\"/tutorials/\"},{\"text\":\"Partial Evaluation\",\"link\":\"/tutorials/partial-evaluation\"},{\"text\":\"Control Flow\",\"link\":\"/tutorials/control-flow\"},{\"text\":\"Automatic Differentiation\",\"link\":\"/tutorials/automatic-differentiation\"},{\"text\":\"Sharding\",\"link\":\"/tutorials/sharding\"},{\"text\":\"Profiling\",\"link\":\"/tutorials/profiling\"},{\"text\":\"Multi-Host Environments\",\"link\":\"/tutorials/multihost\"},{\"text\":\"Local build\",\"link\":\"/tutorials/local-build\"},{\"text\":\"Persistent Compilation Cache\",\"link\":\"/tutorials/persistent_compile_cache\"}]}],\"/api/\":[{\"text\":\"API Reference\",\"collapsed\":false,\"items\":[{\"text\":\"Reactant API\",\"link\":\"/api/api\"},{\"text\":\"Sharding\",\"link\":\"/api/sharding\"},{\"text\":\"Serialization\",\"link\":\"/api/serialization\"},{\"text\":\"Ops\",\"link\":\"/api/ops\"},{\"text\":\"Configuration\",\"link\":\"/api/config\"},{\"text\":\"MLIR Dialects\",\"collapsed\":false,\"items\":[{\"text\":\"ArithOps\",\"link\":\"/api/dialects/arith\"},{\"text\":\"Affine\",\"link\":\"/api/dialects/affine\"},{\"text\":\"Builtin\",\"link\":\"/api/dialects/builtin\"},{\"text\":\"Chlo\",\"link\":\"/api/dialects/chlo\"},{\"text\":\"Enzyme\",\"link\":\"/api/dialects/enzyme\"},{\"text\":\"EnzymeXLA\",\"link\":\"/api/dialects/enzymexla\"},{\"text\":\"Func\",\"link\":\"/api/dialects/func\"},{\"text\":\"GPU\",\"link\":\"/api/dialects/gpu\"},{\"text\":\"LLVM\",\"link\":\"/api/dialects/llvm\"},{\"text\":\"MPI\",\"link\":\"/api/dialects/mpi\"},{\"text\":\"MemRef\",\"link\":\"/api/dialects/memref\"},{\"text\":\"Mosaic GPU\",\"link\":\"/api/dialects/mosaicgpu\"},{\"text\":\"NVVM\",\"link\":\"/api/dialects/nvvm\"},{\"text\":\"Shardy\",\"link\":\"/api/dialects/shardy\"},{\"text\":\"SparseTensor\",\"link\":\"/api/dialects/sparsetensor\"},{\"text\":\"StableHLO\",\"link\":\"/api/dialects/stablehlo\"},{\"text\":\"Triton\",\"link\":\"/api/dialects/triton\"},{\"text\":\"TritonExt\",\"link\":\"/api/dialects/tritonext\"},{\"text\":\"TPU\",\"link\":\"/api/dialects/tpu\"},{\"text\":\"VHLO\",\"link\":\"/api/dialects/vhlo\"}]},{\"text\":\"Low-Level API\",\"collapsed\":false,\"items\":[{\"text\":\"MLIR API\",\"link\":\"/api/mlirc\"},{\"text\":\"XLA\",\"link\":\"/api/xla\"}]},{\"text\":\"Internal API\",\"link\":\"/api/internal\"}]}]},\"editLink\":{\"pattern\":\"https://github.com/EnzymeAD/Reactant.jl/edit/main/docs/src/:path\",\"text\":\"Edit this page on GitHub\"},\"socialLinks\":[{\"icon\":\"slack\",\"link\":\"https://julialang.org/slack/\"}],\"footer\":{\"message\":\"Made with <a href=\\\"https://documenter.juliadocs.org/stable/\\\" target=\\\"_blank\\\"><strong>Documenter.jl</strong></a>, <a href=\\\"https://vitepress.dev\\\" target=\\\"_blank\\\"><strong>VitePress</strong></a> and <a href=\\\"https://luxdl.github.io/DocumenterVitepress.jl/stable\\\" target=\\\"_blank\\\"><strong>DocumenterVitepress.jl</strong></a><br>Released under the MIT License. Powered by the <a href=\\\"https://www.julialang.org\\\">Julia Programming Language</a>.<br>\",\"copyright\":\"© Copyright 2025 Reactant Development Team.\"},\"lastUpdated\":{\"text\":\"Updated at\",\"formatOptions\":{\"dateStyle\":\"full\",\"timeStyle\":\"medium\"}}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>