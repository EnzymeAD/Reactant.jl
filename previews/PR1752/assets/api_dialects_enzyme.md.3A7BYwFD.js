import{_ as o,C as r,c as i,o as d,j as t,a,G as n,w as s,al as u}from"./chunks/framework.DNACSa3W.js";const A=JSON.parse('{"title":"Enzyme Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/enzyme.md","filePath":"api/dialects/enzyme.md","lastUpdated":null}'),c={name:"api/dialects/enzyme.md"},R={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},p={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},M={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},z={class:"jldocstring custom-block"};function D(V,e,k,x,E,S){const l=r("Badge");return d(),i("div",null,[e[65]||(e[65]=t("h1",{id:"Enzyme-Dialect",tabindex:"-1"},[a("Enzyme Dialect "),t("a",{class:"header-anchor",href:"#Enzyme-Dialect","aria-label":'Permalink to "Enzyme Dialect {#Enzyme-Dialect}"'},"â€‹")],-1)),t("details",R,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addRetvalToTrace-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.addRetvalToTrace-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addRetvalToTrace")],-1)),e[1]||(e[1]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=t("p",null,[t("code",null,"addRetvalToTrace")],-1)),e[4]||(e[4]=t("p",null,"Add the function's return value(s) into the execution trace.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L16-L20",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",m,[t("summary",null,[e[5]||(e[5]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addSampleToTrace-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.addSampleToTrace-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addSampleToTrace")],-1)),e[6]||(e[6]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[8]||(e[8]=t("p",null,[t("code",null,"addSampleToTrace")],-1)),e[9]||(e[9]=t("p",null,"Add a sampled value into the execution trace.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[7]||(e[7]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L42-L46",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",p,[t("summary",null,[e[10]||(e[10]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addSubtrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.addSubtrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addSubtrace")],-1)),e[11]||(e[11]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[13]||(e[13]=t("p",null,[t("code",null,"addSubtrace")],-1)),e[14]||(e[14]=t("p",null,"Insert a subtrace into a parent trace.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[12]||(e[12]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L68-L72",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b,[t("summary",null,[e[15]||(e[15]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addTo-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.addTo-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addTo")],-1)),e[16]||(e[16]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[18]||(e[18]=t("p",null,[t("code",null,"addTo")],-1)),e[19]||(e[19]=t("p",null,"TODO",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[17]||(e[17]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L94-L98",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y,[t("summary",null,[e[20]||(e[20]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addWeightToTrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.addWeightToTrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addWeightToTrace")],-1)),e[21]||(e[21]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[23]||(e[23]=t("p",null,[t("code",null,"addWeightToTrace")],-1)),e[24]||(e[24]=t("p",null,"Add the aggregated log-probability weight to the execution trace.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[22]||(e[22]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L118-L122",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[25]||(e[25]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.broadcast-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.broadcast-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.broadcast")],-1)),e[26]||(e[26]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[28]||(e[28]=t("p",null,[t("code",null,"broadcast")],-1)),e[29]||(e[29]=t("p",null,[a("Broadcast the operand by adding extra dimensions with sizes provided by the "),t("code",null,"shape"),a(" attribute to the front. For scalar operands, ranked tensor is created.")],-1)),e[30]||(e[30]=t("p",null,[a("NOTE: Only works for scalar and "),t("em",null,"ranked"),a(" tensor operands for now.")],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[27]||(e[27]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L235-L242",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I,[t("summary",null,[e[31]||(e[31]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.generate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.generate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.generate")],-1)),e[32]||(e[32]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[34]||(e[34]=u("<p><code>generate</code></p><p>Generate an execution trace and weight from a probabilistic function. If a <code>constraint</code> dict is provided AND the sample op&#39;s <code>symbol</code> is in the <code>constrained_symbols</code> array, we will use the corresponding constraint value instead of generating new samples from the probabilistic function. By convention, the 0th operand in <code>inputs</code> or <code>outputs</code> is the initial RNG state (seed).</p>",2)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[33]||(e[33]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L296-L305",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",L,[t("summary",null,[e[35]||(e[35]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getSampleFromConstraint-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getSampleFromConstraint-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getSampleFromConstraint")],-1)),e[36]||(e[36]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[38]||(e[38]=t("p",null,[t("code",null,"getSampleFromConstraint")],-1)),e[39]||(e[39]=t("p",null,"Get sampled values from a constraint for a given symbol.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[37]||(e[37]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L394-L398",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",M,[t("summary",null,[e[40]||(e[40]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getSubconstraint-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getSubconstraint-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getSubconstraint")],-1)),e[41]||(e[41]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[43]||(e[43]=t("p",null,[t("code",null,"getSubconstraint")],-1)),e[44]||(e[44]=t("p",null,"Get a subconstraint from a constraint for a given symbol.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[42]||(e[42]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L420-L424",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",j,[t("summary",null,[e[45]||(e[45]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.initTrace-Tuple{}",href:"#Reactant.MLIR.Dialects.enzyme.initTrace-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.initTrace")],-1)),e[46]||(e[46]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[48]||(e[48]=t("p",null,[t("code",null,"initTrace")],-1)),e[49]||(e[49]=t("p",null,"Initialize an execution trace for a probabilistic function.",-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[47]||(e[47]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L484-L488",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[50]||(e[50]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.sample-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.sample-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.sample")],-1)),e[51]||(e[51]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[53]||(e[53]=t("p",null,[t("code",null,"sample")],-1)),e[54]||(e[54]=t("p",null,[a("Sample from a distribution. By convention, the 0th operand in "),t("code",null,"inputs"),a(" or "),t("code",null,"outputs"),a(" is the initial RNG state (seed).")],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[52]||(e[52]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L565-L570",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",T,[t("summary",null,[e[55]||(e[55]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.simulate-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.simulate-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.simulate")],-1)),e[56]||(e[56]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[58]||(e[58]=t("p",null,[t("code",null,"simulate")],-1)),e[59]||(e[59]=t("p",null,[a("Simulate a probabilistic function to generate execution trace by replacing all SampleOps with distribution calls and recording all sampled values into the trace. This op returns the trace, the weight (accumulated log-probability), and the other outputs. By convention, the 0th operand in "),t("code",null,"inputs"),a(" or "),t("code",null,"outputs"),a(" is the initial RNG state (seed).")],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[57]||(e[57]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L620-L628",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",z,[t("summary",null,[e[60]||(e[60]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.untracedCall-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.untracedCall-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.untracedCall")],-1)),e[61]||(e[61]=a()),n(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[63]||(e[63]=t("p",null,[t("code",null,"untracedCall")],-1)),e[64]||(e[64]=t("p",null,[a("Call a probabilistic function without tracing. By convention, the 0th operand in "),t("code",null,"inputs"),a(" or "),t("code",null,"outputs"),a(" is the initial RNG state (seed).")],-1)),n(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[62]||(e[62]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4dacd1fe3197e8b97f4a20041a623d45e3863642/src/mlir/Dialects/Enzyme.jl#L657-L662",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const O=o(c,[["render",D]]);export{A as __pageData,O as default};
