import{_ as i,C as d,c as r,o as c,j as t,a as l,al as n,G as a,w as o}from"./chunks/framework.w1HMbHlz.js";const w=JSON.parse('{"title":"TPU Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/tpu.md","filePath":"api/dialects/tpu.md","lastUpdated":null}'),u={name:"api/dialects/tpu.md"},p={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"};function M(_,e,L,D,v,x){const s=d("Badge");return c(),r("div",null,[e[55]||(e[55]=t("h1",{id:"TPU-Dialect",tabindex:"-1"},[l("TPU Dialect "),t("a",{class:"header-anchor",href:"#TPU-Dialect","aria-label":'Permalink to "TPU Dialect {#TPU-Dialect}"'},"â€‹")],-1)),e[56]||(e[56]=t("p",null,[l("Refer to the "),t("a",{href:"https://github.com/jax-ml/jax/blob/main/jaxlib/mosaic/dialect/tpu/tpu.td",target:"_blank",rel:"noreferrer"},"official documentation"),l(" for more details.")],-1)),t("details",p,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.tpu.assume_multiple-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.assume_multiple-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.assume_multiple")],-1)),e[1]||(e[1]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=n("",5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/df43451b377e0f5a840cf0d03b1976dfd152df2e/src/mlir/Dialects/TPU.jl#L73-L87",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",m,[t("summary",null,[e[4]||(e[4]=t("a",{id:"Reactant.MLIR.Dialects.tpu.barrier-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.barrier-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.barrier")],-1)),e[5]||(e[5]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[7]||(e[7]=t("p",null,[t("code",null,"barrier")],-1)),e[8]||(e[8]=t("p",null,"Performs barrier synchronization across all SC vector subcores at the specified barrier id.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[6]||(e[6]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/df43451b377e0f5a840cf0d03b1976dfd152df2e/src/mlir/Dialects/TPU.jl#L110-L115",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[9]||(e[9]=t("a",{id:"Reactant.MLIR.Dialects.tpu.broadcast_in_sublanes-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.broadcast_in_sublanes-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.broadcast_in_sublanes")],-1)),e[10]||(e[10]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[12]||(e[12]=t("p",null,[t("code",null,"broadcast_in_sublanes")],-1)),e[13]||(e[13]=t("p",null,[l("For each sublane "),t("code",null,"i"),l(", broadcasts the value in lane "),t("code",null,"lane + i"),l(" along the entire sublane. If "),t("code",null,"lane + i"),l(" is not in [0, lane_count), then the value in sublane "),t("code",null,"i"),l(" is not defined (can be anything).")],-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[11]||(e[11]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/df43451b377e0f5a840cf0d03b1976dfd152df2e/src/mlir/Dialects/TPU.jl#L173-L179",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b,[t("summary",null,[e[14]||(e[14]=t("a",{id:"Reactant.MLIR.Dialects.tpu.create_subelement_mask-Tuple{}",href:"#Reactant.MLIR.Dialects.tpu.create_subelement_mask-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.create_subelement_mask")],-1)),e[15]||(e[15]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[17]||(e[17]=n("",10)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[16]||(e[16]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/df43451b377e0f5a840cf0d03b1976dfd152df2e/src/mlir/Dialects/TPU.jl#L245-L272",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",R,[t("summary",null,[e[18]||(e[18]=t("a",{id:"Reactant.MLIR.Dialects.tpu.dynamic_gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.dynamic_gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.dynamic_gather")],-1)),e[19]||(e[19]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[21]||(e[21]=n("",6)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[20]||(e[20]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/df43451b377e0f5a840cf0d03b1976dfd152df2e/src/mlir/Dialects/TPU.jl#L331-L347",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[22]||(e[22]=t("a",{id:"Reactant.MLIR.Dialects.tpu.iota-Tuple{}",href:"#Reactant.MLIR.Dialects.tpu.iota-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.iota")],-1)),e[23]||(e[23]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[25]||(e[25]=n("",6)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[24]||(e[24]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/df43451b377e0f5a840cf0d03b1976dfd152df2e/src/mlir/Dialects/TPU.jl#L615-L633",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",h,[t("summary",null,[e[26]||(e[26]=t("a",{id:"Reactant.MLIR.Dialects.tpu.load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tpu.load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.load")],-1)),e[27]||(e[27]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[29]||(e[29]=n("",2)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[28]||(e[28]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/df43451b377e0f5a840cf0d03b1976dfd152df2e/src/mlir/Dialects/TPU.jl#L653-L659",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",T,[t("summary",null,[e[30]||(e[30]=t("a",{id:"Reactant.MLIR.Dialects.tpu.mask_cast-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.mask_cast-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.mask_cast")],-1)),e[31]||(e[31]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[33]||(e[33]=t("p",null,[t("code",null,"mask_cast")],-1)),e[34]||(e[34]=t("p",null,"Cast a mask register into a different packing.",-1)),e[35]||(e[35]=t("p",null,"If casting to a type with smaller packing, then values being packed together must be identical. For example, for 8x128x4xi1 -> 8x128x2xi1, input[i, j, 0] == input[i, j, 1] and input[i, j, 2] == input[i, j, 3] must hold for all i, j. Otherwise, the result is undefined.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[32]||(e[32]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/df43451b377e0f5a840cf0d03b1976dfd152df2e/src/mlir/Dialects/TPU.jl#L727-L736",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I,[t("summary",null,[e[36]||(e[36]=t("a",{id:"Reactant.MLIR.Dialects.tpu.pack_elementwise-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tpu.pack_elementwise-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.pack_elementwise")],-1)),e[37]||(e[37]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[39]||(e[39]=n("",3)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[38]||(e[38]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/df43451b377e0f5a840cf0d03b1976dfd152df2e/src/mlir/Dialects/TPU.jl#L913-L923",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",j,[t("summary",null,[e[40]||(e[40]=t("a",{id:"Reactant.MLIR.Dialects.tpu.rotate-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.rotate-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.rotate")],-1)),e[41]||(e[41]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[43]||(e[43]=t("p",null,[t("code",null,"rotate")],-1)),e[44]||(e[44]=t("p",null,[l("Rotates the given vector by the given amount in the given dimension, i.e., for a 2D vector of shape (m, n), rotating dim 0 by "),t("code",null,"amount"),l(" will shift a row at index "),t("code",null,"i"),l(" to index "),t("code",null,"(i + amount) % m")],-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[42]||(e[42]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/df43451b377e0f5a840cf0d03b1976dfd152df2e/src/mlir/Dialects/TPU.jl#L1149-L1155",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y,[t("summary",null,[e[45]||(e[45]=t("a",{id:"Reactant.MLIR.Dialects.tpu.scan_count-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.scan_count-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.scan_count")],-1)),e[46]||(e[46]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[48]||(e[48]=t("p",null,[t("code",null,"scan_count")],-1)),e[49]||(e[49]=t("p",null,"ScanCountOp calculates the running duplicate occurrence count of the elements in the input vector, %values. The output vector, %counts, contains the running duplicate occurrence count for the corresponding element in the input vector, where the count is performed in ascending order of element indices. For example, if the elements of %values at indices 0, 5, and 7 had duplicate values, then the elements of %counts at indices 0, 5, and 7 would be 1, 2, and 3, respectively.",-1)),e[50]||(e[50]=t("p",null,"A mask vector, %in_mask, specifies which of the elements in the input vector are eligible for counting. An element in %values that has its mask set to 0 will always have a count of 1 in %counts, regardless of the position in the vector, or whether there were duplicates or not.",-1)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[47]||(e[47]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/df43451b377e0f5a840cf0d03b1976dfd152df2e/src/mlir/Dialects/TPU.jl#L1208-L1223",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",k,[t("summary",null,[e[51]||(e[51]=t("a",{id:"Reactant.MLIR.Dialects.tpu.unpack_elementwise-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.unpack_elementwise-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.unpack_elementwise")],-1)),e[52]||(e[52]=l()),a(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[54]||(e[54]=n("",3)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[53]||(e[53]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/df43451b377e0f5a840cf0d03b1976dfd152df2e/src/mlir/Dialects/TPU.jl#L1655-L1664",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const P=i(u,[["render",M]]);export{w as __pageData,P as default};
