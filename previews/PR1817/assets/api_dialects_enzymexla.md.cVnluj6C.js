import{_ as r,C as i,c as p,o as u,j as a,a as n,G as l,w as s,al as o}from"./chunks/framework.B8AlOEHq.js";const T=JSON.parse('{"title":"EnzymeXLA Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/enzymexla.md","filePath":"api/dialects/enzymexla.md","lastUpdated":null}'),d={name:"api/dialects/enzymexla.md"},c={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"};function M(x,e,k,j,z,h){const t=i("Badge");return u(),p("div",null,[e[46]||(e[46]=a("h1",{id:"EnzymeXLA-Dialect",tabindex:"-1"},[n("EnzymeXLA Dialect "),a("a",{class:"header-anchor",href:"#EnzymeXLA-Dialect","aria-label":'Permalink to "EnzymeXLA Dialect {#EnzymeXLA-Dialect}"'},"â€‹")],-1)),a("details",c,[a("summary",null,[e[0]||(e[0]=a("a",{id:"Reactant.MLIR.Dialects.enzymexla.gpu_wrapper-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzymexla.gpu_wrapper-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.gpu_wrapper")],-1)),e[1]||(e[1]=n()),l(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=a("p",null,[a("code",null,"gpu_wrapper")],-1)),e[4]||(e[4]=a("p",null,"The optional arguments to this operation are suggestions about what block dimensions this gpu kernel should have - usually taken f rom kernel launch params",-1)),l(t,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[2]||(e[2]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ac6a61a5ff909adad54101d4f4c57bb8196dda00/src/mlir/Dialects/EnzymeXLA.jl#L260-L266",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),a("details",m,[a("summary",null,[e[5]||(e[5]=a("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_gemqrt-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_gemqrt-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_gemqrt")],-1)),e[6]||(e[6]=n()),l(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[8]||(e[8]=a("p",null,[a("code",null,"lapack_gemqrt")],-1)),e[9]||(e[9]=a("p",null,"This operation is modeled after LAPACK's *GEMQR routines.",-1)),l(t,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[7]||(e[7]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ac6a61a5ff909adad54101d4f4c57bb8196dda00/src/mlir/Dialects/EnzymeXLA.jl#L313-L317",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),a("details",R,[a("summary",null,[e[10]||(e[10]=a("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_geqrf-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_geqrf-Tuple{Reactant.MLIR.IR.Value}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_geqrf")],-1)),e[11]||(e[11]=n()),l(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[13]||(e[13]=o(`<p><code>lapack_geqrf</code></p><p>This operation computes the QR factorization of a matrix using Householder reflections. Mathematically, it decomposes A into the product of an orthogonal matri x Q and an upper triangular matrix R, such that A = QR.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>            This operation is modeled after</span></span>
<span class="line"><span>                LAPACK&#39;s *GEQRF routines, which returns the  result in</span></span>
<span class="line"><span>                    the QR packed format.</span></span></code></pre></div>`,3)),l(t,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[12]||(e[12]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ac6a61a5ff909adad54101d4f4c57bb8196dda00/src/mlir/Dialects/EnzymeXLA.jl#L346-L357",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),a("details",f,[a("summary",null,[e[14]||(e[14]=a("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_geqrt-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_geqrt-Tuple{Reactant.MLIR.IR.Value}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_geqrt")],-1)),e[15]||(e[15]=n()),l(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[17]||(e[17]=a("p",null,[a("code",null,"lapack_geqrt")],-1)),e[18]||(e[18]=a("p",null,"This operation computes the QR factorization of a matrix using Householder reflections. Mathematically, it decomposes A into the product of an orthogonal matrix Q and an upper triangular matrix R, such that A = QR.",-1)),e[19]||(e[19]=a("p",null,"This operation is modeled after LAPACK's *GEQRT routines, which returns the result in the QR CompactWY format.",-1)),l(t,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[16]||(e[16]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ac6a61a5ff909adad54101d4f4c57bb8196dda00/src/mlir/Dialects/EnzymeXLA.jl#L379-L388",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),a("details",y,[a("summary",null,[e[20]||(e[20]=a("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_orgqr-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_orgqr-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_orgqr")],-1)),e[21]||(e[21]=n()),l(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[23]||(e[23]=a("p",null,[a("code",null,"lapack_orgqr")],-1)),e[24]||(e[24]=a("p",null,"This operation is modeled after LAPACK's _ORGQR/_UNGQR routines.",-1)),l(t,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[22]||(e[22]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ac6a61a5ff909adad54101d4f4c57bb8196dda00/src/mlir/Dialects/EnzymeXLA.jl#L659-L663",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),a("details",I,[a("summary",null,[e[25]||(e[25]=a("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_ormqr-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_ormqr-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_ormqr")],-1)),e[26]||(e[26]=n()),l(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[28]||(e[28]=a("p",null,[a("code",null,"lapack_ormqr")],-1)),e[29]||(e[29]=a("p",null,"This operation is modeled after LAPACK's *ORMQR routines.",-1)),l(t,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[27]||(e[27]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ac6a61a5ff909adad54101d4f4c57bb8196dda00/src/mlir/Dialects/EnzymeXLA.jl#L683-L687",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),a("details",b,[a("summary",null,[e[30]||(e[30]=a("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_symm-NTuple{5, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_symm-NTuple{5, Reactant.MLIR.IR.Value}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_symm")],-1)),e[31]||(e[31]=n()),l(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[33]||(e[33]=a("p",null,[a("code",null,"lapack_symm")],-1)),e[34]||(e[34]=a("p",null,'C := alpha_A_B + beta_C, or C := alpha_B_A + beta_C, where alpha and beta are scalars, A is a symmetric matrix"',-1)),l(t,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[32]||(e[32]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ac6a61a5ff909adad54101d4f4c57bb8196dda00/src/mlir/Dialects/EnzymeXLA.jl#L904-L908",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),a("details",L,[a("summary",null,[e[35]||(e[35]=a("a",{id:"Reactant.MLIR.Dialects.enzymexla.linalg_qr-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.linalg_qr-Tuple{Reactant.MLIR.IR.Value}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.linalg_qr")],-1)),e[36]||(e[36]=n()),l(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[38]||(e[38]=a("p",null,[a("code",null,"linalg_qr")],-1)),e[39]||(e[39]=a("p",null,"This operation computes the QR factorization of a matrix using Householder reflections. Mathematically, it decomposes A into the product of an orthogonal (unitary if complex) matrix Q and an upper triangular matrix R, such that A = QR.",-1)),e[40]||(e[40]=a("p",null,"If A has size m x n and m > n, Q is an m x n isometric matrix. If m < n, R will be a m x n trapezoidal matrix.",-1)),e[41]||(e[41]=a("p",null,"This operation is modeled after the mathematical formulation of the QR factorization, and not after LAPACK's compact formats.",-1)),l(t,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[37]||(e[37]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ac6a61a5ff909adad54101d4f4c57bb8196dda00/src/mlir/Dialects/EnzymeXLA.jl#L754-L767",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),a("details",g,[a("summary",null,[e[42]||(e[42]=a("a",{id:"Reactant.MLIR.Dialects.enzymexla.memcpy-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.memcpy-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.memcpy")],-1)),e[43]||(e[43]=n()),l(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[45]||(e[45]=o('<p><code>memcpy</code></p><p>The <code>gpu.memcpy</code> operation copies the content of one memref to another.</p><p>The op does not execute before all async dependencies have finished executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.memcpy async [%dep] %dst, %src : memref&lt;?xf32, 1&gt;, memref&lt;?xf32&gt;</span></span></code></pre></div>',6)),l(t,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[44]||(e[44]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/ac6a61a5ff909adad54101d4f4c57bb8196dda00/src/mlir/Dialects/EnzymeXLA.jl#L576-L593",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const A=r(d,[["render",M]]);export{T as __pageData,A as default};
