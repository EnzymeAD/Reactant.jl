import{_ as l,C as p,c as r,o as d,j as a,a as t,al as o,G as n,w as i}from"./chunks/framework.BzX4Jvtv.js";const D=JSON.parse('{"title":"Affine Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/affine.md","filePath":"api/dialects/affine.md","lastUpdated":null}'),c={name:"api/dialects/affine.md"},f={class:"jldocstring custom-block"},u={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},v={class:"jldocstring custom-block"},x={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},_={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"};function j(M,e,w,L,V,A){const s=p("Badge");return d(),r("div",null,[e[57]||(e[57]=a("h1",{id:"Affine-Dialect",tabindex:"-1"},[t("Affine Dialect "),a("a",{class:"header-anchor",href:"#Affine-Dialect","aria-label":'Permalink to "Affine Dialect {#Affine-Dialect}"'},"​")],-1)),e[58]||(e[58]=a("p",null,[t("Refer to the "),a("a",{href:"https://mlir.llvm.org/docs/Dialects/Affine/",target:"_blank",rel:"noreferrer"},"official documentation"),t(" for more details.")],-1)),a("details",f,[a("summary",null,[e[0]||(e[0]=a("a",{id:"Reactant.MLIR.Dialects.affine.apply-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.apply-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.apply")],-1)),e[1]||(e[1]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=o(`<p><code>apply</code></p><p>The <code>affine.apply</code> operation applies an <a href="/Reactant.jl/previews/PR1404/api/dialects/affine#affine-maps">affine mapping</a> to a list of SSA values, yielding a single SSA value. The number of dimension and symbol operands to <code>affine.apply</code> must be equal to the respective number of dimensional and symbolic inputs to the affine mapping; the affine mapping has to be one-dimensional, and so the <code>affine.apply</code> operation always returns one value. The input operands and result must all have ‘index’ type.</p><p>An operand that is a valid dimension as per the <a href="/Reactant.jl/previews/PR1404/api/dialects/affine#restrictions-on-dimensions-and-symbols">rules on valid affine dimensions and symbols</a> cannot be used as a symbolic operand.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#map = affine_map&lt;(d0, d1) -&gt; (d0 floordiv 8 + d1 floordiv 128)&gt;</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>%1 = affine.apply #map (%s, %t)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Inline example.</span></span>
<span class="line"><span>%2 = affine.apply affine_map&lt;(i)[s0] -&gt; (i + s0)&gt; (%42)[%n]</span></span></code></pre></div>`,5)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[2]||(e[2]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L16-L41",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[2]})]),a("details",u,[a("summary",null,[e[4]||(e[4]=a("a",{id:"Reactant.MLIR.Dialects.affine.delinearize_index-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.delinearize_index-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.delinearize_index")],-1)),e[5]||(e[5]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[7]||(e[7]=o(`<p><code>delinearize_index</code></p><p>The <code>affine.delinearize_index</code> operation takes a single index value and calculates the multi-index according to the given basis.</p><p><strong>Example</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%indices:3 = affine.delinearize_index %linear_index into (%c16, %c224, %c224) : index, index, index</span></span></code></pre></div><p>In the above example, <code>%indices:3</code> conceptually holds the following:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#map0 = affine_map&lt;()[s0] -&gt; (s0 floordiv 50176)&gt;</span></span>
<span class="line"><span>#map1 = affine_map&lt;()[s0] -&gt; ((s0 mod 50176) floordiv 224)&gt;</span></span>
<span class="line"><span>#map2 = affine_map&lt;()[s0] -&gt; (s0 mod 224)&gt;</span></span>
<span class="line"><span>%indices_0 = affine.apply #map0()[%linear_index]</span></span>
<span class="line"><span>%indices_1 = affine.apply #map1()[%linear_index]</span></span>
<span class="line"><span>%indices_2 = affine.apply #map2()[%linear_index]</span></span></code></pre></div><p>In other words, <code>%0:3 = affine.delinearize_index %x into (B, C)</code> produces <code>%0 = {%x / (B * C), (%x mod (B * C)) / C, %x mod C}</code>.</p><p>The basis may either contain <code>N</code> or <code>N-1</code> elements, where <code>N</code> is the number of results. If there are N basis elements, the first one will not be used during computations, but may be used during analysis and canonicalization to eliminate terms from the <code>affine.delinearize_index</code> or to enable conclusions about the total size of <code>%linear_index</code>.</p><p>If the basis is fully provided, the delinearize_index operation is said to &quot;have an outer bound&quot;. The builders assume that an <code>affine.delinearize_index</code> has an outer bound by default, as this is how the operation was initially defined.</p><p>That is, the example above could also have been written</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0:3 = affine.delinearize_index %linear_index into (244, 244) : index, index</span></span></code></pre></div><p>Note that, for symmetry with <code>getPaddedBasis()</code>, if <code>hasOuterBound</code> is <code>true</code> when one of the <code>OpFoldResult</code> builders is called but the first element of the basis is <code>nullptr</code>, that first element is ignored and the builder proceeds as if there was no outer bound.</p><p>Due to the constraints of affine maps, all the basis elements must be strictly positive. A dynamic basis element being 0 or negative causes undefined behavior.</p><p>As with other affine operations, lowerings of delinearize_index may assume that the underlying computations do not overflow the index type in a signed sense</p><ul><li>that is, the product of all basis elements is positive as an <code>index</code> as well.</li></ul>`,15)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[6]||(e[6]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L67-L120",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[6]})]),a("details",m,[a("summary",null,[e[8]||(e[8]=a("a",{id:"Reactant.MLIR.Dialects.affine.for_-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.for_-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.for_")],-1)),e[9]||(e[9]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[11]||(e[11]=o(`<p><code>for_</code></p><p><strong>Syntax</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>operation   ::= \`affine.for\` ssa-id \`=\` lower-bound \`to\` upper-bound</span></span>
<span class="line"><span>                (\`step\` integer-literal)? \`{\` op* \`}\`</span></span>
<span class="line"><span></span></span>
<span class="line"><span>lower-bound ::= \`max\`? affine-map-attribute dim-and-symbol-use-list | shorthand-bound</span></span>
<span class="line"><span>upper-bound ::= \`min\`? affine-map-attribute dim-and-symbol-use-list | shorthand-bound</span></span>
<span class="line"><span>shorthand-bound ::= ssa-id | \`-\`? integer-literal</span></span></code></pre></div><p>The <code>affine.for</code> operation represents an affine loop nest. It has one region containing its body. This region must contain one block that terminates with <a href="/Reactant.jl/previews/PR1404/api/dialects/affine#affineyield-mliraffineyieldop"><code>affine.yield</code></a>. <em>Note:</em> when <code>affine.for</code> is printed in custom format, the terminator is omitted. The block has one argument of <a href="./Builtin.md/#indextype"><code>index</code></a> type that represents the induction variable of the loop.</p><p>The <code>affine.for</code> operation executes its body a number of times iterating from a lower bound to an upper bound by a stride. The stride, represented by <code>step</code>, is a positive constant integer which defaults to &quot;1&quot; if not present. The lower and upper bounds specify a half-open range: the range includes the lower bound but does not include the upper bound.</p><p>The lower and upper bounds of a <code>affine.for</code> operation are represented as an application of an affine mapping to a list of SSA values passed to the map. The <a href="/Reactant.jl/previews/PR1404/api/dialects/affine#restrictions-on-dimensions-and-symbols">same restrictions</a> hold for these SSA values as for all bindings of SSA values to dimensions and symbols.</p><p>The affine mappings for the bounds may return multiple results, in which case the <code>max</code>/<code>min</code> keywords are required (for the lower/upper bound respectively), and the bound is the maximum/minimum of the returned values. There is no semantic ambiguity, but MLIR syntax requires the use of these keywords to make things more obvious to human readers.</p><p>Many upper and lower bounds are simple, so MLIR accepts two custom form syntaxes: the form that accepts a single &#39;ssa-id&#39; (e.g. <code>%N</code>) is shorthand for applying that SSA value to a function that maps a single symbol to itself, e.g., <code>()[s]-&gt;(s)()[%N]</code>. The integer literal form (e.g. <code>-42</code>) is shorthand for a nullary mapping function that returns the constant value (e.g. <code>()-&gt;(-42)()</code>).</p><p>Example showing reverse iteration of the inner loop:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#map57 = affine_map&lt;(d0)[s0] -&gt; (s0 - d0 - 1)&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func.func @simple_example(%A: memref&lt;?x?xf32&gt;, %B: memref&lt;?x?xf32&gt;) {</span></span>
<span class="line"><span>  %N = dim %A, 0 : memref&lt;?x?xf32&gt;</span></span>
<span class="line"><span>  affine.for %i = 0 to %N step 1 {</span></span>
<span class="line"><span>    affine.for %j = 0 to %N {   // implicitly steps by 1</span></span>
<span class="line"><span>      %0 = affine.apply #map57(%j)[%N]</span></span>
<span class="line"><span>      %tmp = call @F1(%A, %i, %0) : (memref&lt;?x?xf32&gt;, index, index)-&gt;(f32)</span></span>
<span class="line"><span>      call @F2(%tmp, %B, %i, %0) : (f32, memref&lt;?x?xf32&gt;, index, index)-&gt;()</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><code>affine.for</code> can also operate on loop-carried variables (<code>iter_args</code>) and return the final values after loop termination. The initial values of the variables are passed as additional SSA operands to the <code>affine.for</code> following the operands for the loop&#39;s lower and upper bounds. The operation&#39;s region has equivalent arguments for each variable representing the value of the variable at the current iteration.</p><p>The region must terminate with an <code>affine.yield</code> that passes all the current iteration variables to the next iteration, or to the <code>affine.for</code>&#39;s results if at the last iteration. For <code>affine.for</code>&#39;s that execute zero iterations, the initial values of the loop-carried variables (corresponding to the SSA operands) will be the op&#39;s results.</p><p>For example, to sum-reduce a memref:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>func.func @reduce(%buffer: memref&lt;1024xf32&gt;) -&gt; (f32) {</span></span>
<span class="line"><span>  // Initial sum set to 0.</span></span>
<span class="line"><span>  %sum_0 = arith.constant 0.0 : f32</span></span>
<span class="line"><span>  // iter_args binds initial values to the loop&#39;s region arguments.</span></span>
<span class="line"><span>  %sum = affine.for %i = 0 to 10 step 2</span></span>
<span class="line"><span>      iter_args(%sum_iter = %sum_0) -&gt; (f32) {</span></span>
<span class="line"><span>    %t = affine.load %buffer[%i] : memref&lt;1024xf32&gt;</span></span>
<span class="line"><span>    %sum_next = arith.addf %sum_iter, %t : f32</span></span>
<span class="line"><span>    // Yield current iteration sum to next iteration %sum_iter or to %sum</span></span>
<span class="line"><span>    // if final iteration.</span></span>
<span class="line"><span>    affine.yield %sum_next : f32</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return %sum : f32</span></span>
<span class="line"><span>}</span></span></code></pre></div><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%res:2 = affine.for %i = 0 to 128 iter_args(%arg0 = %init0, %arg1 = %init1)</span></span>
<span class="line"><span>           -&gt; (index, index) {</span></span>
<span class="line"><span>  %y0 = arith.addi %arg0, %c1 : index</span></span>
<span class="line"><span>  %y1 = arith.addi %arg1, %c2 : index</span></span>
<span class="line"><span>  affine.yield %y0, %y1 : index, index</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>If the <code>affine.for</code> defines any values, a yield terminator must be explicitly present. The number and types of the &quot;affine.for&quot; results must match the initial values in the <code>iter_args</code> binding and the yield operands.</p>`,16)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[10]||(e[10]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L146-L252",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[10]})]),a("details",h,[a("summary",null,[e[12]||(e[12]=a("a",{id:"Reactant.MLIR.Dialects.affine.if_-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.if_-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.if_")],-1)),e[13]||(e[13]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[15]||(e[15]=o(`<p><code>if_</code></p><p><strong>Syntax</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>operation  ::= \`affine.if\` if-op-cond \`{\` op* \`}\` (\`else\` \`{\` op* \`}\`)?</span></span>
<span class="line"><span>if-op-cond ::= integer-set-attr dim-and-symbol-use-list</span></span></code></pre></div><p>The <code>affine.if</code> operation restricts execution to a subset of the loop iteration space defined by an integer set (a conjunction of affine constraints). A single <code>affine.if</code> may end with an optional <code>else</code> clause.</p><p>The condition of the <code>affine.if</code> is represented by an <a href="/Reactant.jl/previews/PR1404/api/dialects/affine#integer-sets">integer set</a> (a conjunction of affine constraints), and the SSA values bound to the dimensions and symbols in the integer set. The <a href="/Reactant.jl/previews/PR1404/api/dialects/affine#restrictions-on-dimensions-and-symbols">same restrictions</a> hold for these SSA values as for all bindings of SSA values to dimensions and symbols.</p><p>The <code>affine.if</code> operation contains two regions for the &quot;then&quot; and &quot;else&quot; clauses. <code>affine.if</code> may return results that are defined in its regions. The values defined are determined by which execution path is taken. Each region of the <code>affine.if</code> must contain a single block with no arguments, and be terminated by <code>affine.yield</code>. If <code>affine.if</code> defines no values, the <code>affine.yield</code> can be left out, and will be inserted implicitly. Otherwise, it must be explicit. If no values are defined, the else block may be empty (i.e. contain no blocks).</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#set = affine_set&lt;(d0, d1)[s0]: (d0 - 10 &gt;= 0, s0 - d0 - 9 &gt;= 0,</span></span>
<span class="line"><span>                                 d1 - 10 &gt;= 0, s0 - d1 - 9 &gt;= 0)&gt;</span></span>
<span class="line"><span>func.func @reduced_domain_example(%A, %X, %N) : (memref&lt;10xi32&gt;, i32, i32) {</span></span>
<span class="line"><span>  affine.for %i = 0 to %N {</span></span>
<span class="line"><span>     affine.for %j = 0 to %N {</span></span>
<span class="line"><span>       %0 = affine.apply #map42(%j)</span></span>
<span class="line"><span>       %tmp = call @S1(%X, %i, %0)</span></span>
<span class="line"><span>       affine.if #set(%i, %j)[%N] {</span></span>
<span class="line"><span>          %1 = affine.apply #map43(%i, %j)</span></span>
<span class="line"><span>          call @S2(%tmp, %A, %i, %1)</span></span>
<span class="line"><span>       }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Example with an explicit yield (initialization with edge padding):</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#interior = affine_set&lt;(i, j) : (i - 1 &gt;= 0, j - 1 &gt;= 0,  10 - i &gt;= 0, 10 - j &gt;= 0)&gt; (%i, %j)</span></span>
<span class="line"><span>func.func @pad_edges(%I : memref&lt;10x10xf32&gt;) -&gt; (memref&lt;12x12xf32) {</span></span>
<span class="line"><span>  %O = alloc memref&lt;12x12xf32&gt;</span></span>
<span class="line"><span>  affine.parallel (%i, %j) = (0, 0) to (12, 12) {</span></span>
<span class="line"><span>    %1 = affine.if #interior (%i, %j) {</span></span>
<span class="line"><span>      %2 = load %I[%i - 1, %j - 1] : memref&lt;10x10xf32&gt;</span></span>
<span class="line"><span>      affine.yield %2</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>      %2 = arith.constant 0.0 : f32</span></span>
<span class="line"><span>      affine.yield %2 : f32</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    affine.store %1, %O[%i, %j] : memref&lt;12x12xf32&gt;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return %O</span></span>
<span class="line"><span>}</span></span></code></pre></div>`,10)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[14]||(e[14]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L292-L361",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[14]})]),a("details",b,[a("summary",null,[e[16]||(e[16]=a("a",{id:"Reactant.MLIR.Dialects.affine.linearize_index-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.linearize_index-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.linearize_index")],-1)),e[17]||(e[17]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[19]||(e[19]=o(`<p><code>linearize_index</code></p><p>The <code>affine.linearize_index</code> operation takes a sequence of index values and a basis of the same length and linearizes the indices using that basis.</p><p>That is, for indices <code>%idx_0</code> to <code>%idx_{N-1}</code> and basis elements <code>b_0</code> (or <code>b_1</code>) up to <code>b_{N-1}</code> it computes</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sum(i = 0 to N-1) %idx_i * product(j = i + 1 to N-1) B_j</span></span></code></pre></div><p>In other words, <code>%0 = affine.linearize_index [%z, %y, %x] by (Z, Y, X)</code> gives <code>%0 = %x + %y * X + %z * X * Y</code>, or <code>%0 = %x + X * (%y + Y * (%z))</code>.</p><p>The basis may either have <code>N</code> or <code>N-1</code> elements, where <code>N</code> is the number of inputs to linearize_index. If <code>N</code> inputs are provided, the first one is not used in computation, but may be used during analysis or canonicalization as a bound on <code>%idx_0</code>.</p><p>If all <code>N</code> basis elements are provided, the linearize_index operation is said to &quot;have an outer bound&quot;.</p><p>As a convenience, and for symmetry with <code>getPaddedBasis()</code>, ifg the first element of a set of <code>OpFoldResult</code>s passed to the builders of this operation is <code>nullptr</code>, that element is ignored.</p><p>If the <code>disjoint</code> property is present, this is an optimization hint that, for all <code>i</code>, <code>0 &lt;= %idx_i &lt; B_i</code> - that is, no index affects any other index, except that <code>%idx_0</code> may be negative to make the index as a whole negative. In addition, <code>disjoint</code> is an assertion that all bases elements are non-negative.</p><p>Note that the outputs of <code>affine.delinearize_index</code> are, by definition, <code>disjoint</code>.</p><p>As with other affine ops, undefined behavior occurs if the linearization computation overflows in the signed sense.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%linear_index = affine.linearize_index [%index_0, %index_1, %index_2] by (2, 3, 5) : index</span></span>
<span class="line"><span>// Same effect</span></span>
<span class="line"><span>%linear_index = affine.linearize_index [%index_0, %index_1, %index_2] by (3, 5) : index</span></span></code></pre></div><p>In the above example, <code>%linear_index</code> conceptually holds the following:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#map = affine_map&lt;()[s0, s1, s2] -&gt; (s0 * 15 + s1 * 5 + s2)&gt;</span></span>
<span class="line"><span>%linear_index = affine.apply #map()[%index_0, %index_1, %index_2]</span></span></code></pre></div>`,15)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[18]||(e[18]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L388-L440",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[18]})]),a("details",g,[a("summary",null,[e[20]||(e[20]=a("a",{id:"Reactant.MLIR.Dialects.affine.load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.load")],-1)),e[21]||(e[21]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[23]||(e[23]=o('<p><code>load</code></p><p><strong>Syntax</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>operation ::= ssa-id `=` `affine.load` ssa-use `[` multi-dim-affine-map-of-ssa-ids `]` `:` memref-type</span></span></code></pre></div><p>The <code>affine.load</code> op reads an element from a memref, where the index for each memref dimension is an affine expression of loop induction variables and symbols. The output of <code>affine.load</code> is a new value with the same type as the elements of the memref. An affine expression of loop IVs and symbols must be specified for each dimension of the memref. The keyword <code>symbol</code> can be used to indicate SSA identifiers which are symbolic.</p><p>Example 1:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = affine.load %0[%i0 + 3, %i1 + 7] : memref&lt;100x100xf32&gt;</span></span></code></pre></div><p>Example 2: Uses <code>symbol</code> keyword for symbols <code>%n</code> and <code>%m</code>.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = affine.load %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref&lt;100x100xf32&gt;</span></span></code></pre></div>',8)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[22]||(e[22]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L468-L495",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[22]})]),a("details",y,[a("summary",null,[e[24]||(e[24]=a("a",{id:"Reactant.MLIR.Dialects.affine.max-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.max-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.max")],-1)),e[25]||(e[25]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[27]||(e[27]=o('<p><code>max</code></p><p>The <code>affine.max</code> operation computes the maximum value result from a multi-result affine map.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = affine.max (d0) -&gt; (1000, d0 + 512) (%i0) : index</span></span></code></pre></div>',4)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[26]||(e[26]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L517-L528",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[26]})]),a("details",v,[a("summary",null,[e[28]||(e[28]=a("a",{id:"Reactant.MLIR.Dialects.affine.min-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.min-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.min")],-1)),e[29]||(e[29]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[31]||(e[31]=o('<p><code>min</code></p><p><strong>Syntax</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>operation ::= ssa-id `=` `affine.min` affine-map-attribute dim-and-symbol-use-list</span></span></code></pre></div><p>The <code>affine.min</code> operation applies an <a href="/Reactant.jl/previews/PR1404/api/dialects/affine#affine-expressions">affine mapping</a> to a list of SSA values, and returns the minimum value of all result expressions. The number of dimension and symbol arguments to <code>affine.min</code> must be equal to the respective number of dimensional and symbolic inputs to the affine mapping; the <code>affine.min</code> operation always returns one value. The input operands and result must all have &#39;index&#39; type.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = affine.min affine_map&lt;(d0)[s0] -&gt; (1000, d0 + 512, s0)&gt; (%arg0)[%arg1]</span></span></code></pre></div>',6)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[30]||(e[30]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L554-L575",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[30]})]),a("details",x,[a("summary",null,[e[32]||(e[32]=a("a",{id:"Reactant.MLIR.Dialects.affine.parallel-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.parallel-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.parallel")],-1)),e[33]||(e[33]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[35]||(e[35]=o(`<p><code>parallel</code></p><p>The <code>affine.parallel</code> operation represents a hyper-rectangular affine parallel band, defining zero or more SSA values for its induction variables. It has one region capturing the parallel band body. The induction variables are represented as arguments of this region. These SSA values always have type index, which is the size of the machine word. The strides, represented by steps, are positive constant integers which defaults to &quot;1&quot; if not present. The lower and upper bounds specify a half-open range: the range includes the lower bound but does not include the upper bound. The body region must contain exactly one block that terminates with <code>affine.yield</code>.</p><p>The lower and upper bounds of a parallel operation are represented as an application of an affine mapping to a list of SSA values passed to the map. The same restrictions hold for these SSA values as for all bindings of SSA values to dimensions and symbols. The list of expressions in each map is interpreted according to the respective bounds group attribute. If a single expression belongs to the group, then the result of this expression is taken as a lower(upper) bound of the corresponding loop induction variable. If multiple expressions belong to the group, then the lower(upper) bound is the max(min) of these values obtained from these expressions. The loop band has as many loops as elements in the group bounds attributes.</p><p>Each value yielded by <code>affine.yield</code> will be accumulated/reduced via one of the reduction methods defined in the AtomicRMWKind enum. The order of reduction is unspecified, and lowering may produce any valid ordering. Loops with a 0 trip count will produce as a result the identity value associated with each reduction (i.e. 0.0 for addf, 1.0 for mulf). Assign reductions for loops with a trip count != 1 produces undefined results.</p><p>Note: Calling <code>AffineParallelOp::build</code> will create the required region and block, and insert the required terminator if it is trivial (i.e. no values are yielded). Parsing will also create the required region, block, and terminator, even when they are missing from the textual representation.</p><p>Example (3x3 valid convolution):</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>func.func @conv_2d(%D : memref&lt;100x100xf32&gt;, %K : memref&lt;3x3xf32&gt;) -&gt; (memref&lt;98x98xf32&gt;) {</span></span>
<span class="line"><span>  %O = memref.alloc() : memref&lt;98x98xf32&gt;</span></span>
<span class="line"><span>  affine.parallel (%x, %y) = (0, 0) to (98, 98) {</span></span>
<span class="line"><span>    %0 = affine.parallel (%kx, %ky) = (0, 0) to (2, 2) reduce (&quot;addf&quot;) -&gt; f32 {</span></span>
<span class="line"><span>      %1 = affine.load %D[%x + %kx, %y + %ky] : memref&lt;100x100xf32&gt;</span></span>
<span class="line"><span>      %2 = affine.load %K[%kx, %ky] : memref&lt;3x3xf32&gt;</span></span>
<span class="line"><span>      %3 = arith.mulf %1, %2 : f32</span></span>
<span class="line"><span>      affine.yield %3 : f32</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    affine.store %0, %O[%x, %y] : memref&lt;98x98xf32&gt;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return %O : memref&lt;98x98xf32&gt;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Example (tiling by potentially imperfectly dividing sizes):</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>affine.parallel (%ii, %jj) = (0, 0) to (%N, %M) step (32, 32) {</span></span>
<span class="line"><span>  affine.parallel (%i, %j) = (%ii, %jj)</span></span>
<span class="line"><span>                          to (min(%ii + 32, %N), min(%jj + 32, %M)) {</span></span>
<span class="line"><span>    call @f(%i, %j) : (index, index) -&gt; ()</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre></div>`,9)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[34]||(e[34]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L601-L665",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[34]})]),a("details",R,[a("summary",null,[e[36]||(e[36]=a("a",{id:"Reactant.MLIR.Dialects.affine.prefetch-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.prefetch-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.prefetch")],-1)),e[37]||(e[37]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[39]||(e[39]=o('<p><code>prefetch</code></p><p>The <code>affine.prefetch</code> op prefetches data from a memref location described with an affine subscript similar to affine.load, and has three attributes: a read/write specifier, a locality hint, and a cache type specifier as shown below:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>affine.prefetch %0[%i, %j + 5], read, locality&lt;3&gt;, data : memref&lt;400x400xi32&gt;</span></span></code></pre></div><p>The read/write specifier is either &#39;read&#39; or &#39;write&#39;, the locality hint specifier ranges from locality&lt;0&gt; (no locality) to locality&lt;3&gt; (extremely local keep in cache). The cache type specifier is either &#39;data&#39; or &#39;instr&#39; and specifies whether the prefetch is performed on data cache or on instruction cache.</p>',4)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[38]||(e[38]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L703-L720",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[38]})]),a("details",_,[a("summary",null,[e[40]||(e[40]=a("a",{id:"Reactant.MLIR.Dialects.affine.store-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.store-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.store")],-1)),e[41]||(e[41]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[43]||(e[43]=o('<p><code>store</code></p><p><strong>Syntax</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>operation ::= `affine.store` ssa-use, ssa-use `[` multi-dim-affine-map-of-ssa-ids `]` `:` memref-type</span></span></code></pre></div><p>The <code>affine.store</code> op writes an element to a memref, where the index for each memref dimension is an affine expression of loop induction variables and symbols. The <code>affine.store</code> op stores a new value which is the same type as the elements of the memref. An affine expression of loop IVs and symbols must be specified for each dimension of the memref. The keyword <code>symbol</code> can be used to indicate SSA identifiers which are symbolic.</p><p>Example 1:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>affine.store %v0, %0[%i0 + 3, %i1 + 7] : memref&lt;100x100xf32&gt;</span></span></code></pre></div><p>Example 2: Uses <code>symbol</code> keyword for symbols <code>%n</code> and <code>%m</code>.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>affine.store %v0, %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref&lt;100x100xf32&gt;</span></span></code></pre></div>',8)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[42]||(e[42]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L753-L780",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[42]})]),a("details",I,[a("summary",null,[e[44]||(e[44]=a("a",{id:"Reactant.MLIR.Dialects.affine.vector_load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.vector_load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.vector_load")],-1)),e[45]||(e[45]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[47]||(e[47]=o('<p><code>vector_load</code></p><p>The <code>affine.vector_load</code> is the vector counterpart of <a href="/Reactant.jl/previews/PR1404/api/dialects/affine#affineload-mliraffineloadop">affine.load</a>. It reads a slice from a <a href="./Builtin.md/#memreftype">MemRef</a>, supplied as its first operand, into a <a href="./Builtin.md/#vectortype">vector</a> of the same base elemental type. The index for each memref dimension is an affine expression of loop induction variables and symbols. These indices determine the start position of the read within the memref. The shape of the return vector type determines the shape of the slice read from the memref. This slice is contiguous along the respective dimensions of the shape. Strided vector loads will be supported in the future. An affine expression of loop IVs and symbols must be specified for each dimension of the memref. The keyword <code>symbol</code> can be used to indicate SSA identifiers which are symbolic.</p><p>Example 1: 8-wide f32 vector load.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = affine.vector_load %0[%i0 + 3, %i1 + 7] : memref&lt;100x100xf32&gt;, vector&lt;8xf32&gt;</span></span></code></pre></div><p>Example 2: 4-wide f32 vector load. Uses <code>symbol</code> keyword for symbols <code>%n</code> and <code>%m</code>.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = affine.vector_load %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref&lt;100x100xf32&gt;, vector&lt;4xf32&gt;</span></span></code></pre></div><p>Example 3: 2-dim f32 vector load.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = affine.vector_load %0[%i0, %i1] : memref&lt;100x100xf32&gt;, vector&lt;2x8xf32&gt;</span></span></code></pre></div><p>TODOs:</p><ul><li><p>Add support for strided vector loads.</p></li><li><p>Consider adding a permutation map to permute the slice that is read from memory</p></li></ul><p>(see <a href="./../Vector/#vectortransfer_read-mlirvectortransferreadop">vector.transfer_read</a>).</p>',11)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[46]||(e[46]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L802-L840",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[46]})]),a("details",T,[a("summary",null,[e[48]||(e[48]=a("a",{id:"Reactant.MLIR.Dialects.affine.vector_store-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.vector_store-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.vector_store")],-1)),e[49]||(e[49]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[51]||(e[51]=o('<p><code>vector_store</code></p><p>The <code>affine.vector_store</code> is the vector counterpart of <a href="/Reactant.jl/previews/PR1404/api/dialects/affine#affinestore-mliraffinestoreop">affine.store</a>. It writes a <a href="./Builtin.md/#vectortype">vector</a>, supplied as its first operand, into a slice within a <a href="./Builtin.md/#memreftype">MemRef</a> of the same base elemental type, supplied as its second operand. The index for each memref dimension is an affine expression of loop induction variables and symbols. These indices determine the start position of the write within the memref. The shape of th input vector determines the shape of the slice written to the memref. This slice is contiguous along the respective dimensions of the shape. Strided vector stores will be supported in the future. An affine expression of loop IVs and symbols must be specified for each dimension of the memref. The keyword <code>symbol</code> can be used to indicate SSA identifiers which are symbolic.</p><p>Example 1: 8-wide f32 vector store.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>affine.vector_store %v0, %0[%i0 + 3, %i1 + 7] : memref&lt;100x100xf32&gt;, vector&lt;8xf32&gt;</span></span></code></pre></div><p>Example 2: 4-wide f32 vector store. Uses <code>symbol</code> keyword for symbols <code>%n</code> and <code>%m</code>.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>affine.vector_store %v0, %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref&lt;100x100xf32&gt;, vector&lt;4xf32&gt;</span></span></code></pre></div><p>Example 3: 2-dim f32 vector store.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>affine.vector_store %v0, %0[%i0, %i1] : memref&lt;100x100xf32&gt;, vector&lt;2x8xf32&gt;</span></span></code></pre></div><p>TODOs:</p><ul><li><p>Add support for strided vector stores.</p></li><li><p>Consider adding a permutation map to permute the slice that is written to memory</p></li></ul><p>(see <a href="./../Vector/#vectortransfer_write-mlirvectortransferwriteop">vector.transfer_write</a>).</p>',11)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[50]||(e[50]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L862-L902",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[50]})]),a("details",k,[a("summary",null,[e[52]||(e[52]=a("a",{id:"Reactant.MLIR.Dialects.affine.yield-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.affine.yield-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[a("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.affine.yield")],-1)),e[53]||(e[53]=t()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[55]||(e[55]=a("p",null,[a("code",null,"yield")],-1)),e[56]||(e[56]=a("p",null,[t("The "),a("code",null,"affine.yield"),t(" yields zero or more SSA values from an affine op region and terminates the region. The semantics of how the values yielded are used is defined by the parent operation. If "),a("code",null,"affine.yield"),t(" has any operands, the operands must match the parent operation's results. If the parent operation defines no values, then the "),a("code",null,"affine.yield"),t(" may be left out in the custom syntax and the builders will insert one implicitly. Otherwise, it has to be present in the syntax to indicate which values are yielded.")],-1)),n(s,{type:"info",class:"source-link",text:"source"},{default:i(()=>e[54]||(e[54]=[a("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6cd026a3a40c31b756a89e0de3107e491083e643/src/mlir/Dialects/Affine.jl#L924-L936",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[54]})])])}const S=l(c,[["render",j]]);export{D as __pageData,S as default};
