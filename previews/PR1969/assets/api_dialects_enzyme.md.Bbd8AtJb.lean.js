import{_ as r,C as i,c as u,o as d,j as t,a as n,G as l,w as s,al as o}from"./chunks/framework.DA4SFFYg.js";const Q=JSON.parse('{"title":"Enzyme Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/enzyme.md","filePath":"api/dialects/enzyme.md","lastUpdated":null}'),R={name:"api/dialects/enzyme.md"},c={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},p={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},M={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},z={class:"jldocstring custom-block"},D={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},V={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"},x={class:"jldocstring custom-block"},E={class:"jldocstring custom-block"},v={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},A={class:"jldocstring custom-block"},S={class:"jldocstring custom-block"},O={class:"jldocstring custom-block"},w={class:"jldocstring custom-block"},N={class:"jldocstring custom-block"},C={class:"jldocstring custom-block"},F={class:"jldocstring custom-block"},G={class:"jldocstring custom-block"},B={class:"jldocstring custom-block"},P={class:"jldocstring custom-block"};function W(U,e,H,$,J,q){const a=i("Badge");return d(),u("div",null,[e[153]||(e[153]=t("h1",{id:"Enzyme-Dialect",tabindex:"-1"},[n("Enzyme Dialect "),t("a",{class:"header-anchor",href:"#Enzyme-Dialect","aria-label":'Permalink to "Enzyme Dialect {#Enzyme-Dialect}"'},"â€‹")],-1)),t("details",c,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addRetvalToTrace-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.addRetvalToTrace-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addRetvalToTrace")],-1)),e[1]||(e[1]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=t("p",null,[t("code",null,"addRetvalToTrace")],-1)),e[4]||(e[4]=t("p",null,"Add the function's return value(s) into the execution trace.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L16-L20",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",m,[t("summary",null,[e[5]||(e[5]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addSampleToTrace-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.addSampleToTrace-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addSampleToTrace")],-1)),e[6]||(e[6]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[8]||(e[8]=t("p",null,[t("code",null,"addSampleToTrace")],-1)),e[9]||(e[9]=t("p",null,"Add a sampled value into the execution trace.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[7]||(e[7]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L42-L46",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",p,[t("summary",null,[e[10]||(e[10]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addSubtrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.addSubtrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addSubtrace")],-1)),e[11]||(e[11]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[13]||(e[13]=t("p",null,[t("code",null,"addSubtrace")],-1)),e[14]||(e[14]=t("p",null,"Insert a subtrace into a parent trace.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[12]||(e[12]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L68-L72",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[15]||(e[15]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addTo-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.addTo-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addTo")],-1)),e[16]||(e[16]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[18]||(e[18]=t("p",null,[t("code",null,"addTo")],-1)),e[19]||(e[19]=t("p",null,"TODO",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[17]||(e[17]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L94-L98",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b,[t("summary",null,[e[20]||(e[20]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addWeightToTrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.addWeightToTrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addWeightToTrace")],-1)),e[21]||(e[21]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[23]||(e[23]=t("p",null,[t("code",null,"addWeightToTrace")],-1)),e[24]||(e[24]=t("p",null,"Add the aggregated log-probability weight to the execution trace.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[22]||(e[22]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L118-L122",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y,[t("summary",null,[e[25]||(e[25]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.broadcast-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.broadcast-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.broadcast")],-1)),e[26]||(e[26]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[28]||(e[28]=t("p",null,[t("code",null,"broadcast")],-1)),e[29]||(e[29]=t("p",null,[n("Broadcast the operand by adding extra dimensions with sizes provided by the "),t("code",null,"shape"),n(" attribute to the front. For scalar operands, ranked tensor is created.")],-1)),e[30]||(e[30]=t("p",null,[n("NOTE: Only works for scalar and "),t("em",null,"ranked"),n(" tensor operands for now.")],-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[27]||(e[27]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L235-L242",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I,[t("summary",null,[e[31]||(e[31]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.cholesky_solve-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.cholesky_solve-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.cholesky_solve")],-1)),e[32]||(e[32]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[34]||(e[34]=t("p",null,[t("code",null,"cholesky_solve")],-1)),e[35]||(e[35]=t("p",null,"Solves the linear system Ax = b for x using Cholesky decomposition. Assuming A is symmetric positive definite!",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[33]||(e[33]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L262-L267",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",M,[t("summary",null,[e[36]||(e[36]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.concat-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.concat-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.concat")],-1)),e[37]||(e[37]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[39]||(e[39]=t("p",null,[t("code",null,"concat")],-1)),e[40]||(e[40]=t("p",null,"Concat list of input arguments into a generic value",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[38]||(e[38]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L287-L291",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",L,[t("summary",null,[e[41]||(e[41]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.dot-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.dot-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.dot")],-1)),e[42]||(e[42]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[44]||(e[44]=t("p",null,[t("code",null,"dot")],-1)),e[45]||(e[45]=t("p",null,"Computes the dot product of two 1D tensors (vectors).",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[43]||(e[43]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L311-L315",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[46]||(e[46]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.dump-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.dump-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.dump")],-1)),e[47]||(e[47]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[49]||(e[49]=t("p",null,[t("code",null,"dump")],-1)),e[50]||(e[50]=t("p",null,"Debug operation that dumps a tensor value with a label.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[48]||(e[48]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L335-L339",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",j,[t("summary",null,[e[51]||(e[51]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.extract-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.extract-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.extract")],-1)),e[52]||(e[52]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[54]||(e[54]=t("p",null,[t("code",null,"extract")],-1)),e[55]||(e[55]=t("p",null,"Extract value from batched operand at index",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[53]||(e[53]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L359-L363",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",z,[t("summary",null,[e[56]||(e[56]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.generate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.generate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.generate")],-1)),e[57]||(e[57]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[59]||(e[59]=o("",2)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[58]||(e[58]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L417-L426",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",D,[t("summary",null,[e[60]||(e[60]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getFlattenedSamplesFromTrace-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getFlattenedSamplesFromTrace-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getFlattenedSamplesFromTrace")],-1)),e[61]||(e[61]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[63]||(e[63]=t("p",null,[t("code",null,"getFlattenedSamplesFromTrace")],-1)),e[64]||(e[64]=t("p",null,"Get sampled values for multiple addresses from an execution trace and flatten them into a single position vector for HMC.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[62]||(e[62]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L496-L501",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",T,[t("summary",null,[e[65]||(e[65]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getSampleFromConstraint-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getSampleFromConstraint-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getSampleFromConstraint")],-1)),e[66]||(e[66]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[68]||(e[68]=t("p",null,[t("code",null,"getSampleFromConstraint")],-1)),e[69]||(e[69]=t("p",null,"Get sampled values from a constraint for a given symbol.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[67]||(e[67]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L542-L546",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",V,[t("summary",null,[e[70]||(e[70]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getSampleFromTrace-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getSampleFromTrace-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getSampleFromTrace")],-1)),e[71]||(e[71]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[73]||(e[73]=t("p",null,[t("code",null,"getSampleFromTrace")],-1)),e[74]||(e[74]=t("p",null,"Get the sampled value for a given symbol from an execution trace.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[72]||(e[72]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L568-L572",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",k,[t("summary",null,[e[75]||(e[75]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getSubconstraint-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getSubconstraint-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getSubconstraint")],-1)),e[76]||(e[76]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[78]||(e[78]=t("p",null,[t("code",null,"getSubconstraint")],-1)),e[79]||(e[79]=t("p",null,"Get a subconstraint from a constraint for a given symbol.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[77]||(e[77]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L594-L598",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",x,[t("summary",null,[e[80]||(e[80]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getSubtrace-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getSubtrace-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getSubtrace")],-1)),e[81]||(e[81]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[83]||(e[83]=t("p",null,[t("code",null,"getSubtrace")],-1)),e[84]||(e[84]=t("p",null,"Get a subtrace from a trace for a given symbol.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[82]||(e[82]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L620-L624",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",E,[t("summary",null,[e[85]||(e[85]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getWeightFromTrace-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getWeightFromTrace-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getWeightFromTrace")],-1)),e[86]||(e[86]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[88]||(e[88]=t("p",null,[t("code",null,"getWeightFromTrace")],-1)),e[89]||(e[89]=t("p",null,"Get the accumulated log-probability weight from an execution trace.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[87]||(e[87]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L644-L648",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",v,[t("summary",null,[e[90]||(e[90]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.initTrace-Tuple{}",href:"#Reactant.MLIR.Dialects.enzyme.initTrace-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.initTrace")],-1)),e[91]||(e[91]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[93]||(e[93]=t("p",null,[t("code",null,"initTrace")],-1)),e[94]||(e[94]=t("p",null,"Initialize an execution trace for a probabilistic function.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[92]||(e[92]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L706-L710",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",h,[t("summary",null,[e[95]||(e[95]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.loop-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.loop-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.loop")],-1)),e[96]||(e[96]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[98]||(e[98]=t("p",null,[t("code",null,"loop")],-1)),e[99]||(e[99]=t("p",null,[n("A counted loop operation that iterates from "),t("code",null,"lowerBound"),n(" to "),t("code",null,"upperBound"),n(" by "),t("code",null,"step"),n(", carrying "),t("code",null,"iter_args"),n(" through each iteration. The iteration variable and iter_args are passed to the body region.")],-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[97]||(e[97]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L749-L755",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",A,[t("summary",null,[e[100]||(e[100]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.mcmc",href:"#Reactant.MLIR.Dialects.enzyme.mcmc"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.mcmc")],-1)),e[101]||(e[101]=n()),l(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[103]||(e[103]=o("",4)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[102]||(e[102]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L783-L797",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",S,[t("summary",null,[e[104]||(e[104]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.mh-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.mh-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.mh")],-1)),e[105]||(e[105]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[107]||(e[107]=t("p",null,[t("code",null,"mh")],-1)),e[108]||(e[108]=t("p",null,"Perform a Metropolis-Hastings step on a probabilistic function. This operation proposes a new trace by regenerating selected addresses, computes the acceptance probability, and returns the updated trace. By convention, the 0th operand in inputs is the initial RNG state and the 0th operand in results is the updated RNG state.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[106]||(e[106]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L852-L860",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",O,[t("summary",null,[e[109]||(e[109]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.random-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.random-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.random")],-1)),e[110]||(e[110]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[112]||(e[112]=t("p",null,[t("code",null,"random")],-1)),e[113]||(e[113]=t("p",null,"Generates random numbers using the rng_distribution algorithm and produces a result tensor.",-1)),e[114]||(e[114]=t("p",null,"If rng_distribution = UNIFORM, then the random numbers are generated following the uniform distribution over the interval [a, b). If a >= b, the behavior is undefined.",-1)),e[115]||(e[115]=t("p",null,"If rng_distribution = NORMAL, then the random numbers are generated following the normal distribution with mean = a and standard deviation = b. If b < 0, the behavior is undefined.",-1)),e[116]||(e[116]=t("p",null,"If rng_distribution = MULTINORMAL, then the random numbers are generated following the multivariate normal distribution with mean = a (scalar or vector) and covariance matrix = b. The parameter b should be a positive definite matrix.",-1)),e[117]||(e[117]=t("p",null,"By convention, the 0th operand in inputs is the initial RNG state and the 0th operand in results is the updated RNG state.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[111]||(e[111]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L950-L970",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",w,[t("summary",null,[e[118]||(e[118]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.regenerate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.regenerate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.regenerate")],-1)),e[119]||(e[119]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[121]||(e[121]=t("p",null,[t("code",null,"regenerate")],-1)),e[122]||(e[122]=t("p",null,"Regenerate selected addresses in a probabilistic function while keeping other addresses fixed to their values in the given trace. By convention, the 0th operand in inputs is the initial RNG state and the 0th operand in results is the updated RNG state.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[120]||(e[120]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L998-L1005",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",N,[t("summary",null,[e[123]||(e[123]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.sample-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.sample-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.sample")],-1)),e[124]||(e[124]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[126]||(e[126]=t("p",null,[t("code",null,"sample")],-1)),e[127]||(e[127]=t("p",null,[n("Sample from a distribution. By convention, the 0th operand in "),t("code",null,"inputs"),n(" or "),t("code",null,"outputs"),n(" is the initial RNG state (seed).")],-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[125]||(e[125]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L1038-L1043",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",C,[t("summary",null,[e[128]||(e[128]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.selectTrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.selectTrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.selectTrace")],-1)),e[129]||(e[129]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[131]||(e[131]=t("p",null,[t("code",null,"selectTrace")],-1)),e[132]||(e[132]=t("p",null,"Selects between two !enzyme.Trace values (considered scalars here) based on a tensor<i1> condition.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[130]||(e[130]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L1074-L1078",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",F,[t("summary",null,[e[133]||(e[133]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.simulate-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.simulate-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.simulate")],-1)),e[134]||(e[134]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[136]||(e[136]=t("p",null,[t("code",null,"simulate")],-1)),e[137]||(e[137]=t("p",null,[n("Simulate a probabilistic function to generate execution trace by replacing all SampleOps with distribution calls and recording all sampled values into the trace. This op returns the trace, the weight (accumulated log-probability), and the other outputs. By convention, the 0th operand in "),t("code",null,"inputs"),n(" or "),t("code",null,"outputs"),n(" is the initial RNG state (seed).")],-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[135]||(e[135]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L1123-L1131",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",G,[t("summary",null,[e[138]||(e[138]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.unflatten_slice-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.unflatten_slice-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.unflatten_slice")],-1)),e[139]||(e[139]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[141]||(e[141]=t("p",null,[t("code",null,"unflatten_slice")],-1)),e[142]||(e[142]=t("p",null,"Extract a slice from a 1D position vector starting at the given offset, and reconstruct the original multi-dimensional tensor shape (implied by the type).",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[140]||(e[140]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L1179-L1184",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",B,[t("summary",null,[e[143]||(e[143]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.untracedCall-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.untracedCall-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.untracedCall")],-1)),e[144]||(e[144]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[146]||(e[146]=t("p",null,[t("code",null,"untracedCall")],-1)),e[147]||(e[147]=t("p",null,[n("Call a probabilistic function without tracing. By convention, the 0th operand in "),t("code",null,"inputs"),n(" or "),t("code",null,"outputs"),n(" is the initial RNG state (seed).")],-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[145]||(e[145]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L1204-L1209",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",P,[t("summary",null,[e[148]||(e[148]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.update-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.update-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.update")],-1)),e[149]||(e[149]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[151]||(e[151]=t("p",null,[t("code",null,"update")],-1)),e[152]||(e[152]=t("p",null,"Update selected addresses in a trace with new values from a position vector, re-evaluate the probabilistic function, and return the updated trace with the new weight (log probability) and updated RNG state. By convention, the 0th operand in inputs is the initial RNG state.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[150]||(e[150]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/92dffd55da0f2e1ee5c5a1e25ad64411b2e18fa5/src/mlir/Dialects/Enzyme.jl#L1232-L1239",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const X=r(R,[["render",W]]);export{Q as __pageData,X as default};
