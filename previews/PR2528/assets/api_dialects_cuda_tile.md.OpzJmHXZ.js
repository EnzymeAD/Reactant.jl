import{_ as s,C as d,o as r,c,j as t,a as o,E as a,w as l,al as n}from"./chunks/framework.EjdC9AR9.js";const it=JSON.parse('{"title":"CUDA Tile IR Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/cuda_tile.md","filePath":"api/dialects/cuda_tile.md","lastUpdated":null}'),u={name:"api/dialects/cuda_tile.md"},p={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},_={class:"jldocstring custom-block"},M={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},D={class:"jldocstring custom-block"},x={class:"jldocstring custom-block"},w={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"},v={class:"jldocstring custom-block"},A={class:"jldocstring custom-block"},V={class:"jldocstring custom-block"},C={class:"jldocstring custom-block"},S={class:"jldocstring custom-block"},E={class:"jldocstring custom-block"},z={class:"jldocstring custom-block"},N={class:"jldocstring custom-block"},P={class:"jldocstring custom-block"},U={class:"jldocstring custom-block"},O={class:"jldocstring custom-block"},q={class:"jldocstring custom-block"},F={class:"jldocstring custom-block"},B={class:"jldocstring custom-block"},K={class:"jldocstring custom-block"},$={class:"jldocstring custom-block"},X={class:"jldocstring custom-block"},W={class:"jldocstring custom-block"},Z={class:"jldocstring custom-block"},Y={class:"jldocstring custom-block"},G={class:"jldocstring custom-block"},H={class:"jldocstring custom-block"},J={class:"jldocstring custom-block"},Q={class:"jldocstring custom-block"},ee={class:"jldocstring custom-block"},te={class:"jldocstring custom-block"},oe={class:"jldocstring custom-block"},ie={class:"jldocstring custom-block"},ae={class:"jldocstring custom-block"},le={class:"jldocstring custom-block"},ne={class:"jldocstring custom-block"},se={class:"jldocstring custom-block"},de={class:"jldocstring custom-block"},re={class:"jldocstring custom-block"},ce={class:"jldocstring custom-block"},ue={class:"jldocstring custom-block"},pe={class:"jldocstring custom-block"},fe={class:"jldocstring custom-block"},me={class:"jldocstring custom-block"},Re={class:"jldocstring custom-block"},be={class:"jldocstring custom-block"},he={class:"jldocstring custom-block"},ge={class:"jldocstring custom-block"},Te={class:"jldocstring custom-block"},Ie={class:"jldocstring custom-block"},ye={class:"jldocstring custom-block"},_e={class:"jldocstring custom-block"},Me={class:"jldocstring custom-block"},Le={class:"jldocstring custom-block"},je={class:"jldocstring custom-block"},De={class:"jldocstring custom-block"},xe={class:"jldocstring custom-block"},we={class:"jldocstring custom-block"},ke={class:"jldocstring custom-block"},ve={class:"jldocstring custom-block"},Ae={class:"jldocstring custom-block"},Ve={class:"jldocstring custom-block"},Ce={class:"jldocstring custom-block"},Se={class:"jldocstring custom-block"},Ee={class:"jldocstring custom-block"},ze={class:"jldocstring custom-block"},Ne={class:"jldocstring custom-block"},Pe={class:"jldocstring custom-block"},Ue={class:"jldocstring custom-block"},Oe={class:"jldocstring custom-block"},qe={class:"jldocstring custom-block"},Fe={class:"jldocstring custom-block"},Be={class:"jldocstring custom-block"},Ke={class:"jldocstring custom-block"},$e={class:"jldocstring custom-block"},Xe={class:"jldocstring custom-block"},We={class:"jldocstring custom-block"},Ze={class:"jldocstring custom-block"},Ye={class:"jldocstring custom-block"};function Ge(He,e,Je,Qe,et,tt){const i=d("Badge");return r(),c("div",null,[e[471]||(e[471]=t("h1",{id:"CUDA-Tile-IR-Dialect",tabindex:"-1"},[o("CUDA Tile IR Dialect "),t("a",{class:"header-anchor",href:"#CUDA-Tile-IR-Dialect","aria-label":'Permalink to "CUDA Tile IR Dialect {#CUDA-Tile-IR-Dialect}"'},"â€‹")],-1)),e[472]||(e[472]=t("p",null,[o("Refer to the "),t("a",{href:"https://docs.nvidia.com/cuda/tile-ir/latest/",target:"_blank",rel:"noreferrer"},"official documentation"),o(" for more details.")],-1)),t("details",p,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.absf-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.absf-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.absf")],-1)),e[1]||(e[1]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=t("p",null,[t("code",null,"absf")],-1)),e[4]||(e[4]=t("p",null,[o("The :code:"),t("code",null,"absf"),o(" operation computes the element-wise absolute value of the input float tile.")],-1)),e[5]||(e[5]=t("p",null,".. math:: \\text{absf}(x)_i = |x|_i",-1)),e[6]||(e[6]=t("p",null,[o(":suffix: Element-wise floating-point arithmetic operations are performed by the target architecture's native floating-point instructions. If the :code:"),t("code",null,"rounding"),o(" modifier is specified, the particular rounding mode will be applied to each element of the result. See :ref:"),t("code",null,"op-group-floating-point"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L16-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[7]||(e[7]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.absi-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.absi-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.absi")],-1)),e[8]||(e[8]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[10]||(e[10]=t("p",null,[t("code",null,"absi")],-1)),e[11]||(e[11]=t("p",null,[o("The :code:"),t("code",null,"absi"),o(" operation computes the absolute value of the input integer tile.")],-1)),e[12]||(e[12]=t("p",null,"The input tile is always interpreted as a signed integer. The output tile is always interpreted as an unsigned integer.",-1)),e[13]||(e[13]=t("p",null,".. math:: \\text{absi}(x) = |x|",-1)),e[14]||(e[14]=t("p",null,[o(":suffix: Element-wise integer arithmetic operations are performed by the target architecture's native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:"),t("code",null,"op-group-integer"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[9]||(e[9]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L46-L58",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",m,[t("summary",null,[e[15]||(e[15]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.addf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.addf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.addf")],-1)),e[16]||(e[16]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[18]||(e[18]=n("<p><code>addf</code></p><p>The :code:<code>addf</code> operation computes the element-wise addition of two tiles with floating-point element type.</p><p>.. math:: \\text{addf}(x, y)_i = x_i + y_i</p><p>The addition of individual elements is performed by the target architecture&#39;s native floating-point addition for the given element type unless otherwise specified.</p><p>:suffix: Element-wise floating-point arithmetic operations are performed by the target architecture&#39;s native floating-point instructions. If the :code:<code>rounding</code> modifier is specified, the particular rounding mode will be applied to each element of the result. See :ref:<code>op-group-floating-point</code> for more details.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[17]||(e[17]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L79-L91",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",R,[t("summary",null,[e[19]||(e[19]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.addi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.addi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.addi")],-1)),e[20]||(e[20]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[22]||(e[22]=t("p",null,[t("code",null,"addi")],-1)),e[23]||(e[23]=t("p",null,[o("The :code:"),t("code",null,"addi"),o(" operation computes the element-wise addition of two tiles with integer element types.")],-1)),e[24]||(e[24]=t("p",null,".. math:: \\text{addi}(x, y)_i = x_i + y_i",-1)),e[25]||(e[25]=t("p",null,[o(":suffix: Element-wise integer arithmetic operations are performed by the target architecture's native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:"),t("code",null,"op-group-integer"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[21]||(e[21]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L121-L130",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b,[t("summary",null,[e[26]||(e[26]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.andi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.andi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.andi")],-1)),e[27]||(e[27]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[29]||(e[29]=t("p",null,[t("code",null,"andi")],-1)),e[30]||(e[30]=t("p",null,[o("The :code:"),t("code",null,"andi"),o(' operation produces a value that is the result of an element-wise, bitwise "and" of two tiles with integer element type.')],-1)),e[31]||(e[31]=t("p",null,[o(":suffix: Element-wise integer arithmetic operations are performed by the target architecture's native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:"),t("code",null,"op-group-integer"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[28]||(e[28]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L158-L166",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",h,[t("summary",null,[e[32]||(e[32]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.assert-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.assert-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.assert")],-1)),e[33]||(e[33]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[35]||(e[35]=n("<p><code>assert</code></p><p>The :code:<code>assert</code> operation takes as :code:<code>condition</code> a tile of :code:<code>i1</code> values. For each value that is :code:<code>0</code>, it prints the given error message, along with the index of the value within the tile.</p><p>If at least one value is :code:<code>0</code>, an error is signalled to the host side. The kernel, including the tile block that failed the assertion, may keep running.</p><p>Assertions are for debugging purposes. They can affect performance and it is therefore recommended to remove them in production code.</p>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[34]||(e[34]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L189-L202",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[36]||(e[36]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.assume-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.assume-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.assume")],-1)),e[37]||(e[37]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[39]||(e[39]=n("<p><code>assume</code></p><p>The :code:<code>assume</code> operation passes through :code<code>value</code> as the result and attaches a predicate to it. The assumed predicate is a property of :code:<code>result</code>.</p><p>This operation can be used to inject static information into the compiler, potentially resulting in more efficient code generation.</p><p>:code:<code>predicate</code> must implement the :code:<code>AssumePredicateAttrInterface</code>.</p><p>.. note::</p><p>:code:<code>assume</code> does not check the correctness of the predicate. Incorrect predicates may inject incorrect static information and cause miscompilation. If an incorrect predicate is attached to an SSA value, the behavior of the program is undefined.</p>",6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[38]||(e[38]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L222-L240",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",T,[t("summary",null,[e[40]||(e[40]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.atomic_cas_tko",href:"#Reactant.MLIR.Dialects.cuda_tile.atomic_cas_tko"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.atomic_cas_tko")],-1)),e[41]||(e[41]=o()),a(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[43]||(e[43]=n(`<p><code>atomic_cas_tko</code></p><p>The :code:<code>atomic_cas</code> operation performs element-wise, atomic compare-and-swaps at the specified global memory :code:<code>pointers</code>. The data in memory is compared to :code:<code>cmp</code> and the data written to memory is specified by :code:<code>val</code>. The operation returns the original value that was stored in memory before the atomic operation was performed.</p><p>The shape (and the element type) of :code:<code>pointers</code>, :code:<code>cmp</code>, :code:<code>val</code> and :code:<code>result</code> must match. The :code:<code>atomic_cas</code> operation performs the following steps for every :code:<code>(pointer, cmp, val)</code> tuple in one atomic transaction. (One atomic transaction per tuple.)</p><p>.. code-block:: mlir</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>atomic() {</span></span>
<span class="line"><span>  x = *pointer</span></span>
<span class="line"><span>  if x == cmp {</span></span>
<span class="line"><span>  *pointer = val</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>return x</span></span></code></pre></div><p>}</p><p>An optional parameter, :code:<code>mask</code>, allows specifying which elements participate in the atomic operation. A false value at position i masks out the corresponding element in :code:<code>pointers</code>, excluding it from the operation. The returned value for a masked element at position i is :code:<code>cmp[i]</code>. If no mask is provided, all elements are included in the computation by default. The shape of mask must match that of pointers, cmp, and val.</p><p>A token-ordered atomic compare-and-swap is not constrained by program order. The compiler may reorder it (i.e. place them earlier or later in program order) unless constrained by tokens.</p><p>Supported data types:</p><ul><li><p>i32, i64: integer values</p></li><li><p>f32, f64: floating-point values</p></li></ul><p>For floating-point types, the comparison uses bitwise equality rather than IEEE-754 semantics. This means different :code:<code>NaN</code> bit patterns are treated as distinct values, and :code:<code>+0.0</code> and :code:<code>-0.0</code> are considered different if their bit representations differ.</p>`,11)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[42]||(e[42]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L263-L306",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I,[t("summary",null,[e[44]||(e[44]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.atomic_rmw_tko",href:"#Reactant.MLIR.Dialects.cuda_tile.atomic_rmw_tko"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.atomic_rmw_tko")],-1)),e[45]||(e[45]=o()),a(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[47]||(e[47]=n("<p><code>atomic_rmw_tko</code></p><p>The :code:<code>atomic_rmw_tko</code> operation performs element-wise, atomic read-modify-write operations at the global memory locations specified by :code:<code>pointers</code>. The values written to memory are determined by :code:<code>mode</code> and :code:<code>arg</code>. The operation returns the original value stored at each location before the atomic update.</p><p>The shapes of :code:<code>pointers</code>, :code:<code>arg</code>, and :code:<code>result</code> must match. The element type of the pointer type must match the element types of both :code:<code>arg</code> and :code:<code>result</code>. Each (pointer, arg) pair is processed in a single atomic transaction.</p><p>.. code-block:: mlir</p>",4)),e[48]||(e[48]=t("p",{x:""},"atomic",-1)),e[49]||(e[49]=n("<p>An optional parameter, :code:<code>mask</code>, specifies which elements participate in the atomic operation. A <code>False</code> value at position :code:<code>i</code> excludes the corresponding element in :code:<code>pointers</code> from the operation. The value returned for a masked-out element is implementation-defined. The shape of :code:<code>mask</code> must match the shape of :code:<code>pointers</code>.</p><p>The :code:<code>atomic_addf</code> operation is defined to round to the nearest even value. .. note:: The current implementation of the compiler flushes denormals to zero. This behavior will be fixed in a future version of the compiler and users should not rely on it.</p><p>Token-ordered atomic read-modify-write operations are not constrained by program order. The compiler may reorder them (i.e., move them earlier or later in the program) unless further constrained by tokens.</p><p>Supported data types by :code:<code>mode</code>:</p><ul><li><p>ADD, AND, MAX, MIN, OR, UMAX, UMIN, XOR: i32, i64</p></li><li><p>ADDF: f16, f32, f64</p></li><li><p>XCHF: i32, i64, f32, f64</p></li></ul><p>The :code:<code>U</code> prefix in UMAX and UMIN distinguishes these from their signed counterparts (MAX and MIN) by interpreting the comparison as unsigned.</p>",6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[46]||(e[46]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L348-L395",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y,[t("summary",null,[e[50]||(e[50]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.bitcast-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.bitcast-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.bitcast")],-1)),e[51]||(e[51]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[53]||(e[53]=n("<p><code>bitcast</code></p><p>The :code:<code>bitcast</code> operation casts the input tile from one element type to another without modifying the underlying bits.</p><p>Only non-pointer types of the same bit width are allowed (e.g., :code:<code>i32</code> to :code:<code>f32</code>). Pointer types must use :ref:<code>op-cuda_tile.ptr_to_int</code> or :ref:<code>op-cuda_tile.int_to_ptr</code> instead.</p>",3)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[52]||(e[52]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L438-L446",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_,[t("summary",null,[e[54]||(e[54]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.break_-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.cuda_tile.break_-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.break_")],-1)),e[55]||(e[55]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[57]||(e[57]=n("<p><code>break_</code></p><p>The :code:<code>break</code> operation is a terminator operation of a :ref:<code>op-cuda_tile.loop</code>.</p><p>It may yield any number of :code:<code>$operands</code> to the parent loop upon termination. The number of values yielded and the execution semantics of how they are yielded are determined by the parent loop.</p><p>The :code:<code>break</code> operation always returns control to the innermost enclosing loop operation, even when it is nested within other control constructs such as :code:<code>if</code> or additional loops.</p>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[56]||(e[56]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L466-L476",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",M,[t("summary",null,[e[58]||(e[58]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.broadcast-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.broadcast-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.broadcast")],-1)),e[59]||(e[59]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[61]||(e[61]=t("p",null,[t("code",null,"broadcast")],-1)),e[62]||(e[62]=t("p",null,[o("The :code:"),t("code",null,"broadcast"),o(" operation expands each unary (:code:"),t("code",null,"1"),o(") dimension in the input tile by duplicating the data along that dimension.")],-1)),e[63]||(e[63]=t("p",null,'Expansion happens only for dimensions of size one that are stretched or "copied" to match the size of the dimension implied by the result type of the operation. The operation does not change the rank of the source tile. Any change to the rank of the source tile must be made using reshape-like operations before broadcasting.',-1)),e[64]||(e[64]=t("p",null,".. .. math:: .. broadcast(x, idim_n, odim_n) = x",-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[60]||(e[60]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L496-L509",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",L,[t("summary",null,[e[65]||(e[65]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.cat-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.cat-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.cat")],-1)),e[66]||(e[66]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[68]||(e[68]=t("p",null,[t("code",null,"cat")],-1)),e[69]||(e[69]=t("p",null,[o("The :code:"),t("code",null,"cat"),o(" operation concatenates the two input tiles. The input tiles must have the same shape in all but the concatenating dimension. Concatenation happens along the dimension specified by the the attribute :code:"),t("code",null,"dim"),o(" the resulting dimension is the sum of the the two input tiles concatenating dimension.")],-1)),e[70]||(e[70]=t("p",null,".. math::",-1)),e[71]||(e[71]=t("p",{cases:""},[o("\\text{cat}(x, y, dim_{cat})[ \\vec{i} ] = \\begin{cases} x[..., i_{cat}, ..., i_n] & \\text{if } i_{cat} < d_{cat} "),t("br"),o(" y[..., i_{cat} - d_{cat}, ..., i_n] & \\text{if } i_{cat} \\geq d_{cat} \\end")],-1)),e[72]||(e[72]=t("p",null,".. \\text{where } X \\text{ has type tile}<d_0 \\times d_1 \\times \\cdots \\times d_n> .. \\text{ and } Y \\text{ has type tile}<d_0 \\times d_1 \\times \\cdots \\times d_n>",-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[67]||(e[67]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L529-L547",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",j,[t("summary",null,[e[73]||(e[73]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.ceil-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.ceil-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.ceil")],-1)),e[74]||(e[74]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[76]||(e[76]=t("p",null,[t("code",null,"ceil")],-1)),e[77]||(e[77]=t("p",null,[o("The :code:"),t("code",null,"ceil"),o(" operation computes the element-wise ceiling on the input floating-point tile. The ceiling operation rounds each element up to the largest integer value that is greater than or equal to the input value.")],-1)),e[78]||(e[78]=t("p",null,".. math::",-1)),e[79]||(e[79]=t("p",null,"\\text{ceil}(x)_i = \\min{n \\in \\mathbb{Z} \\mid n \\geq x_i}",-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[75]||(e[75]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L567-L578",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",D,[t("summary",null,[e[80]||(e[80]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.cmpf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.cmpf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.cmpf")],-1)),e[81]||(e[81]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[83]||(e[83]=t("p",null,[t("code",null,"cmpf")],-1)),e[84]||(e[84]=t("p",null,[o("The :code:"),t("code",null,"cmpf"),o(" operation is a generic comparison for float-like types. The operands must have the same shape and type, and this type must be a float type.")],-1)),e[85]||(e[85]=t("p",null,[o("The result is :code:"),t("code",null,"1"),o(" if the comparison is true and :code:"),t("code",null,"0"),o(" otherwise. The comparison is performed element-wise and the element of the result indicates whether the comparison is true for the operand elements with the same indices as those of the result.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[82]||(e[82]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L599-L609",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",x,[t("summary",null,[e[86]||(e[86]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.cmpi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.cmpi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.cmpi")],-1)),e[87]||(e[87]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[89]||(e[89]=t("p",null,[t("code",null,"cmpi")],-1)),e[90]||(e[90]=t("p",null,[o("The :code:"),t("code",null,"cmpi"),o(" operation is a generic comparison for integer-like types. The operands must have the same shape and type, and this type must be an integer type. The result type has i1 element type and the same shape as the operands.")],-1)),e[91]||(e[91]=t("p",null,[o("The result is :code:"),t("code",null,"1"),o(" if the comparison is true and :code:"),t("code",null,"0"),o(" otherwise. The comparison is performed element-wise and the element of the result indicates whether the comparison is true for the operand elements with the same indices as those of the result.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[88]||(e[88]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L640-L651",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",w,[t("summary",null,[e[92]||(e[92]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.constant-Tuple{}",href:"#Reactant.MLIR.Dialects.cuda_tile.constant-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.constant")],-1)),e[93]||(e[93]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[95]||(e[95]=n("<p><code>constant</code></p><p>The :code:<code>constant</code> operation creates a tile initialized by :code:<code>$value</code>.</p><p>There are two main forms of using the operation:</p><ul><li><p>One where the value is a single constant specified by :code:<code>dense&lt;c&gt;</code> and the tile is filled with identical values for all elements.</p></li><li><p>One where the value is a list of constants specified by :code:<code>dense&lt;[c0, c1, c2, ...]&gt;</code> and the constant value&#39;s shape must match the tile&#39;s shape.</p></li></ul><p>The annotated type of the tile constrains its rank, shape, and element type.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[94]||(e[94]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L682-L696",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",k,[t("summary",null,[e[96]||(e[96]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.continue_-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.cuda_tile.continue_-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.continue_")],-1)),e[97]||(e[97]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[99]||(e[99]=n("<p><code>continue_</code></p><p>The :code:<code>continue</code> operation represents a block terminator that returns control to a loop operation, such as :ref:<code>op-cuda_tile.for</code> and :ref:<code>op-cuda_tile.loop</code>. The operation may yield any number of :code:<code>$operands</code> to the parent loop upon termination.</p><p>The requirements and semantics of the :code:<code>continue</code> operation are defined by the parent loop operation, see the loop operation&#39;s description for particular semantics.</p><p>The :code:<code>continue</code> operation always returns control to the innermost enclosing loop operation, even when it is nested within other control constructs such as :code:<code>if</code> or additional loops.</p>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[98]||(e[98]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L717-L729",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",v,[t("summary",null,[e[100]||(e[100]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.cos-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.cos-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.cos")],-1)),e[101]||(e[101]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[103]||(e[103]=n("<p><code>cos</code></p><p>The :code:<code>cos</code> operation computes the element-wise cosine of the input floating-point tile.</p><p>.. math::</p><p>\\text{cos}(x)_i = \\cos(x_i)</p><p>:suffix: This operation is emulated in :code:<code>f32</code> when executed on half-precision inputs (:code:<code>f16</code> and :code:<code>bf16</code>). See :ref:<code>op-group-floating-point</code> for more details.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[102]||(e[102]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L782-L793",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",A,[t("summary",null,[e[104]||(e[104]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.cosh-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.cosh-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.cosh")],-1)),e[105]||(e[105]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[107]||(e[107]=n("<p><code>cosh</code></p><p>The :code:<code>cosh</code> operation computes the element-wise hyperbolic cosine of the input tile with floating-point element type.</p><p>.. math::</p><p>\\text{cosh}(x)_i = {\\cosh x}_i</p><p>:suffix: This operation is emulated in :code:<code>f32</code> when executed on half-precision inputs (:code:<code>f16</code> and :code:<code>bf16</code>). See :ref:<code>op-group-floating-point</code> for more details.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[106]||(e[106]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L749-L761",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",V,[t("summary",null,[e[108]||(e[108]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.divf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.divf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.divf")],-1)),e[109]||(e[109]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[111]||(e[111]=n("<p><code>divf</code></p><p>The :code:<code>divf</code> operation computes the element-wise division of two input tiles with floating-point element types.</p><p>The :code:<code>approx</code> rounding mode implements a fast approximation of divide, computed as a multiplication by reciprocal. For :code:<code>|rhs|</code> in normalized range :code:<code>[2^(-126), 2^(126)]</code> the maximum ULP (Unit in the Last Place) error is :code:<code>2</code>. For :code:<code>2^(126) &lt; |rhs| &lt; 2^(128)</code>, if :code:<code>lhs</code> is infinity the operation returns :code:<code>NaN</code>, otherwise :code:<code>0</code>.</p><p>The :code:<code>full</code> rounding mode implements a relatively fast, full-range approximation that scales operands to achieve better accuracy, but is not fully IEEE 754 compliant. The maximum ulp error is 2 across the full range of inputs.</p><p>.. math:: \\text{div(lhs, rhs)}_i = \\text{lhs}_i / \\text{rhs}_i</p><p>:suffix: Element-wise floating-point arithmetic operations are performed by the target architecture&#39;s native floating-point instructions. If the :code:<code>rounding</code> modifier is specified, the particular rounding mode will be applied to each element of the result. See :ref:<code>op-group-floating-point</code> for more details.</p>",6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[110]||(e[110]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L814-L834",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",C,[t("summary",null,[e[112]||(e[112]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.divi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.divi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.divi")],-1)),e[113]||(e[113]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[115]||(e[115]=n("<p><code>divi</code></p><p>The :code:<code>divi</code> operation computes the element-wise division of two tile values with integer element type.</p><p>The default rounding is towards zero. The rounding mode can be set to <code>positive_inf</code> (&quot;ceil div&quot;), or <code>negative_inf</code> (&quot;floor div&quot;), other values are illegal.</p><p>The use of the rounding flag <code>negative_inf</code> with <code>unsigned</code> is not a valid combination.</p><p>If the <code>unsigned</code> flag is provided, the operands are treated as unsigned integers, otherwise they are treated as signed integers.</p><p>The behavior is undefined if the right hand side is zero. A signed division overflow (minimum value divided by -1) is undefined behavior.</p><p>.. math:: \\text{div(lhs, rhs)}_i = \\text{lhs}_i / \\text{rhs}_i</p><p>:suffix: Element-wise integer arithmetic operations are performed by the target architecture&#39;s native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:<code>op-group-integer</code> for more details.</p>",8)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[114]||(e[114]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L864-L884",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",S,[t("summary",null,[e[116]||(e[116]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.entry-Tuple{}",href:"#Reactant.MLIR.Dialects.cuda_tile.entry-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.entry")],-1)),e[117]||(e[117]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[119]||(e[119]=t("p",null,[t("code",null,"entry")],-1)),e[120]||(e[120]=t("p",null,[o("The :code:"),t("code",null,"entry"),o(" operation defines a tile kernel; a kernel is a function that can serve as the program entry point. It has a unique name per-module. A kernel can not return any value. It must be launched from the host side using :code:"),t("code",null,"cuLaunchKernel"),o(" or similar CUDA runtime API functions.")],-1)),e[121]||(e[121]=t("p",null,"Tile kernels require that the user specifies the 3-d grid dimensions at launch which defines the number of tile blocks (or kernel instances) that will execute the kernel in parallel.",-1)),e[122]||(e[122]=t("p",null,[o("For detailed semantics of tile kernels see :ref:"),t("code",null,"sub_sec_tile_kernel"),o(".")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[118]||(e[118]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L913-L926",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",E,[t("summary",null,[e[123]||(e[123]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.exp-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.exp-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.exp")],-1)),e[124]||(e[124]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[126]||(e[126]=t("p",null,[t("code",null,"exp")],-1)),e[127]||(e[127]=t("p",null,[o("The :code:"),t("code",null,"exp"),o(" operation computes the element-wise exponential of the input floating-point tile.")],-1)),e[128]||(e[128]=t("p",null,".. math::",-1)),e[129]||(e[129]=t("p",{x_i:""},"\\text{exp}(x)_i = e^",-1)),e[130]||(e[130]=t("p",null,[o(":suffix: This operation is emulated in :code:"),t("code",null,"f32"),o(" when executed on half-precision inputs (:code:"),t("code",null,"f16"),o(" and :code:"),t("code",null,"bf16"),o("). See :ref:"),t("code",null,"op-group-floating-point"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[125]||(e[125]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L999-L1011",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",z,[t("summary",null,[e[131]||(e[131]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.exp2-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.exp2-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.exp2")],-1)),e[132]||(e[132]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[134]||(e[134]=t("p",null,[t("code",null,"exp2")],-1)),e[135]||(e[135]=t("p",null,[o("The :code:"),t("code",null,"exp2"),o(" operation computes the element-wise power of two of the input floating-point tile.")],-1)),e[136]||(e[136]=t("p",null,".. math::",-1)),e[137]||(e[137]=t("p",{x_i:""},"\\text{exp2}(x)_i = 2^",-1)),e[138]||(e[138]=t("p",null,[o(":suffix: This operation is emulated in :code:"),t("code",null,"f32"),o(" when executed on half-precision inputs (:code:"),t("code",null,"f16"),o(" and :code:"),t("code",null,"bf16"),o("). See :ref:"),t("code",null,"op-group-floating-point"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[133]||(e[133]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L960-L971",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",N,[t("summary",null,[e[139]||(e[139]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.exti-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.exti-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.exti")],-1)),e[140]||(e[140]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[142]||(e[142]=t("p",null,[t("code",null,"exti")],-1)),e[143]||(e[143]=t("p",null,[o("The :code:"),t("code",null,"exti"),o(" operation converts a tile of integers of a given width to a strictly larger width. Zero-extension is used for :code:"),t("code",null,"unsigned"),o(" integers and sign-extension is used for :code:"),t("code",null,"signed"),o(" integers.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[141]||(e[141]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1032-L1039",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",P,[t("summary",null,[e[144]||(e[144]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.extract-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.cuda_tile.extract-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.extract")],-1)),e[145]||(e[145]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[147]||(e[147]=n("<p><code>extract</code></p><p>The :code:<code>extract</code> operation extracts a subtile from the given source tile.</p><p>The shape of the result tile must divide the shape of the source tile evenly e.g., :code:<code>tile&lt;4xf32&gt;</code> is a valid extraction from :code:<code>tile&lt;8xf32&gt;</code>, but :code:<code>tile&lt;3xf32&gt;</code> is not.</p><p>The :code:<code>$indices</code> indicate the number of the slice to extract, but <em>importantly</em> not the offsets used to construct the subtile for extraction. The semantics of extract means that only full size slices can be extracted.</p><p>Slices of a source tile with the same shape are non-overlapping by definition for unique indices.</p><p>.. warning::</p><p>If the :code:<code>indices</code> specify a non-existent (i.e., out-of-bounds) slice, the behavior of the operation is undefined.</p>",7)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[146]||(e[146]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1059-L1079",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",U,[t("summary",null,[e[148]||(e[148]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.floor-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.floor-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.floor")],-1)),e[149]||(e[149]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[151]||(e[151]=t("p",null,[t("code",null,"floor")],-1)),e[152]||(e[152]=t("p",null,[o("The :code:"),t("code",null,"floor"),o(" operation computes the element-wise floor on the input floating-point tile rounding each element down to the largest integer that is less than or equal to the element.")],-1)),e[153]||(e[153]=t("p",null,".. math:: \\text{floor}_i(x_i) = \\max{n \\in \\mathbb{Z} \\mid n \\leq x_i}",-1)),e[154]||(e[154]=t("p",null,[o(":suffix: Element-wise floating-point arithmetic operations are performed by the target architecture's native floating-point instructions. If the :code:"),t("code",null,"rounding"),o(" modifier is specified, the particular rounding mode will be applied to each element of the result. See :ref:"),t("code",null,"op-group-floating-point"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[150]||(e[150]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1168-L1178",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",O,[t("summary",null,[e[155]||(e[155]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.fma-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.fma-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.fma")],-1)),e[156]||(e[156]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[158]||(e[158]=t("p",null,[t("code",null,"fma")],-1)),e[159]||(e[159]=t("p",null,[o("Takes three operands :code:"),t("code",null,"lhs"),o(", :code:"),t("code",null,"rhs"),o(" and :code:"),t("code",null,"acc"),o(", returns :code:"),t("code",null,"result = lhs * rhs + acc"),o(".")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[157]||(e[157]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1199-L1203",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",q,[t("summary",null,[e[160]||(e[160]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.for_-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.cuda_tile.for_-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.for_")],-1)),e[161]||(e[161]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[163]||(e[163]=n("<p><code>for_</code></p><p>The :code:<code>for</code> operation is a structured range-based sequential loop.</p><p>The loop operation consists of (1) a range formed by :code:<code>lowerBound</code>, :code:<code>upperBound</code>, and :code:<code>step</code>, (2) a set of loop-carried values which are initialized by :code:<code>initValues</code> and updated by each iteration of the loop, and (3) a region which represents the loop body.</p><p>The iteration space is defined by the interval :math:<code>[lowerBound, upperBound)</code> with each value seperated by :code:<code>step</code>.</p><p>.. math::</p><p>range(L_b, U_b, S) = { L_b + i \\cdot S \\mid i \\in \\mathbb{Z}, L_b + i \\cdot S &lt; U_b }</p><p>:code:<code>lowerBound</code>, :code:<code>upperBound</code>, and :code:<code>step</code> must be of the same type. :code:<code>lowerBound</code> and :code:<code>upperBound</code> specify a half-open (or exclusive) range: the range includes the :code:<code>lowerBound</code> but does not include the :code:<code>upperBound</code>. :code:<code>step</code> must be positive but the bounds may be negative or zero.</p><p>The first iteration of the loop receives the induction variable initialized to the value of :code:<code>lowerBound</code> and the loop-carried values initialized to the values of :code:<code>initValues</code>.</p><p>The loop body is executed for each value in the range, receiving an integer induction variable incremented by :code:<code>step</code> on each iteration and the loop-carried values which correspond to the loop-carried values yielded by the previous loop iteration.</p><p>The loop terminates when the induction variable is greater than or equal to :code:<code>upperBound</code>. By default, signed comparison is used between the upperBound and the induction variable. To use unsigned comparison instead, specify the optional :code:<code>unsigned</code> unit attribute.</p><p>The body of the loop must be terminated by a :ref:<code>op-cuda_tile.continue</code> that yields the next iteration&#39;s value for each loop carried variable.</p><p>The for operation produces one return value for each loop carried variable. The type of the :math:<code>i</code>-th return value is that of the :math:<code>i</code>-th loop carried variable and its value is the final value of the :math:<code>i</code>-th loop carried variable.</p><p>.. warning::</p><ul><li><p>Loop carried variables can not be a :tileirty:<code>tensor_view</code> or view type.</p></li><li><p>:code:<code>for</code> operations cannot terminate early and must end in a :ref:<code>op-cuda_tile.continue</code>.</p></li></ul>",14)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[162]||(e[162]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1234-L1278",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",F,[t("summary",null,[e[164]||(e[164]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.ftof-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.ftof-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.ftof")],-1)),e[165]||(e[165]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[167]||(e[167]=t("p",null,[t("code",null,"ftof")],-1)),e[168]||(e[168]=t("p",null,[o("The :code:"),t("code",null,"ftof"),o(" operation converts a tile of a given floating-point element type into one of a different floating-point element type (for example, from :code:"),t("code",null,"f32"),o(" to :code:"),t("code",null,"f64"),o(").")],-1)),e[169]||(e[169]=t("p",null,"The source type and the result type must be different.",-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[166]||(e[166]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1101-L1108",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",B,[t("summary",null,[e[170]||(e[170]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.ftoi-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.ftoi-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.ftoi")],-1)),e[171]||(e[171]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[173]||(e[173]=n("<p><code>ftoi</code></p><p>The :code:<code>ftoi</code> operation converts a floating-point tile into an integer tile.</p><p>In contrast to a :code:<code>bitcast</code> which is bits preserving, this preserves the numerical value of the tile, rounded towards zero to the nearest integer of the provided type.</p><p>.. warning::</p><p>If the input floating-point value, after being rounded, is outside the (signed or unsigned) range of the target integer type, the closest representable value is used instead. :code:<code>NaN</code> values are converted to 0. Input :code:<code>Inf</code> values are undefined behavior.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[172]||(e[172]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1130-L1145",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",K,[t("summary",null,[e[174]||(e[174]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.get_global-Tuple{}",href:"#Reactant.MLIR.Dialects.cuda_tile.get_global-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.get_global")],-1)),e[175]||(e[175]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[177]||(e[177]=n("<p><code>get_global</code></p><p>The :code:<code>get_global</code> operation returns a pointer to the specified :code:<code>global</code> variable. A global variable is a form of static global memory allocation that can be declared using the :ref:<code>op-cuda_tile.global</code> operation.</p><p>The element type of the returned pointer will be of the same type as the element type of the declared global variable.</p><p>For detailed semantics of global variables see :ref:<code>sub_sec_tile_global</code>.</p>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[176]||(e[176]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1306-L1317",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$,[t("summary",null,[e[178]||(e[178]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.get_index_space_shape-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.get_index_space_shape-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.get_index_space_shape")],-1)),e[179]||(e[179]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[181]||(e[181]=t("p",null,[t("code",null,"get_index_space_shape")],-1)),e[182]||(e[182]=t("p",null,[o("The :code:"),t("code",null,"get_index_space_shape"),o(" operation returns the shape of the index space of :code:"),t("code",null,"src"),o(".")],-1)),e[183]||(e[183]=t("p",null,"The result types must be the same as the view's index type, and the number of results must be the same as the view's index rank.",-1)),e[184]||(e[184]=t("p",null,"If the index space shape sizes do not fit within the provided type, behavior is undefined.",-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[180]||(e[180]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1337-L1348",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",X,[t("summary",null,[e[185]||(e[185]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.get_num_tile_blocks-Tuple{}",href:"#Reactant.MLIR.Dialects.cuda_tile.get_num_tile_blocks-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.get_num_tile_blocks")],-1)),e[186]||(e[186]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[188]||(e[188]=n("<p><code>get_num_tile_blocks</code></p><p>The :code:<code>get_num_tile_blocks</code> operation queries the total number of tile blocks in the form of a 3-tuple specifying the extent of each grid dimension.</p><p>A tile :code:<code>id</code> is a coordinate in 3-space and therefore the must also be a 3-tuple containing the extent of each dimension: :code:<code>x</code>, :code:<code>y</code> and :code:<code>z</code>.</p><p>When launching 1- or 2-dimensional grids, the unspecified dimensions will have a cardinality of 1.</p><p>For example if the grid used to launch the kernel is :code:<code>(1024, 1024)</code> then the result of this operation will be :code:<code>(1024, 1024, 1)</code>.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[187]||(e[187]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1368-L1381",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",W,[t("summary",null,[e[189]||(e[189]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.get_tensor_shape-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.get_tensor_shape-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.get_tensor_shape")],-1)),e[190]||(e[190]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[192]||(e[192]=t("p",null,[t("code",null,"get_tensor_shape")],-1)),e[193]||(e[193]=t("p",null,[o("The :code:"),t("code",null,"get_tensor_shape"),o(" operation returns the shape of the tensor backing the provided :code:"),t("code",null,"tensor_view"),o(".")],-1)),e[194]||(e[194]=t("p",null,"If the tensor shape sizes do not fit within the provided type, behavior is undefined.",-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[191]||(e[191]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1409-L1417",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Z,[t("summary",null,[e[195]||(e[195]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.get_tile_block_id-Tuple{}",href:"#Reactant.MLIR.Dialects.cuda_tile.get_tile_block_id-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.get_tile_block_id")],-1)),e[196]||(e[196]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[198]||(e[198]=n("<p><code>get_tile_block_id</code></p><p>:code:<code>get_tile_block_id</code> returns a 3-d tile block coordinates (or ID) of the currently executing tile block.</p><p>A tile ID has three dimensions: :code:<code>x</code>, :code:<code>y</code>, and :code:<code>z</code>. This operation returns all three of them simultaneously. The value of each dimension returned by this operation is between :code:<code>0</code> (including) and the value returned by :code:<code>get_num_tile_blocks</code> for the respective axis (excluding), represented by the inclusive interval :code:<code>[0, get_num_tile_blocks(dim) - 1]</code> . Grid dimensions unspecified at kernel launch (i.e., a 1-d or 2-d grid) will always be :code:<code>0</code> for all tile blocks.</p>",3)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[197]||(e[197]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1437-L1449",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Y,[t("summary",null,[e[199]||(e[199]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.global_-Tuple{}",href:"#Reactant.MLIR.Dialects.cuda_tile.global_-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.global_")],-1)),e[200]||(e[200]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[202]||(e[202]=n("<p><code>global_</code></p><p>The :code:<code>global</code> operation statically allocates a mutable 1-dimensional location in global memory and initializes it using :code:<code>value</code>. The initialization of the allocation is performed at <code>CUDA module &lt;https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef&gt;</code>_ load time. The lifetime of the allocation is the same as the lifetime of the module.</p><p>The allocation may be read or written to by first using :ref:<code>op-cuda_tile.get_global</code> to obtain a pointer to the the memory and then read using :ref:<code>op-cuda_tile.load_ptr_tko</code> or written to using :ref:<code>op-cuda_tile.store_ptr_tko</code>.</p><p>The initial values are stored in memory in linear order, so the pointer returned by :ref:<code>op-cuda_tile.get_global</code> points to the first element, and offsetting the pointer by <code>x</code> would allow to load element at position <code>x</code>.</p><p>:code:<code>global</code> operations must be directly nested within the |cuda_tile| module. They cannot be defined inside functions. As globals are defined at the module scope their names are globally unique symbols and must not collide with any other symbol in the module.</p><p>For more detailed semantics of global variables see :ref:<code>sub_sec_tile_global</code>.</p>",6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[201]||(e[201]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1477-L1496",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",G,[t("summary",null,[e[203]||(e[203]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.if_-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.if_-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.if_")],-1)),e[204]||(e[204]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[206]||(e[206]=n("<p><code>if_</code></p><p>The :code:<code>if</code> operation represents an if-then-else construct.</p><p>The <code>if</code> operation consists of (1) a control operand which is a :code:<code>tile&lt;i1&gt;</code> value, (2) a true branch :code:<code>thenRegion</code> and (3) an optional false branch :code:<code>elseRegion</code>.</p><p>The :code:<code>if</code> operation may produce results by yielding values in each branch using :ref:<code>op-cuda_tile.yield</code>.</p><p>If yielding value(s) the types of yielded values must match and the result result type of the :code:<code>if</code> operation will be the same as the yielded values.</p><p>If yielding values the else branch is required and must also yield a value.</p><p>The values returned will be dependent on which branch is taken.</p><p>.. warning::</p><p>The :code:<code>if</code> operation has a set of additional restrictions today:</p><ul><li>Results of :code:<code>if</code> must not be a :tileirty:<code>tensor_view</code> or view type.</li></ul>",10)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[205]||(e[205]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1554-L1576",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",H,[t("summary",null,[e[207]||(e[207]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.int_to_ptr-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.int_to_ptr-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.int_to_ptr")],-1)),e[208]||(e[208]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[210]||(e[210]=t("p",null,[t("code",null,"int_to_ptr")],-1)),e[211]||(e[211]=t("p",null,[o("The :code:"),t("code",null,"int_to_ptr"),o(" operation converts a tile of integers to a tile of pointers.")],-1)),e[212]||(e[212]=t("p",null,[o("The inverse of this operation is :ref:"),t("code",null,"op-cuda_tile.ptr_to_int"),o(".")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[209]||(e[209]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1602-L1608",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",J,[t("summary",null,[e[213]||(e[213]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.iota-Tuple{}",href:"#Reactant.MLIR.Dialects.cuda_tile.iota-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.iota")],-1)),e[214]||(e[214]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[216]||(e[216]=n("<p><code>iota</code></p><p>The :code:<code>iota</code> operation generates a 1-d tile with a sequence of integer values. The starting value is :code:<code>0</code> and the stride is :code:<code>1</code>. If the shape of the result tile is :code:<code>(n)</code>, then the generated values are :code:<code>[0, n - 1]</code>.</p><p>.. note::</p><p>The number of elements in the result tile must not exceed the maximum value that the element type can express.</p>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[215]||(e[215]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1628-L1639",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Q,[t("summary",null,[e[217]||(e[217]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.itof-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.itof-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.itof")],-1)),e[218]||(e[218]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[220]||(e[220]=t("p",null,[t("code",null,"itof")],-1)),e[221]||(e[221]=t("p",null,[o("The :code:"),t("code",null,"itof"),o(" operation converts an integer tile into a float tile. In contrast to a bitcast, this preserves the numerical value of the tile, rounded to the nearest floating-point number of the provided type.")],-1)),e[222]||(e[222]=t("p",null,".. warning::",-1)),e[223]||(e[223]=t("p",null,[o("If the input integer value, after being rounded, is outside the range of the target floating-point type, it is converted to :code:"),t("code",null,"Inf"),o(" for types that support that value, and :code:"),t("code",null,"NaN"),o(" otherwise.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[219]||(e[219]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1519-L1531",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ee,[t("summary",null,[e[224]||(e[224]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.join_tokens-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.cuda_tile.join_tokens-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.join_tokens")],-1)),e[225]||(e[225]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[227]||(e[227]=t("p",null,[t("code",null,"join_tokens")],-1)),e[228]||(e[228]=t("p",null,[o("The :code:"),t("code",null,"join_tokens"),o(" operation produces a fresh token which depends on all input tokens. Token-ordered operations which consume the new token will then be ordered with respect to all joined tokens.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[226]||(e[226]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1659-L1665",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",te,[t("summary",null,[e[229]||(e[229]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.load_ptr_tko",href:"#Reactant.MLIR.Dialects.cuda_tile.load_ptr_tko"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.load_ptr_tko")],-1)),e[230]||(e[230]=o()),a(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[232]||(e[232]=n("<p><code>load_ptr_tko</code></p><p>This :code:<code>load</code> OP performs a gather operation by loading a tile of data from global memory into a result tile based on a tile of pointers provided by the :code:<code>source</code> operand.</p><p>The :code:<code>source</code> operand is a tile of pointers, which specifies the memory locations from which the data is gathered. The operation loads this data and returns it as the :code:<code>result</code> tile. When loading i1 values, each value is loaded from a full byte in memory. Any nonzero byte is canonicalized to 0x01, and zero bytes become 0x00.</p><p>Optionally, a :code:<code>mask</code> operand can be provided to control the gathering of elements. If present, only the elements specified by the :code:<code>mask</code> are loaded. The shape of the :code:<code>mask</code> must match the shape of the :code:<code>result</code>.</p><p>When :code:<code>mask</code> is present one :code:<code>paddingValue</code> can be optionally present as well. The :code:<code>paddingValue</code> must have the same shape of the :code:<code>source</code> tile. If it is not present, the value of masked elements are undefined.</p><p>Token-ordered operations are not constrained by program order. The compiler may reorder them (i.e. place them earlier or later in program order) unless further constrained by tokens.</p>",6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[231]||(e[231]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1688-L1712",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",oe,[t("summary",null,[e[233]||(e[233]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.load_view_tko",href:"#Reactant.MLIR.Dialects.cuda_tile.load_view_tko"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.load_view_tko")],-1)),e[234]||(e[234]=o()),a(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[236]||(e[236]=n("<p><code>load_view_tko</code></p><p>The :code:<code>load_view_tko</code> operation loads a tile from a tile view.</p><p>A view is mapping from view-space indices to a particular element in the view, each view type has a defined mapping from view-space indices to tiles produced from elements of the view.</p><p>For example, the :ref:<code>type-partition_view</code> partitions a :ref:<code>type-tensor_view</code> into a grid of equally sized tiles. The view indices one of the partitioned tiles in the grid.</p><p>For a given view the rank of the indices must match the rank of the view&#39;s index space. The space of valid indices depends on which view is passed to the operation. For example the index space of a :ref:<code>type-partition_view</code> is equal to the rank of the partitioned tiles.</p><p>Out of bounds accesses are handling according to the semantics of the tile view.</p>",6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[235]||(e[235]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1758-L1776",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ie,[t("summary",null,[e[237]||(e[237]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.log-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.log-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.log")],-1)),e[238]||(e[238]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[240]||(e[240]=n("<p><code>log</code></p><p>The :code:<code>log</code> operation computes the element-wise natural logarithm of a floating-point tile.</p><p>.. math::</p><p>\\text{log}(x)_i = \\ln(x_i)</p><p>:suffix: This operation is emulated in :code:<code>f32</code> when executed on half-precision inputs (:code:<code>f16</code> and :code:<code>bf16</code>). See :ref:<code>op-group-floating-point</code> for more details.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[239]||(e[239]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1846-L1857",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ae,[t("summary",null,[e[241]||(e[241]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.log2-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.log2-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.log2")],-1)),e[242]||(e[242]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[244]||(e[244]=n("<p><code>log2</code></p><p>The :code:<code>log2</code> operation computes the element-wise base-2 logarithm of a floating-point tile.</p><p>.. math::</p><p>\\text{log2}(x)_i = \\log_2(x_i)</p><p>:suffix: This operation is emulated in :code:<code>f32</code> when executed on half-precision inputs (:code:<code>f16</code> and :code:<code>bf16</code>). See :ref:<code>op-group-floating-point</code> for more details.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[243]||(e[243]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1814-L1825",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",le,[t("summary",null,[e[245]||(e[245]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.loop-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.cuda_tile.loop-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.loop")],-1)),e[246]||(e[246]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[248]||(e[248]=n("<p><code>loop</code></p><p>The :code:<code>loop</code> operation represents an, unstructured, infinite loop that executes until a :ref:<code>op-cuda_tile.break</code> is reached.</p><p>The loop consists of a (1) a set of loop-carried values which are initialized by :code:<code>initValues</code> and updated by each iteration of the loop, and (2) a region which represents the loop body.</p><p>The loop will execute the body of the loop until a :ref:<code>op-cuda_tile.break</code> is dynamically executed.</p><p>Each control path of the loop must be terminated by:</p><ul><li><p>a :ref:<code>op-cuda_tile.continue</code> that yields the next iteration&#39;s value for each loop carried variable.</p></li><li><p>a :ref:<code>op-cuda_tile.break</code> that terminates the loop and yields the final loop carried values.</p></li></ul><p>As long as each loop iteration is terminated by one of these operations they may be combined with other control flow operations to express different control flow patterns.</p><p>The loop operation produces one return value for each loop carried variable. The type of the :math:<code>i</code>-th return value is that of the :math:<code>i</code>-th loop carried variable and its value is the final value of the :math:<code>i</code>-th loop carried variable.</p><p>.. warning::</p><p>Loop operations have a set of additional restrictions today:</p><ul><li><p>Early returns from inside loops are not supported, a code generator must first terminate the loop and then return if they wish to end the function execution entirely.</p></li><li><p>Loop carried variables can not be a :tileirty:<code>tensor_view</code> or view type.</p></li></ul>",11)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[247]||(e[247]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1878-L1908",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ne,[t("summary",null,[e[249]||(e[249]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.make_partition_view-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.make_partition_view-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.make_partition_view")],-1)),e[250]||(e[250]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[252]||(e[252]=n("<p><code>make_partition_view</code></p><p>The :code:<code>make_partition_view</code> operation creates a :tileirty:<code>partition_view</code> from a :tileirty:<code>tensor_view</code>. For more details about partition views see :ref:<code>type-partition_view</code>.</p><p>The operation uses the type constraints of the input tensor view and the annotated return type to perform the partitioning. The tensor view&#39;s type contains its physical layout in the form of shapes and strides and the partition view containts the logical size of a single tile.</p><p>The resulting partition view can be loaded from using :ref:<code>op-cuda_tile.load_view_tko</code> and stored to using :ref:<code>op-cuda_tile.store_view_tko</code>.</p><p>The view memory options act on the computed index space of the partition view see :ref:<code>type-tensor_view</code> and :ref:<code>type-partition_view</code> for detailed semantics.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[251]||(e[251]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1933-L1948",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",se,[t("summary",null,[e[253]||(e[253]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.make_tensor_view-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.cuda_tile.make_tensor_view-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.make_tensor_view")],-1)),e[254]||(e[254]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[256]||(e[256]=n("<p><code>make_tensor_view</code></p><p>The :code:<code>make_tensor_view</code> operation constructs a :code:<code>tensor_view</code> from a global memory pointer, a dynamic shape and dynamic strides. See :ref:<code>type-tensor_view</code> for more details.</p><p>The constructor supports taking dynamic arrays for shapes and strides as part of the constructor enabling workloads to take global memory tensors of dynamic shape and strides. If these arguments are static they will be statically reflected in the type of the resulting :code:<code>tensor_view</code>, if they are dynamic they will appear as :code:<code>?</code> in the type. See below for concrete examples.</p><p>If shapes or strides are larger than the :code:<code>indexBitwidth</code> of the :code:<code>tensor_view</code>, behavior is undefined on the creation of the :code:<code>tensor_view</code>.</p>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[255]||(e[255]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L1968-L1982",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",de,[t("summary",null,[e[257]||(e[257]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.make_token-Tuple{}",href:"#Reactant.MLIR.Dialects.cuda_tile.make_token-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.make_token")],-1)),e[258]||(e[258]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[260]||(e[260]=t("p",null,[t("code",null,"make_token")],-1)),e[261]||(e[261]=t("p",null,[o("The :code:"),t("code",null,"make_token"),o(" operation creates a fresh token with no prior dependencies.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[259]||(e[259]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2011-L2015",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",re,[t("summary",null,[e[262]||(e[262]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.maxf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.maxf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.maxf")],-1)),e[263]||(e[263]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[265]||(e[265]=n("<p><code>maxf</code></p><p>The :code:maxf` operation computes the element-wise maximum of two input tiles with floating-point element types.</p><p>The :code:<code>propagate_nan</code> controls how :code:<code>maxf</code> will interpret :code:<code>NaN</code>. If the :code:<code>propagate_nan</code> modifier is set, :code:<code>maxf</code> returns a canonical :code:<code>NaN</code> if either of the compared elements is :code:<code>NaN</code> (IEEE 754-2019&#39;s maximum). While if the :code:<code>propagate_nan</code> modifier is not set, :code:<code>maxf</code> returns a canonical :code:<code>NaN</code> only if both elements are :code:<code>NaN</code>; otherwise, it returns the non-:code:<code>NaN</code> element (IEEE 754-2019&#39;s maximumNumber).</p><p>If neither element is :code:<code>NaN</code>, :code:<code>maxf</code> will return the greater of the inputs. :code:<code>+0.0</code> is considered greater than :code:<code>-0.0</code>.</p><p>If the :code:<code>flush_to_zero</code> modifier is specified, denormal numbers are flushed to sign-preserving zero. The :code:<code>flush_to_zero</code> modifier applies only to the f32 data type.</p>",5)),e[266]||(e[266]=t("p",{cases:""},[o(".. math:: \\text{maxi}(x, y)_i = \\begin{cases} x_i & \\text{if } x_i \\geq y_i "),t("br"),o(" y_i & \\text{if } x_i < y_i \\end")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[264]||(e[264]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2036-L2061",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ce,[t("summary",null,[e[267]||(e[267]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.maxi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.maxi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.maxi")],-1)),e[268]||(e[268]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[270]||(e[270]=t("p",null,[t("code",null,"maxi")],-1)),e[271]||(e[271]=t("p",null,[o("The :code:"),t("code",null,"maxi"),o(" operation computes the element-wise maximum between two input integer tiles.")],-1)),e[272]||(e[272]=t("p",{cases:""},[o(".. math:: \\text{maxi}(x, y)_i = \\begin{cases} x_i & \\text{if } x_i \\geq y_i "),t("br"),o(" y_i & \\text{if } x_i < y_i \\end")],-1)),e[273]||(e[273]=t("p",null,[o(":suffix: Element-wise integer arithmetic operations are performed by the target architecture's native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:"),t("code",null,"op-group-integer"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[269]||(e[269]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2093-L2105",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ue,[t("summary",null,[e[274]||(e[274]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.minf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.minf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.minf")],-1)),e[275]||(e[275]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[277]||(e[277]=n("<p><code>minf</code></p><p>The :code:<code>minf</code> operation computes the element-wise minimum of two input tiles with floating-point element types.</p><p>The :code:<code>propagate_nan</code> controls how :code:<code>minf</code> will interpret :code:<code>NaN</code>. If the :code:<code>propagate_nan</code> modifier is set, :code:<code>minf</code> returns a canonical :code:<code>NaN</code> if either of the compared elements is :code:<code>NaN</code> (IEEE 754-2019&#39;s minimum). While if the :code:<code>propagate_nan</code> modifier is not set, :code:<code>minf</code> returns a canonical :code:<code>NaN</code> only if both elements are :code:<code>NaN</code>; otherwise, it returns the non-:code:<code>NaN</code> element (IEEE 754-2019&#39;s minimumNumber).</p><p>If neither element is :code:<code>NaN</code>, :code:<code>minf</code> will return the lowest of the inputs. :code:<code>-0.0</code> is considered less than :code:<code>+0.0</code>.</p><p>If the :code:<code>flush_to_zero</code> modifier is specified, denormal numbers are flushed to sign-preserving zero. The :code:<code>flush_to_zero</code> modifier applies only to the f32 data type.</p>",5)),e[278]||(e[278]=t("p",{cases:""},[o(".. math:: \\text{minf}(x, y)_i = \\begin{cases} x_i & \\text{if } x_i \\leq y_i "),t("br"),o(" y_i & \\text{if } x_i > y_i \\end")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[276]||(e[276]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2132-L2157",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",pe,[t("summary",null,[e[279]||(e[279]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.mini-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.mini-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.mini")],-1)),e[280]||(e[280]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[282]||(e[282]=t("p",null,[t("code",null,"mini")],-1)),e[283]||(e[283]=t("p",null,[o("The :code:"),t("code",null,"mini"),o(" operation computes the element-wise minimum between the two input tiles with integer element types.")],-1)),e[284]||(e[284]=t("p",{cases:""},[o(".. math:: \\text{mini}(x, y)_i = \\begin{cases} x_i & \\text{if } x_i \\leq y_i "),t("br"),o(" y_i & \\text{if } x_i > y_i \\end")],-1)),e[285]||(e[285]=t("p",null,[o(":suffix: Element-wise integer arithmetic operations are performed by the target architecture's native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:"),t("code",null,"op-group-integer"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[281]||(e[281]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2189-L2202",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",fe,[t("summary",null,[e[286]||(e[286]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.mmaf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.mmaf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.mmaf")],-1)),e[287]||(e[287]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[289]||(e[289]=n("<p><code>mmaf</code></p><p>The :code:<code>mmaf</code> operation implements an MMA (matrix-multiply-accumulate) operation for floating-point tiles. It performs matrix multiplication on the floating-point tiles :code:<code>lhs</code> and :code:<code>rhs</code>, then adds the tile :code:<code>acc</code> to the result. :code:<code>lhs</code>, :code:<code>rhs</code>, and :code:<code>acc</code> must be 2D tiles or 3D tiles. The latter case indicates a batched matrix multiplication.</p><p>The types of all operands must be a supported combination (see :ref:<code>table-cuda_tile.mmaf-0</code>).</p><p>Shapes must be a valid matrix multiplication configuration. Unbatched (2D) MMA expects the operands :code:<code>lhs</code>, :code:<code>rhs</code>, and :code:<code>acc</code> to have shapes :code:<code>M x K</code>, :code:<code>K x N</code>, and :code:<code>M x N</code> (respectively). Batched (3D) MMA expects the operands to have shapes :code:<code>B x M x K</code>, :code:<code>B x K x N</code>, and :code:<code>B x M x N</code> (respectively).</p>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[288]||(e[288]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2229-L2243",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",me,[t("summary",null,[e[290]||(e[290]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.mmai-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.mmai-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.mmai")],-1)),e[291]||(e[291]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[293]||(e[293]=n("<p><code>mmai</code></p><p>The :code:<code>mmai</code> operation implements an MMA (matrix-multiply-accumulate) operation for integer tiles. It performs matrix multiplication on the integer tiles :code:<code>lhs</code> and :code:<code>rhs</code>, then adds the tile :code:<code>acc</code> to the result. :code:<code>lhs</code>, :code:<code>rhs</code>, and :code:<code>acc</code> must be 2D tiles or 3D tiles. The latter case indicates a batched matrix multiplication.</p><p>Input tiles :code:<code>lhs</code> and :code:<code>rhs</code> must be of integer type :code:<code>i8</code>. The signedness of :code:<code>lhs</code> and :code:<code>rhs</code> are specified separately by the :code:<code>signedness_lhs</code> and :code:<code>signedness_rhs</code> attributes, respectively. The accumulator tile :code:<code>acc</code> must be of type :code:<code>i32</code> and is always interpreted as signed. The output tile :code:<code>result</code> is of type :code:<code>i32</code> and is always interpreted as signed.</p><p>Shapes must be a valid matrix multiplication configuration. Unbatched (2D) MMA expects the operands :code:<code>lhs</code>, :code:<code>rhs</code>, and :code:<code>acc</code> to have shapes :code:<code>M x K</code>, :code:<code>K x N</code>, and :code:<code>M x N</code> (respectively). Batched (3D) MMA expects the operands to have shapes :code:<code>B x M x K</code>, :code:<code>B x K x N</code>, and :code:<code>B x M x N</code> (respectively).</p>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[292]||(e[292]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2270-L2287",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Re,[t("summary",null,[e[294]||(e[294]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.module_-Tuple{}",href:"#Reactant.MLIR.Dialects.cuda_tile.module_-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.module_")],-1)),e[295]||(e[295]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[297]||(e[297]=t("p",null,[t("code",null,"module_")],-1)),e[298]||(e[298]=t("p",null,[o("A :code:"),t("code",null,"module"),o(" operation represents a single compilation unit and contains zero or more items (global variables, functions, or kernels).")],-1)),e[299]||(e[299]=t("p",null,[o("For detailed description of the semantics of modules, and the full definition of each item type see :ref:"),t("code",null,"sub_sec_modules"),o(".")],-1)),e[300]||(e[300]=t("p",null,[o("The :code:"),t("code",null,"module"),o(" operation is the top-level operation in a |cuda_tile| module and must contain only |cuda_tile| operations and no other dialects.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[296]||(e[296]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2319-L2330",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",be,[t("summary",null,[e[301]||(e[301]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.mulf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.mulf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.mulf")],-1)),e[302]||(e[302]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[304]||(e[304]=n("<p><code>mulf</code></p><p>The :code:<code>mulf</code> operation computes the element-wise product between the two input tiles with with floating-point element types.</p><p>If the :code:<code>flush_to_zero</code> modifier is specified, denormal numbers are flushed to positive zero.</p><p>If the :code:<code>rounding</code> modifier is specified, the particular rounding mode will be applied to each element of the result.</p><p>.. math:: \\text{mulf}(x, y)_i = x_i \\times y_i</p><p>:suffix: Element-wise floating-point arithmetic operations are performed by the target architecture&#39;s native floating-point instructions. If the :code:<code>rounding</code> modifier is specified, the particular rounding mode will be applied to each element of the result. See :ref:<code>op-group-floating-point</code> for more details.</p>",6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[303]||(e[303]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2350-L2365",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",he,[t("summary",null,[e[305]||(e[305]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.mulhii-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.mulhii-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.mulhii")],-1)),e[306]||(e[306]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[308]||(e[308]=n("<p><code>mulhii</code></p><p>The :code:<code>mulhii</code> operation produces the most significant N bits of the 2N-bit product of two N-bit integer tiles. For :code:<code>i64</code>, this is the most significant 64 bits of the full 128-bit product; for :code:<code>i8</code>, it is the most significant 8 bits of the full 16-bit product; etc.</p><p>This is in contrast to :code:<code>muli</code>, which produces the lower N bits of the 2N-bit product.</p><p>The :code:<code>mulhii</code> operation is only defined for unsigned integers.</p><p>.. math:: \\text{mulhii}(x_i, y_i) = x_i \\times y_i &gt;&gt; \\text{bitwidth}(\\text{type}(x_i))</p><p>:suffix: Element-wise integer arithmetic operations are performed by the target architecture&#39;s native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:<code>op-group-integer</code> for more details.</p>",6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[307]||(e[307]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2433-L2450",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ge,[t("summary",null,[e[309]||(e[309]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.muli-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.muli-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.muli")],-1)),e[310]||(e[310]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[312]||(e[312]=t("p",null,[t("code",null,"muli")],-1)),e[313]||(e[313]=t("p",null,[o("The :code:"),t("code",null,"muli"),o(" operation computes the element-wise product between the two input tiles with integer element types.")],-1)),e[314]||(e[314]=t("p",null,".. math:: \\text{muli}(x, y)_i = x_i \\times y_i",-1)),e[315]||(e[315]=t("p",null,[o(":suffix: Element-wise integer arithmetic operations are performed by the target architecture's native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:"),t("code",null,"op-group-integer"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[311]||(e[311]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2395-L2405",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Te,[t("summary",null,[e[316]||(e[316]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.negf-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.negf-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.negf")],-1)),e[317]||(e[317]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[319]||(e[319]=t("p",null,[t("code",null,"negf")],-1)),e[320]||(e[320]=t("p",null,[o(":code:"),t("code",null,"negf"),o(" is an element-wise operation that negates the sign of :code:"),t("code",null,"source"),o(".")],-1)),e[321]||(e[321]=t("p",null,[o(":suffix: Element-wise floating-point arithmetic operations are performed by the target architecture's native floating-point instructions. If the :code:"),t("code",null,"rounding"),o(" modifier is specified, the particular rounding mode will be applied to each element of the result. See :ref:"),t("code",null,"op-group-floating-point"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[318]||(e[318]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2473-L2479",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ie,[t("summary",null,[e[322]||(e[322]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.negi-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.negi-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.negi")],-1)),e[323]||(e[323]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[325]||(e[325]=t("p",null,[t("code",null,"negi")],-1)),e[326]||(e[326]=t("p",null,[o("The :code:"),t("code",null,"negi"),o(" operation computes the element-wise negation of the input integer tile. The input and output tiles are always interpreted as signed integers.")],-1)),e[327]||(e[327]=t("p",null,".. math:: \\text{negi}(x_i) = -x_i",-1)),e[328]||(e[328]=t("p",null,[o(":suffix: Element-wise integer arithmetic operations are performed by the target architecture's native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:"),t("code",null,"op-group-integer"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[324]||(e[324]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2500-L2510",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ye,[t("summary",null,[e[329]||(e[329]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.offset-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.offset-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.offset")],-1)),e[330]||(e[330]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[332]||(e[332]=n('<p><code>offset</code></p><p>:code:<code>offset</code> advances a tile of pointers. It takes :code:<code>ptr</code> as base and :code:<code>offset</code> as increment, and performs element-wise addition of :code:<code>ptr</code> by :code:<code>offset</code>:</p><p>.. code-block:: mlir</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>result[i,j] = ptr[i,j] + offset[i,j] * bitwidth</span></span></code></pre></div><p>:code:<code>ptr</code> is interpreted as an unsigned integer. :code:<code>offset</code> is interpreted as a signed integer. :code:<code>bitwidth</code> is the storage bitwidth of the pointee type. The multiplication must not overflow (wrap-around) in a signed sense. The addition must not overflow (wrap-around) in an unsigned sense. In case of an overflow, the result is undefined.</p>',5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[331]||(e[331]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2531-L2547",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_e,[t("summary",null,[e[333]||(e[333]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.ori-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.ori-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.ori")],-1)),e[334]||(e[334]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[336]||(e[336]=t("p",null,[t("code",null,"ori")],-1)),e[337]||(e[337]=t("p",null,[o("The :code:"),t("code",null,"ori"),o(" operation computes the element-wise bitwise OR of two tiles with integer element types.")],-1)),e[338]||(e[338]=t("p",null,".. math:: \\text{ori}(x, y)_i = x_i | y_i",-1)),e[339]||(e[339]=t("p",null,[o(":suffix: Element-wise integer arithmetic operations are performed by the target architecture's native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:"),t("code",null,"op-group-integer"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[335]||(e[335]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2570-L2580",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Me,[t("summary",null,[e[340]||(e[340]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.permute-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.permute-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.permute")],-1)),e[341]||(e[341]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[343]||(e[343]=n("<p><code>permute</code></p><p>Permute the dimensions of the input tile :code:<code>source</code> according to the :code:<code>permutation</code> array. The :code:<code>permutation</code> array is a list of integers that specify the new order of the dimensions.</p><p>For example, if the input tile has shape :code:<code>[2, 4, 8]</code>, and the permutation is :code:<code>[2, 0, 1]</code>, the output tile will have shape :code:<code>[8, 2, 4]</code>.</p><p>This operation logically is a change in the indexing of the tile.</p>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[342]||(e[342]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2603-L2613",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Le,[t("summary",null,[e[344]||(e[344]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.pow-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.pow-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.pow")],-1)),e[345]||(e[345]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[347]||(e[347]=t("p",null,[t("code",null,"pow")],-1)),e[348]||(e[348]=t("p",null,[o("The :code:"),t("code",null,"pow"),o(" operation computes the element-wise exponentiation of the source floating-point tile raised to the power of the exponent floating-point tile.")],-1)),e[349]||(e[349]=t("p",{y_i:""},".. math:: \\text{pow}(x, y)_i = x_i^",-1)),e[350]||(e[350]=t("p",null,[o(":suffix: Element-wise floating-point arithmetic operations are performed by the target architecture's native floating-point instructions. If the :code:"),t("code",null,"rounding"),o(" modifier is specified, the particular rounding mode will be applied to each element of the result. See :ref:"),t("code",null,"op-group-floating-point"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[346]||(e[346]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2633-L2643",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",je,[t("summary",null,[e[351]||(e[351]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.print-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.cuda_tile.print-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.print")],-1)),e[352]||(e[352]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[354]||(e[354]=t("p",null,[t("code",null,"print")],-1)),e[355]||(e[355]=t("p",null,[o("The :code:"),t("code",null,"print"),o(" operation prints a C-printf-style format string, interleaved with the given operands. The number of format expressions (starting with the :code:"),t("code",null,"%"),o(" character) must match the number of operands. If a format expression is not applicable to its respective operand, then the output is undefined.")],-1)),e[356]||(e[356]=t("p",null,"This operation is meant for debugging. Its implementation is not optimized for performance, so it should not be used in production mode. Moreover, prints may execute in an order that is different from the one in which they appear in the program.",-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[353]||(e[353]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2669-L2682",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",De,[t("summary",null,[e[357]||(e[357]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.ptr_to_int-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.ptr_to_int-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.ptr_to_int")],-1)),e[358]||(e[358]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[360]||(e[360]=t("p",null,[t("code",null,"ptr_to_int")],-1)),e[361]||(e[361]=t("p",null,[o("The :code:"),t("code",null,"ptr_to_int"),o(" operation converts a tile of pointer-type elements to a tile of :code:"),t("code",null,"i64"),o(" elements.")],-1)),e[362]||(e[362]=t("p",null,[o("The inverse of this operation is :ref:"),t("code",null,"op-cuda_tile.int_to_ptr"),o(".")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[359]||(e[359]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2702-L2708",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",xe,[t("summary",null,[e[363]||(e[363]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.ptr_to_ptr-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.ptr_to_ptr-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.ptr_to_ptr")],-1)),e[364]||(e[364]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[366]||(e[366]=t("p",null,[t("code",null,"ptr_to_ptr")],-1)),e[367]||(e[367]=t("p",null,[o("The :code:"),t("code",null,"ptr_to_ptr"),o(" operation casts a tile of pointers from a pointer of one element type to another element. Casts between pointer and non-pointer types are disallowed.")],-1)),e[368]||(e[368]=t("p",null,[o("In order to perform those conversions, use :ref:"),t("code",null,"op-cuda_tile.ptr_to_int"),o(" or :ref:"),t("code",null,"op-cuda_tile.int_to_ptr"),o(". These operations are distinct to enable future compiler reasoning about pointer provenance.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[365]||(e[365]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2728-L2736",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",we,[t("summary",null,[e[369]||(e[369]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.reduce-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.cuda_tile.reduce-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.reduce")],-1)),e[370]||(e[370]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[372]||(e[372]=n("<p><code>reduce</code></p><p>Applies a reduction function :code:<code>body</code> to :code:<code>operands</code> and :code:<code>identities</code> along dimensions :code:<code>dimensions</code> and produces new :code:<code>results</code> tile values. The order of reduction is implementation-defined but the result is deterministic.</p><p>Argument explained:</p><ul><li><p>:code:<code>operands</code> are the tiles to reduce.</p></li><li><p>:code:<code>identities</code> are the reduction identities for each operand. Identity at position i binds with the operand at the same position. Identities are properties of the reduction function in the :code:<code>body</code>. For example, the identity of a min reduction is +inf, while the identity of a sum is 0.</p></li><li><p>:code:<code>dim</code> is the index of the dimension to be reduced.</p></li><li><p>:code:<code>body</code> is a region carrying the reduction(s) semantics. Each operation within the region must be a cuda_tile operation with 0-rank cuda_tile tile types. Region arguments are bound to operands in the following way: [operand_0_current_iter, operand_0_prev_iter, operand_1_current_iter, operand_1_prev_iter...]. operand_i_current_iter is the current element to reduce from operand at index i. operand_i_prev_iter is the accumulator that might be an element of the same operand at index i, the result of the previous reduction step or the identity value associated with :code:<code>operand_i_current_iter</code>.</p></li></ul>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[371]||(e[371]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2756-L2778",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ke,[t("summary",null,[e[373]||(e[373]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.remf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.remf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.remf")],-1)),e[374]||(e[374]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[376]||(e[376]=n("<p><code>remf</code></p><p>The :code:<code>remf</code> operation computes the element-wise floating-point remainder using truncated division (rounding towards zero).</p><p>.. math:: \\text{remf}(x, y)_i = x_i - \\text{trunc}(x_i / y_i) \\times y_i</p><p>The result has the same sign as the dividend (:code:<code>lhs</code>) and its magnitude is less than the magnitude of divisor (:code:<code>rhs</code>).</p><p><strong>Special cases:</strong></p><ul><li><p>If :code:<code>y</code> is zero, returns :code:<code>NaN</code></p></li><li><p>If :code:<code>x</code> is infinite and :code:<code>y</code> is finite, returns :code:<code>NaN</code></p></li><li><p>If :code:<code>x</code> is finite and :code:<code>y</code> is infinite, returns :code:<code>x</code></p></li><li><p>If either argument is :code:<code>NaN</code>, returns :code:<code>NaN</code></p></li></ul><p>:suffix: Element-wise floating-point arithmetic operations are performed by the target architecture&#39;s native floating-point instructions. If the :code:<code>rounding</code> modifier is specified, the particular rounding mode will be applied to each element of the result. See :ref:<code>op-group-floating-point</code> for more details.</p>",7)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[375]||(e[375]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2807-L2827",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ve,[t("summary",null,[e[377]||(e[377]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.remi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.remi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.remi")],-1)),e[378]||(e[378]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[380]||(e[380]=n("<p><code>remi</code></p><p>The :code:<code>remi</code> operation computes the element-wise remainder of the input tiles with integer element types using truncated division (rounding towards zero). Division by zero is undefined behavior.</p><p>.. math:: \\text{remi}(x, y)_i = x_i - \\text{trunc}(x_i / y_i) \\times y_i</p><p>If the operation is signed, the sign of the result matches the sign of the dividend (:code:<code>lhs</code>). For example:</p><ul><li><p>:code:<code>remi(7, 3) = 1</code></p></li><li><p>:code:<code>remi(7, -3) = 1</code></p></li><li><p>:code:<code>remi(-7, 3) = -1</code></p></li><li><p>:code:<code>remi(-7, -3) = -1</code></p></li></ul><p>:suffix: Element-wise integer arithmetic operations are performed by the target architecture&#39;s native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:<code>op-group-integer</code> for more details.</p>",6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[379]||(e[379]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2850-L2870",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ae,[t("summary",null,[e[381]||(e[381]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.reshape-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.reshape-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.reshape")],-1)),e[382]||(e[382]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[384]||(e[384]=n("<p><code>reshape</code></p><p>The :code:<code>reshape</code> operation changes the shape of the :code:<code>source</code> operand. :code:<code>reshape</code> is only a change in the indexing of the tile. The number of elements and element type must remain unchanged.</p><p>0-d tiles (i.e., scalars) contain precisely one element and thus are the one exception where a 0-d tile can be reshaped to shape where the :code:<code>size(shape) == 1</code>.</p><p>Conceptually reshaping a tile is equivalent to first creating a 1-d tile from the data of the source assuming a row-major layout and then converting the 1-d tile into the new shape in a row-major layout.</p>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[383]||(e[383]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2897-L2909",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ve,[t("summary",null,[e[385]||(e[385]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.return_-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.cuda_tile.return_-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.return_")],-1)),e[386]||(e[386]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[388]||(e[388]=n("<p><code>return_</code></p><p>The :code:<code>return</code> operation returns control to the caller of a function.</p><p>.. warning:: Today the :code:<code>return</code> operation has restricted semantics:</p><ul><li><p>:ref:<code>op-cuda_tile.entry</code> operations do not produce return value(s) and thus :code:<code>return</code> may be used to terminate the execution of the kernel by invoking the operation with no operands</p></li><li><p>:code:<code>return</code> can not be directly used inside of loop bodies to terminate the the execution of the kernel</p></li></ul>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[387]||(e[387]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2929-L2941",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ce,[t("summary",null,[e[389]||(e[389]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.rsqrt-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.rsqrt-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.rsqrt")],-1)),e[390]||(e[390]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[392]||(e[392]=n("<p><code>rsqrt</code></p><p>The :code:<code>rsqrt</code> operation computes the element-wise reciprocal square root of the input floating-point tile.</p><p>This operation supports: :code:<code>flush_to_zero</code>: if set by the user, will flush subnormal inputs and results to sign-preserving zero.</p><p>.. math::</p><p>\\text{rsqrt}(x)_i = \\frac{1}{\\sqrt{x_i}}</p><p>:suffix: This operation is emulated in :code:<code>f32</code> when executed on half-precision inputs (:code:<code>f16</code> and :code:<code>bf16</code>). See :ref:<code>op-group-floating-point</code> for more details.</p>",6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[391]||(e[391]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L2961-L2975",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Se,[t("summary",null,[e[393]||(e[393]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.scan-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.cuda_tile.scan-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.scan")],-1)),e[394]||(e[394]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[396]||(e[396]=n("<p><code>scan</code></p><p>Applies a scan function :code:<code>body</code> to :code:<code>operands</code> and :code:<code>identities</code> along dimension :code:<code>dim</code> and produces new :code:<code>results</code> tile values. The scan operation maintains a carry value that is updated as it processes elements along the specified dimension. For each element, the scan function combines the current element with the carry value to produce both a result and an updated carry. The order of scan is implementation-defined but the result is deterministic.</p><p>:code:<code>identities</code> are the scan identities for each operand. Identity at position i binds with the operand at the same position. Identities are properties of the scan function in the :code:<code>body</code>. For example, the identity of a min scan is +inf, while the identity of a sum is 0.</p><p>:code:<code>body</code> is a region carrying the scan semantics. Each operation within the region must be a cuda_tile operation with 0-rank cuda_tile tile types. Region arguments are bound to operands in the following way: :code:<code>[operand_0_current_iter, operand_0_prev_iter, operand_1_current_iter, operand_1_prev_iter...]</code>. :code:<code>operand_i_current_iter</code> is the current element to scan from operand at index :code:<code>i</code>. :code:<code>operand_i_prev_iter</code> is the accumulator that might be an element of the same operand at index :code:<code>i</code>, the result of the previous scan step or the identity value associated with :code:<code>operand_i_current_iter</code>.</p><p>.. warning::</p><p>The current implementation only supports single tile input.</p>",6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[395]||(e[395]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3003-L3030",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ee,[t("summary",null,[e[397]||(e[397]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.select")],-1)),e[398]||(e[398]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[400]||(e[400]=n("<p><code>select</code></p><p>The :code:<code>select</code> op chooses values based on the binary conditions supplied as the :code:<code>cond</code> operand. The :code:<code>val_if_true</code> operand contains the value(s) to use if the condition is 1. The :code:<code>val_if_false</code> operand contains the value(s) to use if the condition is 0. The choice is made element-wise according to the values in the condition tile.</p><p>All tiles must have the same shape. The tiles :code:<code>val_if_true</code>, :code:<code>val_if_false</code>, and the result must have the same element type. The :code:<code>cond</code> tile must be a tile of :code:<code>i1</code> values.</p>",3)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[399]||(e[399]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3062-L3074",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",ze,[t("summary",null,[e[401]||(e[401]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.shli-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.shli-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.shli")],-1)),e[402]||(e[402]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[404]||(e[404]=n("<p><code>shli</code></p><p>The :code:<code>shli</code> operation computes the element-wise left shift of the :code:<code>lhs</code> integer operand by the :code:<code>rhs</code> operand. The lower-order bits on the right are filled with zeros.</p><p>The :code:<code>rhs</code> operand is interpreted as an unsigned integer.</p><p>:suffix: Element-wise integer arithmetic operations are performed by the target architecture&#39;s native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:<code>op-group-integer</code> for more details.</p>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[403]||(e[403]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3101-L3110",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ne,[t("summary",null,[e[405]||(e[405]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.shri-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.shri-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.shri")],-1)),e[406]||(e[406]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[408]||(e[408]=n("<p><code>shri</code></p><p>The :code:<code>shri</code> operation computes the element-wise right shift of the :code:<code>lhs</code> integer operand by the value of the :code:<code>rhs</code> operand for tiles with integer element types.</p><p>When :code:<code>unsigned</code>, higher-order bits are zero-filled; when :code:<code>signed</code>, the higher-order bits are filled with the sign bit.</p><p>The :code:<code>rhs</code> operand is always interpreted as an unsigned integer.</p><p>:suffix: Element-wise integer arithmetic operations are performed by the target architecture&#39;s native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:<code>op-group-integer</code> for more details.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[407]||(e[407]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3138-L3151",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Pe,[t("summary",null,[e[409]||(e[409]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.sin-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.sin-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.sin")],-1)),e[410]||(e[410]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[412]||(e[412]=n("<p><code>sin</code></p><p>The :code:<code>sin</code> operation computes the element-wise sine of the input floating-point tile.</p><p>.. math::</p><p>\\text{sin}(x)_i = \\sin(x_i)</p><p>:suffix: This operation is emulated in :code:<code>f32</code> when executed on half-precision inputs (:code:<code>f16</code> and :code:<code>bf16</code>). See :ref:<code>op-group-floating-point</code> for more details.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[411]||(e[411]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3210-L3220",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ue,[t("summary",null,[e[413]||(e[413]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.sinh-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.sinh-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.sinh")],-1)),e[414]||(e[414]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[416]||(e[416]=n("<p><code>sinh</code></p><p>The :code:<code>sinh</code> operation computes the element-wise hyperbolic sine of the input floating-point tile.</p><p>.. math::</p><p>\\text{sinh}(x)_i = \\sinh(x_i)</p><p>:suffix: This operation is emulated in :code:<code>f32</code> when executed on half-precision inputs (:code:<code>f16</code> and :code:<code>bf16</code>). See :ref:<code>op-group-floating-point</code> for more details.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[415]||(e[415]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3178-L3189",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Oe,[t("summary",null,[e[417]||(e[417]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.sqrt-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.sqrt-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.sqrt")],-1)),e[418]||(e[418]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[420]||(e[420]=t("p",null,[t("code",null,"sqrt")],-1)),e[421]||(e[421]=t("p",null,[o("The :code:"),t("code",null,"sqrt"),o(" operation computes the element-wise square root of a floating-point tile.")],-1)),e[422]||(e[422]=t("p",null,".. math::",-1)),e[423]||(e[423]=t("p",{x_i:""},"\\text{sqrt}(x)_i = \\sqrt",-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[419]||(e[419]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3241-L3249",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",qe,[t("summary",null,[e[424]||(e[424]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.store_ptr_tko",href:"#Reactant.MLIR.Dialects.cuda_tile.store_ptr_tko"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.store_ptr_tko")],-1)),e[425]||(e[425]=o()),a(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[427]||(e[427]=n("<p><code>store_ptr_tko</code></p><p>The :code:<code>store</code> operation performs a scatter by storing a tile of data from a tile into global memory.</p><p>The :code:<code>destination</code> operand is a tile of pointers indicating the global memory locations where data from the :code:<code>value</code> tile will be stored. When storing i1 values, each value occupies a full byte in memory. Any nonzero byte is canonicalized to 0x01, and zero bytes become 0x00.</p><p>Additionally, the operation supports an optional :code:<code>mask</code> operand, which allows selective scattering of elements. If provided, only the elements specified by the :code:<code>mask</code> are stored. The shape of the :code:<code>mask</code> must align with the shape of the :code:<code>value</code> tile.</p>",4)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[426]||(e[426]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3278-L3293",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Fe,[t("summary",null,[e[428]||(e[428]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.store_view_tko",href:"#Reactant.MLIR.Dialects.cuda_tile.store_view_tko"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.store_view_tko")],-1)),e[429]||(e[429]=o()),a(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[431]||(e[431]=n("<p><code>store_view_tko</code></p><p>The :code:<code>store_view_tko</code> operation stores a tile to a view indexing into a tile view.</p><p>A view is mapping from view-space indices to a particular element in the view, each view type has a defined mapping from view-space indices to tiles produced from elements of the view.</p><p>For example, the :ref:<code>type-partition_view</code> partitions a :ref:<code>type-tensor_view</code> into a grid of equally sized tiles. The view indices one of the partitioned tiles in the grid.</p><p>For a given view the rank of the indices must match the rank of the view&#39;s index space. The space of valid indices depends on which view is passed to the operation. For example the index space of a :ref:<code>type-partition_view</code> is equal to the rank of the partitioned tiles.</p><p>The index space of the view is computed a function of the requested tile size and the shape of the view.</p>",6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[430]||(e[430]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3336-L3356",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Be,[t("summary",null,[e[432]||(e[432]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.subf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.subf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.subf")],-1)),e[433]||(e[433]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[435]||(e[435]=t("p",null,[t("code",null,"subf")],-1)),e[436]||(e[436]=t("p",null,[o("The :code:"),t("code",null,"subf"),o(" operation computes the element-wise subtraction of the input floating-point tiles.")],-1)),e[437]||(e[437]=t("p",null,".. math:: \\text{subf}(x, y)_i = x_i - y_i",-1)),e[438]||(e[438]=t("p",null,[o(":suffix: Element-wise floating-point arithmetic operations are performed by the target architecture's native floating-point instructions. If the :code:"),t("code",null,"rounding"),o(" modifier is specified, the particular rounding mode will be applied to each element of the result. See :ref:"),t("code",null,"op-group-floating-point"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[434]||(e[434]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3395-L3404",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ke,[t("summary",null,[e[439]||(e[439]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.subi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.subi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.subi")],-1)),e[440]||(e[440]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[442]||(e[442]=t("p",null,[t("code",null,"subi")],-1)),e[443]||(e[443]=t("p",null,[o("The :code:"),t("code",null,"subi"),o(" operation computes the element-wise subtraction of two input integer tiles.")],-1)),e[444]||(e[444]=t("p",null,".. math:: \\text{subi}(x, y)_i = x_i - y_i",-1)),e[445]||(e[445]=t("p",null,[o(":suffix: Element-wise integer arithmetic operations are performed by the target architecture's native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:"),t("code",null,"op-group-integer"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[441]||(e[441]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3434-L3443",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$e,[t("summary",null,[e[446]||(e[446]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.tan-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.tan-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.tan")],-1)),e[447]||(e[447]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[449]||(e[449]=n("<p><code>tan</code></p><p>The :code:<code>tan</code> operation computes the element-wise tangent of the input floating-point tile.</p><p>.. math::</p><p>\\text{tan}(x)_i = \\tan(x_i)</p><p>:suffix: This operation is emulated in :code:<code>f32</code> when executed on half-precision inputs (:code:<code>f16</code> and :code:<code>bf16</code>). See :ref:<code>op-group-floating-point</code> for more details.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[448]||(e[448]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3503-L3514",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Xe,[t("summary",null,[e[450]||(e[450]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.tanh-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.tanh-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.tanh")],-1)),e[451]||(e[451]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[453]||(e[453]=n("<p><code>tanh</code></p><p>The :code:<code>tanh</code> operation computes the element-wise hyperbolic tangent of the input floating-point tile.</p><p>.. math::</p><p>\\text{tanh}(x)_i = \\tanh(x_i)</p><p>:suffix: This operation is emulated in :code:<code>f32</code> when executed on half-precision inputs (:code:<code>f16</code> and :code:<code>bf16</code>). See :ref:<code>op-group-floating-point</code> for more details.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[452]||(e[452]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3471-L3482",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",We,[t("summary",null,[e[454]||(e[454]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.trunci-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.trunci-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.trunci")],-1)),e[455]||(e[455]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[457]||(e[457]=t("p",null,[t("code",null,"trunci")],-1)),e[458]||(e[458]=t("p",null,[o("The :code:"),t("code",null,"trunci"),o(" operation converts a tile of integers of a given element type to one with a strictly smaller width.")],-1)),e[459]||(e[459]=t("p",null,[o("The optional "),t("code",null,"overflow"),o(' attribute specifies whether an overflow can occur when interpreting the operand as a signed and/or unsigned integer. In case of "no signed wrap", all truncated bits must have the same value as the most significant bit of the truncated result. In case of "no unsigned wrap", the truncated bits must be zero.')],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[456]||(e[456]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3535-L3546",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ze,[t("summary",null,[e[460]||(e[460]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.xori-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.cuda_tile.xori-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.xori")],-1)),e[461]||(e[461]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[463]||(e[463]=t("p",null,[t("code",null,"xori")],-1)),e[464]||(e[464]=t("p",null,[o("The :code:"),t("code",null,"xori"),o(" operation computes the element-wise bitwise exclusive or (XOR) of two tile values with integer element types.")],-1)),e[465]||(e[465]=t("p",null,".. math:: \\text{xori}(x, y)_i = x_i \\oplus y_i",-1)),e[466]||(e[466]=t("p",null,[o(":suffix: Element-wise integer arithmetic operations are performed by the target architecture's native integer instructions. The default semantics are wrap-around semantics on overflow or underflow. See :ref:"),t("code",null,"op-group-integer"),o(" for more details.")],-1)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[462]||(e[462]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3567-L3577",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Ye,[t("summary",null,[e[467]||(e[467]=t("a",{id:"Reactant.MLIR.Dialects.cuda_tile.yield-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.cuda_tile.yield-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.cuda_tile.yield")],-1)),e[468]||(e[468]=o()),a(i,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[470]||(e[470]=n("<p><code>yield</code></p><p>The :code:<code>yield</code> operation terminates a block that must yield control back to the parent operation such as :code:<code>if</code>, :code:<code>scan</code>, :code:<code>reduce</code>.</p><p>The operation may yield any number of :code:<code>$operands</code> to the parent upon termination. The number of values yielded and the execution semantics of how they are yielded are determined by the parent operation.</p><p>.. note::</p><p>Unlike standard MLIR control flow dialects :code:<code>yield</code> is not used for loop controlf low, see :ref:<code>op-cuda_tile.break</code> and :ref:<code>op-cuda_tile.continue</code> for loop control flow.</p>",5)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[469]||(e[469]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/6047afc00be1ead657235fc84190442be8c00d05/src/mlir/Dialects/CUDATile.jl#L3600-L3613",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const at=s(u,[["render",Ge]]);export{it as __pageData,at as default};
