import{_ as r,C as i,o as c,c as d,j as t,a as l,E as o,al as n,w as s}from"./chunks/framework.BZC9WIPQ.js";const E=JSON.parse('{"title":"MPI Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/mpi.md","filePath":"api/dialects/mpi.md","lastUpdated":null}'),u={name:"api/dialects/mpi.md"},p={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},M={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},D={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},v={class:"jldocstring custom-block"};function P(V,e,x,A,_,z){const a=i("Badge");return c(),d("div",null,[e[81]||(e[81]=t("h1",{id:"MPI-Dialect",tabindex:"-1"},[l("MPI Dialect "),t("a",{class:"header-anchor",href:"#MPI-Dialect","aria-label":'Permalink to "MPI Dialect {#MPI-Dialect}"'},"â€‹")],-1)),e[82]||(e[82]=t("p",null,[l("Refer to the "),t("a",{href:"https://mlir.llvm.org/docs/Dialects/MPI/",target:"_blank",rel:"noreferrer"},"official documentation"),l(" for more details.")],-1)),t("details",p,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.mpi.allgather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.allgather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.allgather")],-1)),e[1]||(e[1]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=n("<p><code>allgather</code></p><p>MPI_Allgather collects data from all processes in a given communicator and stores the gathered data in the receive buffer of each process.</p><p>Each process contributes the same amount of data defined by <code>sendbuf</code>. The MPI call specifies the number of elements contributed by each process via the <code>recvcount</code> parameter. However, this operation, assumes <code>recvbuf</code> to be sufficiently large to hold the data contributed by all processes. Therefore, <code>recvcount</code> is implicitly defined as <code>num_elements(recvbuf) / MPI_Comm_size(comm)</code>.</p><p>This operation may optionally return an !mpi.retval value, which can be used for error checking.</p>",4)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L16-L31",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",m,[t("summary",null,[e[4]||(e[4]=t("a",{id:"Reactant.MLIR.Dialects.mpi.allreduce-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.allreduce-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.allreduce")],-1)),e[5]||(e[5]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[7]||(e[7]=n("<p><code>allreduce</code></p><p>MPI_Allreduce performs a reduction operation on the values in the sendbuf array and stores the result in the recvbuf array. The operation is performed across all processes in the communicator.</p><p>The <code>op</code> attribute specifies the reduction operation to be performed. Currently only the <code>MPI_Op</code> predefined in the standard (e.g. <code>MPI_SUM</code>) are supported.</p><p>This operation can optionally return an <code>!mpi.retval</code> value that can be used to check for errors.</p>",4)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[6]||(e[6]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L58-L71",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",R,[t("summary",null,[e[8]||(e[8]=t("a",{id:"Reactant.MLIR.Dialects.mpi.barrier-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.barrier-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.barrier")],-1)),e[9]||(e[9]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[11]||(e[11]=t("p",null,[t("code",null,"barrier")],-1)),e[12]||(e[12]=t("p",null,"MPI_Barrier blocks execution until all processes in the communicator have reached this routine.",-1)),e[13]||(e[13]=t("p",null,[l("This operation can optionally return an "),t("code",null,"!mpi.retval"),l(" value that can be used to check for errors.")],-1)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[10]||(e[10]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L99-L107",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b,[t("summary",null,[e[14]||(e[14]=t("a",{id:"Reactant.MLIR.Dialects.mpi.comm_rank-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.comm_rank-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.comm_rank")],-1)),e[15]||(e[15]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[17]||(e[17]=t("p",null,[t("code",null,"comm_rank")],-1)),e[18]||(e[18]=t("p",null,[l("This operation can optionally return an "),t("code",null,"!mpi.retval"),l(" value that can be used to check for errors.")],-1)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[16]||(e[16]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L128-L133",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I,[t("summary",null,[e[19]||(e[19]=t("a",{id:"Reactant.MLIR.Dialects.mpi.comm_size-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.comm_size-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.comm_size")],-1)),e[20]||(e[20]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[22]||(e[22]=t("p",null,[t("code",null,"comm_size")],-1)),e[23]||(e[23]=t("p",null,[l("This operation can optionally return an "),t("code",null,"!mpi.retval"),l(" value that can be used to check for errors.")],-1)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[21]||(e[21]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L156-L161",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[24]||(e[24]=t("a",{id:"Reactant.MLIR.Dialects.mpi.comm_split-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.comm_split-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.comm_split")],-1)),e[25]||(e[25]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[27]||(e[27]=t("p",null,[t("code",null,"comm_split")],-1)),e[28]||(e[28]=t("p",null,"This operation splits the communicator into multiple sub-communicators. The color value determines the group of processes that will be part of the new communicator. The key value determines the rank of the calling process in the new communicator.",-1)),e[29]||(e[29]=t("p",null,[l("This operation can optionally return an "),t("code",null,"!mpi.retval"),l(" value that can be used to check for errors.")],-1)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[26]||(e[26]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L184-L194",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",M,[t("summary",null,[e[30]||(e[30]=t("a",{id:"Reactant.MLIR.Dialects.mpi.comm_world-Tuple{}",href:"#Reactant.MLIR.Dialects.mpi.comm_world-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.comm_world")],-1)),e[31]||(e[31]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[33]||(e[33]=t("p",null,[t("code",null,"comm_world")],-1)),e[34]||(e[34]=t("p",null,"This operation returns the predefined MPI_COMM_WORLD communicator.",-1)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[32]||(e[32]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L222-L226",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y,[t("summary",null,[e[35]||(e[35]=t("a",{id:"Reactant.MLIR.Dialects.mpi.error_class-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.error_class-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.error_class")],-1)),e[36]||(e[36]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[38]||(e[38]=t("p",null,[t("code",null,"error_class")],-1)),e[39]||(e[39]=t("p",null,[t("code",null,"MPI_Error_class"),l(" maps return values from MPI calls to a set of well-known MPI error classes.")],-1)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[37]||(e[37]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L246-L251",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",L,[t("summary",null,[e[40]||(e[40]=t("a",{id:"Reactant.MLIR.Dialects.mpi.finalize-Tuple{}",href:"#Reactant.MLIR.Dialects.mpi.finalize-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.finalize")],-1)),e[41]||(e[41]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[43]||(e[43]=t("p",null,[t("code",null,"finalize")],-1)),e[44]||(e[44]=t("p",null,"This function cleans up the MPI state. Afterwards, no MPI methods may be invoked (excpet for MPI_Get_version, MPI_Initialized, and MPI_Finalized). Notably, MPI_Init cannot be called again in the same program.",-1)),e[45]||(e[45]=t("p",null,[l("This operation can optionally return an "),t("code",null,"!mpi.retval"),l(" value that can be used to check for errors.")],-1)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[42]||(e[42]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L271-L280",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",T,[t("summary",null,[e[46]||(e[46]=t("a",{id:"Reactant.MLIR.Dialects.mpi.init-Tuple{}",href:"#Reactant.MLIR.Dialects.mpi.init-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.init")],-1)),e[47]||(e[47]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[49]||(e[49]=t("p",null,[t("code",null,"init")],-1)),e[50]||(e[50]=t("p",null,"This operation must preceed most MPI calls (except for very few exceptions, please consult with the MPI specification on these).",-1)),e[51]||(e[51]=t("p",null,"Passing &argc, &argv is not supported currently.",-1)),e[52]||(e[52]=t("p",null,[l("This operation can optionally return an "),t("code",null,"!mpi.retval"),l(" value that can be used to check for errors.")],-1)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[48]||(e[48]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L379-L389",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",j,[t("summary",null,[e[53]||(e[53]=t("a",{id:"Reactant.MLIR.Dialects.mpi.irecv-NTuple{4, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.irecv-NTuple{4, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.irecv")],-1)),e[54]||(e[54]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[56]||(e[56]=n("<p><code>irecv</code></p><p>MPI_Irecv begins a non-blocking receive of <code>size</code> elements of type <code>dtype</code> from rank <code>source</code>. The <code>tag</code> value and communicator enables the library to determine the matching of multiple sends and receives between the same ranks.</p><p>This operation can optionally return an <code>!mpi.retval</code> value that can be used to check for errors.</p>",3)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[55]||(e[55]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L301-L311",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[57]||(e[57]=t("a",{id:"Reactant.MLIR.Dialects.mpi.isend-NTuple{4, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.isend-NTuple{4, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.isend")],-1)),e[58]||(e[58]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[60]||(e[60]=n("<p><code>isend</code></p><p>MPI_Isend begins a non-blocking send of <code>size</code> elements of type <code>dtype</code> to rank <code>dest</code>. The <code>tag</code> value and communicator enables the library to determine the matching of multiple sends and receives between the same ranks.</p><p>This operation can optionally return an <code>!mpi.retval</code> value that can be used to check for errors.</p>",3)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[59]||(e[59]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L340-L350",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",D,[t("summary",null,[e[61]||(e[61]=t("a",{id:"Reactant.MLIR.Dialects.mpi.recv-NTuple{4, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.recv-NTuple{4, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.recv")],-1)),e[62]||(e[62]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[64]||(e[64]=n("<p><code>recv</code></p><p>MPI_Recv performs a blocking receive of <code>size</code> elements of type <code>dtype</code> from rank <code>source</code>. The <code>tag</code> value and communicator enables the library to determine the matching of multiple sends and receives between the same ranks.</p><p>The MPI_Status is set to <code>MPI_STATUS_IGNORE</code>, as the status object is not yet ported to MLIR.</p><p>This operation can optionally return an <code>!mpi.retval</code> value that can be used to check for errors.</p>",4)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[63]||(e[63]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L410-L423",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",k,[t("summary",null,[e[65]||(e[65]=t("a",{id:"Reactant.MLIR.Dialects.mpi.retval_check-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.retval_check-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.retval_check")],-1)),e[66]||(e[66]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[68]||(e[68]=t("p",null,[t("code",null,"retval_check")],-1)),e[69]||(e[69]=t("p",null,[l("This operation compares MPI status codes to known error class constants such as "),t("code",null,"MPI_SUCCESS"),l(", or "),t("code",null,"MPI_ERR_COMM"),l(".")],-1)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[67]||(e[67]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L451-L456",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",h,[t("summary",null,[e[70]||(e[70]=t("a",{id:"Reactant.MLIR.Dialects.mpi.send-NTuple{4, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.send-NTuple{4, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.send")],-1)),e[71]||(e[71]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[73]||(e[73]=n("<p><code>send</code></p><p>MPI_Send performs a blocking send of <code>size</code> elements of type <code>dtype</code> to rank <code>dest</code>. The <code>tag</code> value and communicator enables the library to determine the matching of multiple sends and receives between the same ranks.</p><p>This operation can optionally return an <code>!mpi.retval</code> value that can be used to check for errors.</p>",3)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[72]||(e[72]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L476-L485",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",v,[t("summary",null,[e[74]||(e[74]=t("a",{id:"Reactant.MLIR.Dialects.mpi.wait-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.mpi.wait-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.mpi.wait")],-1)),e[75]||(e[75]=l()),o(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[77]||(e[77]=t("p",null,[t("code",null,"wait")],-1)),e[78]||(e[78]=t("p",null,"MPI_Wait blocks execution until the request has completed.",-1)),e[79]||(e[79]=t("p",null,[l("The MPI_Status is set to "),t("code",null,"MPI_STATUS_IGNORE"),l(", as the status object is not yet ported to MLIR.")],-1)),e[80]||(e[80]=t("p",null,[l("This operation can optionally return an "),t("code",null,"!mpi.retval"),l(" value that can be used to check for errors.")],-1)),o(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[76]||(e[76]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/4d4db2a56c3027ae183d5c402986b8436c3961f7/src/mlir/Dialects/MPI.jl#L513-L523",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const w=r(u,[["render",P]]);export{E as __pageData,w as default};
