import{_ as p,C as i,o as c,c as d,j as t,a as s,E as l,al as o,w as n}from"./chunks/framework.Cg5e5iWY.js";const K=JSON.parse('{"title":"Complex Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/complex.md","filePath":"api/dialects/complex.md","lastUpdated":null}'),r={name:"api/dialects/complex.md"},m={class:"jldocstring custom-block"},u={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},x={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},_={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},M={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"},D={class:"jldocstring custom-block"},v={class:"jldocstring custom-block"},C={class:"jldocstring custom-block"},V={class:"jldocstring custom-block"},A={class:"jldocstring custom-block"},E={class:"jldocstring custom-block"},S={class:"jldocstring custom-block"},P={class:"jldocstring custom-block"},w={class:"jldocstring custom-block"},N={class:"jldocstring custom-block"},q={class:"jldocstring custom-block"},O={class:"jldocstring custom-block"},z={class:"jldocstring custom-block"};function B($,e,F,J,U,G){const a=i("Badge");return c(),d("div",null,[e[116]||(e[116]=t("h1",{id:"Complex-Dialect",tabindex:"-1"},[s("Complex Dialect "),t("a",{class:"header-anchor",href:"#Complex-Dialect","aria-label":'Permalink to "Complex Dialect {#Complex-Dialect}"'},"â€‹")],-1)),e[117]||(e[117]=t("p",null,[s("Refer to the "),t("a",{href:"https://mlir.llvm.org/docs/Dialects/ComplexOps/",target:"_blank",rel:"noreferrer"},"official documentation"),s(" for more details.")],-1)),t("details",m,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.complex.abs-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.abs-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.abs")],-1)),e[1]||(e[1]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=o('<p><code>abs</code></p><p>The <code>abs</code> op takes a single complex number and computes its absolute value.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.abs %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L16-L26",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",u,[t("summary",null,[e[4]||(e[4]=t("a",{id:"Reactant.MLIR.Dialects.complex.add-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.add-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.add")],-1)),e[5]||(e[5]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[7]||(e[7]=o('<p><code>add</code></p><p>The <code>add</code> operation takes two complex numbers and returns their sum.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.add %b, %c : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[6]||(e[6]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L53-L63",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b,[t("summary",null,[e[8]||(e[8]=t("a",{id:"Reactant.MLIR.Dialects.complex.angle-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.angle-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.angle")],-1)),e[9]||(e[9]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[11]||(e[11]=o('<p><code>angle</code></p><p>The <code>angle</code> op takes a single complex number and computes its argument value with a branch cut along the negative real axis.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>     %a = complex.angle %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[10]||(e[10]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L91-L101",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",R,[t("summary",null,[e[12]||(e[12]=t("a",{id:"Reactant.MLIR.Dialects.complex.atan2-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.atan2-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.atan2")],-1)),e[13]||(e[13]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[15]||(e[15]=o('<p><code>atan2</code></p><p>For complex numbers it is expressed using complex logarithm atan2(y, x) = -i * log((x + i * y) / sqrt(x<strong>2 + y</strong>2))</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.atan2 %b, %c : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[14]||(e[14]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L128-L139",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[16]||(e[16]=t("a",{id:"Reactant.MLIR.Dialects.complex.bitcast-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.bitcast-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.bitcast")],-1)),e[17]||(e[17]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[19]||(e[19]=o('<p><code>bitcast</code></p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>     %a = complex.bitcast %b : complex&lt;f32&gt; -&gt; i64</span></span></code></pre></div>',3)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[18]||(e[18]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L167-L176",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",x,[t("summary",null,[e[20]||(e[20]=t("a",{id:"Reactant.MLIR.Dialects.complex.conj-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.conj-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.conj")],-1)),e[21]||(e[21]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[23]||(e[23]=o('<p><code>conj</code></p><p>The <code>conj</code> op takes a single complex number and computes the complex conjugate.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.conj %b: complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[22]||(e[22]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L196-L207",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I,[t("summary",null,[e[24]||(e[24]=t("a",{id:"Reactant.MLIR.Dialects.complex.constant-Tuple{}",href:"#Reactant.MLIR.Dialects.complex.constant-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.constant")],-1)),e[25]||(e[25]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[27]||(e[27]=o('<p><code>constant</code></p><p>The <code>complex.constant</code> operation creates a constant complex number from an attribute containing the real and imaginary parts.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.constant [0.1, -1.0] : complex&lt;f64&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[26]||(e[26]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L234-L245",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[28]||(e[28]=t("a",{id:"Reactant.MLIR.Dialects.complex.cos-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.cos-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.cos")],-1)),e[29]||(e[29]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[31]||(e[31]=o('<p><code>cos</code></p><p>The <code>cos</code> op takes a single complex number and computes the cosine of it, i.e. <code>cos(x)</code>, where <code>x</code> is the input value.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.cos %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[30]||(e[30]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L265-L276",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",T,[t("summary",null,[e[32]||(e[32]=t("a",{id:"Reactant.MLIR.Dialects.complex.create-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.create-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.create")],-1)),e[33]||(e[33]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[35]||(e[35]=o('<p><code>create</code></p><p>The <code>complex.create</code> operation creates a complex number from two floating-point operands, the real and the imaginary part.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.create %b, %c : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[34]||(e[34]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L303-L314",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",h,[t("summary",null,[e[36]||(e[36]=t("a",{id:"Reactant.MLIR.Dialects.complex.div-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.div-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.div")],-1)),e[37]||(e[37]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[39]||(e[39]=o('<p><code>div</code></p><p>The <code>div</code> operation takes two complex numbers and returns result of their division:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.div %b, %c : complex&lt;f32&gt;</span></span></code></pre></div>',3)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[38]||(e[38]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L334-L343",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_,[t("summary",null,[e[40]||(e[40]=t("a",{id:"Reactant.MLIR.Dialects.complex.eq-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.eq-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.eq")],-1)),e[41]||(e[41]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[43]||(e[43]=o('<p><code>eq</code></p><p>The <code>eq</code> op takes two complex numbers and returns whether they are equal.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.eq %b, %c : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[42]||(e[42]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L371-L381",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",L,[t("summary",null,[e[44]||(e[44]=t("a",{id:"Reactant.MLIR.Dialects.complex.exp-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.exp-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.exp")],-1)),e[45]||(e[45]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[47]||(e[47]=o('<p><code>exp</code></p><p>The <code>exp</code> op takes a single complex number and computes the exponential of it, i.e. <code>exp(x)</code> or <code>e^(x)</code>, where <code>x</code> is the input value. <code>e</code> denotes Euler&#39;s number and is approximately equal to 2.718281.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.exp %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[46]||(e[46]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L404-L416",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",M,[t("summary",null,[e[48]||(e[48]=t("a",{id:"Reactant.MLIR.Dialects.complex.expm1-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.expm1-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.expm1")],-1)),e[49]||(e[49]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[51]||(e[51]=o('<p><code>expm1</code></p><p>complex.expm1(x) := complex.exp(x) - 1</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.expm1 %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[50]||(e[50]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L443-L453",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y,[t("summary",null,[e[52]||(e[52]=t("a",{id:"Reactant.MLIR.Dialects.complex.im-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.im-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.im")],-1)),e[53]||(e[53]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[55]||(e[55]=o('<p><code>im</code></p><p>The <code>im</code> op takes a single complex number and extracts the imaginary part.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.im %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[54]||(e[54]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L480-L490",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",j,[t("summary",null,[e[56]||(e[56]=t("a",{id:"Reactant.MLIR.Dialects.complex.log-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.log-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.log")],-1)),e[57]||(e[57]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[59]||(e[59]=o('<p><code>log</code></p><p>The <code>log</code> op takes a single complex number and computes the natural logarithm of it, i.e. <code>log(x)</code> or <code>log_e(x)</code>, where <code>x</code> is the input value. <code>e</code> denotes Euler&#39;s number and is approximately equal to 2.718281.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.log %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[58]||(e[58]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L557-L569",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",k,[t("summary",null,[e[60]||(e[60]=t("a",{id:"Reactant.MLIR.Dialects.complex.log1p-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.log1p-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.log1p")],-1)),e[61]||(e[61]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[63]||(e[63]=o('<p><code>log1p</code></p><p>The <code>log</code> op takes a single complex number and computes the natural logarithm of one plus the given value, i.e. <code>log(1 + x)</code> or <code>log_e(1 + x)</code>, where <code>x</code> is the input value. <code>e</code> denotes Euler&#39;s number and is approximately equal to 2.718281.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.log1p %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[62]||(e[62]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L517-L530",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",D,[t("summary",null,[e[64]||(e[64]=t("a",{id:"Reactant.MLIR.Dialects.complex.mul-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.mul-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.mul")],-1)),e[65]||(e[65]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[67]||(e[67]=o('<p><code>mul</code></p><p>The <code>mul</code> operation takes two complex numbers and returns their product:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.mul %b, %c : complex&lt;f32&gt;</span></span></code></pre></div>',3)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[66]||(e[66]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L596-L604",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",v,[t("summary",null,[e[68]||(e[68]=t("a",{id:"Reactant.MLIR.Dialects.complex.neg-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.neg-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.neg")],-1)),e[69]||(e[69]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[71]||(e[71]=o('<p><code>neg</code></p><p>The <code>neg</code> op takes a single complex number <code>complex</code> and returns <code>-complex</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.neg %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[70]||(e[70]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L632-L642",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",C,[t("summary",null,[e[72]||(e[72]=t("a",{id:"Reactant.MLIR.Dialects.complex.neq-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.neq-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.neq")],-1)),e[73]||(e[73]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[75]||(e[75]=o('<p><code>neq</code></p><p>The <code>neq</code> op takes two complex numbers and returns whether they are not equal.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.neq %b, %c : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[74]||(e[74]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L669-L680",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",V,[t("summary",null,[e[76]||(e[76]=t("a",{id:"Reactant.MLIR.Dialects.complex.pow-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.pow-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.pow")],-1)),e[77]||(e[77]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[79]||(e[79]=o('<p><code>pow</code></p><p>The <code>pow</code> operation takes a complex number raises it to the given complex exponent.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.pow %b, %c : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[78]||(e[78]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L703-L714",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",A,[t("summary",null,[e[80]||(e[80]=t("a",{id:"Reactant.MLIR.Dialects.complex.powi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.powi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.powi")],-1)),e[81]||(e[81]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[83]||(e[83]=o('<p><code>powi</code></p><p>The <code>powi</code> operation takes a <code>base</code> operand of complex type and a <code>power</code> operand of signed integer type and returns one result of the same type as <code>base</code>. The result is <code>base</code> raised to the power of <code>power</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.powi %b, %c : complex&lt;f32&gt;, i32</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[82]||(e[82]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L742-L754",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",E,[t("summary",null,[e[84]||(e[84]=t("a",{id:"Reactant.MLIR.Dialects.complex.re-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.re-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.re")],-1)),e[85]||(e[85]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[87]||(e[87]=o('<p><code>re</code></p><p>The <code>re</code> op takes a single complex number and extracts the real part.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.re %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[86]||(e[86]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L782-L792",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",S,[t("summary",null,[e[88]||(e[88]=t("a",{id:"Reactant.MLIR.Dialects.complex.rsqrt-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.rsqrt-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.rsqrt")],-1)),e[89]||(e[89]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[91]||(e[91]=o('<p><code>rsqrt</code></p><p>The <code>rsqrt</code> operation computes reciprocal of square root.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.rsqrt %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[90]||(e[90]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L819-L829",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",P,[t("summary",null,[e[92]||(e[92]=t("a",{id:"Reactant.MLIR.Dialects.complex.sign-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.sign-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.sign")],-1)),e[93]||(e[93]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[95]||(e[95]=o('<p><code>sign</code></p><p>The <code>sign</code> op takes a single complex number and computes the sign of it, i.e. <code>y = sign(x) = x / |x|</code> if <code>x != 0</code>, otherwise <code>y = 0</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.sign %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[94]||(e[94]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L856-L867",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",w,[t("summary",null,[e[96]||(e[96]=t("a",{id:"Reactant.MLIR.Dialects.complex.sin-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.sin-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.sin")],-1)),e[97]||(e[97]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[99]||(e[99]=o('<p><code>sin</code></p><p>The <code>sin</code> op takes a single complex number and computes the sine of it, i.e. <code>sin(x)</code>, where <code>x</code> is the input value.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.sin %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[98]||(e[98]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L894-L905",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",N,[t("summary",null,[e[100]||(e[100]=t("a",{id:"Reactant.MLIR.Dialects.complex.sqrt-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.sqrt-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.sqrt")],-1)),e[101]||(e[101]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[103]||(e[103]=o('<p><code>sqrt</code></p><p>The <code>sqrt</code> operation takes a complex number and returns its square root.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.sqrt %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[102]||(e[102]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L932-L942",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",q,[t("summary",null,[e[104]||(e[104]=t("a",{id:"Reactant.MLIR.Dialects.complex.sub-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.sub-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.sub")],-1)),e[105]||(e[105]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[107]||(e[107]=o('<p><code>sub</code></p><p>The <code>sub</code> operation takes two complex numbers and returns their difference.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.sub %b, %c : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[106]||(e[106]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L969-L979",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",O,[t("summary",null,[e[108]||(e[108]=t("a",{id:"Reactant.MLIR.Dialects.complex.tan-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.tan-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.tan")],-1)),e[109]||(e[109]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[111]||(e[111]=o('<p><code>tan</code></p><p>The <code>tan</code> op takes a single complex number and computes the tangent of it, i.e. <code>tan(x)</code>, where <code>x</code> is the input value.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.tan %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[110]||(e[110]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L1007-L1018",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",z,[t("summary",null,[e[112]||(e[112]=t("a",{id:"Reactant.MLIR.Dialects.complex.tanh-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.complex.tanh-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.complex.tanh")],-1)),e[113]||(e[113]=s()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[115]||(e[115]=o('<p><code>tanh</code></p><p>The <code>tanh</code> operation takes a complex number and returns its hyperbolic tangent.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%a = complex.tanh %b : complex&lt;f32&gt;</span></span></code></pre></div>',4)),l(a,{type:"info",class:"source-link",text:"source"},{default:n(()=>[...e[114]||(e[114]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/abe7e2a444b543f2b4ecd2d0d87ce623b6d657f7/src/mlir/Dialects/Complex.jl#L1045-L1056",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const Q=p(r,[["render",B]]);export{K as __pageData,Q as default};
