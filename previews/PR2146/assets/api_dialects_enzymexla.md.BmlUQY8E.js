import{_ as i,C as r,c as u,o as p,j as t,a as n,G as l,w as s,al as o}from"./chunks/framework.DNwc0rid.js";const C=JSON.parse('{"title":"EnzymeXLA Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/enzymexla.md","filePath":"api/dialects/enzymexla.md","lastUpdated":null}'),d={name:"api/dialects/enzymexla.md"},m={class:"jldocstring custom-block"},c={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},M={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},x={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"};function k(z,e,A,D,T,V){const a=r("Badge");return p(),u("div",null,[e[67]||(e[67]=t("h1",{id:"EnzymeXLA-Dialect",tabindex:"-1"},[n("EnzymeXLA Dialect "),t("a",{class:"header-anchor",href:"#EnzymeXLA-Dialect","aria-label":'Permalink to "EnzymeXLA Dialect {#EnzymeXLA-Dialect}"'},"â€‹")],-1)),t("details",m,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.blas_symm-NTuple{5, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.blas_symm-NTuple{5, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.blas_symm")],-1)),e[1]||(e[1]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=t("p",null,[t("code",null,"blas_symm")],-1)),e[4]||(e[4]=t("p",null,'C := alpha_A_B + beta_C, or C := alpha_B_A + beta_C, where alpha and beta are scalars, A is a symmetric matrix"',-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L1587-L1591",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",c,[t("summary",null,[e[5]||(e[5]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.blas_syrk-NTuple{4, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.blas_syrk-NTuple{4, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.blas_syrk")],-1)),e[6]||(e[6]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[8]||(e[8]=o("<p><code>blas_syrk</code></p><p>C_out := alpha_A_A^T + beta<em>C, or C_out := alpha_A^T_A + beta</em>C, where alpha and beta are scalars. C must be a n x n symmetric matrix.</p><p><code>output_uplo</code> determines which part of <code>C_out</code> is populated. Accessing the values in the non-<code>output_uplo</code> part of the matrix is undefined behavior.</p><p>LAPACK/BLAS routines typically require a single <code>uplo</code> attribute and it is implicitly assumed that the output <code>uplo</code> corresponds to the input <code>uplo</code>. This means the burden lies on the user to manually copy data if they need to access the other half of the matrix. By specifying the <code>output_uplo</code> we can perform transformations that analyze the entire dataflow, and avoid computing/copying half of the tensor all together. Generally, it is recommended to set this attribute to <code>enzymexla::LapackUplo::F</code>, and our passes will automatically refine this to minimize data copies.</p>",4)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[7]||(e[7]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L1621-L1637",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",R,[t("summary",null,[e[9]||(e[9]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.blas_trmm-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.blas_trmm-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.blas_trmm")],-1)),e[10]||(e[10]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[12]||(e[12]=t("p",null,[t("code",null,"blas_trmm")],-1)),e[13]||(e[13]=t("p",null,"B := alpha * op(A) x B, or B := alpha * B x op(A), where alpha is a scalar, B is a m x n matrix, A is a unit, or non-unit, upper or lower triangular matrix, and op(A) is one of op(A) = A, or op(A) = A^T or A^H.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[11]||(e[11]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L1670-L1676",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[14]||(e[14]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.gpu_wrapper-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzymexla.gpu_wrapper-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.gpu_wrapper")],-1)),e[15]||(e[15]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[17]||(e[17]=t("p",null,[t("code",null,"gpu_wrapper")],-1)),e[18]||(e[18]=t("p",null,"The optional arguments to this operation are suggestions about what block dimensions this gpu kernel should have - usually taken f rom kernel launch params",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[16]||(e[16]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L484-L490",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b,[t("summary",null,[e[19]||(e[19]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_gemqrt-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_gemqrt-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_gemqrt")],-1)),e[20]||(e[20]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[22]||(e[22]=t("p",null,[t("code",null,"lapack_gemqrt")],-1)),e[23]||(e[23]=t("p",null,"This operation is modeled after LAPACK's *GEMQR routines.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[21]||(e[21]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L537-L541",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y,[t("summary",null,[e[24]||(e[24]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_geqrf-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_geqrf-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_geqrf")],-1)),e[25]||(e[25]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[27]||(e[27]=t("p",null,[t("code",null,"lapack_geqrf")],-1)),e[28]||(e[28]=t("p",null,"This operation computes the QR factorization of a matrix using Householder reflections. Mathematically, it decomposes A into the product of an orthogonal matri x Q and an upper triangular matrix R, such that A = QR.",-1)),e[29]||(e[29]=t("p",null,"This operation is modeled after LAPACK's *GEQRF routines, which returns the result in the QR packed format.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[26]||(e[26]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L570-L580",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I,[t("summary",null,[e[30]||(e[30]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_geqrt-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_geqrt-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_geqrt")],-1)),e[31]||(e[31]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[33]||(e[33]=t("p",null,[t("code",null,"lapack_geqrt")],-1)),e[34]||(e[34]=t("p",null,"This operation computes the QR factorization of a matrix using Householder reflections. Mathematically, it decomposes A into the product of an orthogonal matrix Q and an upper triangular matrix R, such that A = QR.",-1)),e[35]||(e[35]=t("p",null,"This operation is modeled after LAPACK's *GEQRT routines, which returns the result in the QR CompactWY format.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[32]||(e[32]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L602-L611",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",L,[t("summary",null,[e[36]||(e[36]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_orgqr-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_orgqr-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_orgqr")],-1)),e[37]||(e[37]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[39]||(e[39]=t("p",null,[t("code",null,"lapack_orgqr")],-1)),e[40]||(e[40]=t("p",null,"This operation is modeled after LAPACK's _ORGQR/_UNGQR routines.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[38]||(e[38]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L1296-L1300",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",M,[t("summary",null,[e[41]||(e[41]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_ormqr-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_ormqr-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_ormqr")],-1)),e[42]||(e[42]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[44]||(e[44]=t("p",null,[t("code",null,"lapack_ormqr")],-1)),e[45]||(e[45]=t("p",null,"This operation is modeled after LAPACK's *ORMQR routines.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[43]||(e[43]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L1320-L1324",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[46]||(e[46]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.linalg_qr-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.linalg_qr-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.linalg_qr")],-1)),e[47]||(e[47]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[49]||(e[49]=t("p",null,[t("code",null,"linalg_qr")],-1)),e[50]||(e[50]=t("p",null,"This operation computes the QR factorization of a matrix using Householder reflections. Mathematically, it decomposes A into the product of an orthogonal (unitary if complex) matrix Q and an upper triangular matrix R, such that A = QR.",-1)),e[51]||(e[51]=t("p",null,"If A has size m x n and m > n, Q is an m x n isometric matrix. If m < n, R will be a m x n trapezoidal matrix.",-1)),e[52]||(e[52]=t("p",null,"This operation is modeled after the mathematical formulation of the QR factorization, and not after LAPACK's compact formats.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[48]||(e[48]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L1391-L1404",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",x,[t("summary",null,[e[53]||(e[53]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.memcpy-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.memcpy-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.memcpy")],-1)),e[54]||(e[54]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[56]||(e[56]=o('<p><code>memcpy</code></p><p>The <code>gpu.memcpy</code> operation copies the content of one memref to another.</p><p>The op does not execute before all async dependencies have finished executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.memcpy async [%dep] %dst, %src : memref&lt;?xf32, 1&gt;, memref&lt;?xf32&gt;</span></span></code></pre></div>',6)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[55]||(e[55]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L1213-L1230",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",j,[t("summary",null,[e[57]||(e[57]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.special_besselh-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.special_besselh-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.special_besselh")],-1)),e[58]||(e[58]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[60]||(e[60]=t("p",null,[t("code",null,"special_besselh")],-1)),e[61]||(e[61]=t("p",null,"Computes the Bessel function of the third kind, also known as the Hankel function. The parameter k must be either 1 or 2, selecting between Hankel functions of the first kind (H1) and second kind (H2).",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[59]||(e[59]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L94-L100",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",h,[t("summary",null,[e[62]||(e[62]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.special_jinc-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.special_jinc-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.special_jinc")],-1)),e[63]||(e[63]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[65]||(e[65]=t("p",null,[t("code",null,"special_jinc")],-1)),e[66]||(e[66]=t("p",null,"Computes the jinc function, also known as the sombrero or besinc function. It is defined as J1(pi_x) / (2_x) where J1 is the Bessel function of the first kind of order 1. At x=0, the function evaluates to pi/4.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[64]||(e[64]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d203b8453bf0886bfed98f1ea8d75aee58e29993/src/mlir/Dialects/EnzymeXLA.jl#L880-L886",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const q=i(d,[["render",k]]);export{C as __pageData,q as default};
