import{_ as i,C as d,c,o as r,j as t,a,G as n,w as l,al as o}from"./chunks/framework.D8cs_3Gc.js";const M=JSON.parse('{"title":"TPU Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/tpu.md","filePath":"api/dialects/tpu.md","lastUpdated":null}'),u={name:"api/dialects/tpu.md"},p={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"};function I(T,e,y,_,j,v){const s=d("Badge");return r(),c("div",null,[e[32]||(e[32]=t("h1",{id:"TPU-Dialect",tabindex:"-1"},[a("TPU Dialect "),t("a",{class:"header-anchor",href:"#TPU-Dialect","aria-label":'Permalink to "TPU Dialect {#TPU-Dialect}"'},"â€‹")],-1)),e[33]||(e[33]=t("p",null,[a("Refer to the "),t("a",{href:"https://github.com/jax-ml/jax/blob/main/jaxlib/mosaic/dialect/tpu/tpu.td",target:"_blank",rel:"noreferrer"},"official documentation"),a(" for more details.")],-1)),t("details",p,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.tpu.broadcast_in_sublanes-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.broadcast_in_sublanes-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.broadcast_in_sublanes")],-1)),e[1]||(e[1]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=t("p",null,[t("code",null,"broadcast_in_sublanes")],-1)),e[4]||(e[4]=t("p",null,[a("For each sublane "),t("code",null,"i"),a(", broadcasts the value in lane "),t("code",null,"lane + i"),a(" along the entire sublane. If "),t("code",null,"lane + i"),a(" is not in [0, lane_count), then the value in sublane "),t("code",null,"i"),a(" is not defined (can be anything).")],-1)),n(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/b60a97370fe7b985e50d4d709270191090b6e1b1/src/mlir/Dialects/TPU.jl#L133-L139",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b,[t("summary",null,[e[5]||(e[5]=t("a",{id:"Reactant.MLIR.Dialects.tpu.create_subelement_mask-Tuple{}",href:"#Reactant.MLIR.Dialects.tpu.create_subelement_mask-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.create_subelement_mask")],-1)),e[6]||(e[6]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[8]||(e[8]=o('<p><code>create_subelement_mask</code></p><p>The &quot;half-sublanes&quot;, &quot;quarter-sublanes&quot;, etc. (unit is determined by the type of <code>output</code>) of the mask are masked in the range specified by <code>from</code> and <code>to</code>.</p><ul><li><p>If <code>from &lt;= to</code>, the range <code>[from, to)</code> is set and the rest is unset.</p></li><li><p>If <code>to &lt;= from</code>, the range <code>[to, from)</code> is unset and the rest is set.</p></li></ul><p>All lanes are set identically.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%msk = tpu.create_subelement_mask 3, 9 : vector&lt;8x128x2xi1&gt;</span></span></code></pre></div><p>This creates a mask <code>%msk</code> where, for all <code>lane</code>s, <code>%msk[*][lane][*]</code> is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[[0, 0], [0, 1], [1, 1], [1, 1], [1, 0], [0, 0], [0, 0], [0, 0]]</span></span></code></pre></div><p>It is currently only supported:</p><ul><li><p>In TPU v4, for <code>num_subelems</code> of 1 and 2.</p></li><li><p>In TPU v5, for <code>num_subelems</code> of 1, 2, and 4.</p></li></ul>',10)),n(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[7]||(e[7]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/b60a97370fe7b985e50d4d709270191090b6e1b1/src/mlir/Dialects/TPU.jl#L205-L232",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",m,[t("summary",null,[e[9]||(e[9]=t("a",{id:"Reactant.MLIR.Dialects.tpu.dynamic_gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.dynamic_gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.dynamic_gather")],-1)),e[10]||(e[10]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[12]||(e[12]=o("<p><code>dynamic_gather</code></p><p>Gathers elements from <code>source</code> using <code>indices</code>.</p><p>The specified <code>dimensions</code> of <code>source</code> are collapsed together and indexed by <code>indices</code>.</p><p>Given a shape <code>N0 x N1 x ...</code>, the <code>output[i0, i1, ...]</code> is given by <code>collapsed_source[j0, j1, ..., indices[i0, i1, ...] mod M]</code> where</p><ul><li><p><code>collapsed_source</code> is the result of collapsing <code>dimensions</code> of <code>source</code> into a new trailing dimension of size <code>M</code>.</p></li><li><p><code>jk</code> is the subsequence of <code>in</code> for <code>n</code> not in <code>dimensions</code>.</p></li></ul><p>When a single dimension is specified, this is similar to <code>np.take_along_axis</code>.</p>",6)),n(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[11]||(e[11]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/b60a97370fe7b985e50d4d709270191090b6e1b1/src/mlir/Dialects/TPU.jl#L291-L307",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[13]||(e[13]=t("a",{id:"Reactant.MLIR.Dialects.tpu.iota-Tuple{}",href:"#Reactant.MLIR.Dialects.tpu.iota-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.iota")],-1)),e[14]||(e[14]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[16]||(e[16]=o(`<p><code>iota</code></p><p>Creates a vector that with values that start at 0 and increase along a dimension resulting from collapsing the given <code>dimensions</code> together in row-major order.</p><p><strong>Example</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>tpu.iota {dimensions = array&lt;i32: 2, 0&gt;} : vector&lt;4x3x2xi16&gt;</span></span></code></pre></div><p>This produces a vector with the following values:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[[[0, 4], [0, 4], [0, 4]]</span></span>
<span class="line"><span> [[1, 5], [1, 5], [1, 5]]</span></span>
<span class="line"><span> [[2, 6], [2, 6], [2, 6]]</span></span>
<span class="line"><span> [[3, 7], [3, 7], [3, 7]]]</span></span></code></pre></div>`,6)),n(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[15]||(e[15]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/b60a97370fe7b985e50d4d709270191090b6e1b1/src/mlir/Dialects/TPU.jl#L579-L597",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",R,[t("summary",null,[e[17]||(e[17]=t("a",{id:"Reactant.MLIR.Dialects.tpu.load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tpu.load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.load")],-1)),e[18]||(e[18]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[20]||(e[20]=o("<p><code>load</code></p><p>Similar to <code>vector::LoadOp</code> but with <code>sublane_mask</code> and <code>sublane_stride</code>. When <code>indices</code> are negative, it means loading from negative offset of <code>base</code> address.</p>",2)),n(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[19]||(e[19]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/b60a97370fe7b985e50d4d709270191090b6e1b1/src/mlir/Dialects/TPU.jl#L617-L623",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[21]||(e[21]=t("a",{id:"Reactant.MLIR.Dialects.tpu.rotate-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.rotate-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.rotate")],-1)),e[22]||(e[22]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[24]||(e[24]=t("p",null,[t("code",null,"rotate")],-1)),e[25]||(e[25]=t("p",null,[a("Rotates the given vector by the given amount in the given dimension, i.e., for a 2D vector of shape (m, n), rotating dim 0 by "),t("code",null,"amount"),a(" will shift a row at index "),t("code",null,"i"),a(" to index "),t("code",null,"(i + amount) % m")],-1)),n(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[23]||(e[23]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/b60a97370fe7b985e50d4d709270191090b6e1b1/src/mlir/Dialects/TPU.jl#L1071-L1077",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",h,[t("summary",null,[e[26]||(e[26]=t("a",{id:"Reactant.MLIR.Dialects.tpu.scan_count-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.scan_count-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.scan_count")],-1)),e[27]||(e[27]=a()),n(s,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[29]||(e[29]=t("p",null,[t("code",null,"scan_count")],-1)),e[30]||(e[30]=t("p",null,"ScanCountOp calculates the running duplicate occurrence count of the elements in the input vector, %values. The output vector, %counts, contains the running duplicate occurrence count for the corresponding element in the input vector, where the count is performed in ascending order of element indices. For example, if the elements of %values at indices 0, 5, and 7 had duplicate values, then the elements of %counts at indices 0, 5, and 7 would be 1, 2, and 3, respectively.",-1)),e[31]||(e[31]=t("p",null,"A mask vector, %in_mask, specifies which of the elements in the input vector are eligible for counting. An element in %values that has its mask set to 0 will always have a count of 1 in %counts, regardless of the position in the vector, or whether there were duplicates or not.",-1)),n(s,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[28]||(e[28]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/b60a97370fe7b985e50d4d709270191090b6e1b1/src/mlir/Dialects/TPU.jl#L1130-L1145",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const L=i(u,[["render",I]]);export{M as __pageData,L as default};
