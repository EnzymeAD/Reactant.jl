import{_ as o,C as r,c as i,o as u,j as t,a as n,G as l,w as s,al as p}from"./chunks/framework.CSMik11j.js";const h=JSON.parse('{"title":"EnzymeXLA Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/enzymexla.md","filePath":"api/dialects/enzymexla.md","lastUpdated":null}'),m={name:"api/dialects/enzymexla.md"},c={class:"jldocstring custom-block"},d={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"};function M(x,e,k,j,z,D){const a=r("Badge");return u(),i("div",null,[e[48]||(e[48]=t("h1",{id:"EnzymeXLA-Dialect",tabindex:"-1"},[n("EnzymeXLA Dialect "),t("a",{class:"header-anchor",href:"#EnzymeXLA-Dialect","aria-label":'Permalink to "EnzymeXLA Dialect {#EnzymeXLA-Dialect}"'},"â€‹")],-1)),t("details",c,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.gpu_wrapper-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzymexla.gpu_wrapper-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.gpu_wrapper")],-1)),e[1]||(e[1]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=t("p",null,[t("code",null,"gpu_wrapper")],-1)),e[4]||(e[4]=t("p",null,"The optional arguments to this operation are suggestions about what block dimensions this gpu kernel should have - usually taken from kernel launch params",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/a20bf4d9db6e85c28681379e09e2601e4c149d68/src/mlir/Dialects/EnzymeXLA.jl#L239-L245",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",d,[t("summary",null,[e[5]||(e[5]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_gemqrt-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_gemqrt-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_gemqrt")],-1)),e[6]||(e[6]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[8]||(e[8]=t("p",null,[t("code",null,"lapack_gemqrt")],-1)),e[9]||(e[9]=t("p",null,"This operation is modeled after LAPACK's *GEMQR routines.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[7]||(e[7]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/a20bf4d9db6e85c28681379e09e2601e4c149d68/src/mlir/Dialects/EnzymeXLA.jl#L292-L296",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",R,[t("summary",null,[e[10]||(e[10]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_geqrf-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_geqrf-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_geqrf")],-1)),e[11]||(e[11]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[13]||(e[13]=t("p",null,[t("code",null,"lapack_geqrf")],-1)),e[14]||(e[14]=t("p",null,"This operation computes the QR factorization of a matrix using Householder reflections. Mathematically, it decomposes A into the product of an orthogonal matrix Q and an upper triangular matrix R, such that A = QR.",-1)),e[15]||(e[15]=t("p",null,"This operation is modeled after LAPACK's *GEQRF routines, which returns the result in the QR packed format.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[12]||(e[12]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/a20bf4d9db6e85c28681379e09e2601e4c149d68/src/mlir/Dialects/EnzymeXLA.jl#L325-L334",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y,[t("summary",null,[e[16]||(e[16]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_geqrt-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_geqrt-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_geqrt")],-1)),e[17]||(e[17]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[19]||(e[19]=t("p",null,[t("code",null,"lapack_geqrt")],-1)),e[20]||(e[20]=t("p",null,"This operation computes the QR factorization of a matrix using Householder reflections. Mathematically, it decomposes A into the product of an orthogonal matrix Q and an upper triangular matrix R, such that A = QR.",-1)),e[21]||(e[21]=t("p",null,"This operation is modeled after LAPACK's *GEQRT routines, which returns the result in the QR CompactWY format.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[18]||(e[18]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/a20bf4d9db6e85c28681379e09e2601e4c149d68/src/mlir/Dialects/EnzymeXLA.jl#L356-L365",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[22]||(e[22]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_orgqr-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_orgqr-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_orgqr")],-1)),e[23]||(e[23]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[25]||(e[25]=t("p",null,[t("code",null,"lapack_orgqr")],-1)),e[26]||(e[26]=t("p",null,"This operation is modeled after LAPACK's _ORGQR/_UNGQR routines.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[24]||(e[24]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/a20bf4d9db6e85c28681379e09e2601e4c149d68/src/mlir/Dialects/EnzymeXLA.jl#L614-L618",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I,[t("summary",null,[e[27]||(e[27]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_ormqr-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_ormqr-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_ormqr")],-1)),e[28]||(e[28]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[30]||(e[30]=t("p",null,[t("code",null,"lapack_ormqr")],-1)),e[31]||(e[31]=t("p",null,"This operation is modeled after LAPACK's *ORMQR routines.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[29]||(e[29]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/a20bf4d9db6e85c28681379e09e2601e4c149d68/src/mlir/Dialects/EnzymeXLA.jl#L638-L642",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",L,[t("summary",null,[e[32]||(e[32]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.lapack_symm-NTuple{5, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.lapack_symm-NTuple{5, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.lapack_symm")],-1)),e[33]||(e[33]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[35]||(e[35]=t("p",null,[t("code",null,"lapack_symm")],-1)),e[36]||(e[36]=t("p",null,'C := alpha_A_B + beta_C, or C := alpha_B_A + beta_C, where alpha and beta are scalars, A is a symmetric matrix"',-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[34]||(e[34]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/a20bf4d9db6e85c28681379e09e2601e4c149d68/src/mlir/Dialects/EnzymeXLA.jl#L840-L844",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b,[t("summary",null,[e[37]||(e[37]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.linalg_qr-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.linalg_qr-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.linalg_qr")],-1)),e[38]||(e[38]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[40]||(e[40]=t("p",null,[t("code",null,"linalg_qr")],-1)),e[41]||(e[41]=t("p",null,"This operation computes the QR factorization of a matrix using Householder reflections. Mathematically, it decomposes A into the product of an orthogonal (unitary if complex) matrix Q and an upper triangular matrix R, such that A = QR.",-1)),e[42]||(e[42]=t("p",null,"If A has size m x n and m > n, Q is an m x n isometric matrix. If m < n, R will be a m x n trapezoidal matrix.",-1)),e[43]||(e[43]=t("p",null,"This operation is modeled after the mathematical formulation of the QR factorization, and not after LAPACK's compact formats.",-1)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[39]||(e[39]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/a20bf4d9db6e85c28681379e09e2601e4c149d68/src/mlir/Dialects/EnzymeXLA.jl#L709-L722",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[44]||(e[44]=t("a",{id:"Reactant.MLIR.Dialects.enzymexla.memcpy-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzymexla.memcpy-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzymexla.memcpy")],-1)),e[45]||(e[45]=n()),l(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[47]||(e[47]=p('<p><code>memcpy</code></p><p>The <code>gpu.memcpy</code> operation copies the content of one memref to another.</p><p>The op does not execute before all async dependencies have finished executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e. it does not block until the execution has finished on the device). In that case, it returns a !gpu.async.token.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%token = gpu.memcpy async [%dep] %dst, %src : memref&lt;?xf32, 1&gt;, memref&lt;?xf32&gt;</span></span></code></pre></div>',6)),l(a,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[46]||(e[46]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/a20bf4d9db6e85c28681379e09e2601e4c149d68/src/mlir/Dialects/EnzymeXLA.jl#L531-L548",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const T=o(m,[["render",M]]);export{h as __pageData,T as default};
