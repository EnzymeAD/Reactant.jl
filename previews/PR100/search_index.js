var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Types-and-constants","page":"API reference","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [Reactant, Reactant.XLA, Reactant.MLIR, Reactant.MLIR.API, Reactant.MLIR.IR, Reactant.MLIR.Dialects.chlo, Reactant.MLIR.Dialects.vhlo, Reactant.MLIR.Dialects.stablehlo, Reactant.MLIR.Dialects.enzyme, Reactant.MLIR.Dialects.arith, Reactant.MLIR.Dialects.func, Reactant.MLIR.Dialects.affine, Reactant.MLIR.Dialects.builtin]\nOrder = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API reference","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [Reactant, Reactant.XLA, Reactant.MLIR, Reactant.MLIR.API, Reactant.MLIR.IR, Reactant.MLIR.Dialects.chlo, Reactant.MLIR.Dialects.vhlo, Reactant.MLIR.Dialects.stablehlo, Reactant.MLIR.Dialects.enzyme, Reactant.MLIR.Dialects.arith, Reactant.MLIR.Dialects.func, Reactant.MLIR.Dialects.affine, Reactant.MLIR.Dialects.builtin]\nOrder = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API reference","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [Reactant, Reactant.XLA, Reactant.MLIR, Reactant.MLIR.API, Reactant.MLIR.IR, Reactant.MLIR.Dialects.chlo, Reactant.MLIR.Dialects.vhlo, Reactant.MLIR.Dialects.stablehlo, Reactant.MLIR.Dialects.enzyme, Reactant.MLIR.Dialects.arith, Reactant.MLIR.Dialects.func, Reactant.MLIR.Dialects.affine, Reactant.MLIR.Dialects.builtin]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#Reactant.@code_hlo","page":"API reference","title":"Reactant.@code_hlo","text":"@code_hlo [optimize = ...] f(args...)\n\n\n\n\n\n","category":"macro"},{"location":"api/#Reactant.MLIR.API.LLVMAttributeRef","page":"API reference","title":"Reactant.MLIR.API.LLVMAttributeRef","text":"Used to represent an attributes.\n\nSee also\n\nllvm::Attribute\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMBasicBlockRef","page":"API reference","title":"Reactant.MLIR.API.LLVMBasicBlockRef","text":"Represents a basic block of instructions in LLVM IR.\n\nThis models llvm::BasicBlock.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMBinaryRef","page":"API reference","title":"Reactant.MLIR.API.LLVMBinaryRef","text":"See also\n\nllvm::object::Binary\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMBool","page":"API reference","title":"Reactant.MLIR.API.LLVMBool","text":"LLVMCSupportTypes Types and Enumerations\n\n@{\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMBuilderRef","page":"API reference","title":"Reactant.MLIR.API.LLVMBuilderRef","text":"Represents an LLVM basic block builder.\n\nThis models llvm::IRBuilder.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMComdatRef","page":"API reference","title":"Reactant.MLIR.API.LLVMComdatRef","text":"See also\n\nllvm::Comdat\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMContextRef","page":"API reference","title":"Reactant.MLIR.API.LLVMContextRef","text":"The top-level container for all LLVM global data. See the LLVMContext class.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMDIBuilderRef","page":"API reference","title":"Reactant.MLIR.API.LLVMDIBuilderRef","text":"Represents an LLVM debug info builder.\n\nThis models llvm::DIBuilder.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMDbgRecordRef","page":"API reference","title":"Reactant.MLIR.API.LLVMDbgRecordRef","text":"See also\n\nllvm::DbgRecord\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMDiagnosticInfoRef","page":"API reference","title":"Reactant.MLIR.API.LLVMDiagnosticInfoRef","text":"See also\n\nllvm::DiagnosticInfo\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMJITEventListenerRef","page":"API reference","title":"Reactant.MLIR.API.LLVMJITEventListenerRef","text":"See also\n\nllvm::JITEventListener\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMMemoryBufferRef","page":"API reference","title":"Reactant.MLIR.API.LLVMMemoryBufferRef","text":"Used to pass regions of memory through LLVM interfaces.\n\nSee also\n\nllvm::MemoryBuffer\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMMetadataRef","page":"API reference","title":"Reactant.MLIR.API.LLVMMetadataRef","text":"Represents an LLVM Metadata.\n\nThis models llvm::Metadata.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMModuleFlagEntry","page":"API reference","title":"Reactant.MLIR.API.LLVMModuleFlagEntry","text":"See also\n\nllvm::Module::ModuleFlagEntry\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMModuleProviderRef","page":"API reference","title":"Reactant.MLIR.API.LLVMModuleProviderRef","text":"Interface used to provide a module to JIT or interpreter. This is now just a synonym for llvm::Module, but we have to keep using the different type to keep binary compatibility.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMModuleRef","page":"API reference","title":"Reactant.MLIR.API.LLVMModuleRef","text":"The top-level container for all other LLVM Intermediate Representation (IR) objects.\n\nSee also\n\nllvm::Module\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMNamedMDNodeRef","page":"API reference","title":"Reactant.MLIR.API.LLVMNamedMDNodeRef","text":"Represents an LLVM Named Metadata Node.\n\nThis models llvm::NamedMDNode.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMOperandBundleRef","page":"API reference","title":"Reactant.MLIR.API.LLVMOperandBundleRef","text":"See also\n\nllvm::OperandBundleDef\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMPassManagerRef","page":"API reference","title":"Reactant.MLIR.API.LLVMPassManagerRef","text":"See also\n\nllvm::PassManagerBase\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMTypeRef","page":"API reference","title":"Reactant.MLIR.API.LLVMTypeRef","text":"Each value in the LLVM IR has a type, an LLVMTypeRef.\n\nSee also\n\nllvm::Type\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMUseRef","page":"API reference","title":"Reactant.MLIR.API.LLVMUseRef","text":"Used to get the users and usees of a Value.\n\nSee also\n\nllvm::Use\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMValueMetadataEntry","page":"API reference","title":"Reactant.MLIR.API.LLVMValueMetadataEntry","text":"Represents an entry in a Global Object's metadata attachments.\n\nThis models std::pair<unsigned, MDNode *>\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMValueRef","page":"API reference","title":"Reactant.MLIR.API.LLVMValueRef","text":"Represents an individual value in LLVM IR.\n\nThis models llvm::Value.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirDiagnostic","page":"API reference","title":"Reactant.MLIR.API.MlirDiagnostic","text":"MlirDiagnostic\n\nAn opaque reference to a diagnostic, always owned by the diagnostics engine (context). Must not be stored outside of the diagnostic handler.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirDiagnosticHandler","page":"API reference","title":"Reactant.MLIR.API.MlirDiagnosticHandler","text":"Diagnostic handler type. Accepts a reference to a diagnostic, which is only guaranteed to be live during the call. The handler is passed the userData that was provided when the handler was attached to a context. If the handler processed the diagnostic completely, it is expected to return success. Otherwise, it is expected to return failure to indicate that other handlers should attempt to process the diagnostic.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirDiagnosticHandlerID","page":"API reference","title":"Reactant.MLIR.API.MlirDiagnosticHandlerID","text":"Opaque identifier of a diagnostic handler, useful to detach a handler.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirDiagnosticSeverity","page":"API reference","title":"Reactant.MLIR.API.MlirDiagnosticSeverity","text":"MlirDiagnosticSeverity\n\nSeverity of a diagnostic.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirExternalPassCallbacks","page":"API reference","title":"Reactant.MLIR.API.MlirExternalPassCallbacks","text":"MlirExternalPassCallbacks\n\nStructure of external MlirPass callbacks. All callbacks are required to be set unless otherwise specified.\n\nField Note\nconstruct This callback is called from the pass is created. This is analogous to a C++ pass constructor.\ndestruct This callback is called when the pass is destroyed This is analogous to a C++ pass destructor.\ninitialize This callback is optional. The callback is called before the pass is run, allowing a chance to initialize any complex state necessary for running the pass. See Pass::initialize(MLIRContext *).\nclone This callback is called when the pass is cloned. See Pass::clonePass().\nrun This callback is called when the pass is run. See Pass::runOnOperation().\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirLlvmThreadPool","page":"API reference","title":"Reactant.MLIR.API.MlirLlvmThreadPool","text":"MlirLlvmThreadPool\n\nRe-export llvm::ThreadPool so as to avoid including the LLVM C API directly.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirLogicalResult","page":"API reference","title":"Reactant.MLIR.API.MlirLogicalResult","text":"MlirLogicalResult\n\nA logical result value, essentially a boolean with named states. LLVM convention for using boolean values to designate success or failure of an operation is a moving target, so MLIR opted for an explicit class. Instances of MlirLogicalResult must only be inspected using the associated functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirNamedAttribute","page":"API reference","title":"Reactant.MLIR.API.MlirNamedAttribute","text":"MlirNamedAttribute\n\nNamed MLIR attribute.\n\nA named attribute is essentially a (name, attribute) pair where the name is a string.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirOperationState","page":"API reference","title":"Reactant.MLIR.API.MlirOperationState","text":"MlirOperationState\n\nAn auxiliary class for constructing operations.\n\nThis class contains all the information necessary to construct the operation. It owns the MlirRegions it has pointers to and does not own anything else. By default, the state can be constructed from a name and location, the latter being also used to access the context, and has no other components. These components can be added progressively until the operation is constructed. Users are not expected to rely on the internals of this class and should use mlirOperationState* functions instead.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirOperationWalkCallback","page":"API reference","title":"Reactant.MLIR.API.MlirOperationWalkCallback","text":"Operation walker type. The handler is passed an (opaque) reference to an operation and a pointer to a userData.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirShapedTypeComponentsCallback","page":"API reference","title":"Reactant.MLIR.API.MlirShapedTypeComponentsCallback","text":"These callbacks are used to return multiple shaped type components from functions while transferring ownership to the caller. The first argument is the has rank boolean followed by the the rank and a pointer to the shape (if applicable). The next argument is the element type, then the attribute. The last argument is an opaque pointer forwarded to the callback by the caller. This callback will be called potentially multiple times for each shaped type components.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirSparseTensorLevelType","page":"API reference","title":"Reactant.MLIR.API.MlirSparseTensorLevelType","text":"Dimension level types (and properties) that define sparse tensors. See the documentation in SparseTensorAttrDefs.td for their meaning.\n\nThese correspond to SparseTensorEncodingAttr::LevelType in the C++ API. If updating, keep them in sync and update the static_assert in the impl file.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirStringCallback","page":"API reference","title":"Reactant.MLIR.API.MlirStringCallback","text":"A callback for returning string references.\n\nThis function is called back by the functions that need to return a reference to the portion of the string with the following arguments: - an MlirStringRef representing the current portion of the string - a pointer to user data forwarded from the printing call.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirStringRef","page":"API reference","title":"Reactant.MLIR.API.MlirStringRef","text":"MlirStringRef\n\nA pointer to a sized fragment of a string, not necessarily null-terminated. Does not own the underlying string. This is equivalent to llvm::StringRef.\n\nField Note\ndata Pointer to the first symbol.\nlength Length of the fragment.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirTypesCallback","page":"API reference","title":"Reactant.MLIR.API.MlirTypesCallback","text":"These callbacks are used to return multiple types from functions while transferring ownership to the caller. The first argument is the number of consecutive elements pointed to by the second argument. The third argument is an opaque pointer forwarded to the callback by the caller.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.MlirWalkOrder","page":"API reference","title":"Reactant.MLIR.API.MlirWalkOrder","text":"MlirWalkOrder\n\nTraversal order for operation walk.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.API.LLVMAddSymbol-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.LLVMAddSymbol","text":"LLVMAddSymbol(symbolName, symbolValue)\n\nThis functions permanently adds the symbol symbolName with the value symbolValue. These symbols are searched before any libraries.\n\nSee also\n\nsys::DynamicLibrary::AddSymbol()\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.LLVMLoadLibraryPermanently-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.LLVMLoadLibraryPermanently","text":"LLVMLoadLibraryPermanently(Filename)\n\nThis function permanently loads the dynamic library at the given path. It is safe to call this function multiple times for the same library.\n\nSee also\n\nsys::DynamicLibrary::LoadLibraryPermanently()\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.LLVMParseCommandLineOptions-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.LLVMParseCommandLineOptions","text":"LLVMParseCommandLineOptions(argc, argv, Overview)\n\nThis function parses the given arguments using the LLVM command line parser. Note that the only stable thing about this function is its signature; you cannot rely on any particular set of command line arguments being interpreted the same way across LLVM versions.\n\nSee also\n\nllvm::cl::ParseCommandLineOptions()\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.LLVMSearchForAddressOfSymbol-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.LLVMSearchForAddressOfSymbol","text":"LLVMSearchForAddressOfSymbol(symbolName)\n\nThis function will search through all previously loaded dynamic libraries for the symbol symbolName. If it is found, the address of that symbol is returned. If not, null is returned.\n\nSee also\n\nsys::DynamicLibrary::SearchForAddressOfSymbol()\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineAddExprGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineAddExprGet","text":"mlirAffineAddExprGet(lhs, rhs)\n\nCreates an affine add expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineBinaryOpExprGetLHS-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineBinaryOpExprGetLHS","text":"mlirAffineBinaryOpExprGetLHS(affineExpr)\n\nReturns the left hand side affine expression of the given affine binary operation expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineBinaryOpExprGetRHS-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineBinaryOpExprGetRHS","text":"mlirAffineBinaryOpExprGetRHS(affineExpr)\n\nReturns the right hand side affine expression of the given affine binary operation expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineCeilDivExprGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineCeilDivExprGet","text":"mlirAffineCeilDivExprGet(lhs, rhs)\n\nCreates an affine ceildiv expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineConstantExprGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineConstantExprGet","text":"mlirAffineConstantExprGet(ctx, constant)\n\nCreates an affine constant expression with 'constant' in the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineConstantExprGetValue-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineConstantExprGetValue","text":"mlirAffineConstantExprGetValue(affineExpr)\n\nReturns the value of the given affine constant expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineDimExprGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineDimExprGet","text":"mlirAffineDimExprGet(ctx, position)\n\nCreates an affine dimension expression with 'position' in the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineDimExprGetPosition-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineDimExprGetPosition","text":"mlirAffineDimExprGetPosition(affineExpr)\n\nReturns the position of the given affine dimension expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprCompose-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprCompose","text":"mlirAffineExprCompose(affineExpr, affineMap)\n\nComposes the given map with the given expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprDump-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprDump","text":"mlirAffineExprDump(affineExpr)\n\nPrints the affine expression to the standard error stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprEqual","text":"mlirAffineExprEqual(lhs, rhs)\n\nReturns true if the two affine expressions are equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprGetContext-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprGetContext","text":"mlirAffineExprGetContext(affineExpr)\n\nGets the context that owns the affine expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprGetLargestKnownDivisor-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprGetLargestKnownDivisor","text":"mlirAffineExprGetLargestKnownDivisor(affineExpr)\n\nReturns the greatest known integral divisor of this affine expression. The result is always positive.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsAAdd-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsAAdd","text":"mlirAffineExprIsAAdd(affineExpr)\n\nChecks whether the given affine expression is an add expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsABinary-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsABinary","text":"mlirAffineExprIsABinary(affineExpr)\n\nChecks whether the given affine expression is binary.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsACeilDiv-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsACeilDiv","text":"mlirAffineExprIsACeilDiv(affineExpr)\n\nChecks whether the given affine expression is an ceildiv expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsAConstant-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsAConstant","text":"mlirAffineExprIsAConstant(affineExpr)\n\nChecks whether the given affine expression is a constant expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsADim-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsADim","text":"mlirAffineExprIsADim(affineExpr)\n\nChecks whether the given affine expression is a dimension expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsAFloorDiv-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsAFloorDiv","text":"mlirAffineExprIsAFloorDiv(affineExpr)\n\nChecks whether the given affine expression is an floordiv expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsAMod-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsAMod","text":"mlirAffineExprIsAMod(affineExpr)\n\nChecks whether the given affine expression is an mod expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsAMul-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsAMul","text":"mlirAffineExprIsAMul(affineExpr)\n\nChecks whether the given affine expression is an mul expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsASymbol-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsASymbol","text":"mlirAffineExprIsASymbol(affineExpr)\n\nChecks whether the given affine expression is a symbol expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsFunctionOfDim-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsFunctionOfDim","text":"mlirAffineExprIsFunctionOfDim(affineExpr, position)\n\nChecks whether the given affine expression involves AffineDimExpr 'position'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsMultipleOf-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsMultipleOf","text":"mlirAffineExprIsMultipleOf(affineExpr, factor)\n\nChecks whether the given affine expression is a multiple of 'factor'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsNull","text":"mlirAffineExprIsNull(affineExpr)\n\nReturns true if the given affine expression is a null expression. Note constant zero is not a null expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsPureAffine-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsPureAffine","text":"mlirAffineExprIsPureAffine(affineExpr)\n\nChecks whether the given affine expression is a pure affine expression, i.e. mul, floordiv, ceildic, and mod is only allowed w.r.t constants.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprIsSymbolicOrConstant-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprIsSymbolicOrConstant","text":"mlirAffineExprIsSymbolicOrConstant(affineExpr)\n\nChecks whether the given affine expression is made out of only symbols and constants.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineExprPrint-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineExprPrint","text":"mlirAffineExprPrint(affineExpr, callback, userData)\n\nPrints an affine expression by sending chunks of the string representation and forwarding userData tocallback`. Note that the callback may be called several times with consecutive chunks of the string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineFloorDivExprGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineFloorDivExprGet","text":"mlirAffineFloorDivExprGet(lhs, rhs)\n\nCreates an affine floordiv expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapAttrGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapAttrGet","text":"mlirAffineMapAttrGet(map)\n\nCreates an affine map attribute wrapping the given map. The attribute belongs to the same context as the affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapAttrGetTypeID","text":"mlirAffineMapAttrGetTypeID()\n\nReturns the typeID of an AffineMap attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapAttrGetValue-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapAttrGetValue","text":"mlirAffineMapAttrGetValue(attr)\n\nReturns the affine map wrapped in the given affine map attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapCompressUnusedSymbols-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapCompressUnusedSymbols","text":"mlirAffineMapCompressUnusedSymbols(affineMaps, size, result, populateResult)\n\nReturns the simplified affine map resulting from dropping the symbols that do not appear in any of the individual maps in affineMaps. Asserts that all maps in affineMaps are normalized to the same number of dims and symbols. Takes a callback populateResult to fill the res container with value m at entry idx. This allows returning without worrying about ownership considerations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapConstantGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapConstantGet","text":"mlirAffineMapConstantGet(ctx, val)\n\nCreates a single constant result affine map in the context. The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapDump-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapDump","text":"mlirAffineMapDump(affineMap)\n\nPrints the affine map to the standard error stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapEmptyGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapEmptyGet","text":"mlirAffineMapEmptyGet(ctx)\n\nCreates a zero result affine map with no dimensions or symbols in the context. The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapEqual","text":"mlirAffineMapEqual(a1, a2)\n\nChecks if two affine maps are equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapGet-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapGet","text":"mlirAffineMapGet(ctx, dimCount, symbolCount, nAffineExprs, affineExprs)\n\nCreates an affine map with results defined by the given list of affine expressions. The map resulting map also has the requested number of input dimensions and symbols, regardless of them being used in the results.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapGetContext-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapGetContext","text":"mlirAffineMapGetContext(affineMap)\n\nGets the context that the given affine map was created with\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapGetMajorSubMap-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapGetMajorSubMap","text":"mlirAffineMapGetMajorSubMap(affineMap, numResults)\n\nReturns the affine map consisting of the most major numResults results. Returns the null AffineMap if the numResults is equal to zero. Returns the affineMap if numResults is greater or equals to number of results of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapGetMinorSubMap-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapGetMinorSubMap","text":"mlirAffineMapGetMinorSubMap(affineMap, numResults)\n\nReturns the affine map consisting of the most minor numResults results. Returns the null AffineMap if the numResults is equal to zero. Returns the affineMap if numResults is greater or equals to number of results of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapGetNumDims-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapGetNumDims","text":"mlirAffineMapGetNumDims(affineMap)\n\nReturns the number of dimensions of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapGetNumInputs-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapGetNumInputs","text":"mlirAffineMapGetNumInputs(affineMap)\n\nReturns the number of inputs (dimensions + symbols) of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapGetNumResults-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapGetNumResults","text":"mlirAffineMapGetNumResults(affineMap)\n\nReturns the number of results of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapGetNumSymbols-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapGetNumSymbols","text":"mlirAffineMapGetNumSymbols(affineMap)\n\nReturns the number of symbols of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapGetResult-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapGetResult","text":"mlirAffineMapGetResult(affineMap, pos)\n\nReturns the result at the given position.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapGetSingleConstantResult-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapGetSingleConstantResult","text":"mlirAffineMapGetSingleConstantResult(affineMap)\n\nReturns the constant result of the given affine map. The function asserts that the map has a single constant result.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapGetSubMap-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapGetSubMap","text":"mlirAffineMapGetSubMap(affineMap, size, resultPos)\n\nReturns the affine map consisting of the resultPos subset.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapIsEmpty-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapIsEmpty","text":"mlirAffineMapIsEmpty(affineMap)\n\nChecks whether the given affine map is an empty affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapIsIdentity-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapIsIdentity","text":"mlirAffineMapIsIdentity(affineMap)\n\nChecks whether the given affine map is an identity affine map. The function asserts that the number of dimensions is greater or equal to the number of results.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapIsMinorIdentity-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapIsMinorIdentity","text":"mlirAffineMapIsMinorIdentity(affineMap)\n\nChecks whether the given affine map is a minor identity affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapIsNull","text":"mlirAffineMapIsNull(affineMap)\n\nChecks whether an affine map is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapIsPermutation-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapIsPermutation","text":"mlirAffineMapIsPermutation(affineMap)\n\nChecks whether the given affine map represents a symbol-less permutation map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapIsProjectedPermutation-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapIsProjectedPermutation","text":"mlirAffineMapIsProjectedPermutation(affineMap)\n\nChecks whether the given affine map represents a subset of a symbol-less permutation map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapIsSingleConstant-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapIsSingleConstant","text":"mlirAffineMapIsSingleConstant(affineMap)\n\nChecks whether the given affine map is a single result constant affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapMinorIdentityGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapMinorIdentityGet","text":"mlirAffineMapMinorIdentityGet(ctx, dims, results)\n\nCreates an identity affine map on the most minor dimensions in the context. The affine map is owned by the context. The function asserts that the number of dimensions is greater or equal to the number of results.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapMultiDimIdentityGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapMultiDimIdentityGet","text":"mlirAffineMapMultiDimIdentityGet(ctx, numDims)\n\nCreates an affine map with 'numDims' identity in the context. The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapPermutationGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapPermutationGet","text":"mlirAffineMapPermutationGet(ctx, size, permutation)\n\nCreates an affine map with a permutation expression and its size in the context. The permutation expression is a non-empty vector of integers. The elements of the permutation vector must be continuous from 0 and cannot be repeated (i.e. [1,2,0] is a valid permutation. [2,0] or [1,1,2] is an invalid permutation.) The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapPrint-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapPrint","text":"mlirAffineMapPrint(affineMap, callback, userData)\n\nPrints an affine map by sending chunks of the string representation and forwarding userData tocallback`. Note that the callback may be called several times with consecutive chunks of the string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapReplace-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapReplace","text":"mlirAffineMapReplace(affineMap, expression, replacement, numResultDims, numResultSyms)\n\nApply AffineExpr::replace(map) to each of the results and return a new new AffineMap with the new results and the specified number of dims and symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMapZeroResultGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMapZeroResultGet","text":"mlirAffineMapZeroResultGet(ctx, dimCount, symbolCount)\n\nCreates a zero result affine map of the given dimensions and symbols in the context. The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineModExprGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineModExprGet","text":"mlirAffineModExprGet(lhs, rhs)\n\nCreates an affine mod expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineMulExprGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineMulExprGet","text":"mlirAffineMulExprGet(lhs, rhs)\n\nCreates an affine mul expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineSymbolExprGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineSymbolExprGet","text":"mlirAffineSymbolExprGet(ctx, position)\n\nCreates an affine symbol expression with 'position' in the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAffineSymbolExprGetPosition-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAffineSymbolExprGetPosition","text":"mlirAffineSymbolExprGetPosition(affineExpr)\n\nReturns the position of the given affine symbol expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAnyQuantizedTypeGet-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAnyQuantizedTypeGet","text":"mlirAnyQuantizedTypeGet(flags, storageType, expressedType, storageTypeMin, storageTypeMax)\n\nCreates an instance of AnyQuantizedType with the given parameters in the same context as storageType and returns it. The instance is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirArrayAttrGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirArrayAttrGet","text":"mlirArrayAttrGet(ctx, numElements, elements)\n\nCreates an array element containing the given list of elements in the given context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirArrayAttrGetElement-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirArrayAttrGetElement","text":"mlirArrayAttrGetElement(attr, pos)\n\nReturns pos-th element stored in the given array attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirArrayAttrGetNumElements-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirArrayAttrGetNumElements","text":"mlirArrayAttrGetNumElements(attr)\n\nReturns the number of elements stored in the given array attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirArrayAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirArrayAttrGetTypeID","text":"mlirArrayAttrGetTypeID()\n\nReturns the typeID of an Array attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAsmStateCreateForOperation-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAsmStateCreateForOperation","text":"mlirAsmStateCreateForOperation(op, flags)\n\nCreates new AsmState, as with AsmState the IR should not be mutated in-between using this state. Must be freed with a call to mlirAsmStateDestroy().\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAsmStateCreateForValue-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAsmStateCreateForValue","text":"mlirAsmStateCreateForValue(value, flags)\n\nCreates new AsmState from value. Must be freed with a call to mlirAsmStateDestroy().\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAsmStateDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAsmStateDestroy","text":"mlirAsmStateDestroy(state)\n\nDestroys printing flags created with mlirAsmStateCreate.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeDump-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeDump","text":"mlirAttributeDump(attr)\n\nPrints the attribute to the standard error stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeEqual","text":"mlirAttributeEqual(a1, a2)\n\nChecks if two attributes are equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeGetContext-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeGetContext","text":"mlirAttributeGetContext(attribute)\n\nGets the context that an attribute was created with.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeGetDialect-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeGetDialect","text":"mlirAttributeGetDialect(attribute)\n\nGets the dialect of the attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeGetNull-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeGetNull","text":"mlirAttributeGetNull()\n\nReturns an empty attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeGetType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeGetType","text":"mlirAttributeGetType(attribute)\n\nGets the type of this attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeGetTypeID-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeGetTypeID","text":"mlirAttributeGetTypeID(attribute)\n\nGets the type id of the attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsAAffineMap-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsAAffineMap","text":"mlirAttributeIsAAffineMap(attr)\n\nChecks whether the given attribute is an affine map attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsAArray-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsAArray","text":"mlirAttributeIsAArray(attr)\n\nChecks whether the given attribute is an array attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsABool-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsABool","text":"mlirAttributeIsABool(attr)\n\nChecks whether the given attribute is a bool attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsADenseBoolArray-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsADenseBoolArray","text":"mlirAttributeIsADenseBoolArray(attr)\n\nChecks whether the given attribute is a dense array attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsADenseElements-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsADenseElements","text":"mlirAttributeIsADenseElements(attr)\n\nChecks whether the given attribute is a dense elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsADictionary-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsADictionary","text":"mlirAttributeIsADictionary(attr)\n\nChecks whether the given attribute is a dictionary attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsAElements-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsAElements","text":"mlirAttributeIsAElements(attr)\n\nChecks whether the given attribute is an elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsAFlatSymbolRef-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsAFlatSymbolRef","text":"mlirAttributeIsAFlatSymbolRef(attr)\n\nChecks whether the given attribute is a flat symbol reference attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsAFloat-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsAFloat","text":"mlirAttributeIsAFloat(attr)\n\nChecks whether the given attribute is a floating point attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsAInteger-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsAInteger","text":"mlirAttributeIsAInteger(attr)\n\nChecks whether the given attribute is an integer attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsAIntegerSet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsAIntegerSet","text":"mlirAttributeIsAIntegerSet(attr)\n\nChecks whether the given attribute is an integer set attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsAOpaque-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsAOpaque","text":"mlirAttributeIsAOpaque(attr)\n\nChecks whether the given attribute is an opaque attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsASparseElements-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsASparseElements","text":"mlirAttributeIsASparseElements(attr)\n\nChecks whether the given attribute is a sparse elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsASparseTensorEncodingAttr-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsASparseTensorEncodingAttr","text":"mlirAttributeIsASparseTensorEncodingAttr(attr)\n\nChecks whether the given attribute is a sparse\\_tensor.encoding attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsAString-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsAString","text":"mlirAttributeIsAString(attr)\n\nChecks whether the given attribute is a string attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsASymbolRef-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsASymbolRef","text":"mlirAttributeIsASymbolRef(attr)\n\nChecks whether the given attribute is a symbol reference attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsAType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsAType","text":"mlirAttributeIsAType(attr)\n\nChecks whether the given attribute is a type attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsAUnit-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsAUnit","text":"mlirAttributeIsAUnit(attr)\n\nChecks whether the given attribute is a unit attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeIsNull","text":"mlirAttributeIsNull(attr)\n\nChecks whether an attribute is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributeParseGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributeParseGet","text":"mlirAttributeParseGet(context, attr)\n\nParses an attribute. The attribute is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirAttributePrint-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirAttributePrint","text":"mlirAttributePrint(attr, callback, userData)\n\nPrints an attribute by sending chunks of the string representation and forwarding userData tocallback`. Note that the callback may be called several times with consecutive chunks of the string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBF16TypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBF16TypeGet","text":"mlirBF16TypeGet(ctx)\n\nCreates a bf16 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBFloat16TypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirBFloat16TypeGetTypeID","text":"mlirBFloat16TypeGetTypeID()\n\nReturns the typeID of an BFloat16 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockAddArgument-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockAddArgument","text":"mlirBlockAddArgument(block, type, loc)\n\nAppends an argument of the specified type to the block. Returns the newly added argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockAppendOwnedOperation-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockAppendOwnedOperation","text":"mlirBlockAppendOwnedOperation(block, operation)\n\nTakes an operation owned by the caller and appends it to the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockArgumentGetArgNumber-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockArgumentGetArgNumber","text":"mlirBlockArgumentGetArgNumber(value)\n\nReturns the position of the value in the argument list of its block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockArgumentGetOwner-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockArgumentGetOwner","text":"mlirBlockArgumentGetOwner(value)\n\nReturns the block in which this value is defined as an argument. Asserts if the value is not a block argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockArgumentSetType-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockArgumentSetType","text":"mlirBlockArgumentSetType(value, type)\n\nSets the type of the block argument to the given type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockCreate-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockCreate","text":"mlirBlockCreate(nArgs, args, locs)\n\nCreates a new empty block with the given argument types and transfers ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockDestroy","text":"mlirBlockDestroy(block)\n\nTakes a block owned by the caller and destroys it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockDetach-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockDetach","text":"mlirBlockDetach(block)\n\nDetach a block from the owning region and assume ownership.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockEqual","text":"mlirBlockEqual(block, other)\n\nChecks whether two blocks handles point to the same block. This does not perform deep comparison.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockGetArgument-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockGetArgument","text":"mlirBlockGetArgument(block, pos)\n\nReturns pos-th argument of the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockGetFirstOperation-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockGetFirstOperation","text":"mlirBlockGetFirstOperation(block)\n\nReturns the first operation in the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockGetNextInRegion-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockGetNextInRegion","text":"mlirBlockGetNextInRegion(block)\n\nReturns the block immediately following the given block in its parent region.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockGetNumArguments-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockGetNumArguments","text":"mlirBlockGetNumArguments(block)\n\nReturns the number of arguments of the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockGetParentOperation-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockGetParentOperation","text":"mlirBlockGetParentOperation(arg1)\n\nReturns the closest surrounding operation that contains this block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockGetParentRegion-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockGetParentRegion","text":"mlirBlockGetParentRegion(block)\n\nReturns the region that contains this block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockGetTerminator-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockGetTerminator","text":"mlirBlockGetTerminator(block)\n\nReturns the terminator operation in the block or null if no terminator.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockInsertArgument-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockInsertArgument","text":"mlirBlockInsertArgument(block, pos, type, loc)\n\nInserts an argument of the specified type at a specified index to the block. Returns the newly added argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockInsertOwnedOperation-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockInsertOwnedOperation","text":"mlirBlockInsertOwnedOperation(block, pos, operation)\n\nTakes an operation owned by the caller and inserts it as pos to the block. This is an expensive operation that scans the block linearly, prefer insertBefore/After instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockInsertOwnedOperationAfter-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockInsertOwnedOperationAfter","text":"mlirBlockInsertOwnedOperationAfter(block, reference, operation)\n\nTakes an operation owned by the caller and inserts it after the (non-owned) reference operation in the given block. If the reference is null, prepends the operation. Otherwise, the reference must belong to the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockInsertOwnedOperationBefore-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockInsertOwnedOperationBefore","text":"mlirBlockInsertOwnedOperationBefore(block, reference, operation)\n\nTakes an operation owned by the caller and inserts it before the (non-owned) reference operation in the given block. If the reference is null, appends the operation. Otherwise, the reference must belong to the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockIsNull","text":"mlirBlockIsNull(block)\n\nChecks whether a block is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBlockPrint-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBlockPrint","text":"mlirBlockPrint(block, callback, userData)\n\nPrints a block by sending chunks of the string representation and forwarding userData tocallback`. Note that the callback may be called several times with consecutive chunks of the string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBoolAttrGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBoolAttrGet","text":"mlirBoolAttrGet(ctx, value)\n\nCreates a bool attribute in the given context with the given value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBoolAttrGetValue-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBoolAttrGetValue","text":"mlirBoolAttrGetValue(attr)\n\nReturns the value stored in the given bool attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBytecodeWriterConfigCreate-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirBytecodeWriterConfigCreate","text":"mlirBytecodeWriterConfigCreate()\n\nCreates new printing flags with defaults, intended for customization. Must be freed with a call to mlirBytecodeWriterConfigDestroy().\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBytecodeWriterConfigDesiredEmitVersion-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBytecodeWriterConfigDesiredEmitVersion","text":"mlirBytecodeWriterConfigDesiredEmitVersion(flags, version)\n\nSets the version to emit in the writer config.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirBytecodeWriterConfigDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirBytecodeWriterConfigDestroy","text":"mlirBytecodeWriterConfigDestroy(config)\n\nDestroys printing flags created with mlirBytecodeWriterConfigCreate.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirCalibratedQuantizedTypeGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirCalibratedQuantizedTypeGet","text":"mlirCalibratedQuantizedTypeGet(expressedType, min, max)\n\nCreates an instance of CalibratedQuantizedType with the given parameters in the same context as expressedType and returns it. The instance is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMax-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMax","text":"mlirCalibratedQuantizedTypeGetMax(type)\n\nReturns the max value of the given calibrated quantized type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMin-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirCalibratedQuantizedTypeGetMin","text":"mlirCalibratedQuantizedTypeGetMin(type)\n\nReturns the min value of the given calibrated quantized type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirComplexTypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirComplexTypeGet","text":"mlirComplexTypeGet(elementType)\n\nCreates a complex type with the given element type in the same context as the element type. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirComplexTypeGetElementType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirComplexTypeGetElementType","text":"mlirComplexTypeGetElementType(type)\n\nReturns the element type of the given complex type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirComplexTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirComplexTypeGetTypeID","text":"mlirComplexTypeGetTypeID()\n\nReturns the typeID of an Complex type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextAppendDialectRegistry-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextAppendDialectRegistry","text":"mlirContextAppendDialectRegistry(ctx, registry)\n\nAppend the contents of the given dialect registry to the registry associated with the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextAttachDiagnosticHandler-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextAttachDiagnosticHandler","text":"mlirContextAttachDiagnosticHandler(context, handler, userData, deleteUserData)\n\nAttaches the diagnostic handler to the context. Handlers are invoked in the reverse order of attachment until one of them processes the diagnostic completely. When a handler is invoked it is passed the userData that was provided when it was attached. If non-NULL, deleteUserData is called once the system no longer needs to call the handler (for instance after the handler is detached or the context is destroyed). Returns an identifier that can be used to detach the handler.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextCreate-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirContextCreate","text":"mlirContextCreate()\n\nCreates an MLIR context and transfers its ownership to the caller. This sets the default multithreading option (enabled).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextCreateWithRegistry-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextCreateWithRegistry","text":"mlirContextCreateWithRegistry(registry, threadingEnabled)\n\nCreates an MLIR context, setting the multithreading setting explicitly and pre-loading the dialects from the provided DialectRegistry.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextCreateWithThreading-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextCreateWithThreading","text":"mlirContextCreateWithThreading(threadingEnabled)\n\nCreates an MLIR context with an explicit setting of the multithreading setting and transfers its ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextDestroy","text":"mlirContextDestroy(context)\n\nTakes an MLIR context owned by the caller and destroys it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextDetachDiagnosticHandler-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextDetachDiagnosticHandler","text":"mlirContextDetachDiagnosticHandler(context, id)\n\nDetaches an attached diagnostic handler from the context given its identifier.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextEnableMultithreading-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextEnableMultithreading","text":"mlirContextEnableMultithreading(context, enable)\n\nSet threading mode (must be set to false to mlir-print-ir-after-all).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextEqual","text":"mlirContextEqual(ctx1, ctx2)\n\nChecks if two contexts are equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextGetAllowUnregisteredDialects-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextGetAllowUnregisteredDialects","text":"mlirContextGetAllowUnregisteredDialects(context)\n\nReturns whether the context allows unregistered dialects.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextGetNumLoadedDialects-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextGetNumLoadedDialects","text":"mlirContextGetNumLoadedDialects(context)\n\nReturns the number of dialects loaded by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextGetNumRegisteredDialects-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextGetNumRegisteredDialects","text":"mlirContextGetNumRegisteredDialects(context)\n\nReturns the number of dialects registered with the given context. A registered dialect will be loaded if needed by the parser.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextGetOrLoadDialect-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextGetOrLoadDialect","text":"mlirContextGetOrLoadDialect(context, name)\n\nGets the dialect instance owned by the given context using the dialect namespace to identify it, loads (i.e., constructs the instance of) the dialect if necessary. If the dialect is not registered with the context, returns null. Use mlirContextLoad<Name>Dialect to load an unregistered dialect.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextIsNull","text":"mlirContextIsNull(context)\n\nChecks whether a context is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextIsRegisteredOperation-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextIsRegisteredOperation","text":"mlirContextIsRegisteredOperation(context, name)\n\nReturns whether the given fully-qualified operation (i.e. 'dialect.operation') is registered with the context. This will return true if the dialect is loaded and the operation is registered within the dialect.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextLoadAllAvailableDialects-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextLoadAllAvailableDialects","text":"mlirContextLoadAllAvailableDialects(context)\n\nEagerly loads all available dialects registered with a context, making them available for use for IR construction.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextSetAllowUnregisteredDialects-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextSetAllowUnregisteredDialects","text":"mlirContextSetAllowUnregisteredDialects(context, allow)\n\nSets whether unregistered dialects are allowed in this context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirContextSetThreadPool-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirContextSetThreadPool","text":"mlirContextSetThreadPool(context, threadPool)\n\nSets the thread pool of the context explicitly, enabling multithreading in the process. This API should be used to avoid re-creating thread pools in long-running applications that perform multiple compilations, see the C++ documentation for MLIRContext for details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirCreateExternalPass-NTuple{9, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirCreateExternalPass","text":"mlirCreateExternalPass(passID, name, argument, description, opName, nDependentDialects, dependentDialects, callbacks, userData)\n\nCreates an external MlirPass that calls the supplied callbacks using the supplied userData. If opName is empty, the pass is a generic operation pass. Otherwise it is an operation pass specific to the specified pass name.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseArrayGetNumElements-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseArrayGetNumElements","text":"mlirDenseArrayGetNumElements(attr)\n\nGet the size of a dense array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseBoolArrayGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseBoolArrayGet","text":"mlirDenseBoolArrayGet(ctx, size, values)\n\nCreate a dense array attribute with the given elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseBoolArrayGetElement-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseBoolArrayGetElement","text":"mlirDenseBoolArrayGetElement(attr, pos)\n\nGet an element of a dense array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseBoolResourceElementsAttrGetValue-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseBoolResourceElementsAttrGetValue","text":"mlirDenseBoolResourceElementsAttrGetValue(attr, pos)\n\nReturns the pos-th value (flat contiguous indexing) of a specific type contained by the given dense resource elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseElementsAttrBoolGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseElementsAttrBoolGet","text":"mlirDenseElementsAttrBoolGet(shapedType, numElements, elements)\n\nCreates a dense elements attribute with the given shaped type from elements of a specific type. Expects the element type of the shaped type to match the data element type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseElementsAttrGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseElementsAttrGet","text":"mlirDenseElementsAttrGet(shapedType, numElements, elements)\n\nCreates a dense elements attribute with the given Shaped type and elements in the same context as the type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseElementsAttrGetBoolValue-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseElementsAttrGetBoolValue","text":"mlirDenseElementsAttrGetBoolValue(attr, pos)\n\nReturns the pos-th value (flat contiguous indexing) of a specific type contained by the given dense elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseElementsAttrGetRawData-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseElementsAttrGetRawData","text":"mlirDenseElementsAttrGetRawData(attr)\n\nReturns the raw data of the given dense elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseElementsAttrGetSplatValue-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseElementsAttrGetSplatValue","text":"mlirDenseElementsAttrGetSplatValue(attr)\n\nReturns the single replicated value (splat) of a specific type contained by the given dense elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseElementsAttrIsSplat-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseElementsAttrIsSplat","text":"mlirDenseElementsAttrIsSplat(attr)\n\nChecks whether the given dense elements attribute contains a single replicated value (splat).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseElementsAttrRawBufferGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseElementsAttrRawBufferGet","text":"mlirDenseElementsAttrRawBufferGet(shapedType, rawBufferSize, rawBuffer)\n\nCreates a dense elements attribute with the given Shaped type and elements populated from a packed, row-major opaque buffer of contents.\n\nThe format of the raw buffer is a densely packed array of values that can be bitcast to the storage format of the element type specified. Types that are not byte aligned will be: - For bitwidth > 1: Rounded up to the next byte. - For bitwidth = 1: Packed into 8bit bytes with bits corresponding to the linear order of the shape type from MSB to LSB, padded to on the right.\n\nA raw buffer of a single element (or for 1-bit, a byte of value 0 or 255) will be interpreted as a splat. User code should be prepared for additional, conformant patterns to be identified as splats in the future.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseElementsAttrReshapeGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseElementsAttrReshapeGet","text":"mlirDenseElementsAttrReshapeGet(attr, shapedType)\n\nCreates a dense elements attribute that has the same data as the given dense elements attribute and a different shaped type. The new type must have the same total number of elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseElementsAttrSplatGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseElementsAttrSplatGet","text":"mlirDenseElementsAttrSplatGet(shapedType, element)\n\nCreates a dense elements attribute with the given Shaped type containing a single replicated element (splat).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseElementsAttrStringGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseElementsAttrStringGet","text":"mlirDenseElementsAttrStringGet(shapedType, numElements, strs)\n\nCreates a dense elements attribute with the given shaped type from string elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDenseIntOrFPElementsAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirDenseIntOrFPElementsAttrGetTypeID","text":"mlirDenseIntOrFPElementsAttrGetTypeID()\n\nReturns the typeID of an DenseIntOrFPElements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDiagnosticGetLocation-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDiagnosticGetLocation","text":"mlirDiagnosticGetLocation(diagnostic)\n\nReturns the location at which the diagnostic is reported.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDiagnosticGetNote-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDiagnosticGetNote","text":"mlirDiagnosticGetNote(diagnostic, pos)\n\nReturns pos-th note attached to the diagnostic. Expects pos to be a valid zero-based index into the list of notes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDiagnosticGetNumNotes-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDiagnosticGetNumNotes","text":"mlirDiagnosticGetNumNotes(diagnostic)\n\nReturns the number of notes attached to the diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDiagnosticGetSeverity-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDiagnosticGetSeverity","text":"mlirDiagnosticGetSeverity(diagnostic)\n\nReturns the severity of the diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDiagnosticPrint-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDiagnosticPrint","text":"mlirDiagnosticPrint(diagnostic, callback, userData)\n\nPrints a diagnostic using the provided callback.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDialectEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDialectEqual","text":"mlirDialectEqual(dialect1, dialect2)\n\nChecks if two dialects that belong to the same context are equal. Dialects from different contexts will not compare equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDialectGetContext-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDialectGetContext","text":"mlirDialectGetContext(dialect)\n\nReturns the context that owns the dialect.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDialectGetNamespace-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDialectGetNamespace","text":"mlirDialectGetNamespace(dialect)\n\nReturns the namespace of the given dialect.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDialectHandleGetNamespace-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDialectHandleGetNamespace","text":"mlirDialectHandleGetNamespace(arg1)\n\nReturns the namespace associated with the provided dialect handle.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDialectHandleInsertDialect-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDialectHandleInsertDialect","text":"mlirDialectHandleInsertDialect(arg1, arg2)\n\nInserts the dialect associated with the provided dialect handle into the provided dialect registry\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDialectHandleLoadDialect-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDialectHandleLoadDialect","text":"mlirDialectHandleLoadDialect(arg1, arg2)\n\nLoads the dialect associated with the provided dialect handle.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDialectHandleRegisterDialect-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDialectHandleRegisterDialect","text":"mlirDialectHandleRegisterDialect(arg1, arg2)\n\nRegisters the dialect associated with the provided dialect handle.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDialectIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDialectIsNull","text":"mlirDialectIsNull(dialect)\n\nChecks if the dialect is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDialectRegistryCreate-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirDialectRegistryCreate","text":"mlirDialectRegistryCreate()\n\nCreates a dialect registry and transfers its ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDialectRegistryDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDialectRegistryDestroy","text":"mlirDialectRegistryDestroy(registry)\n\nTakes a dialect registry owned by the caller and destroys it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDialectRegistryIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDialectRegistryIsNull","text":"mlirDialectRegistryIsNull(registry)\n\nChecks if the dialect registry is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDictionaryAttrGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDictionaryAttrGet","text":"mlirDictionaryAttrGet(ctx, numElements, elements)\n\nCreates a dictionary attribute containing the given list of elements in the provided context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDictionaryAttrGetElement-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDictionaryAttrGetElement","text":"mlirDictionaryAttrGetElement(attr, pos)\n\nReturns pos-th element of the given dictionary attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDictionaryAttrGetElementByName-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDictionaryAttrGetElementByName","text":"mlirDictionaryAttrGetElementByName(attr, name)\n\nReturns the dictionary attribute element with the given name or NULL if the given name does not exist in the dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDictionaryAttrGetNumElements-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDictionaryAttrGetNumElements","text":"mlirDictionaryAttrGetNumElements(attr)\n\nReturns the number of attributes contained in a dictionary attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDictionaryAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirDictionaryAttrGetTypeID","text":"mlirDictionaryAttrGetTypeID()\n\nReturns the typeID of a Dictionary attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirDisctinctAttrCreate-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirDisctinctAttrCreate","text":"mlirDisctinctAttrCreate(referencedAttr)\n\nCreates a DisctinctAttr with the referenced attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirElementsAttrGetNumElements-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirElementsAttrGetNumElements","text":"mlirElementsAttrGetNumElements(attr)\n\nGets the total number of elements in the given elements attribute. In order to iterate over the attribute, obtain its type, which must be a statically shaped type and use its sizes to build a multi-dimensional index.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirElementsAttrGetValue-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirElementsAttrGetValue","text":"mlirElementsAttrGetValue(attr, rank, idxs)\n\nReturns the element at the given rank-dimensional index.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirElementsAttrIsValidIndex-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirElementsAttrIsValidIndex","text":"mlirElementsAttrIsValidIndex(attr, rank, idxs)\n\nChecks whether the given rank-dimensional index is valid in the given elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirEmitError-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirEmitError","text":"mlirEmitError(location, message)\n\nEmits an error at the given location through the diagnostics engine. Used for testing purposes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirEnableGlobalDebug-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirEnableGlobalDebug","text":"mlirEnableGlobalDebug(enable)\n\nSets the global debugging flag.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirExecutionEngineCreate-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirExecutionEngineCreate","text":"mlirExecutionEngineCreate(op, optLevel, numPaths, sharedLibPaths, enableObjectDump)\n\nCreates an ExecutionEngine for the provided ModuleOp. The ModuleOp is expected to be \"translatable\" to LLVM IR (only contains operations in dialects that implement the LLVMTranslationDialectInterface). The module ownership stays with the client and can be destroyed as soon as the call returns. optLevel is the optimization level to be used for transformation and code generation. LLVM passes at optLevel are run before code generation. The number and array of paths corresponding to shared libraries that will be loaded are specified via numPaths and sharedLibPaths respectively. TODO: figure out other options.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirExecutionEngineDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirExecutionEngineDestroy","text":"mlirExecutionEngineDestroy(jit)\n\nDestroy an ExecutionEngine instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirExecutionEngineDumpToObjectFile-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirExecutionEngineDumpToObjectFile","text":"mlirExecutionEngineDumpToObjectFile(jit, fileName)\n\nDump as an object in fileName.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirExecutionEngineInvokePacked-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirExecutionEngineInvokePacked","text":"mlirExecutionEngineInvokePacked(jit, name, arguments)\n\nInvoke a native function in the execution engine by name with the arguments and result of the invoked function passed as an array of pointers. The function must have been tagged with the llvm.emit\\_c\\_interface attribute. Returns a failure if the execution fails for any reason (the function name can't be resolved for instance).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirExecutionEngineIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirExecutionEngineIsNull","text":"mlirExecutionEngineIsNull(jit)\n\nChecks whether an execution engine is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirExecutionEngineLookup-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirExecutionEngineLookup","text":"mlirExecutionEngineLookup(jit, name)\n\nLookup a native function in the execution engine by name, returns nullptr if the name can't be looked-up.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirExecutionEngineLookupPacked-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirExecutionEngineLookupPacked","text":"mlirExecutionEngineLookupPacked(jit, name)\n\nLookup the wrapper of the native function in the execution engine with the given name, returns nullptr if the function can't be looked-up.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirExecutionEngineRegisterSymbol-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirExecutionEngineRegisterSymbol","text":"mlirExecutionEngineRegisterSymbol(jit, name, sym)\n\nRegister a symbol with the jit: this symbol will be accessible to the jitted code.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirExternalPassSignalFailure-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirExternalPassSignalFailure","text":"mlirExternalPassSignalFailure(pass)\n\nThis signals that the pass has failed. This is only valid to call during the run callback of MlirExternalPassCallbacks. See Pass::signalPassFailure().\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirF16TypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirF16TypeGet","text":"mlirF16TypeGet(ctx)\n\nCreates an f16 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirF32TypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirF32TypeGet","text":"mlirF32TypeGet(ctx)\n\nCreates an f32 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirF64TypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirF64TypeGet","text":"mlirF64TypeGet(ctx)\n\nCreates a f64 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFlatSymbolRefAttrGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFlatSymbolRefAttrGet","text":"mlirFlatSymbolRefAttrGet(ctx, symbol)\n\nCreates a flat symbol reference attribute in the given context referencing a symbol identified by the given string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFlatSymbolRefAttrGetValue-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFlatSymbolRefAttrGetValue","text":"mlirFlatSymbolRefAttrGetValue(attr)\n\nReturns the referenced symbol as a string reference. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat16TypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat16TypeGetTypeID","text":"mlirFloat16TypeGetTypeID()\n\nReturns the typeID of an Float16 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat32TypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat32TypeGetTypeID","text":"mlirFloat32TypeGetTypeID()\n\nReturns the typeID of an Float32 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat64TypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat64TypeGetTypeID","text":"mlirFloat64TypeGetTypeID()\n\nReturns the typeID of an Float64 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGet","text":"mlirFloat8E4M3B11FNUZTypeGet(ctx)\n\nCreates an f8E4M3B11FNUZ type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat8E4M3B11FNUZTypeGetTypeID","text":"mlirFloat8E4M3B11FNUZTypeGetTypeID()\n\nReturns the typeID of an Float8E4M3B11FNUZ type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat8E4M3FNTypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat8E4M3FNTypeGet","text":"mlirFloat8E4M3FNTypeGet(ctx)\n\nCreates an f8E4M3FN type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat8E4M3FNTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat8E4M3FNTypeGetTypeID","text":"mlirFloat8E4M3FNTypeGetTypeID()\n\nReturns the typeID of an Float8E4M3FN type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGet","text":"mlirFloat8E4M3FNUZTypeGet(ctx)\n\nCreates an f8E4M3FNUZ type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat8E4M3FNUZTypeGetTypeID","text":"mlirFloat8E4M3FNUZTypeGetTypeID()\n\nReturns the typeID of an Float8E4M3FNUZ type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGet","text":"mlirFloat8E5M2FNUZTypeGet(ctx)\n\nCreates an f8E5M2FNUZ type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat8E5M2FNUZTypeGetTypeID","text":"mlirFloat8E5M2FNUZTypeGetTypeID()\n\nReturns the typeID of an Float8E5M2FNUZ type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat8E5M2TypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat8E5M2TypeGet","text":"mlirFloat8E5M2TypeGet(ctx)\n\nCreates an f8E5M2 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloat8E5M2TypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirFloat8E5M2TypeGetTypeID","text":"mlirFloat8E5M2TypeGetTypeID()\n\nReturns the typeID of an Float8E5M2 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloatAttrDoubleGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFloatAttrDoubleGet","text":"mlirFloatAttrDoubleGet(ctx, type, value)\n\nCreates a floating point attribute in the given context with the given double value and double-precision FP semantics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloatAttrDoubleGetChecked-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFloatAttrDoubleGetChecked","text":"mlirFloatAttrDoubleGetChecked(loc, type, value)\n\nSame as \"mlirFloatAttrDoubleGet\", but if the type is not valid for a construction of a FloatAttr, returns a null MlirAttribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloatAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirFloatAttrGetTypeID","text":"mlirFloatAttrGetTypeID()\n\nReturns the typeID of a Float attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloatAttrGetValueDouble-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFloatAttrGetValueDouble","text":"mlirFloatAttrGetValueDouble(attr)\n\nReturns the value stored in the given floating point attribute, interpreting the value as double.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloatTF32TypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirFloatTF32TypeGetTypeID","text":"mlirFloatTF32TypeGetTypeID()\n\nReturns the typeID of a TF32 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFloatTypeGetWidth-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFloatTypeGetWidth","text":"mlirFloatTypeGetWidth(type)\n\nReturns the bitwidth of a floating-point type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFuncSetArgAttr-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFuncSetArgAttr","text":"mlirFuncSetArgAttr(op, pos, name, attr)\n\nSets the argument attribute 'name' of an argument at index 'pos'. Asserts that the operation is a FuncOp.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFunctionTypeGet-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFunctionTypeGet","text":"mlirFunctionTypeGet(ctx, numInputs, inputs, numResults, results)\n\nCreates a function type, mapping a list of input types to result types.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFunctionTypeGetInput-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFunctionTypeGetInput","text":"mlirFunctionTypeGetInput(type, pos)\n\nReturns the pos-th input type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFunctionTypeGetNumInputs-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFunctionTypeGetNumInputs","text":"mlirFunctionTypeGetNumInputs(type)\n\nReturns the number of input types.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFunctionTypeGetNumResults-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFunctionTypeGetNumResults","text":"mlirFunctionTypeGetNumResults(type)\n\nReturns the number of result types.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFunctionTypeGetResult-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirFunctionTypeGetResult","text":"mlirFunctionTypeGetResult(type, pos)\n\nReturns the pos-th result type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirFunctionTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirFunctionTypeGetTypeID","text":"mlirFunctionTypeGetTypeID()\n\nReturns the typeID of an Function type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIdentifierEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIdentifierEqual","text":"mlirIdentifierEqual(ident, other)\n\nChecks whether two identifiers are the same.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIdentifierGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIdentifierGet","text":"mlirIdentifierGet(context, str)\n\nGets an identifier with the given string value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIdentifierGetContext-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIdentifierGetContext","text":"mlirIdentifierGetContext(arg1)\n\nReturns the context associated with this identifier\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIdentifierStr-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIdentifierStr","text":"mlirIdentifierStr(ident)\n\nGets the string value of the identifier.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIndexTypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIndexTypeGet","text":"mlirIndexTypeGet(ctx)\n\nCreates an index type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIndexTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirIndexTypeGetTypeID","text":"mlirIndexTypeGetTypeID()\n\nReturns the typeID of an Index type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceInferReturnTypes-NTuple{11, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceInferReturnTypes","text":"mlirInferShapedTypeOpInterfaceInferReturnTypes(opName, context, location, nOperands, operands, attributes, properties, nRegions, regions, callback, userData)\n\nInfers the return shaped type components of the operation. Calls callback with the types of inferred arguments on success. Returns failure otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirInferShapedTypeOpInterfaceTypeID","text":"mlirInferShapedTypeOpInterfaceTypeID()\n\nReturns the interface TypeID of the InferShapedTypeOpInterface.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirInferTypeOpInterfaceInferReturnTypes-NTuple{11, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirInferTypeOpInterfaceInferReturnTypes","text":"mlirInferTypeOpInterfaceInferReturnTypes(opName, context, location, nOperands, operands, attributes, properties, nRegions, regions, callback, userData)\n\nInfers the return types of the operation identified by its canonical given the arguments that will be supplied to its generic builder. Calls callback with the types of inferred arguments, potentially several times, on success. Returns failure otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirInferTypeOpInterfaceTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirInferTypeOpInterfaceTypeID","text":"mlirInferTypeOpInterfaceTypeID()\n\nReturns the interface TypeID of the InferTypeOpInterface.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerAttrGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerAttrGet","text":"mlirIntegerAttrGet(type, value)\n\nCreates an integer attribute of the given type with the given integer value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerAttrGetTypeID","text":"mlirIntegerAttrGetTypeID()\n\nReturns the typeID of an Integer attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerAttrGetValueInt-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerAttrGetValueInt","text":"mlirIntegerAttrGetValueInt(attr)\n\nReturns the value stored in the given integer attribute, assuming the value is of signless type and fits into a signed 64-bit integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerAttrGetValueSInt-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerAttrGetValueSInt","text":"mlirIntegerAttrGetValueSInt(attr)\n\nReturns the value stored in the given integer attribute, assuming the value is of signed type and fits into a signed 64-bit integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerAttrGetValueUInt-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerAttrGetValueUInt","text":"mlirIntegerAttrGetValueUInt(attr)\n\nReturns the value stored in the given integer attribute, assuming the value is of unsigned type and fits into an unsigned 64-bit integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetAttrGetTypeID","text":"mlirIntegerSetAttrGetTypeID()\n\nReturns the typeID of an IntegerSet attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetDump-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetDump","text":"mlirIntegerSetDump(set)\n\nPrints an integer set to the standard error stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetEmptyGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetEmptyGet","text":"mlirIntegerSetEmptyGet(context, numDims, numSymbols)\n\nGets or creates a new canonically empty integer set with the give number of dimensions and symbols in the given context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetEqual","text":"mlirIntegerSetEqual(s1, s2)\n\nChecks if two integer set objects are equal. This is a \"shallow\" comparison of two objects. Only the sets with some small number of constraints are uniqued and compare equal here. Set objects that represent the same integer set with different constraints may be considered non-equal by this check. Set difference followed by an (expensive) emptiness check should be used to check equivalence of the underlying integer sets.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetGet-NTuple{6, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetGet","text":"mlirIntegerSetGet(context, numDims, numSymbols, numConstraints, constraints, eqFlags)\n\nGets or creates a new integer set in the given context. The set is defined by a list of affine constraints, with the given number of input dimensions and symbols, which are treated as either equalities (eqFlags is 1) or inequalities (eqFlags is 0). Both constraints and eqFlags are expected to point to at least numConstraint consecutive values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetGetConstraint-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetGetConstraint","text":"mlirIntegerSetGetConstraint(set, pos)\n\nReturns pos-th constraint of the set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetGetContext-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetGetContext","text":"mlirIntegerSetGetContext(set)\n\nGets the context in which the given integer set lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetGetNumConstraints-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetGetNumConstraints","text":"mlirIntegerSetGetNumConstraints(set)\n\nReturns the number of constraints (equalities + inequalities) in the given set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetGetNumDims-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetGetNumDims","text":"mlirIntegerSetGetNumDims(set)\n\nReturns the number of dimensions in the given set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetGetNumEqualities-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetGetNumEqualities","text":"mlirIntegerSetGetNumEqualities(set)\n\nReturns the number of equalities in the given set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetGetNumInequalities-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetGetNumInequalities","text":"mlirIntegerSetGetNumInequalities(set)\n\nReturns the number of inequalities in the given set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetGetNumInputs-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetGetNumInputs","text":"mlirIntegerSetGetNumInputs(set)\n\nReturns the number of inputs (dimensions + symbols) in the given set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetGetNumSymbols-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetGetNumSymbols","text":"mlirIntegerSetGetNumSymbols(set)\n\nReturns the number of symbols in the given set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetIsCanonicalEmpty-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetIsCanonicalEmpty","text":"mlirIntegerSetIsCanonicalEmpty(set)\n\nChecks whether the given set is a canonical empty set, e.g., the set returned by mlirIntegerSetEmptyGet.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetIsConstraintEq-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetIsConstraintEq","text":"mlirIntegerSetIsConstraintEq(set, pos)\n\nReturns true of the pos-th constraint of the set is an equality constraint, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetIsNull","text":"mlirIntegerSetIsNull(set)\n\nChecks whether an integer set is a null object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetPrint-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetPrint","text":"mlirIntegerSetPrint(set, callback, userData)\n\nPrints an integer set by sending chunks of the string representation and forwarding userData tocallback`. Note that the callback may be called several times with consecutive chunks of the string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerSetReplaceGet-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerSetReplaceGet","text":"mlirIntegerSetReplaceGet(set, dimReplacements, symbolReplacements, numResultDims, numResultSymbols)\n\nGets or creates a new integer set in which the values and dimensions of the given set are replaced with the given affine expressions. dimReplacements and symbolReplacements are expected to point to at least as many consecutive expressions as the given set has dimensions and symbols, respectively. The new set will have numResultDims and numResultSymbols dimensions and symbols, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerTypeGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerTypeGet","text":"mlirIntegerTypeGet(ctx, bitwidth)\n\nCreates a signless integer type of the given bitwidth in the context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerTypeGetTypeID","text":"mlirIntegerTypeGetTypeID()\n\nReturns the typeID of an Integer type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerTypeGetWidth-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerTypeGetWidth","text":"mlirIntegerTypeGetWidth(type)\n\nReturns the bitwidth of an integer type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerTypeIsSigned-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerTypeIsSigned","text":"mlirIntegerTypeIsSigned(type)\n\nChecks whether the given integer type is signed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerTypeIsSignless-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerTypeIsSignless","text":"mlirIntegerTypeIsSignless(type)\n\nChecks whether the given integer type is signless.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerTypeIsUnsigned-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerTypeIsUnsigned","text":"mlirIntegerTypeIsUnsigned(type)\n\nChecks whether the given integer type is unsigned.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerTypeSignedGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerTypeSignedGet","text":"mlirIntegerTypeSignedGet(ctx, bitwidth)\n\nCreates a signed integer type of the given bitwidth in the context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIntegerTypeUnsignedGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirIntegerTypeUnsignedGet","text":"mlirIntegerTypeUnsignedGet(ctx, bitwidth)\n\nCreates an unsigned integer type of the given bitwidth in the context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirIsGlobalDebugEnabled-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirIsGlobalDebugEnabled","text":"mlirIsGlobalDebugEnabled()\n\nRetuns true if the global debugging flag is set, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMArrayTypeGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMArrayTypeGet","text":"mlirLLVMArrayTypeGet(elementType, numElements)\n\nCreates an llvm.array type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMCConvAttrGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMCConvAttrGet","text":"mlirLLVMCConvAttrGet(ctx, cconv)\n\nCreates a LLVM CConv attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMComdatAttrGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMComdatAttrGet","text":"mlirLLVMComdatAttrGet(ctx, comdat)\n\nCreates a LLVM Comdat attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDIBasicTypeAttrGet-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDIBasicTypeAttrGet","text":"mlirLLVMDIBasicTypeAttrGet(ctx, tag, name, sizeInBits, encoding)\n\nCreates a LLVM DIBasicType attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDICompileUnitAttrGet-NTuple{7, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDICompileUnitAttrGet","text":"mlirLLVMDICompileUnitAttrGet(ctx, id, sourceLanguage, file, producer, isOptimized, emissionKind)\n\nCreates a LLVM DICompileUnit attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGet-NTuple{13, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDICompositeTypeAttrGet","text":"mlirLLVMDICompositeTypeAttrGet(ctx, tag, recId, name, file, line, scope, baseType, flags, sizeInBits, alignInBits, nElements, elements)\n\nCreates a LLVM DICompositeType attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGet-NTuple{8, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGet","text":"mlirLLVMDIDerivedTypeAttrGet(ctx, tag, name, baseType, sizeInBits, alignInBits, offsetInBits, extraData)\n\nCreates a LLVM DIDerivedType attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGetBaseType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDIDerivedTypeAttrGetBaseType","text":"mlirLLVMDIDerivedTypeAttrGetBaseType(diDerivedType)\n\nGets the base type from a LLVM DIDerivedType attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDIExpressionAttrGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDIExpressionAttrGet","text":"mlirLLVMDIExpressionAttrGet(ctx, nOperations, operations)\n\nCreates a LLVM DIExpression attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDIExpressionElemAttrGet-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDIExpressionElemAttrGet","text":"mlirLLVMDIExpressionElemAttrGet(ctx, opcode, nArguments, arguments)\n\nCreates a LLVM DIExpressionElem attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDIFileAttrGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDIFileAttrGet","text":"mlirLLVMDIFileAttrGet(ctx, name, directory)\n\nCreates a LLVM DIFileAttr attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDIFlagsAttrGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDIFlagsAttrGet","text":"mlirLLVMDIFlagsAttrGet(ctx, value)\n\nCreates a LLVM DIFlags attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDILexicalBlockAttrGet-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDILexicalBlockAttrGet","text":"mlirLLVMDILexicalBlockAttrGet(ctx, scope, file, line, column)\n\nCreates a LLVM DILexicalBlock attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDILexicalBlockFileAttrGet-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDILexicalBlockFileAttrGet","text":"mlirLLVMDILexicalBlockFileAttrGet(ctx, scope, file, discriminator)\n\nCreates a LLVM DILexicalBlockFile attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDILocalVariableAttrGet-NTuple{8, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDILocalVariableAttrGet","text":"mlirLLVMDILocalVariableAttrGet(ctx, scope, name, diFile, line, arg, alignInBits, diType)\n\nCreates a LLVM DILocalVariableAttr attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDIModuleAttrGet-NTuple{9, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDIModuleAttrGet","text":"mlirLLVMDIModuleAttrGet(ctx, file, scope, name, configMacros, includePath, apinotes, line, isDecl)\n\nCreates a LLVM DIModuleAttr attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDIModuleAttrGetScope-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDIModuleAttrGetScope","text":"mlirLLVMDIModuleAttrGetScope(diModule)\n\nGets the scope of this DIModuleAttr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDINullTypeAttrGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDINullTypeAttrGet","text":"mlirLLVMDINullTypeAttrGet(ctx)\n\nCreates a LLVM DINullType attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGet-NTuple{11, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGet","text":"mlirLLVMDISubprogramAttrGet(ctx, id, compileUnit, scope, name, linkageName, file, line, scopeLine, subprogramFlags, type)\n\nCreates a LLVM DISubprogramAttr attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetCompileUnit-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetCompileUnit","text":"mlirLLVMDISubprogramAttrGetCompileUnit(diSubprogram)\n\nGets the compile unit from this DISubprogram.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetFile-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetFile","text":"mlirLLVMDISubprogramAttrGetFile(diSubprogram)\n\nGets the file from this DISubprogramAttr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetLine-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetLine","text":"mlirLLVMDISubprogramAttrGetLine(diSubprogram)\n\nGets the line from this DISubprogramAttr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScope-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScope","text":"mlirLLVMDISubprogramAttrGetScope(diSubprogram)\n\nGets the scope from this DISubprogramAttr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScopeLine-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetScopeLine","text":"mlirLLVMDISubprogramAttrGetScopeLine(diSubprogram)\n\nGets the scope line from this DISubprogram.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDISubprogramAttrGetType","text":"mlirLLVMDISubprogramAttrGetType(diSubprogram)\n\nGets the type from this DISubprogramAttr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMDISubroutineTypeAttrGet-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMDISubroutineTypeAttrGet","text":"mlirLLVMDISubroutineTypeAttrGet(ctx, callingConvention, nTypes, types)\n\nCreates a LLVM DISubroutineTypeAttr attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMFunctionTypeGet-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMFunctionTypeGet","text":"mlirLLVMFunctionTypeGet(resultType, nArgumentTypes, argumentTypes, isVarArg)\n\nCreates an llvm.func type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMLinkageAttrGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMLinkageAttrGet","text":"mlirLLVMLinkageAttrGet(ctx, linkage)\n\nCreates a LLVM Linkage attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMPointerTypeGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMPointerTypeGet","text":"mlirLLVMPointerTypeGet(ctx, addressSpace)\n\nCreates an llvm.ptr type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMStructTypeGetElementType-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMStructTypeGetElementType","text":"mlirLLVMStructTypeGetElementType(type, position)\n\nReturns the positions-th field of the struct. Asserts if the struct is opaque, not yet initialized or if the position is out of range.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMStructTypeGetIdentifier-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMStructTypeGetIdentifier","text":"mlirLLVMStructTypeGetIdentifier(type)\n\nReturns the identifier of the identified struct. Asserts that the struct is identified, i.e., not literal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMStructTypeGetNumElementTypes-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMStructTypeGetNumElementTypes","text":"mlirLLVMStructTypeGetNumElementTypes(type)\n\nReturns the number of fields in the struct. Asserts if the struct is opaque or not yet initialized.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedGet","text":"mlirLLVMStructTypeIdentifiedGet(ctx, name)\n\nCreates an LLVM identified struct type with no body. If a struct type with this name already exists in the context, returns that type. Use mlirLLVMStructTypeIdentifiedNewGet to create a fresh struct type, potentially renaming it. The body should be set separatelty by calling mlirLLVMStructTypeSetBody, if it isn't set already.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedNewGet-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMStructTypeIdentifiedNewGet","text":"mlirLLVMStructTypeIdentifiedNewGet(ctx, name, nFieldTypes, fieldTypes, isPacked)\n\nCreates an LLVM identified struct type with no body and a name starting with the given prefix. If a struct with the exact name as the given prefix already exists, appends an unspecified suffix to the name so that the name is unique in context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMStructTypeIsLiteral-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMStructTypeIsLiteral","text":"mlirLLVMStructTypeIsLiteral(type)\n\nReturns true if the type is a literal (unnamed) LLVM struct type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMStructTypeIsOpaque-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMStructTypeIsOpaque","text":"mlirLLVMStructTypeIsOpaque(type)\n\nReturns true is the struct is explicitly opaque (will not have a body) or uninitialized (will eventually have a body).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMStructTypeIsPacked-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMStructTypeIsPacked","text":"mlirLLVMStructTypeIsPacked(type)\n\nReturns true if the struct is packed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMStructTypeLiteralGet-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMStructTypeLiteralGet","text":"mlirLLVMStructTypeLiteralGet(ctx, nFieldTypes, fieldTypes, isPacked)\n\nCreates an LLVM literal (unnamed) struct type. This may assert if the fields have types not compatible with the LLVM dialect. For a graceful failure, use the checked version.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMStructTypeLiteralGetChecked-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMStructTypeLiteralGetChecked","text":"mlirLLVMStructTypeLiteralGetChecked(loc, nFieldTypes, fieldTypes, isPacked)\n\nCreates an LLVM literal (unnamed) struct type if possible. Emits a diagnostic at the given location and returns null otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMStructTypeSetBody-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMStructTypeSetBody","text":"mlirLLVMStructTypeSetBody(structType, nFieldTypes, fieldTypes, isPacked)\n\nSets the body of the identified struct if it hasn't been set yet. Returns whether the operation was successful.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLLVMVoidTypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLLVMVoidTypeGet","text":"mlirLLVMVoidTypeGet(ctx)\n\nCreates an llmv.void type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLinalgFillBuiltinNamedOpRegion-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLinalgFillBuiltinNamedOpRegion","text":"mlirLinalgFillBuiltinNamedOpRegion(mlirOp)\n\nApply the special region builder for the builtin named Linalg op. Assert that mlirOp is a builtin named Linalg op.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLlvmThreadPoolCreate-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirLlvmThreadPoolCreate","text":"mlirLlvmThreadPoolCreate()\n\nCreate an LLVM thread pool. This is reexported here to avoid directly pulling in the LLVM headers directly.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLlvmThreadPoolDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLlvmThreadPoolDestroy","text":"mlirLlvmThreadPoolDestroy(pool)\n\nDestroy an LLVM thread pool.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLocationCallSiteGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLocationCallSiteGet","text":"mlirLocationCallSiteGet(callee, caller)\n\nCreates a call site location with a callee and a caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLocationEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLocationEqual","text":"mlirLocationEqual(l1, l2)\n\nChecks if two locations are equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLocationFileLineColGet-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLocationFileLineColGet","text":"mlirLocationFileLineColGet(context, filename, line, col)\n\nCreates an File/Line/Column location owned by the given context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLocationFromAttribute-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLocationFromAttribute","text":"mlirLocationFromAttribute(attribute)\n\nCreates a location from a location attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLocationFusedGet-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLocationFusedGet","text":"mlirLocationFusedGet(ctx, nLocations, locations, metadata)\n\nCreates a fused location with an array of locations and metadata.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLocationGetAttribute-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLocationGetAttribute","text":"mlirLocationGetAttribute(location)\n\nReturns the underlying location attribute of this location.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLocationGetContext-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLocationGetContext","text":"mlirLocationGetContext(location)\n\nGets the context that a location was created with.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLocationIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLocationIsNull","text":"mlirLocationIsNull(location)\n\nChecks if the location is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLocationNameGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLocationNameGet","text":"mlirLocationNameGet(context, name, childLoc)\n\nCreates a name location owned by the given context. Providing null location for childLoc is allowed and if childLoc is null location, then the behavior is the same as having unknown child location.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLocationPrint-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLocationPrint","text":"mlirLocationPrint(location, callback, userData)\n\nPrints a location by sending chunks of the string representation and forwarding userData tocallback`. Note that the callback may be called several times with consecutive chunks of the string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLocationUnknownGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLocationUnknownGet","text":"mlirLocationUnknownGet(context)\n\nCreates a location with unknown position owned by the given context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLogicalResultFailure-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirLogicalResultFailure","text":"mlirLogicalResultFailure()\n\nCreates a logical result representing a failure.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLogicalResultIsFailure-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLogicalResultIsFailure","text":"mlirLogicalResultIsFailure(res)\n\nChecks if the given logical result represents a failure.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLogicalResultIsSuccess-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirLogicalResultIsSuccess","text":"mlirLogicalResultIsSuccess(res)\n\nChecks if the given logical result represents a success.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirLogicalResultSuccess-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirLogicalResultSuccess","text":"mlirLogicalResultSuccess()\n\nCreates a logical result representing a success.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirMemRefTypeContiguousGet-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirMemRefTypeContiguousGet","text":"mlirMemRefTypeContiguousGet(elementType, rank, shape, memorySpace)\n\nCreates a MemRef type with the given rank, shape, memory space and element type in the same context as the element type. The type has no affine maps, i.e. represents a default row-major contiguous memref. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirMemRefTypeContiguousGetChecked-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirMemRefTypeContiguousGetChecked","text":"mlirMemRefTypeContiguousGetChecked(loc, elementType, rank, shape, memorySpace)\n\nSame as \"mlirMemRefTypeContiguousGet\" but returns a nullptr wrapping MlirType on illegal arguments, emitting appropriate diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirMemRefTypeGet-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirMemRefTypeGet","text":"mlirMemRefTypeGet(elementType, rank, shape, layout, memorySpace)\n\nCreates a MemRef type with the given rank and shape, a potentially empty list of affine layout maps, the given memory space and element type, in the same context as element type. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirMemRefTypeGetAffineMap-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirMemRefTypeGetAffineMap","text":"mlirMemRefTypeGetAffineMap(type)\n\nReturns the affine map of the given MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirMemRefTypeGetChecked-NTuple{6, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirMemRefTypeGetChecked","text":"mlirMemRefTypeGetChecked(loc, elementType, rank, shape, layout, memorySpace)\n\nSame as \"mlirMemRefTypeGet\" but returns a nullptr-wrapping MlirType o illegal arguments, emitting appropriate diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirMemRefTypeGetLayout-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirMemRefTypeGetLayout","text":"mlirMemRefTypeGetLayout(type)\n\nReturns the layout of the given MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirMemRefTypeGetMemorySpace-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirMemRefTypeGetMemorySpace","text":"mlirMemRefTypeGetMemorySpace(type)\n\nReturns the memory space of the given MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirMemRefTypeGetStridesAndOffset-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirMemRefTypeGetStridesAndOffset","text":"mlirMemRefTypeGetStridesAndOffset(type, strides, offset)\n\nReturns the strides of the MemRef if the layout map is in strided form. Both strides and offset are out params. strides must point to pre-allocated memory of length equal to the rank of the memref.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirMemRefTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirMemRefTypeGetTypeID","text":"mlirMemRefTypeGetTypeID()\n\nReturns the typeID of an MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirModuleCreateEmpty-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirModuleCreateEmpty","text":"mlirModuleCreateEmpty(location)\n\nCreates a new, empty module and transfers ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirModuleCreateParse-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirModuleCreateParse","text":"mlirModuleCreateParse(context, _module)\n\nParses a module from the string and transfers ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirModuleDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirModuleDestroy","text":"mlirModuleDestroy(_module)\n\nTakes a module owned by the caller and deletes it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirModuleFromOperation-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirModuleFromOperation","text":"mlirModuleFromOperation(op)\n\nViews the generic operation as a module. The returned module is null when the input operation was not a ModuleOp.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirModuleGetBody-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirModuleGetBody","text":"mlirModuleGetBody(_module)\n\nGets the body of the module, i.e. the only block it contains.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirModuleGetContext-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirModuleGetContext","text":"mlirModuleGetContext(_module)\n\nGets the context that a module was created with.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirModuleGetOperation-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirModuleGetOperation","text":"mlirModuleGetOperation(_module)\n\nViews the module as a generic operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirModuleIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirModuleIsNull","text":"mlirModuleIsNull(_module)\n\nChecks whether a module is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirNamedAttributeGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirNamedAttributeGet","text":"mlirNamedAttributeGet(name, attr)\n\nAssociates an attribute with the name. Takes ownership of neither.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirNoneTypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirNoneTypeGet","text":"mlirNoneTypeGet(ctx)\n\nCreates a None type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirNoneTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirNoneTypeGetTypeID","text":"mlirNoneTypeGetTypeID()\n\nReturns the typeID of an None type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpOperandGetNextUse-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpOperandGetNextUse","text":"mlirOpOperandGetNextUse(opOperand)\n\nReturns an op operand representing the next use of the value, or a null op operand if there is no next use.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpOperandGetOperandNumber-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpOperandGetOperandNumber","text":"mlirOpOperandGetOperandNumber(opOperand)\n\nReturns the operand number of an op operand.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpOperandGetOwner-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpOperandGetOwner","text":"mlirOpOperandGetOwner(opOperand)\n\nReturns the owner operation of an op operand.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpOperandGetValue-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpOperandGetValue","text":"mlirOpOperandGetValue(opOperand)\n\nReturns the value of an op operand.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpOperandIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpOperandIsNull","text":"mlirOpOperandIsNull(opOperand)\n\nReturns whether the op operand is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpPassManagerAddOwnedPass-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpPassManagerAddOwnedPass","text":"mlirOpPassManagerAddOwnedPass(passManager, pass)\n\nAdd a pass and transfer ownership to the provided mlirOpPassManager. If the pass is not a generic operation pass or matching the type of the provided PassManager, a new OpPassManager is implicitly nested under the provided PassManager.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpPassManagerAddPipeline-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpPassManagerAddPipeline","text":"mlirOpPassManagerAddPipeline(passManager, pipelineElements, callback, userData)\n\nParse a sequence of textual MLIR pass pipeline elements and add them to the provided OpPassManager. If parsing fails an error message is reported using the provided callback.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpPassManagerGetNestedUnder-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpPassManagerGetNestedUnder","text":"mlirOpPassManagerGetNestedUnder(passManager, operationName)\n\nNest an OpPassManager under the provided OpPassManager, the nested passmanager will only run on operations matching the provided name. The returned OpPassManager will be destroyed when the parent is destroyed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpPrintingFlagsAssumeVerified-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpPrintingFlagsAssumeVerified","text":"mlirOpPrintingFlagsAssumeVerified(flags)\n\nDo not verify the operation when using custom operation printers.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpPrintingFlagsCreate-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirOpPrintingFlagsCreate","text":"mlirOpPrintingFlagsCreate()\n\nCreates new printing flags with defaults, intended for customization. Must be freed with a call to mlirOpPrintingFlagsDestroy().\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpPrintingFlagsDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpPrintingFlagsDestroy","text":"mlirOpPrintingFlagsDestroy(flags)\n\nDestroys printing flags created with mlirOpPrintingFlagsCreate.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeElementsAttrs-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpPrintingFlagsElideLargeElementsAttrs","text":"mlirOpPrintingFlagsElideLargeElementsAttrs(flags, largeElementLimit)\n\nEnables the elision of large elements attributes by printing a lexically valid but otherwise meaningless form instead of the element data. The largeElementLimit is used to configure what is considered to be a \"large\" ElementsAttr by providing an upper limit to the number of elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpPrintingFlagsEnableDebugInfo-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpPrintingFlagsEnableDebugInfo","text":"mlirOpPrintingFlagsEnableDebugInfo(flags, enable, prettyForm)\n\nEnable or disable printing of debug information (based on enable). If 'prettyForm' is set to true, debug information is printed in a more readable 'pretty' form. Note: The IR generated with 'prettyForm' is not parsable.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpPrintingFlagsPrintGenericOpForm-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpPrintingFlagsPrintGenericOpForm","text":"mlirOpPrintingFlagsPrintGenericOpForm(flags)\n\nAlways print operations in the generic form.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpPrintingFlagsUseLocalScope-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpPrintingFlagsUseLocalScope","text":"mlirOpPrintingFlagsUseLocalScope(flags)\n\nUse local scope when printing the operation. This allows for using the printer in a more localized and thread-safe setting, but may not necessarily be identical to what the IR will look like when dumping the full module.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpResultGetOwner-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpResultGetOwner","text":"mlirOpResultGetOwner(value)\n\nReturns an operation that produced this value as its result. Asserts if the value is not an op result.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpResultGetResultNumber-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpResultGetResultNumber","text":"mlirOpResultGetResultNumber(value)\n\nReturns the position of the value in the list of results of the operation that produced it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpaqueAttrGet-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpaqueAttrGet","text":"mlirOpaqueAttrGet(ctx, dialectNamespace, dataLength, data, type)\n\nCreates an opaque attribute in the given context associated with the dialect identified by its namespace. The attribute contains opaque byte data of the specified length (data need not be null-terminated).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpaqueAttrGetData-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpaqueAttrGetData","text":"mlirOpaqueAttrGetData(attr)\n\nReturns the raw data as a string reference. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpaqueAttrGetDialectNamespace-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpaqueAttrGetDialectNamespace","text":"mlirOpaqueAttrGetDialectNamespace(attr)\n\nReturns the namespace of the dialect with which the given opaque attribute is associated. The namespace string is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpaqueAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirOpaqueAttrGetTypeID","text":"mlirOpaqueAttrGetTypeID()\n\nReturns the typeID of an Opaque attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpaqueTypeGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpaqueTypeGet","text":"mlirOpaqueTypeGet(ctx, dialectNamespace, typeData)\n\nCreates an opaque type in the given context associated with the dialect identified by its namespace. The type contains opaque byte data of the specified length (data need not be null-terminated).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpaqueTypeGetData-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpaqueTypeGetData","text":"mlirOpaqueTypeGetData(type)\n\nReturns the raw data as a string reference. The data remains live as long as the context in which the type lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpaqueTypeGetDialectNamespace-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOpaqueTypeGetDialectNamespace","text":"mlirOpaqueTypeGetDialectNamespace(type)\n\nReturns the namespace of the dialect with which the given opaque type is associated. The namespace string is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOpaqueTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirOpaqueTypeGetTypeID","text":"mlirOpaqueTypeGetTypeID()\n\nReturns the typeID of an Opaque type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationClone-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationClone","text":"mlirOperationClone(op)\n\nCreates a deep copy of an operation. The operation is not inserted and ownership is transferred to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationCreate-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationCreate","text":"mlirOperationCreate(state)\n\nCreates an operation and transfers ownership to the caller. Note that caller owned child objects are transferred in this call and must not be further used. Particularly, this applies to any regions added to the state (the implementation may invalidate any such pointers).\n\nThis call can fail under the following conditions, in which case, it will return a null operation and emit diagnostics: - Result type inference is enabled and cannot be performed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationCreateParse-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationCreateParse","text":"mlirOperationCreateParse(context, sourceStr, sourceName)\n\nParses an operation, giving ownership to the caller. If parsing fails a null operation will be returned, and an error diagnostic emitted.\n\nsourceStr may be either the text assembly format, or binary bytecode format. sourceName is used as the file name of the source; any IR without locations will get a FileLineColLoc location with sourceName as the file name.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationDestroy","text":"mlirOperationDestroy(op)\n\nTakes an operation owned by the caller and destroys it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationDump-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationDump","text":"mlirOperationDump(op)\n\nPrints an operation to stderr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationEqual","text":"mlirOperationEqual(op, other)\n\nChecks whether two operation handles point to the same operation. This does not perform deep comparison.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetAttribute-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetAttribute","text":"mlirOperationGetAttribute(op, pos)\n\nReturn pos-th attribute of the operation. Deprecated, please use mlirOperationGetInherentAttribute or mlirOperationGetDiscardableAttribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetAttributeByName-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetAttributeByName","text":"mlirOperationGetAttributeByName(op, name)\n\nReturns an attribute attached to the operation given its name. Deprecated, please use mlirOperationGetInherentAttributeByName or mlirOperationGetDiscardableAttributeByName.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetBlock-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetBlock","text":"mlirOperationGetBlock(op)\n\nGets the block that owns this operation, returning null if the operation is not owned.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetContext-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetContext","text":"mlirOperationGetContext(op)\n\nGets the context this operation is associated with\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetDiscardableAttribute-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetDiscardableAttribute","text":"mlirOperationGetDiscardableAttribute(op, pos)\n\nReturn pos-th discardable attribute of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetDiscardableAttributeByName-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetDiscardableAttributeByName","text":"mlirOperationGetDiscardableAttributeByName(op, name)\n\nReturns a discardable attribute attached to the operation given its name.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetFirstRegion-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetFirstRegion","text":"mlirOperationGetFirstRegion(op)\n\nReturns first region attached to the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetInherentAttributeByName-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetInherentAttributeByName","text":"mlirOperationGetInherentAttributeByName(op, name)\n\nReturns an inherent attribute attached to the operation given its name.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetLocation-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetLocation","text":"mlirOperationGetLocation(op)\n\nGets the location of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetName-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetName","text":"mlirOperationGetName(op)\n\nGets the name of the operation as an identifier.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetNextInBlock-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetNextInBlock","text":"mlirOperationGetNextInBlock(op)\n\nReturns an operation immediately following the given operation it its enclosing block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetNumAttributes-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetNumAttributes","text":"mlirOperationGetNumAttributes(op)\n\nReturns the number of attributes attached to the operation. Deprecated, please use mlirOperationGetNumInherentAttributes or mlirOperationGetNumDiscardableAttributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetNumDiscardableAttributes-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetNumDiscardableAttributes","text":"mlirOperationGetNumDiscardableAttributes(op)\n\nReturns the number of discardable attributes attached to the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetNumOperands-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetNumOperands","text":"mlirOperationGetNumOperands(op)\n\nReturns the number of operands of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetNumRegions-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetNumRegions","text":"mlirOperationGetNumRegions(op)\n\nReturns the number of regions attached to the given operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetNumResults-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetNumResults","text":"mlirOperationGetNumResults(op)\n\nReturns the number of results of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetNumSuccessors-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetNumSuccessors","text":"mlirOperationGetNumSuccessors(op)\n\nReturns the number of successor blocks of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetOperand-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetOperand","text":"mlirOperationGetOperand(op, pos)\n\nReturns pos-th operand of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetParentOperation-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetParentOperation","text":"mlirOperationGetParentOperation(op)\n\nGets the operation that owns this operation, returning null if the operation is not owned.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetRegion-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetRegion","text":"mlirOperationGetRegion(op, pos)\n\nReturns pos-th region attached to the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetResult-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetResult","text":"mlirOperationGetResult(op, pos)\n\nReturns pos-th result of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetSuccessor-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetSuccessor","text":"mlirOperationGetSuccessor(op, pos)\n\nReturns pos-th successor of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationGetTypeID-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationGetTypeID","text":"mlirOperationGetTypeID(op)\n\nGets the type id of the operation. Returns null if the operation does not have a registered operation description.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationHasInherentAttributeByName-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationHasInherentAttributeByName","text":"mlirOperationHasInherentAttributeByName(op, name)\n\nReturns true if this operation defines an inherent attribute with this name. Note: the attribute can be optional, so mlirOperationGetInherentAttributeByName can still return a null attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationImplementsInterface-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationImplementsInterface","text":"mlirOperationImplementsInterface(operation, interfaceTypeID)\n\nReturns true if the given operation implements an interface identified by its TypeID.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationImplementsInterfaceStatic-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationImplementsInterfaceStatic","text":"mlirOperationImplementsInterfaceStatic(operationName, context, interfaceTypeID)\n\nReturns true if the operation identified by its canonical string name implements the interface identified by its TypeID in the given context. Note that interfaces may be attached to operations in some contexts and not others.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationIsNull","text":"mlirOperationIsNull(op)\n\nChecks whether the underlying operation is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationMoveAfter-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationMoveAfter","text":"mlirOperationMoveAfter(op, other)\n\nMoves the given operation immediately after the other operation in its parent block. The given operation may be owned by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationMoveBefore-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationMoveBefore","text":"mlirOperationMoveBefore(op, other)\n\nMoves the given operation immediately before the other operation in its parent block. The given operation may be owner by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationPrint-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationPrint","text":"mlirOperationPrint(op, callback, userData)\n\nPrints an operation by sending chunks of the string representation and forwarding userData tocallback`. Note that the callback may be called several times with consecutive chunks of the string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationPrintWithFlags-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationPrintWithFlags","text":"mlirOperationPrintWithFlags(op, flags, callback, userData)\n\nSame as mlirOperationPrint but accepts flags controlling the printing behavior.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationPrintWithState-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationPrintWithState","text":"mlirOperationPrintWithState(op, state, callback, userData)\n\nSame as mlirOperationPrint but accepts AsmState controlling the printing behavior as well as caching computed names.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationRemoveAttributeByName-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationRemoveAttributeByName","text":"mlirOperationRemoveAttributeByName(op, name)\n\nRemoves an attribute by name. Returns false if the attribute was not found and true if removed. Deprecated, please use mlirOperationRemoveInherentAttributeByName or mlirOperationRemoveDiscardableAttributeByName.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationRemoveDiscardableAttributeByName-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationRemoveDiscardableAttributeByName","text":"mlirOperationRemoveDiscardableAttributeByName(op, name)\n\nRemoves a discardable attribute by name. Returns false if the attribute was not found and true if removed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationRemoveFromParent-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationRemoveFromParent","text":"mlirOperationRemoveFromParent(op)\n\nRemoves the given operation from its parent block. The operation is not destroyed. The ownership of the operation is transferred to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationSetAttributeByName-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationSetAttributeByName","text":"mlirOperationSetAttributeByName(op, name, attr)\n\nSets an attribute by name, replacing the existing if it exists or adding a new one otherwise. Deprecated, please use mlirOperationSetInherentAttributeByName or mlirOperationSetDiscardableAttributeByName.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationSetDiscardableAttributeByName-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationSetDiscardableAttributeByName","text":"mlirOperationSetDiscardableAttributeByName(op, name, attr)\n\nSets a discardable attribute by name, replacing the existing if it exists or adding a new one otherwise. The new attr Attribute is not allowed to be null, use mlirOperationRemoveDiscardableAttributeByName to remove an Attribute instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationSetInherentAttributeByName-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationSetInherentAttributeByName","text":"mlirOperationSetInherentAttributeByName(op, name, attr)\n\nSets an inherent attribute by name, replacing the existing if it exists. This has no effect if \"name\" does not match an inherent attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationSetOperand-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationSetOperand","text":"mlirOperationSetOperand(op, pos, newValue)\n\nSets the pos-th operand of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationSetOperands-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationSetOperands","text":"mlirOperationSetOperands(op, nOperands, operands)\n\nReplaces the operands of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationSetSuccessor-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationSetSuccessor","text":"mlirOperationSetSuccessor(op, pos, block)\n\nSet pos-th successor of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationStateAddResults-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationStateAddResults","text":"mlirOperationStateAddResults(state, n, results)\n\nAdds a list of components to the operation state.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationStateEnableResultTypeInference-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationStateEnableResultTypeInference","text":"mlirOperationStateEnableResultTypeInference(state)\n\nEnables result type inference for the operation under construction. If enabled, then the caller must not have called mlirOperationStateAddResults(). Note that if enabled, the mlirOperationCreate() call is failable: it will return a null operation on inference failure and will emit diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationStateGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationStateGet","text":"mlirOperationStateGet(name, loc)\n\nConstructs an operation state from a name and a location.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationVerify-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationVerify","text":"mlirOperationVerify(op)\n\nVerify the operation and return true if it passes, false if it fails.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationWalk-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationWalk","text":"mlirOperationWalk(op, callback, userData, walkOrder)\n\nWalks operation op in walkOrder and calls callback on that operation. *userData is passed to the callback as well and can be used to tunnel some context or other data into the callback.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationWriteBytecode-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationWriteBytecode","text":"mlirOperationWriteBytecode(op, callback, userData)\n\nSame as mlirOperationPrint but writing the bytecode format.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirOperationWriteBytecodeWithConfig-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirOperationWriteBytecodeWithConfig","text":"mlirOperationWriteBytecodeWithConfig(op, config, callback, userData)\n\nSame as mlirOperationWriteBytecode but with writer config and returns failure only if desired bytecode could not be honored.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirParsePassPipeline-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirParsePassPipeline","text":"mlirParsePassPipeline(passManager, pipeline, callback, userData)\n\nParse a textual MLIR pass pipeline and assign it to the provided OpPassManager. If parsing fails an error message is reported using the provided callback.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirPassManagerAddOwnedPass-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirPassManagerAddOwnedPass","text":"mlirPassManagerAddOwnedPass(passManager, pass)\n\nAdd a pass and transfer ownership to the provided top-level mlirPassManager. If the pass is not a generic operation pass or a ModulePass, a new OpPassManager is implicitly nested under the provided PassManager.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirPassManagerCreate-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirPassManagerCreate","text":"mlirPassManagerCreate(ctx)\n\nCreate a new top-level PassManager with the default anchor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirPassManagerCreateOnOperation-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirPassManagerCreateOnOperation","text":"mlirPassManagerCreateOnOperation(ctx, anchorOp)\n\nCreate a new top-level PassManager anchored on anchorOp.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirPassManagerDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirPassManagerDestroy","text":"mlirPassManagerDestroy(passManager)\n\nDestroy the provided PassManager.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirPassManagerEnableIRPrinting-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirPassManagerEnableIRPrinting","text":"mlirPassManagerEnableIRPrinting(passManager)\n\nEnable mlir-print-ir-after-all.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirPassManagerEnableVerifier-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirPassManagerEnableVerifier","text":"mlirPassManagerEnableVerifier(passManager, enable)\n\nEnable / disable verify-each.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirPassManagerGetAsOpPassManager-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirPassManagerGetAsOpPassManager","text":"mlirPassManagerGetAsOpPassManager(passManager)\n\nCast a top-level PassManager to a generic OpPassManager.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirPassManagerGetNestedUnder-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirPassManagerGetNestedUnder","text":"mlirPassManagerGetNestedUnder(passManager, operationName)\n\nNest an OpPassManager under the top-level PassManager, the nested passmanager will only run on operations matching the provided name. The returned OpPassManager will be destroyed when the parent is destroyed. To further nest more OpPassManager under the newly returned one, see mlirOpPassManagerNest below.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirPassManagerIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirPassManagerIsNull","text":"mlirPassManagerIsNull(passManager)\n\nChecks if a PassManager is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirPassManagerRunOnOp-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirPassManagerRunOnOp","text":"mlirPassManagerRunOnOp(passManager, op)\n\nRun the provided passManager on the given op.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirPrintPassPipeline-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirPrintPassPipeline","text":"mlirPrintPassPipeline(passManager, callback, userData)\n\nPrint a textual MLIR pass pipeline by sending chunks of the string representation and forwarding userData tocallback`. Note that the callback may be called several times with consecutive chunks of the string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeCastExpressedToStorageType-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeCastExpressedToStorageType","text":"mlirQuantizedTypeCastExpressedToStorageType(type, candidate)\n\nCasts from a type based on the expressed type of the given quantized type to equivalent type based on storage type of the same quantized type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeCastFromExpressedType-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeCastFromExpressedType","text":"mlirQuantizedTypeCastFromExpressedType(type, candidate)\n\nCasts from a type based on the expressed type of the given type to a corresponding type based on the given type. Returns a null type if the cast is not valid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeCastFromStorageType-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeCastFromStorageType","text":"mlirQuantizedTypeCastFromStorageType(type, candidate)\n\nCasts from a type based on the storage type of the given type to a corresponding type based on the given type. Returns a null type if the cast is not valid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeCastToExpressedType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeCastToExpressedType","text":"mlirQuantizedTypeCastToExpressedType(type)\n\nCasts from a type based on a quantized type to a corresponding typed based on the expressed type. Returns a null type if the cast is not valid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeCastToStorageType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeCastToStorageType","text":"mlirQuantizedTypeCastToStorageType(type)\n\nCasts from a type based on a quantized type to a corresponding typed based on the storage type. Returns a null type if the cast is not valid.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMaximumForInteger-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMaximumForInteger","text":"mlirQuantizedTypeGetDefaultMaximumForInteger(isSigned, integralWidth)\n\nReturns the maximum possible value stored by a quantized type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMinimumForInteger-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeGetDefaultMinimumForInteger","text":"mlirQuantizedTypeGetDefaultMinimumForInteger(isSigned, integralWidth)\n\nReturns the minimum possible value stored by a quantized type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeGetExpressedType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeGetExpressedType","text":"mlirQuantizedTypeGetExpressedType(type)\n\nGets the original type approximated by the given quantized type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeGetFlags-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeGetFlags","text":"mlirQuantizedTypeGetFlags(type)\n\nGets the flags associated with the given quantized type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeGetQuantizedElementType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeGetQuantizedElementType","text":"mlirQuantizedTypeGetQuantizedElementType(type)\n\nReturns the element type of the given quantized type as another quantized type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeGetSignedFlag-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeGetSignedFlag","text":"mlirQuantizedTypeGetSignedFlag()\n\nReturns the bit flag used to indicate signedness of a quantized type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeGetStorageType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeGetStorageType","text":"mlirQuantizedTypeGetStorageType(type)\n\nReturns the underlying type used to store the values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeIntegralWidth-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeIntegralWidth","text":"mlirQuantizedTypeGetStorageTypeIntegralWidth(type)\n\nReturns the integral bitwidth that the storage type of the given quantized type can represent exactly.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMax-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMax","text":"mlirQuantizedTypeGetStorageTypeMax(type)\n\nReturns the maximum value that the storage type of the given quantized type can take.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMin-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeGetStorageTypeMin","text":"mlirQuantizedTypeGetStorageTypeMin(type)\n\nReturns the minimum value that the storage type of the given quantized type can take.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeIsCompatibleExpressedType-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeIsCompatibleExpressedType","text":"mlirQuantizedTypeIsCompatibleExpressedType(type, candidate)\n\nReturns true if the candidate type is compatible with the given quantized type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirQuantizedTypeIsSigned-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirQuantizedTypeIsSigned","text":"mlirQuantizedTypeIsSigned(type)\n\nReturns true if the given type is signed, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRankedTensorTypeGet-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRankedTensorTypeGet","text":"mlirRankedTensorTypeGet(rank, shape, elementType, encoding)\n\nCreates a tensor type of a fixed rank with the given shape, element type, and optional encoding in the same context as the element type. The type is owned by the context. Tensor types without any specific encoding field should assign mlirAttributeGetNull() to this parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRankedTensorTypeGetChecked-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRankedTensorTypeGetChecked","text":"mlirRankedTensorTypeGetChecked(loc, rank, shape, elementType, encoding)\n\nSame as \"mlirRankedTensorTypeGet\" but returns a nullptr wrapping MlirType on illegal arguments, emitting appropriate diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRankedTensorTypeGetEncoding-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRankedTensorTypeGetEncoding","text":"mlirRankedTensorTypeGetEncoding(type)\n\nGets the 'encoding' attribute from the ranked tensor type, returning a null attribute if none.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRankedTensorTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirRankedTensorTypeGetTypeID","text":"mlirRankedTensorTypeGetTypeID()\n\nReturns the typeID of an RankedTensor type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegionAppendOwnedBlock-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRegionAppendOwnedBlock","text":"mlirRegionAppendOwnedBlock(region, block)\n\nTakes a block owned by the caller and appends it to the given region.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegionCreate-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirRegionCreate","text":"mlirRegionCreate()\n\nCreates a new empty region and transfers ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegionDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRegionDestroy","text":"mlirRegionDestroy(region)\n\nTakes a region owned by the caller and destroys it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegionEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRegionEqual","text":"mlirRegionEqual(region, other)\n\nChecks whether two region handles point to the same region. This does not perform deep comparison.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegionGetFirstBlock-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRegionGetFirstBlock","text":"mlirRegionGetFirstBlock(region)\n\nGets the first block in the region.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegionGetNextInOperation-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRegionGetNextInOperation","text":"mlirRegionGetNextInOperation(region)\n\nReturns the region immediately following the given region in its parent operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegionInsertOwnedBlock-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRegionInsertOwnedBlock","text":"mlirRegionInsertOwnedBlock(region, pos, block)\n\nTakes a block owned by the caller and inserts it at pos to the given region. This is an expensive operation that linearly scans the region, prefer insertAfter/Before instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegionInsertOwnedBlockAfter-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRegionInsertOwnedBlockAfter","text":"mlirRegionInsertOwnedBlockAfter(region, reference, block)\n\nTakes a block owned by the caller and inserts it after the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, prepends the block to the region.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegionInsertOwnedBlockBefore-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRegionInsertOwnedBlockBefore","text":"mlirRegionInsertOwnedBlockBefore(region, reference, block)\n\nTakes a block owned by the caller and inserts it before the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, appends the block to the region.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegionIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRegionIsNull","text":"mlirRegionIsNull(region)\n\nChecks whether a region is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegionTakeBody-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRegionTakeBody","text":"mlirRegionTakeBody(target, source)\n\nMoves the entire content of the source region to the target region.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegisterAllDialects-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRegisterAllDialects","text":"mlirRegisterAllDialects(registry)\n\nAppends all upstream dialects and extensions to the dialect registry.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegisterAllLLVMTranslations-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirRegisterAllLLVMTranslations","text":"mlirRegisterAllLLVMTranslations(context)\n\nRegister all translations to LLVM IR for dialects that can support it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirRegisterAllPasses-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirRegisterAllPasses","text":"mlirRegisterAllPasses()\n\nRegister all compiler passes of MLIR.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirShapedTypeGetDimSize-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirShapedTypeGetDimSize","text":"mlirShapedTypeGetDimSize(type, dim)\n\nReturns the dim-th dimension of the given ranked shaped type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirShapedTypeGetDynamicSize-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirShapedTypeGetDynamicSize","text":"mlirShapedTypeGetDynamicSize()\n\nReturns the value indicating a dynamic size in a shaped type. Prefer mlirShapedTypeIsDynamicSize to direct comparisons with this value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirShapedTypeGetDynamicStrideOrOffset-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirShapedTypeGetDynamicStrideOrOffset","text":"mlirShapedTypeGetDynamicStrideOrOffset()\n\nReturns the value indicating a dynamic stride or offset in a shaped type. Prefer mlirShapedTypeGetDynamicStrideOrOffset to direct comparisons with this value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirShapedTypeGetElementType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirShapedTypeGetElementType","text":"mlirShapedTypeGetElementType(type)\n\nReturns the element type of the shaped type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirShapedTypeGetRank-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirShapedTypeGetRank","text":"mlirShapedTypeGetRank(type)\n\nReturns the rank of the given ranked shaped type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirShapedTypeHasRank-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirShapedTypeHasRank","text":"mlirShapedTypeHasRank(type)\n\nChecks whether the given shaped type is ranked.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirShapedTypeHasStaticShape-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirShapedTypeHasStaticShape","text":"mlirShapedTypeHasStaticShape(type)\n\nChecks whether the given shaped type has a static shape.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirShapedTypeIsDynamicDim-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirShapedTypeIsDynamicDim","text":"mlirShapedTypeIsDynamicDim(type, dim)\n\nChecks wither the dim-th dimension of the given shaped type is dynamic.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirShapedTypeIsDynamicSize-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirShapedTypeIsDynamicSize","text":"mlirShapedTypeIsDynamicSize(size)\n\nChecks whether the given value is used as a placeholder for dynamic sizes in shaped types.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirShapedTypeIsDynamicStrideOrOffset-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirShapedTypeIsDynamicStrideOrOffset","text":"mlirShapedTypeIsDynamicStrideOrOffset(val)\n\nChecks whether the given value is used as a placeholder for dynamic strides and offsets in shaped types.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSparseElementsAttrGetIndices-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSparseElementsAttrGetIndices","text":"mlirSparseElementsAttrGetIndices(attr)\n\nReturns the dense elements attribute containing 64-bit integer indices of non-null elements in the given sparse elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSparseElementsAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirSparseElementsAttrGetTypeID","text":"mlirSparseElementsAttrGetTypeID()\n\nReturns the typeID of a SparseElements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSparseElementsAttrGetValues-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSparseElementsAttrGetValues","text":"mlirSparseElementsAttrGetValues(attr)\n\nReturns the dense elements attribute containing the non-null elements in the given sparse elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSparseElementsAttribute-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSparseElementsAttribute","text":"mlirSparseElementsAttribute(shapedType, denseIndices, denseValues)\n\nCreates a sparse elements attribute of the given shape from a list of indices and a list of associated values. Both lists are expected to be dense elements attributes with the same number of elements. The list of indices is expected to contain 64-bit integers. The attribute is created in the same context as the type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGet-NTuple{7, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGet","text":"mlirSparseTensorEncodingAttrGet(ctx, lvlRank, lvlTypes, dimToLvl, lvlTodim, posWidth, crdWidth)\n\nCreates a sparse\\_tensor.encoding attribute with the given parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetCrdWidth-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetCrdWidth","text":"mlirSparseTensorEncodingAttrGetCrdWidth(attr)\n\nReturns the coordinate bitwidth of the sparse\\_tensor.encoding attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetDimToLvl-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetDimToLvl","text":"mlirSparseTensorEncodingAttrGetDimToLvl(attr)\n\nReturns the dimension-to-level mapping of the sparse\\_tensor.encoding attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlFmt-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlFmt","text":"mlirSparseTensorEncodingAttrGetLvlFmt(attr, lvl)\n\nReturns a specified level-format of the sparse\\_tensor.encoding attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlToDim-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlToDim","text":"mlirSparseTensorEncodingAttrGetLvlToDim(attr)\n\nReturns the level-to-dimension mapping of the sparse\\_tensor.encoding attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlType-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetLvlType","text":"mlirSparseTensorEncodingAttrGetLvlType(attr, lvl)\n\nReturns a specified level-type of the sparse\\_tensor.encoding attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetPosWidth-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSparseTensorEncodingAttrGetPosWidth","text":"mlirSparseTensorEncodingAttrGetPosWidth(attr)\n\nReturns the position bitwidth of the sparse\\_tensor.encoding attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSparseTensorEncodingGetLvlRank-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSparseTensorEncodingGetLvlRank","text":"mlirSparseTensorEncodingGetLvlRank(attr)\n\nReturns the level-rank of the sparse\\_tensor.encoding attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirStridedLayoutAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirStridedLayoutAttrGetTypeID","text":"mlirStridedLayoutAttrGetTypeID()\n\nReturns the typeID of a StridedLayout attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirStringAttrGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirStringAttrGet","text":"mlirStringAttrGet(ctx, str)\n\nCreates a string attribute in the given context containing the given string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirStringAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirStringAttrGetTypeID","text":"mlirStringAttrGetTypeID()\n\nReturns the typeID of a String attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirStringAttrGetValue-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirStringAttrGetValue","text":"mlirStringAttrGetValue(attr)\n\nReturns the attribute values as a string reference. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirStringAttrTypedGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirStringAttrTypedGet","text":"mlirStringAttrTypedGet(type, str)\n\nCreates a string attribute in the given context containing the given string. Additionally, the attribute has the given type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirStringRefCreate-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirStringRefCreate","text":"mlirStringRefCreate(str, length)\n\nConstructs a string reference from the pointer and length. The pointer need not reference to a null-terminated string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirStringRefCreateFromCString-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirStringRefCreateFromCString","text":"mlirStringRefCreateFromCString(str)\n\nConstructs a string reference from a null-terminated C string. Prefer mlirStringRefCreate if the length of the string is known.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirStringRefEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirStringRefEqual","text":"mlirStringRefEqual(string, other)\n\nReturns true if two string references are equal, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolRefAttrGet-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolRefAttrGet","text":"mlirSymbolRefAttrGet(ctx, symbol, numReferences, references)\n\nCreates a symbol reference attribute in the given context referencing a symbol identified by the given string inside a list of nested references. Each of the references in the list must not be nested.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolRefAttrGetLeafReference-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolRefAttrGetLeafReference","text":"mlirSymbolRefAttrGetLeafReference(attr)\n\nReturns the string reference to the leaf referenced symbol. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolRefAttrGetNestedReference-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolRefAttrGetNestedReference","text":"mlirSymbolRefAttrGetNestedReference(attr, pos)\n\nReturns pos-th reference nested in the given symbol reference attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolRefAttrGetNumNestedReferences-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolRefAttrGetNumNestedReferences","text":"mlirSymbolRefAttrGetNumNestedReferences(attr)\n\nReturns the number of references nested in the given symbol reference attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolRefAttrGetRootReference-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolRefAttrGetRootReference","text":"mlirSymbolRefAttrGetRootReference(attr)\n\nReturns the string reference to the root referenced symbol. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolRefAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolRefAttrGetTypeID","text":"mlirSymbolRefAttrGetTypeID()\n\nReturns the typeID of an SymbolRef attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolTableCreate-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolTableCreate","text":"mlirSymbolTableCreate(operation)\n\nCreates a symbol table for the given operation. If the operation does not have the SymbolTable trait, returns a null symbol table.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolTableDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolTableDestroy","text":"mlirSymbolTableDestroy(symbolTable)\n\nDestroys the symbol table created with mlirSymbolTableCreate. This does not affect the operations in the table.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolTableErase-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolTableErase","text":"mlirSymbolTableErase(symbolTable, operation)\n\nRemoves the given operation from the symbol table and erases it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolTableGetSymbolAttributeName-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolTableGetSymbolAttributeName","text":"mlirSymbolTableGetSymbolAttributeName()\n\nReturns the name of the attribute used to store symbol names compatible with symbol tables.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolTableGetVisibilityAttributeName-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolTableGetVisibilityAttributeName","text":"mlirSymbolTableGetVisibilityAttributeName()\n\nReturns the name of the attribute used to store symbol visibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolTableInsert-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolTableInsert","text":"mlirSymbolTableInsert(symbolTable, operation)\n\nInserts the given operation into the given symbol table. The operation must have the symbol trait. If the symbol table already has a symbol with the same name, renames the symbol being inserted to ensure name uniqueness. Note that this does not move the operation itself into the block of the symbol table operation, this should be done separately. Returns the name of the symbol after insertion.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolTableIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolTableIsNull","text":"mlirSymbolTableIsNull(symbolTable)\n\nReturns true if the symbol table is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolTableLookup-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolTableLookup","text":"mlirSymbolTableLookup(symbolTable, name)\n\nLooks up a symbol with the given name in the given symbol table and returns the operation that corresponds to the symbol. If the symbol cannot be found, returns a null operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolTableReplaceAllSymbolUses-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolTableReplaceAllSymbolUses","text":"mlirSymbolTableReplaceAllSymbolUses(oldSymbol, newSymbol, from)\n\nAttempt to replace all uses that are nested within the given operation of the given symbol 'oldSymbol' with the provided 'newSymbol'. This does not traverse into nested symbol tables. Will fail atomically if there are any unknown operations that may be potential symbol tables.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirSymbolTableWalkSymbolTables-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirSymbolTableWalkSymbolTables","text":"mlirSymbolTableWalkSymbolTables(from, allSymUsesVisible, callback, userData)\n\nWalks all symbol table operations nested within, and including, op. For each symbol table operation, the provided callback is invoked with the op and a boolean signifying if the symbols within that symbol table can be treated as if all uses within the IR are visible to the caller. allSymUsesVisible identifies whether all of the symbol uses of symbols within op are visible.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTF32TypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTF32TypeGet","text":"mlirTF32TypeGet(ctx)\n\nCreates a TF32 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTransformApplyNamedSequence-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTransformApplyNamedSequence","text":"mlirTransformApplyNamedSequence(payload, transformRoot, transformModule, transformOptions)\n\nApplies the transformation script starting at the given transform root operation to the given payload operation. The module containing the transform root as well as the transform options should be provided. The transform operation must implement TransformOpInterface and the module must be a ModuleOp. Returns the status of the application.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTransformOptionsCreate-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirTransformOptionsCreate","text":"mlirTransformOptionsCreate()\n\nCreates a default-initialized transform options object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTransformOptionsDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTransformOptionsDestroy","text":"mlirTransformOptionsDestroy(transformOptions)\n\nDestroys a transform options object previously created by mlirTransformOptionsCreate.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTransformOptionsEnableExpensiveChecks-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTransformOptionsEnableExpensiveChecks","text":"mlirTransformOptionsEnableExpensiveChecks(transformOptions, enable)\n\nEnables or disables expensive checks in transform options.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTransformOptionsEnforceSingleTopLevelTransformOp-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTransformOptionsEnforceSingleTopLevelTransformOp","text":"mlirTransformOptionsEnforceSingleTopLevelTransformOp(transformOptions, enable)\n\nEnables or disables the enforcement of the top-level transform op being single in transform options.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTransformOptionsGetEnforceSingleTopLevelTransformOp-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTransformOptionsGetEnforceSingleTopLevelTransformOp","text":"mlirTransformOptionsGetEnforceSingleTopLevelTransformOp(transformOptions)\n\nReturns true if the enforcement of the top-level transform op being single is enabled in transform options.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTransformOptionsGetExpensiveChecksEnabled-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTransformOptionsGetExpensiveChecksEnabled","text":"mlirTransformOptionsGetExpensiveChecksEnabled(transformOptions)\n\nReturns true if expensive checks are enabled in transform options.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTranslateModuleToLLVMIR-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTranslateModuleToLLVMIR","text":"mlirTranslateModuleToLLVMIR(_module, context)\n\nTranslate operation that satisfies LLVM dialect module requirements into an LLVM IR module living in the given context. This translates operations from any dilalect that has a registered implementation of LLVMTranslationDialectInterface.\n\nReturns\n\nthe generated LLVM IR Module from the translated MLIR module, it is owned by the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTupleTypeGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTupleTypeGet","text":"mlirTupleTypeGet(ctx, numElements, elements)\n\nCreates a tuple type that consists of the given list of elemental types. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTupleTypeGetNumTypes-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTupleTypeGetNumTypes","text":"mlirTupleTypeGetNumTypes(type)\n\nReturns the number of types contained in a tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTupleTypeGetType-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTupleTypeGetType","text":"mlirTupleTypeGetType(type, pos)\n\nReturns the pos-th type in the tuple type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTupleTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirTupleTypeGetTypeID","text":"mlirTupleTypeGetTypeID()\n\nReturns the typeID of an Tuple type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeAttrGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeAttrGet","text":"mlirTypeAttrGet(type)\n\nCreates a type attribute wrapping the given type in the same context as the type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeAttrGetTypeID","text":"mlirTypeAttrGetTypeID()\n\nReturns the typeID of a Type attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeAttrGetValue-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeAttrGetValue","text":"mlirTypeAttrGetValue(attr)\n\nReturns the type stored in the given type attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeDump-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeDump","text":"mlirTypeDump(type)\n\nPrints the type to the standard error stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeEqual","text":"mlirTypeEqual(t1, t2)\n\nChecks if two types are equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeGetContext-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeGetContext","text":"mlirTypeGetContext(type)\n\nGets the context that a type was created with.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeGetDialect-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeGetDialect","text":"mlirTypeGetDialect(type)\n\nGets the dialect a type belongs to.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeGetTypeID-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeGetTypeID","text":"mlirTypeGetTypeID(type)\n\nGets the type ID of the type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIDAllocatorAllocateTypeID-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIDAllocatorAllocateTypeID","text":"mlirTypeIDAllocatorAllocateTypeID(allocator)\n\nAllocates a type id that is valid for the lifetime of the allocator\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIDAllocatorCreate-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIDAllocatorCreate","text":"mlirTypeIDAllocatorCreate()\n\nCreates a type id allocator for dynamic type id creation\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIDAllocatorDestroy-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIDAllocatorDestroy","text":"mlirTypeIDAllocatorDestroy(allocator)\n\nDeallocates the allocator and all allocated type ids\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIDCreate-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIDCreate","text":"mlirTypeIDCreate(ptr)\n\nptr must be 8 byte aligned and unique to a type valid for the duration of the returned type id's usage\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIDEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIDEqual","text":"mlirTypeIDEqual(typeID1, typeID2)\n\nChecks if two type ids are equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIDHashValue-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIDHashValue","text":"mlirTypeIDHashValue(typeID)\n\nReturns the hash value of the type id.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIDIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIDIsNull","text":"mlirTypeIDIsNull(typeID)\n\nChecks whether a type id is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAAnyQuantizedType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAAnyQuantizedType","text":"mlirTypeIsAAnyQuantizedType(type)\n\nReturns true if the given type is an AnyQuantizedType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsABF16-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsABF16","text":"mlirTypeIsABF16(type)\n\nChecks whether the given type is a bf16 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsACalibratedQuantizedType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsACalibratedQuantizedType","text":"mlirTypeIsACalibratedQuantizedType(type)\n\nReturns true if the given type is a CalibratedQuantizedType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAComplex-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAComplex","text":"mlirTypeIsAComplex(type)\n\nChecks whether the given type is a Complex type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAF16-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAF16","text":"mlirTypeIsAF16(type)\n\nChecks whether the given type is an f16 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAF32-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAF32","text":"mlirTypeIsAF32(type)\n\nChecks whether the given type is an f32 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAF64-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAF64","text":"mlirTypeIsAF64(type)\n\nChecks whether the given type is an f64 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAFloat-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAFloat","text":"mlirTypeIsAFloat(type)\n\nChecks whether the given type is a floating-point type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAFloat8E4M3B11FNUZ-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAFloat8E4M3B11FNUZ","text":"mlirTypeIsAFloat8E4M3B11FNUZ(type)\n\nChecks whether the given type is an f8E4M3B11FNUZ type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FN-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FN","text":"mlirTypeIsAFloat8E4M3FN(type)\n\nChecks whether the given type is an f8E4M3FN type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FNUZ-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAFloat8E4M3FNUZ","text":"mlirTypeIsAFloat8E4M3FNUZ(type)\n\nChecks whether the given type is an f8E4M3FNUZ type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAFloat8E5M2-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAFloat8E5M2","text":"mlirTypeIsAFloat8E5M2(type)\n\nChecks whether the given type is an f8E5M2 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAFloat8E5M2FNUZ-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAFloat8E5M2FNUZ","text":"mlirTypeIsAFloat8E5M2FNUZ(type)\n\nChecks whether the given type is an f8E5M2FNUZ type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAFunction-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAFunction","text":"mlirTypeIsAFunction(type)\n\nChecks whether the given type is a function type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAIndex-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAIndex","text":"mlirTypeIsAIndex(type)\n\nChecks whether the given type is an index type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAInteger-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAInteger","text":"mlirTypeIsAInteger(type)\n\nChecks whether the given type is an integer type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsALLVMStructType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsALLVMStructType","text":"mlirTypeIsALLVMStructType(type)\n\nReturns true if the type is an LLVM dialect struct type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAMemRef-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAMemRef","text":"mlirTypeIsAMemRef(type)\n\nChecks whether the given type is a MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsANone-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsANone","text":"mlirTypeIsANone(type)\n\nChecks whether the given type is a None type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAOpaque-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAOpaque","text":"mlirTypeIsAOpaque(type)\n\nChecks whether the given type is an opaque type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAQuantizedType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAQuantizedType","text":"mlirTypeIsAQuantizedType(type)\n\nReturns true if the given type is a quantization dialect type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsARankedTensor-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsARankedTensor","text":"mlirTypeIsARankedTensor(type)\n\nChecks whether the given type is a ranked tensor type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAShaped-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAShaped","text":"mlirTypeIsAShaped(type)\n\nChecks whether the given type is a Shaped type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsATF32-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsATF32","text":"mlirTypeIsATF32(type)\n\nChecks whether the given type is an TF32 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsATensor-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsATensor","text":"mlirTypeIsATensor(type)\n\nChecks whether the given type is a Tensor type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsATuple-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsATuple","text":"mlirTypeIsATuple(type)\n\nChecks whether the given type is a tuple type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAUniformQuantizedPerAxisType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAUniformQuantizedPerAxisType","text":"mlirTypeIsAUniformQuantizedPerAxisType(type)\n\nReturns true if the given type is a UniformQuantizedPerAxisType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAUniformQuantizedType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAUniformQuantizedType","text":"mlirTypeIsAUniformQuantizedType(type)\n\nReturns true if the given type is a UniformQuantizedType.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAUnrankedMemRef-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAUnrankedMemRef","text":"mlirTypeIsAUnrankedMemRef(type)\n\nChecks whether the given type is an UnrankedMemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAUnrankedTensor-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAUnrankedTensor","text":"mlirTypeIsAUnrankedTensor(type)\n\nChecks whether the given type is an unranked tensor type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsAVector-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsAVector","text":"mlirTypeIsAVector(type)\n\nChecks whether the given type is a Vector type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeIsNull","text":"mlirTypeIsNull(type)\n\nChecks whether a type is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypeParseGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypeParseGet","text":"mlirTypeParseGet(context, type)\n\nParses a type. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirTypePrint-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirTypePrint","text":"mlirTypePrint(type, callback, userData)\n\nPrints a location by sending chunks of the string representation and forwarding userData tocallback`. Note that the callback may be called several times with consecutive chunks of the string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGet-NTuple{9, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGet","text":"mlirUniformQuantizedPerAxisTypeGet(flags, storageType, expressedType, nDims, scales, zeroPoints, quantizedDimension, storageTypeMin, storageTypeMax)\n\nCreates an instance of UniformQuantizedPerAxisType with the given parameters in the same context as storageType and returns it. scales and zeroPoints point to nDims number of elements. The instance is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetNumDims-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetNumDims","text":"mlirUniformQuantizedPerAxisTypeGetNumDims(type)\n\nReturns the number of axes in the given quantized per-axis type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetQuantizedDimension-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetQuantizedDimension","text":"mlirUniformQuantizedPerAxisTypeGetQuantizedDimension(type)\n\nReturns the index of the quantized dimension in the given quantized per-axis type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetScale-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetScale","text":"mlirUniformQuantizedPerAxisTypeGetScale(type, pos)\n\nReturns pos-th scale of the given quantized per-axis type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetZeroPoint-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeGetZeroPoint","text":"mlirUniformQuantizedPerAxisTypeGetZeroPoint(type, pos)\n\nReturns pos-th zero point of the given quantized per-axis type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeIsFixedPoint-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUniformQuantizedPerAxisTypeIsFixedPoint","text":"mlirUniformQuantizedPerAxisTypeIsFixedPoint(type)\n\nReturns true if the given uniform quantized per-axis type is fixed-point.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUniformQuantizedTypeGet-NTuple{7, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUniformQuantizedTypeGet","text":"mlirUniformQuantizedTypeGet(flags, storageType, expressedType, scale, zeroPoint, storageTypeMin, storageTypeMax)\n\nCreates an instance of UniformQuantizedType with the given parameters in the same context as storageType and returns it. The instance is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUniformQuantizedTypeGetScale-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUniformQuantizedTypeGetScale","text":"mlirUniformQuantizedTypeGetScale(type)\n\nReturns the scale of the given uniform quantized type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUniformQuantizedTypeGetZeroPoint-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUniformQuantizedTypeGetZeroPoint","text":"mlirUniformQuantizedTypeGetZeroPoint(type)\n\nReturns the zero point of the given uniform quantized type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUniformQuantizedTypeIsFixedPoint-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUniformQuantizedTypeIsFixedPoint","text":"mlirUniformQuantizedTypeIsFixedPoint(type)\n\nReturns true if the given uniform quantized type is fixed-point.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUnitAttrGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUnitAttrGet","text":"mlirUnitAttrGet(ctx)\n\nCreates a unit attribute in the given context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUnitAttrGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirUnitAttrGetTypeID","text":"mlirUnitAttrGetTypeID()\n\nReturns the typeID of a Unit attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUnmanagedDenseResourceElementsAttrGet-NTuple{8, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUnmanagedDenseResourceElementsAttrGet","text":"mlirUnmanagedDenseResourceElementsAttrGet(shapedType, name, data, dataLength, dataAlignment, dataIsMutable, deleter, userData)\n\nUnlike the typed accessors below, constructs the attribute with a raw data buffer and no type/alignment checking. Use a more strongly typed accessor if possible. If dataIsMutable is false, then an immutable AsmResourceBlob will be created and that passed data contents will be treated as const. If the deleter is non NULL, then it will be called when the data buffer can no longer be accessed (passing userData to it).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUnrankedMemRefTypeGet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUnrankedMemRefTypeGet","text":"mlirUnrankedMemRefTypeGet(elementType, memorySpace)\n\nCreates an Unranked MemRef type with the given element type and in the given memory space. The type is owned by the context of element type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUnrankedMemRefTypeGetChecked-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUnrankedMemRefTypeGetChecked","text":"mlirUnrankedMemRefTypeGetChecked(loc, elementType, memorySpace)\n\nSame as \"mlirUnrankedMemRefTypeGet\" but returns a nullptr wrapping MlirType on illegal arguments, emitting appropriate diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUnrankedMemRefTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirUnrankedMemRefTypeGetTypeID","text":"mlirUnrankedMemRefTypeGetTypeID()\n\nReturns the typeID of an UnrankedMemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUnrankedMemrefGetMemorySpace-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUnrankedMemrefGetMemorySpace","text":"mlirUnrankedMemrefGetMemorySpace(type)\n\nReturns the memory spcae of the given Unranked MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUnrankedTensorTypeGet-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUnrankedTensorTypeGet","text":"mlirUnrankedTensorTypeGet(elementType)\n\nCreates an unranked tensor type with the given element type in the same context as the element type. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUnrankedTensorTypeGetChecked-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirUnrankedTensorTypeGetChecked","text":"mlirUnrankedTensorTypeGetChecked(loc, elementType)\n\nSame as \"mlirUnrankedTensorTypeGet\" but returns a nullptr wrapping MlirType on illegal arguments, emitting appropriate diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirUnrankedTensorTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirUnrankedTensorTypeGetTypeID","text":"mlirUnrankedTensorTypeGetTypeID()\n\nReturns the typeID of an UnrankedTensor type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirValueDump-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirValueDump","text":"mlirValueDump(value)\n\nPrints the value to the standard error stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirValueEqual-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirValueEqual","text":"mlirValueEqual(value1, value2)\n\nReturns 1 if two values are equal, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirValueGetFirstUse-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirValueGetFirstUse","text":"mlirValueGetFirstUse(value)\n\nReturns an op operand representing the first use of the value, or a null op operand if there are no uses.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirValueGetType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirValueGetType","text":"mlirValueGetType(value)\n\nReturns the type of the value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirValueIsABlockArgument-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirValueIsABlockArgument","text":"mlirValueIsABlockArgument(value)\n\nReturns 1 if the value is a block argument, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirValueIsAOpResult-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirValueIsAOpResult","text":"mlirValueIsAOpResult(value)\n\nReturns 1 if the value is an operation result, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirValueIsNull-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirValueIsNull","text":"mlirValueIsNull(value)\n\nReturns whether the value is null.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirValuePrint-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirValuePrint","text":"mlirValuePrint(value, callback, userData)\n\nPrints a value by sending chunks of the string representation and forwarding userData tocallback`. Note that the callback may be called several times with consecutive chunks of the string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirValuePrintAsOperand-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirValuePrintAsOperand","text":"mlirValuePrintAsOperand(value, state, callback, userData)\n\nPrints a value as an operand (i.e., the ValueID).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirValueReplaceAllUsesOfWith-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirValueReplaceAllUsesOfWith","text":"mlirValueReplaceAllUsesOfWith(of, with)\n\nReplace all uses of 'of' value with the 'with' value, updating anything in the IR that uses 'of' to use the other value instead. When this returns there are zero uses of 'of'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirValueSetType-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirValueSetType","text":"mlirValueSetType(value, type)\n\nSet the type of the value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirVectorTypeGet-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirVectorTypeGet","text":"mlirVectorTypeGet(rank, shape, elementType)\n\nCreates a vector type of the shape identified by its rank and dimensions, with the given element type in the same context as the element type. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirVectorTypeGetChecked-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirVectorTypeGetChecked","text":"mlirVectorTypeGetChecked(loc, rank, shape, elementType)\n\nSame as \"mlirVectorTypeGet\" but returns a nullptr wrapping MlirType on illegal arguments, emitting appropriate diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirVectorTypeGetScalable-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirVectorTypeGetScalable","text":"mlirVectorTypeGetScalable(rank, shape, scalable, elementType)\n\nCreates a scalable vector type with the shape identified by its rank and dimensions. A subset of dimensions may be marked as scalable via the corresponding flag list, which is expected to have as many entries as the rank of the vector. The vector is created in the same context as the element type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirVectorTypeGetScalableChecked-NTuple{5, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirVectorTypeGetScalableChecked","text":"mlirVectorTypeGetScalableChecked(loc, rank, shape, scalable, elementType)\n\nSame as \"mlirVectorTypeGetScalable\" but returns a nullptr wrapping MlirType on illegal arguments, emitting appropriate diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirVectorTypeGetTypeID-Tuple{}","page":"API reference","title":"Reactant.MLIR.API.mlirVectorTypeGetTypeID","text":"mlirVectorTypeGetTypeID()\n\nReturns the typeID of an Vector type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirVectorTypeIsDimScalable-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.API.mlirVectorTypeIsDimScalable","text":"mlirVectorTypeIsDimScalable(type, dim)\n\nChecks whether the \"dim\"-th dimension of the given vector is scalable.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.API.mlirVectorTypeIsScalable-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.API.mlirVectorTypeIsScalable","text":"mlirVectorTypeIsScalable(type)\n\nChecks whether the given vector type is scalable, i.e., has at least one scalable dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.Bool-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Core.Bool","text":"Bool(attr)\n\nReturns the value stored in the given bool attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.Float64-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Core.Float64","text":"Float64(attr)\n\nReturns the value stored in the given floating point attribute, interpreting the value as double.\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.Int64-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Core.Int64","text":"Int64(attr)\n\nReturns the value stored in the given integer attribute, assuming the value is of signed type and fits into a signed 64-bit integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.String-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Core.String","text":"String(attr)\n\nReturns the attribute values as a string reference. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.String-Tuple{Reactant.MLIR.IR.Identifier}","page":"API reference","title":"Core.String","text":"String(ident)\n\nGets the string value of the identifier.\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.UInt64-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Core.UInt64","text":"UInt64(attr)\n\nReturns the value stored in the given integer attribute, assuming the value is of unsigned type and fits into an unsigned 64-bit integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.AffineMap-Tuple{Any, Any, Vector{Reactant.MLIR.IR.AffineExpr}}","page":"API reference","title":"Reactant.MLIR.IR.AffineMap","text":"AffineMap(ndims, nsymbols, affineExprs; context=context())\n\nCreates an affine map with results defined by the given list of affine expressions. The map resulting map also has the requested number of input dimensions and symbols, regardless of them being used in the results.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.AffineMap-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.AffineMap","text":"AffineMap(ndims, nsymbols; context=context())\n\nCreates a zero result affine map of the given dimensions and symbols in the context. The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.AffineMap-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.AffineMap","text":"AffineMap(attr)\n\nReturns the affine map wrapped in the given affine map attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.AffineMap-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.AffineMap","text":"AffineMap(; context=context())\n\nCreates a zero result affine map with no dimensions or symbols in the context. The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Attribute-Tuple{AbstractString}","page":"API reference","title":"Reactant.MLIR.IR.Attribute","text":"Attribute(str; context=context())\n\nCreates a string attribute in the given context containing the given string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Attribute-Tuple{Bool}","page":"API reference","title":"Reactant.MLIR.IR.Attribute","text":"Attribute(value; context=context())\n\nCreates a bool attribute in the given context with the given value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Attribute-Tuple{Dict}","page":"API reference","title":"Reactant.MLIR.IR.Attribute","text":"Attribute(elements; context=context())\n\nCreates a dictionary attribute containing the given list of elements in the provided context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Reactant.MLIR.IR.Attribute","text":"Attribute(affineMap)\n\nCreates an affine map attribute wrapping the given map. The attribute belongs to the same context as the affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.Type, AbstractString}","page":"API reference","title":"Reactant.MLIR.IR.Attribute","text":"Attribute(type, str)\n\nCreates a string attribute in the given context containing the given string. Additionally, the attribute has the given type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Attribute-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.Attribute","text":"Attribute(type)\n\nCreates a type attribute wrapping the given type in the same context as the type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Attribute-Tuple{T} where T<:AbstractFloat","page":"API reference","title":"Reactant.MLIR.IR.Attribute","text":"Attribute(float; context=context(), location=Location(), check=false)\n\nCreates a floating point attribute in the given context with the given double value and double-precision FP semantics. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Attribute-Tuple{Vector{Reactant.MLIR.IR.Attribute}}","page":"API reference","title":"Reactant.MLIR.IR.Attribute","text":"Attribute(elements; context=context())\n\nCreates an array element containing the given list of elements in the given context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Attribute-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.Attribute","text":"Attribute()\n\nReturns an empty attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Attribute-Union{Tuple{T}, Tuple{T, Any}} where T<:Integer","page":"API reference","title":"Reactant.MLIR.IR.Attribute","text":"Attribute(int)\n\nCreates an integer attribute of the given type with the given integer value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Block-Tuple{Vector{Reactant.MLIR.IR.Type}, Vector{Reactant.MLIR.IR.Location}}","page":"API reference","title":"Reactant.MLIR.IR.Block","text":"Block(args, locs)\n\nCreates a new empty block with the given argument types and transfers ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.BlockIterator","page":"API reference","title":"Reactant.MLIR.IR.BlockIterator","text":"BlockIterator(region::Region)\n\nIterates over all blocks in the given region.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.IR.Context-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.Context","text":"Context()\n\nCreates an MLIR context and transfers its ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.ExecutionEngine","page":"API reference","title":"Reactant.MLIR.IR.ExecutionEngine","text":"ExecutionEngine(op, optLevel, sharedlibs = [])\n\nCreates an ExecutionEngine for the provided ModuleOp. The ModuleOp is expected to be \"translatable\" to LLVM IR (only contains operations in dialects that implement the LLVMTranslationDialectInterface). The module ownership stays with the client and can be destroyed as soon as the call returns. optLevel is the optimization level to be used for transformation and code generation. LLVM passes at optLevel are run before code generation. The number and array of paths corresponding to shared libraries that will be loaded are specified via numPaths and sharedLibPaths respectively. TODO: figure out other options.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.IR.Identifier-Tuple{String}","page":"API reference","title":"Reactant.MLIR.IR.Identifier","text":"Identifier(context, str)\n\nGets an identifier with the given string value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.IntegerSet-NTuple{4, Any}","page":"API reference","title":"Reactant.MLIR.IR.IntegerSet","text":"IntegerSet(ndims, nsymbols, constraints, eqflags; context=context())\n\nGets or creates a new integer set in the given context. The set is defined by a list of affine constraints, with the given number of input dimensions and symbols, which are treated as either equalities (eqflags is 1) or inequalities (eqflags is 0). Both constraints and eqflags need to be arrays of the same length.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.IntegerSet-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.IntegerSet","text":"Integerset(ndims, nsymbols; context=context())\n\nGets or creates a new canonically empty integer set with the give number of dimensions and symbols in the given context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.LogicalResult","page":"API reference","title":"Reactant.MLIR.IR.LogicalResult","text":"LogicalResult\n\nA logical result value, essentially a boolean with named states. LLVM convention for using boolean values to designate success or failure of an operation is a moving target, so MLIR opted for an explicit class. Instances of LogicalResult must only be inspected using the associated functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.IR.Module","page":"API reference","title":"Reactant.MLIR.IR.Module","text":"Module(location=Location())\n\nCreates a new, empty module and transfers ownership to the caller.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.IR.NamedAttribute-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.NamedAttribute","text":"NamedAttribute(name, attr)\n\nAssociates an attribute with the name. Takes ownership of neither.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.OpPassManager, Any}","page":"API reference","title":"Reactant.MLIR.IR.OpPassManager","text":"OpPassManager(opPassManager, operationName)\n\nNest an OpPassManager under the provided OpPassManager, the nested passmanager will only run on operations matching the provided name. The returned OpPassManager will be destroyed when the parent is destroyed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.PassManager, Any}","page":"API reference","title":"Reactant.MLIR.IR.OpPassManager","text":"OpPassManager(passManager, operationName)\n\nNest an OpPassManager under the top-level PassManager, the nested passmanager will only run on operations matching the provided name. The returned OpPassManager will be destroyed when the parent is destroyed. To further nest more OpPassManager under the newly returned one, see mlirOpPassManagerNest below.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.OpPassManager-Tuple{Reactant.MLIR.IR.PassManager}","page":"API reference","title":"Reactant.MLIR.IR.OpPassManager","text":"OpPassManager(passManager)\n\nCast a top-level PassManager to a generic OpPassManager.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Operation-Tuple{Reactant.MLIR.IR.Module}","page":"API reference","title":"Reactant.MLIR.IR.Operation","text":"Operation(module)\n\nViews the module as a generic operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.OperationIterator","page":"API reference","title":"Reactant.MLIR.IR.OperationIterator","text":"OperationIterator(block::Block)\n\nIterates over all operations for the given block.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.IR.PassManager-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.PassManager","text":"PassManager(anchorOp; context=context())\n\nCreate a new top-level PassManager anchored on anchorOp.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.PassManager-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.PassManager","text":"PassManager(; context=context())\n\nCreate a new top-level PassManager.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Region-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.Region","text":"Region()\n\nCreates a new empty region and transfers ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.RegionIterator","page":"API reference","title":"Reactant.MLIR.IR.RegionIterator","text":"RegionIterator(::Operation)\n\nIterates over all sub-regions for the given operation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Reactant.MLIR.IR.SymbolTable-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.SymbolTable","text":"mlirSymbolTableCreate(operation)\n\nCreates a symbol table for the given operation. If the operation does not have the SymbolTable trait, returns a null symbol table.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Type-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.Type","text":"Type(attr)\n\nReturns the type stored in the given type attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Type-Tuple{Type{<:Integer}}","page":"API reference","title":"Reactant.MLIR.IR.Type","text":"Type(T::Core.Type{<:Integer}; context=context()\n\nCreates a signless integer type of the given bitwidth in the context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Type-Tuple{Type{<:Signed}}","page":"API reference","title":"Reactant.MLIR.IR.Type","text":"Type(T::Core.Type{<:Signed}; context=context()\n\nCreates a signed integer type of the given bitwidth in the context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Type-Tuple{Type{<:Unsigned}}","page":"API reference","title":"Reactant.MLIR.IR.Type","text":"Type(T::Core.Type{<:Unsigned}; context=context()\n\nCreates an unsigned integer type of the given bitwidth in the context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Type-Tuple{Type{Bool}}","page":"API reference","title":"Reactant.MLIR.IR.Type","text":"Type(T::Core.Type{Bool}; context=context()\n\nCreates a 1-bit signless integer type in the context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Type-Tuple{Type{Float16}}","page":"API reference","title":"Reactant.MLIR.IR.Type","text":"Type(::Core.Type{Float16}; context=context())\n\nCreates an f16 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Type-Tuple{Type{Float32}}","page":"API reference","title":"Reactant.MLIR.IR.Type","text":"Type(Core.Type{Float32}; context=context())\n\nCreates an f32 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Type-Tuple{Type{Float64}}","page":"API reference","title":"Reactant.MLIR.IR.Type","text":"Type(Core.Type{Float64}; context=context())\n\nCreates a f64 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Type-Tuple{Type{Nothing}}","page":"API reference","title":"Reactant.MLIR.IR.Type","text":"Type(::Core.Type{Nothing}; context=context())\n\nCreates a None type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Type-Tuple{Vector{Reactant.MLIR.IR.Type}}","page":"API reference","title":"Reactant.MLIR.IR.Type","text":"Type(elements; context=context())\nType(::Core.Type{<:Tuple{T...}}; context=context())\n\nCreates a tuple type that consists of the given list of elemental types. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Type-Union{Tuple{Type{Complex{T}}}, Tuple{T}} where T","page":"API reference","title":"Reactant.MLIR.IR.Type","text":"Type(Complex{T}) where {T}\n\nCreates a complex type with the given element type in the same context as the element type. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.@affinemap-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.@affinemap","text":"@affinemap (d1, d2, d3, ...)[s1, s2, ...] -> (d0 + d1, ...)\n\nReturns an affine map from the provided Julia expression. On the right hand side are allowed the following function calls:\n\n+, *, ÷, %, fld, cld\n\nThe rhs can only contains dimensions and symbols present on the left hand side or integer literals.\n\njulia> using MLIR: IR, AffineUtils\n\njulia> IR.context!(IR.Context()) do\n           IR.@affinemap (d1, d2)[s0] -> (d1 + s0, d2 % 10)\n       end\nMLIR.IR.AffineMap(#= (d0, d1)[s0] -> (d0 + s0, d1 mod 10) =#)\n\n\n\n\n\n","category":"macro"},{"location":"api/#Base.:*-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Base.:*","text":"*(lhs, rhs)\n\nCreates an affine mul expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:+-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Base.:+","text":"+(lhs, rhs)\n\nCreates an affine add expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Base.:==","text":"==(a, b)\n\nReturns true if the two affine expressions are equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Tuple{Reactant.MLIR.IR.AffineMap, Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Base.:==","text":"==(a, b)\n\nChecks if two affine maps are equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Tuple{Reactant.MLIR.IR.Attribute, Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Base.:==","text":"==(a1, a2)\n\nChecks if two attributes are equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}","page":"API reference","title":"Base.:==","text":"==(block, other)\n\nChecks whether two blocks handles point to the same block. This does not perform deep comparison.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Tuple{Reactant.MLIR.IR.Identifier, Reactant.MLIR.IR.Identifier}","page":"API reference","title":"Base.:==","text":"==(ident, other)\n\nChecks whether two identifiers are the same.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Tuple{Reactant.MLIR.IR.IntegerSet, Reactant.MLIR.IR.IntegerSet}","page":"API reference","title":"Base.:==","text":"==(s1, s2)\n\nChecks if two integer set objects are equal. This is a \"shallow\" comparison of two objects. Only the sets with some small number of constraints are uniqued and compare equal here. Set objects that represent the same integer set with different constraints may be considered non-equal by this check. Set difference followed by an (expensive) emptiness check should be used to check equivalence of the underlying integer sets.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Region}","page":"API reference","title":"Base.:==","text":"==(region, other)\n\nChecks whether two region handles point to the same region. This does not perform deep comparison.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Tuple{Reactant.MLIR.IR.Type, Reactant.MLIR.IR.Type}","page":"API reference","title":"Base.:==","text":"==(t1, t2)\n\nChecks if two types are equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Tuple{Reactant.MLIR.IR.TypeID, Reactant.MLIR.IR.TypeID}","page":"API reference","title":"Base.:==","text":"==(typeID1, typeID2)\n\nChecks if two type ids are equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Base.:==","text":"==(value1, value2)\n\nReturns 1 if two values are equal, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.cld-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Base.cld","text":"cld(lhs, rhs)\n\nCreates an affine ceildiv expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.copy-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Base.copy","text":"copy(op)\n\nCreates a deep copy of an operation. The operation is not inserted and ownership is transferred to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.div-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Base.div","text":"div(lhs, rhs)\n÷(lhs, rhs)\nfld(lhs, rhs)\n\nCreates an affine floordiv expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.fill-Tuple{Reactant.MLIR.IR.Attribute, Reactant.MLIR.IR.Type}","page":"API reference","title":"Base.fill","text":"fill(attr, shapedType)\n\nCreates a dense elements attribute with the given Shaped type containing a single replicated element (splat).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.gcd-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Base.gcd","text":"gcd(affineExpr)\n\nReturns the greatest known integral divisor of this affine expression. The result is always positive.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.hash-Tuple{Reactant.MLIR.IR.TypeID}","page":"API reference","title":"Base.hash","text":"hash(typeID)\n\nReturns the hash value of the type id.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.insert!-Tuple{Reactant.MLIR.IR.Block, Any, Reactant.MLIR.IR.Operation}","page":"API reference","title":"Base.insert!","text":"insert!(block, index, operation)\n\nTakes an operation owned by the caller and inserts it as index to the block. This is an expensive operation that scans the block linearly, prefer insertBefore/After instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.insert!-Tuple{Reactant.MLIR.IR.Region, Any, Reactant.MLIR.IR.Block}","page":"API reference","title":"Base.insert!","text":"insert!(region, index, block)\n\nTakes a block owned by the caller and inserts it at index to the given region. This is an expensive operation that linearly scans the region, prefer insertAfter/Before instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isempty-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Base.isempty","text":"isempty(affineMap)\n\nChecks whether the given affine map is an empty affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isperm-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Base.isperm","text":"isperm(affineMap)\n\nChecks whether the given affine map represents a symbol-less permutation map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.mod-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Base.mod","text":"mod(lhs, rhs)\n\nCreates an affine mod expression with 'lhs' and 'rhs'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.ndims-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Base.ndims","text":"ndims(affineMap)\n\nReturns the number of dimensions of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.ndims-Tuple{Reactant.MLIR.IR.IntegerSet}","page":"API reference","title":"Base.ndims","text":"ndims(set)\n\nReturns the number of dimensions in the given set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.ndims-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Base.ndims","text":"ndims(type)\n\nReturns the rank of the given ranked shaped type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.parse-Tuple{Reactant.MLIR.IR.OpPassManager, String}","page":"API reference","title":"Base.parse","text":"parse(passManager, pipeline)\n\nParse a textual MLIR pass pipeline and add it to the provided OpPassManager.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.parse-Tuple{Type{Reactant.MLIR.IR.Attribute}, Any}","page":"API reference","title":"Base.parse","text":"parse(::Core.Type{Attribute}, str; context=context())\n\nParses an attribute. The attribute is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.parse-Tuple{Type{Reactant.MLIR.IR.Module}, Any}","page":"API reference","title":"Base.parse","text":"parse(::Type{Module}, module; context=context())\n\nParses a module from the string and transfers ownership to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.parse-Tuple{Type{Reactant.MLIR.IR.Type}, Any}","page":"API reference","title":"Base.parse","text":"parse(type; context=context())\n\nParses a type. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation}","page":"API reference","title":"Base.push!","text":"push!(block, operation)\n\nTakes an operation owned by the caller and appends it to the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block}","page":"API reference","title":"Base.push!","text":"push!(region, block)\n\nTakes a block owned by the caller and appends it to the given region.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{Reactant.MLIR.IR.SymbolTable, Reactant.MLIR.IR.Operation}","page":"API reference","title":"Base.push!","text":"push!(symboltable, operation)\n\nInserts the given operation into the given symbol table. The operation must have the symbol trait. If the symbol table already has a symbol with the same name, renames the symbol being inserted to ensure name uniqueness. Note that this does not move the operation itself into the block of the symbol table operation, this should be done separately. Returns the name of the symbol after insertion.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.replace-Tuple{Reactant.MLIR.IR.AffineMap, Pair{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineExpr}, Any, Any}","page":"API reference","title":"Base.replace","text":"mlirAffineMapReplace(affineMap, expression => replacement, numResultDims, numResultSyms)\n\nApply AffineExpr::replace(map) to each of the results and return a new new AffineMap with the new results and the specified number of dims and symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.replace-Tuple{Reactant.MLIR.IR.IntegerSet, Any, Any}","page":"API reference","title":"Base.replace","text":"mlirIntegerSetReplaceGet(set, dimReplacements, symbolReplacements, numResultDims, numResultSymbols)\n\nGets or creates a new integer set in which the values and dimensions of the given set are replaced with the given affine expressions. dimReplacements and symbolReplacements are expected to point to at least as many consecutive expressions as the given set has dimensions and symbols, respectively. The new set will have numResultDims and numResultSymbols dimensions and symbols, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.reshape-Tuple{Reactant.MLIR.IR.Attribute, Any}","page":"API reference","title":"Base.reshape","text":"Base.reshape(attr, shapedType)\n\nCreates a dense elements attribute that has the same data as the given dense elements attribute and a different shaped type. The new type must have the same total number of elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{Reactant.MLIR.IR.Type, Int64}","page":"API reference","title":"Base.size","text":"size(type, i)\n\nReturns the i-th dimension of the given ranked shaped type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.write-Tuple{String, Reactant.MLIR.IR.ExecutionEngine}","page":"API reference","title":"Base.write","text":"write(fileName, jit)\n\nDump as an object in fileName.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.AffineDimensionExpr-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.AffineDimensionExpr","text":"AffineDimensionExpr(position; context=context)\n\nCreates an affine dimension expression with 'position' in the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.BFloat16Type-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.BFloat16Type","text":"BFloat16Type(; context=context())\n\nCreates a bf16 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.ConstantAffineMap-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.ConstantAffineMap","text":"ConstantAffineMap(val; context=context())\n\nCreates a single constant result affine map in the context. The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.ConstantExpr-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.ConstantExpr","text":"ConstantExpr(constant::Int; context=context())\n\nCreates an affine constant expression with 'constant' in the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.DenseElementsAttribute-Tuple{AbstractArray{String}}","page":"API reference","title":"Reactant.MLIR.IR.DenseElementsAttribute","text":"DenseElementsAttribute(array::AbstractArray{String})\n\nCreates a dense elements attribute with the given shaped type from string elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.DenseElementsAttribute-Tuple{AbstractVector{Bool}}","page":"API reference","title":"Reactant.MLIR.IR.DenseElementsAttribute","text":"DenseElementsAttribute(array::AbstractArray)\n\nCreates a dense elements attribute with the given shaped type from elements of a specific type. Expects the element type of the shaped type to match the data element type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.DenseElementsAttribute-Tuple{Reactant.MLIR.IR.Type, AbstractArray}","page":"API reference","title":"Reactant.MLIR.IR.DenseElementsAttribute","text":"DenseElementsAttribute(shapedType, elements)\n\nCreates a dense elements attribute with the given Shaped type and elements in the same context as the type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.FlatSymbolRefAttribute-Tuple{String}","page":"API reference","title":"Reactant.MLIR.IR.FlatSymbolRefAttribute","text":"FlatSymbolRefAttribute(ctx, symbol)\n\nCreates a flat symbol reference attribute in the given context referencing a symbol identified by the given string.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Float8E4M3FN-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.Float8E4M3FN","text":"Float8E4M3FN(; context=context())\n\nCreates an f8E4M3FN type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.Float8E5M2-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.Float8E5M2","text":"Float8E5M2(; context=context())\n\nCreates an f8E5M2 type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.FunctionType-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.FunctionType","text":"FunctionType(inputs, results; context=context())\n\nCreates a function type, mapping a list of input types to result types.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.IdentityAffineMap-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.IdentityAffineMap","text":"IdentityAffineMap(ndims; context=context())\n\nCreates an affine map with 'ndims' identity in the context. The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.IndexType-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.IndexType","text":"IndexType(; context=context())\n\nCreates an index type in the given context. The type is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.MemRefType","text":"MemRefType(elementType, rank, shape, layout, memorySpace; location=Location(), check=false)\n\nCreates a MemRef type with the given rank and shape, a potentially empty list of affine layout maps, the given memory space and element type, in the same context as element type. The type is owned by the context. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.MemRefType","text":"MemRefType(elementType, rank, shape, memorySpace; location=Location(), check=false)\n\nCreates a MemRef type with the given rank, shape, memory space and element type in the same context as the element type. The type has no affine maps, i.e. represents a default row-major contiguous memref. The type is owned by the context. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.MemRefType-Tuple{Reactant.MLIR.IR.Type, Any}","page":"API reference","title":"Reactant.MLIR.IR.MemRefType","text":"MemRefType(elementType, memorySpace)\n\nCreates an Unranked MemRef type with the given element type and in the given memory space. The type is owned by the context of element type. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.MinorIdentityAffineMap-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.MinorIdentityAffineMap","text":"MinorIdentityAffineMap(ndims, nresults; context=context())\n\nCreates an identity affine map on the most minor dimensions in the context. The affine map is owned by the context. The function asserts that the number of dimensions is greater or equal to the number of results.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.OpaqueAttribute-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.OpaqueAttribute","text":"OpaqueAttribute(dialectNamespace, dataLength, data, type; context=context())\n\nCreates an opaque attribute in the given context associated with the dialect identified by its namespace. The attribute contains opaque byte data of the specified length (data need not be null-terminated).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.OpaqueType-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.OpaqueType","text":"OpaqueType(dialectNamespace, typeData; context=context())\n\nCreates an opaque type in the given context associated with the dialect identified by its namespace. The type contains opaque byte data of the specified length (data need not be null-terminated).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.PermutationAffineMap-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.PermutationAffineMap","text":"PermutationAffineMap(permutation; context=context())\n\nCreates an affine map with a permutation expression and its size in the context. The permutation expression is a non-empty vector of integers. The elements of the permutation vector must be continuous from 0 and cannot be repeated (i.e. [1,2,0] is a valid permutation. [2,0] or [1,1,2] is an invalid invalid permutation). The affine map is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.SymbolExpr-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.SymbolExpr","text":"SymbolExpr(position; context=context())\n\nCreates an affine symbol expression with 'position' in the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.SymbolRefAttribute-Tuple{String, Vector{Reactant.MLIR.IR.Attribute}}","page":"API reference","title":"Reactant.MLIR.IR.SymbolRefAttribute","text":"SymbolRefAttribute(symbol, references; context=context())\n\nCreates a symbol reference attribute in the given context referencing a symbol identified by the given string inside a list of nested references. Each of the references in the list must not be nested.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.TensorType","page":"API reference","title":"Reactant.MLIR.IR.TensorType","text":"TensorType(shape, elementType, encoding=Attribute(); location=Location(), check=false)\n\nCreates a tensor type of a fixed rank with the given shape, element type, and optional encoding in the same context as the element type. The type is owned by the context. Tensor types without any specific encoding field should assign mlirAttributeGetNull to this parameter. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#Reactant.MLIR.IR.TensorType-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.TensorType","text":"TensorType(elementType)\n\nCreates an unranked tensor type with the given element type in the same context as the element type. The type is owned by the context. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.UnitAttribute-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.UnitAttribute","text":"UnitAttribute(; context=context())\n\nCreates a unit attribute in the given context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.VectorType-Tuple{Any, Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.VectorType","text":"VectorType(rank, shape, elementType; location=Location(), check=false)\n\nCreates a vector type of the shape identified by its rank and dimensions, with the given element type in the same context as the element type. The type is owned by the context. If check=true, emits appropriate diagnostics on illegal arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.add_owned_pass!-Tuple{Reactant.MLIR.IR.OpPassManager, Any}","page":"API reference","title":"Reactant.MLIR.IR.add_owned_pass!","text":"add_owned_pass!(opPassManager, pass)\n\nAdd a pass and transfer ownership to the provided OpPassManager. If the pass is not a generic operation pass or matching the type of the provided OpPassManager, a new OpPassManager is implicitly nested under the provided OpPassManager.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.add_owned_pass!-Tuple{Reactant.MLIR.IR.PassManager, Any}","page":"API reference","title":"Reactant.MLIR.IR.add_owned_pass!","text":"add_owned_pass!(passManager, pass)\n\nAdd a pass and transfer ownership to the provided top-level PassManager. If the pass is not a generic operation pass or a ModulePass, a new OpPassManager is implicitly nested under the provided PassManager.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.add_pipeline!-Tuple{Reactant.MLIR.IR.OpPassManager, Any}","page":"API reference","title":"Reactant.MLIR.IR.add_pipeline!","text":"add_pipeline!(passManager, pipelineElements, callback, userData)\n\nParse a sequence of textual MLIR pass pipeline elements and add them to the provided OpPassManager. If parsing fails an error message is reported using the provided callback.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.affinemap-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.affinemap","text":"affinemap(type)\n\nReturns the affine map of the given MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.argument-Tuple{Reactant.MLIR.IR.Block, Any}","page":"API reference","title":"Reactant.MLIR.IR.argument","text":"argument(block, i)\n\nReturns i-th argument of the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.attr!-Tuple{Reactant.MLIR.IR.Operation, Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.attr!","text":"attr!(op, name, attr)\n\nSets an attribute by name, replacing the existing if it exists or adding a new one otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.attr-Tuple{Reactant.MLIR.IR.Operation, AbstractString}","page":"API reference","title":"Reactant.MLIR.IR.attr","text":"attr(op, name)\n\nReturns an attribute attached to the operation given its name.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.attr-Tuple{Reactant.MLIR.IR.Operation, Any}","page":"API reference","title":"Reactant.MLIR.IR.attr","text":"attr(op, i)\n\nReturn i-th attribute of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.bitwidth-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.bitwidth","text":"bitwidth(type)\n\nReturns the bitwidth of an integer type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.block-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.block","text":"block(op)\n\nGets the block that owns this operation, returning null if the operation is not owned.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.block_arg_num-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.IR.block_arg_num","text":"block_arg_num(value)\n\nReturns the position of the value in the argument list of its block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.block_owner-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.IR.block_owner","text":"block_owner(value)\n\nReturns the block in which this value is defined as an argument. Asserts if the value is not a block argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.body-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.body","text":"body(module)\n\nGets the body of the module, i.e. the only block it contains.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.compose-Tuple{Reactant.MLIR.IR.AffineExpr, Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Reactant.MLIR.IR.compose","text":"compose(affineExpr, affineMap)\n\nComposes the given map with the given expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.constraint-Tuple{Reactant.MLIR.IR.IntegerSet, Any}","page":"API reference","title":"Reactant.MLIR.IR.constraint","text":"mlirIntegerSetGetConstraint(set, i)\n\nReturns i-th constraint of the set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.context","text":"context(affineExpr)\n\nGets the context that owns the affine expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Reactant.MLIR.IR.context","text":"context(affineMap)\n\nGets the context that the given affine map was created with.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.context","text":"context(attribute)\n\nGets the context that an attribute was created with.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Identifier}","page":"API reference","title":"Reactant.MLIR.IR.context","text":"context(ident)\n\nReturns the context associated with this identifier\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.IntegerSet}","page":"API reference","title":"Reactant.MLIR.IR.context","text":"context(set)\n\nGets the context in which the given integer set lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Module}","page":"API reference","title":"Reactant.MLIR.IR.context","text":"context(module)\n\nGets the context that a module was created with.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.context","text":"context(op)\n\nGets the context this operation is associated with.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.context-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.context","text":"context(type)\n\nGets the context that a type was created with.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.data-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.data","text":"data(attr)\n\nReturns the raw data as a string reference. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.data-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.data","text":"mlirOpaqueTypeGetData(type)\n\nReturns the raw data as a string reference. The data remains live as long as the context in which the type lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.delete!-Tuple{Reactant.MLIR.IR.SymbolTable, Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.delete!","text":"delete!(symboltable, operation)\n\nRemoves the given operation from the symbol table and erases it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.dynsize-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.dynsize","text":"dynsize()\n\nReturns the value indicating a dynamic size in a shaped type. Prefer isdynsize to direct comparisons with this value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.dynstrideoroffset-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.dynstrideoroffset","text":"mlirShapedTypeGetDynamicStrideOrOffset()\n\nReturns the value indicating a dynamic stride or offset in a shaped type. Prefer isdynstrideoroffset to direct comparisons with this value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.enable_ir_printing!-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.enable_ir_printing!","text":"enable_ir_printing!(passManager)\n\nEnable mlir-print-ir-after-all.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.enable_verifier!","page":"API reference","title":"Reactant.MLIR.IR.enable_verifier!","text":"enable_verifier!(passManager, enable)\n\nEnable / disable verify-each.\n\n\n\n\n\n","category":"function"},{"location":"api/#Reactant.MLIR.IR.encoding-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.encoding","text":"encoding(type)\n\nGets the 'encoding' attribute from the ranked tensor type, returning a nothing if none.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.failure-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.failure","text":"failure()\n\nCreates a logical result representing a failure.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.first_block-Tuple{Reactant.MLIR.IR.Region}","page":"API reference","title":"Reactant.MLIR.IR.first_block","text":"first_block(region)\n\nGets the first block in the region.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.first_op-Tuple{Reactant.MLIR.IR.Block}","page":"API reference","title":"Reactant.MLIR.IR.first_op","text":"first_op(block)\n\nReturns the first operation in the block or nothing if empty.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.first_use-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.IR.first_use","text":"first_use(value)\n\nReturns an OpOperand representing the first use of the value, or a nothing if there are no uses.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.flatsymbol-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.flatsymbol","text":"flatsymbol(attr)\n\nReturns the referenced symbol as a string reference. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.hasrank-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.hasrank","text":"hasrank(type)\n\nChecks whether the given shaped type is ranked.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.hasstaticshape-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.hasstaticshape","text":"hasstaticshape(type)\n\nChecks whether the given shaped type has a static shape.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.input-Tuple{Reactant.MLIR.IR.Type, Any}","page":"API reference","title":"Reactant.MLIR.IR.input","text":"input(type, i)\n\nReturns the i-th input type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.insert_after!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.insert_after!","text":"insert_after!(block, reference, operation)\n\nTakes an operation owned by the caller and inserts it after the (non-owned) reference operation in the given block. If the reference is null, prepends the operation. Otherwise, the reference must belong to the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.insert_after!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}","page":"API reference","title":"Reactant.MLIR.IR.insert_after!","text":"insert_after!(region, reference, block)\n\nTakes a block owned by the caller and inserts it after the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, prepends the block to the region.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.insert_before!-Tuple{Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.insert_before!","text":"insert_before!(block, reference, operation)\n\nTakes an operation owned by the caller and inserts it before the (non-owned) reference operation in the given block. If the reference is null, appends the operation. Otherwise, the reference must belong to the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.insert_before!-Tuple{Reactant.MLIR.IR.Region, Reactant.MLIR.IR.Block, Reactant.MLIR.IR.Block}","page":"API reference","title":"Reactant.MLIR.IR.insert_before!","text":"insert_before!(region, reference, block)\n\nTakes a block owned by the caller and inserts it before the (non-owned) reference block in the given region. The reference block must belong to the region. If the reference block is null, appends the block to the region.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.is_block_arg-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.IR.is_block_arg","text":"is_block_arg(value)\n\nReturns 1 if the value is a block argument, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.is_op_res-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.IR.is_op_res","text":"is_op_res(value)\n\nReturns 1 if the value is an operation result, 0 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.is_pure_affine-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.is_pure_affine","text":"is_pure_affine(affineExpr)\n\nChecks whether the given affine expression is a pure affine expression, i.e. mul, floordiv, ceildic, and mod is only allowed w.r.t constants.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.is_registered-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.is_registered","text":"is_registered(name; context=context())\n\nReturns whether the given fully-qualified operation (i.e. 'dialect.operation') is registered with the context. This will return true if the dialect is loaded and the operation is registered within the dialect.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.is_symbolic_or_constant-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.is_symbolic_or_constant","text":"is_symbolic_or_constant(affineExpr)\n\nChecks whether the given affine expression is made out of only symbols and constants.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isadd-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.isadd","text":"isadd(affineExpr)\n\nChecks whether the given affine expression is an add expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isaffinemap-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.isaffinemap","text":"isaffinemap(attr)\n\nChecks whether the given attribute is an affine map attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isarray-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.isarray","text":"isarray(attr)\n\nChecks whether the given attribute is an array attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isbf16-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isbf16","text":"isbf16(type)\n\nChecks whether the given type is a bf16 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isbinary-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.isbinary","text":"isbinary(affineExpr)\n\nChecks whether the given affine expression is binary.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isbool-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.isbool","text":"isbool(attr)\n\nChecks whether the given attribute is a bool attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isceildiv-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.isceildiv","text":"isceildiv(affineExpr)\n\nChecks whether the given affine expression is an ceildiv expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.iscomplex-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.iscomplex","text":"iscomplex(type)\n\nChecks whether the given type is a Complex type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isconstantexpr-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.isconstantexpr","text":"isconstantexpr(affineExpr)\n\nChecks whether the given affine expression is a constant expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isconstrainteq-Tuple{Reactant.MLIR.IR.IntegerSet, Any}","page":"API reference","title":"Reactant.MLIR.IR.isconstrainteq","text":"mlirIntegerSetIsConstraintEq(set, i)\n\nReturns true of the i-th constraint of the set is an equality constraint, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isdenseelements-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.isdenseelements","text":"isdenseelements(attr)\n\nChecks whether the given attribute is a dense elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isdict-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.isdict","text":"isdict(attr)\n\nChecks whether the given attribute is a dictionary attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isdimexpr-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.isdimexpr","text":"isdimexpr(affineExpr)\n\nChecks whether the given affine expression is a dimension expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isdyndim-Tuple{Reactant.MLIR.IR.Type, Int64}","page":"API reference","title":"Reactant.MLIR.IR.isdyndim","text":"isdyndim(type, i)\n\nChecks wither the i-th dimension of the given shaped type is dynamic.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isdynsize-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.isdynsize","text":"isdynsize(size)\n\nChecks whether the given value is used as a placeholder for dynamic sizes in shaped types.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isdynstrideoroffset-Tuple{Any}","page":"API reference","title":"Reactant.MLIR.IR.isdynstrideoroffset","text":"mlirShapedTypeIsDynamicStrideOrOffset(val)\n\nChecks whether the given value is used as a placeholder for dynamic strides and offsets in shaped types.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.iselements-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.iselements","text":"iselements(attr)\n\nChecks whether the given attribute is an elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isempty-Tuple{Reactant.MLIR.IR.IntegerSet}","page":"API reference","title":"Reactant.MLIR.IR.isempty","text":"isempty(set)\n\nChecks whether the given set is a canonical empty set, e.g., the set returned by mlirIntegerSetEmptyGet.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isf16-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isf16","text":"isf16(type)\n\nChecks whether the given type is an f16 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isf32-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isf32","text":"isf32(type)\n\nChecks whether the given type is an f32 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isf64-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isf64","text":"isf64(type)\n\nChecks whether the given type is an f64 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isf8e4m3fn-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isf8e4m3fn","text":"isf8e4m3fn(type)\n\nChecks whether the given type is an f8E4M3FN type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isf8e5m2-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isf8e5m2","text":"isf8e5m2(type)\n\nChecks whether the given type is an f8E5M2 type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isfailure-Tuple{Reactant.MLIR.IR.LogicalResult}","page":"API reference","title":"Reactant.MLIR.IR.isfailure","text":"isfailure(res)\n\nChecks if the given logical result represents a failure.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isflatsymbolref-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.isflatsymbolref","text":"isflatsymbolref(attr)\n\nChecks whether the given attribute is a flat symbol reference attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isfloat-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.isfloat","text":"isfloat(attr)\n\nChecks whether the given attribute is a floating point attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isfloordiv-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.isfloordiv","text":"isfloordiv(affineExpr)\n\nChecks whether the given affine expression is an floordiv expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isfunction-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isfunction","text":"isfunction(type)\n\nChecks whether the given type is a function type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isfunctionofdimexpr-Tuple{Reactant.MLIR.IR.AffineExpr, Any}","page":"API reference","title":"Reactant.MLIR.IR.isfunctionofdimexpr","text":"isfunctionofdimexpr(affineExpr, position)\n\nChecks whether the given affine expression involves AffineDimExpr 'position'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isidentity-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Reactant.MLIR.IR.isidentity","text":"isidentity(affineMap)\n\nChecks whether the given affine map is an identity affine map. The function asserts that the number of dimensions is greater or equal to the number of results.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isindex-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isindex","text":"isindex(type)\n\nChecks whether the given type is an index type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isinteger-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.isinteger","text":"isinteger(attr)\n\nChecks whether the given attribute is an integer attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isinteger-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isinteger","text":"isinteger(type)\n\nChecks whether the given type is an integer type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isintegerset-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.isintegerset","text":"isintegerset(attr)\n\nChecks whether the given attribute is an integer set attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.ismemref-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.ismemref","text":"ismemref(type)\n\nChecks whether the given type is a MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isminoridentity-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Reactant.MLIR.IR.isminoridentity","text":"isminoridentity(affineMap)\n\nChecks whether the given affine map is a minor identity affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.ismod-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.ismod","text":"ismod(affineExpr)\n\nChecks whether the given affine expression is an mod expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.ismul-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.ismul","text":"ismul(affineExpr)\n\nChecks whether the given affine expression is an mul expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.ismultipleof-Tuple{Reactant.MLIR.IR.AffineExpr, Any}","page":"API reference","title":"Reactant.MLIR.IR.ismultipleof","text":"ismultipleof(affineExpr, factor)\n\nChecks whether the given affine expression is a multiple of 'factor'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isnone-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isnone","text":"mlirTypeIsANone(type)\n\nChecks whether the given type is a None type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isopaque-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.isopaque","text":"isopaque(attr)\n\nChecks whether the given attribute is an opaque attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isopaque-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isopaque","text":"isopaque(type)\n\nChecks whether the given type is an opaque type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isprojperm-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Reactant.MLIR.IR.isprojperm","text":"isprojperm(affineMap)\n\nChecks whether the given affine map represents a subset of a symbol-less permutation map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isrankedtensor-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isrankedtensor","text":"isrankedtensor(type)\n\nChecks whether the given type is a ranked tensor type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isshaped-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isshaped","text":"isshaped(type)\n\nChecks whether the given type is a Shaped type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.issigned-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.issigned","text":"issigned(type)\n\nChecks whether the given integer type is signed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.issignless-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.issignless","text":"issignless(type)\n\nChecks whether the given integer type is signless.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.issingleconstant-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Reactant.MLIR.IR.issingleconstant","text":"issingleconstant(affineMap)\n\nChecks whether the given affine map is a single result constant affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.issparseelements-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.issparseelements","text":"issparseelements(attr)\n\nChecks whether the given attribute is a sparse elements attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.issplat-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.issplat","text":"issplat(attr)\n\nChecks whether the given dense elements attribute contains a single replicated value (splat).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isstring-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.isstring","text":"isstring(attr)\n\nChecks whether the given attribute is a string attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.issuccess-Tuple{Reactant.MLIR.IR.LogicalResult}","page":"API reference","title":"Reactant.MLIR.IR.issuccess","text":"issuccess(res)\n\nChecks if the given logical result represents a success.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.issymbolexpr-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.issymbolexpr","text":"issymbolexpr(affineExpr)\n\nChecks whether the given affine expression is a symbol expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.issymbolref-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.issymbolref","text":"issymbolref(attr)\n\nChecks whether the given attribute is a symbol reference attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.istensor-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.istensor","text":"istensor(type)\n\nChecks whether the given type is a Tensor type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.istuple-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.istuple","text":"istuple(type)\n\nChecks whether the given type is a tuple type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.istype-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.istype","text":"istype(attr)\n\nChecks whether the given attribute is a type attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isunit-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.isunit","text":"isunit(attr)\n\nChecks whether the given attribute is a unit attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isunrankedmemref-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isunrankedmemref","text":"mlirTypeIsAUnrankedMemRef(type)\n\nChecks whether the given type is an UnrankedMemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isunrankedtensor-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isunrankedtensor","text":"isunrankedtensor(type)\n\nChecks whether the given type is an unranked tensor type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isunsigned-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isunsigned","text":"isunsigned(type)\n\nChecks whether the given integer type is unsigned.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.isvector-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.isvector","text":"isvector(type)\n\nChecks whether the given type is a Vector type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.layout-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.layout","text":"layout(type)\n\nReturns the layout of the given MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.leafref-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.leafref","text":"leafref(attr)\n\nReturns the string reference to the leaf referenced symbol. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.lhs-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.lhs","text":"lhs(affineExpr)\n\nReturns the left hand side affine expression of the given affine binary operation expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.location-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.location","text":"location(op)\n\nGets the location of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.lookup-Tuple{Reactant.MLIR.IR.ExecutionEngine, String}","page":"API reference","title":"Reactant.MLIR.IR.lookup","text":"lookup(jit, name)\n\nLookup a native function in the execution engine by name, returns nullptr if the name can't be looked-up.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.lookup-Tuple{Reactant.MLIR.IR.SymbolTable, AbstractString}","page":"API reference","title":"Reactant.MLIR.IR.lookup","text":"lookup(symboltable, name)\n\nLooks up a symbol with the given name in the given symbol table and returns the operation that corresponds to the symbol. If the symbol cannot be found, returns a null operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.majorsubmap-Tuple{Reactant.MLIR.IR.AffineMap, Any}","page":"API reference","title":"Reactant.MLIR.IR.majorsubmap","text":"majorsubmap(affineMap, nresults)\n\nReturns the affine map consisting of the most major nresults results. Returns the null AffineMap if the nresults is equal to zero. Returns the affineMap if nresults is greater or equals to number of results of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.memspace-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.memspace","text":"mlirMemRefTypeGetMemorySpace(type)\n\nReturns the memory space of the given MemRef type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.minorsubmap-Tuple{Reactant.MLIR.IR.AffineMap, Any}","page":"API reference","title":"Reactant.MLIR.IR.minorsubmap","text":"minorsubmap(affineMap, nresults)\n\nReturns the affine map consisting of the most minor nresults results. Returns the null AffineMap if the nresults is equal to zero. Returns the affineMap if nresults is greater or equals to number of results of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.move_after!-Tuple{Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.move_after!","text":"move_after!(op, other)\n\nMoves the given operation immediately after the other operation in its parent block. The given operation may be owned by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.move_before!-Tuple{Reactant.MLIR.IR.Operation, Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.move_before!","text":"move_before!(op, other)\n\nMoves the given operation immediately before the other operation in its parent block. The given operation may be owner by the caller or by its current block. The other operation must belong to a block. In any case, the ownership is transferred to the block of the other operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.name-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.name","text":"name(op)\n\nGets the name of the operation as an identifier.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.namespace-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.namespace","text":"mlirOpaqueAttrGetDialectNamespace(attr)\n\nReturns the namespace of the dialect with which the given opaque attribute is associated. The namespace string is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.namespace-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.namespace","text":"mlirOpaqueTypeGetDialectNamespace(type)\n\nReturns the namespace of the dialect with which the given opaque type is associated. The namespace string is owned by the context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.nargs-Tuple{Reactant.MLIR.IR.Block}","page":"API reference","title":"Reactant.MLIR.IR.nargs","text":"nargs(block)\n\nReturns the number of arguments of the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.nattrs-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.nattrs","text":"nattrs(op)\n\nReturns the number of attributes attached to the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.nconstraints-Tuple{Reactant.MLIR.IR.IntegerSet}","page":"API reference","title":"Reactant.MLIR.IR.nconstraints","text":"nconstraints(set)\n\nReturns the number of constraints (equalities + inequalities) in the given set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.nequalities-Tuple{Reactant.MLIR.IR.IntegerSet}","page":"API reference","title":"Reactant.MLIR.IR.nequalities","text":"nequalities(set)\n\nReturns the number of equalities in the given set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.next-Tuple{Reactant.MLIR.IR.Block}","page":"API reference","title":"Reactant.MLIR.IR.next","text":"next(block)\n\nReturns the block immediately following the given block in its parent region or nothing if last.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.next-Tuple{Reactant.MLIR.IR.OpOperand}","page":"API reference","title":"Reactant.MLIR.IR.next","text":"next(opOperand)\n\nReturns an op operand representing the next use of the value, or nothing if there is no next use.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.ninequalities-Tuple{Reactant.MLIR.IR.IntegerSet}","page":"API reference","title":"Reactant.MLIR.IR.ninequalities","text":"ninequalities(set)\n\nReturns the number of inequalities in the given set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Reactant.MLIR.IR.ninputs","text":"ninputs(affineMap)\n\nReturns the number of inputs (dimensions + symbols) of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.IntegerSet}","page":"API reference","title":"Reactant.MLIR.IR.ninputs","text":"ninputs(set)\n\nReturns the number of inputs (dimensions + symbols) in the given set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.ninputs-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.ninputs","text":"ninputs(type)\n\nReturns the number of input types.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.nnestedrefs-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.nnestedrefs","text":"nnestedrefs(attr)\n\nReturns the number of references nested in the given symbol reference attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.noperands-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.noperands","text":"noperands(op)\n\nReturns the number of operands of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.nregions-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.nregions","text":"nregions(op)\n\nReturns the number of regions attached to the given operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Reactant.MLIR.IR.nresults","text":"nresults(affineMap)\n\nReturns the number of results of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.nresults","text":"nresults(op)\n\nReturns the number of results of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.nresults-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.nresults","text":"nresults(type)\n\nReturns the number of result types.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.nsuccessors-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.nsuccessors","text":"nsuccessors(op)\n\nReturns the number of successor blocks of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.nsymbols-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Reactant.MLIR.IR.nsymbols","text":"nsymbols(affineMap)\n\nReturns the number of symbols of the given affine map.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.nsymbols-Tuple{Reactant.MLIR.IR.IntegerSet}","page":"API reference","title":"Reactant.MLIR.IR.nsymbols","text":"nsymbols(set)\n\nReturns the number of symbols in the given set.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.op_owner-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.IR.op_owner","text":"op_owner(value)\n\nReturns an operation that produced this value as its result. Asserts if the value is not an op result.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.op_res_num-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.IR.op_res_num","text":"op_res_num(value)\n\nReturns the position of the value in the list of results of the operation that produced it.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.operand","page":"API reference","title":"Reactant.MLIR.IR.operand","text":"operand(op, i)\n\nReturns i-th operand of the operation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Reactant.MLIR.IR.operand!-Tuple{Reactant.MLIR.IR.Operation, Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.operand!","text":"operand!(op, i, value)\n\nSets the i-th operand of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.operandindex-Tuple{Reactant.MLIR.IR.OpOperand}","page":"API reference","title":"Reactant.MLIR.IR.operandindex","text":"operandindex(opOperand)\n\nReturns the operand number of an op operand.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.owner-Tuple{Reactant.MLIR.IR.OpOperand}","page":"API reference","title":"Reactant.MLIR.IR.owner","text":"owner(opOperand)\n\nReturns the owner operation of an op operand.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.parent_op-Tuple{Reactant.MLIR.IR.Block}","page":"API reference","title":"Reactant.MLIR.IR.parent_op","text":"parent_op(block)\n\nReturns the closest surrounding operation that contains this block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.parent_op-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.parent_op","text":"parent_op(op)\n\nGets the operation that owns this operation, returning null if the operation is not owned.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.parent_region-Tuple{Reactant.MLIR.IR.Block}","page":"API reference","title":"Reactant.MLIR.IR.parent_region","text":"parent_region(block)\n\nReturns the region that contains this block.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.position-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.position","text":"position(affineExpr)\n\nReturns the position of the given affine dimension expression, affine symbol expression or ...\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.push_argument!-Tuple{Reactant.MLIR.IR.Block, Any}","page":"API reference","title":"Reactant.MLIR.IR.push_argument!","text":"push_argument!(block, type; location=Location())\n\nAppends an argument of the specified type to the block. Returns the newly added argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.region-Tuple{Reactant.MLIR.IR.Operation, Any}","page":"API reference","title":"Reactant.MLIR.IR.region","text":"region(op, i)\n\nReturns i-th region attached to the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.result","page":"API reference","title":"Reactant.MLIR.IR.result","text":"result(type, i)\n\nReturns the i-th result type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Reactant.MLIR.IR.result-2","page":"API reference","title":"Reactant.MLIR.IR.result","text":"result(op, i)\n\nReturns i-th result of the operation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Reactant.MLIR.IR.result-Tuple{Reactant.MLIR.IR.AffineMap, Any}","page":"API reference","title":"Reactant.MLIR.IR.result","text":"result(affineMap, pos)\n\nReturns the result at the given position.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.result-Tuple{Reactant.MLIR.IR.AffineMap}","page":"API reference","title":"Reactant.MLIR.IR.result","text":"result(affineMap)\n\nReturns the constant result of the given affine map. The function asserts that the map has a single constant result.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.rhs-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.rhs","text":"rhs(affineExpr)\n\nReturns the right hand side affine expression of the given affine binary operation expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.rmattr!-Tuple{Reactant.MLIR.IR.Operation, Any}","page":"API reference","title":"Reactant.MLIR.IR.rmattr!","text":"rmattr!(op, name)\n\nRemoves an attribute by name. Returns false if the attribute was not found and true if removed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.rmfromparent!-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.rmfromparent!","text":"rmfromparent(op)\n\nRemoves the given operation from its parent block. The operation is not destroyed. The ownership of the operation is transferred to the caller.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.rootref-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.rootref","text":"rootref(attr)\n\nReturns the string reference to the root referenced symbol. The data remains live as long as the context in which the attribute lives.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.run!-Tuple{Reactant.MLIR.IR.PassManager, Reactant.MLIR.IR.Module}","page":"API reference","title":"Reactant.MLIR.IR.run!","text":"run!(passManager, module)\n\nRun the provided passManager on the given module.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.submap-Tuple{Reactant.MLIR.IR.AffineMap, Vector{Int64}}","page":"API reference","title":"Reactant.MLIR.IR.submap","text":"submap(affineMap, positions)\n\nReturns the affine map consisting of the positions subset.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.success-Tuple{}","page":"API reference","title":"Reactant.MLIR.IR.success","text":"success()\n\nCreates a logical result representing a success.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.successor-Tuple{Reactant.MLIR.IR.Operation, Any}","page":"API reference","title":"Reactant.MLIR.IR.successor","text":"successor(op, i)\n\nReturns i-th successor of the operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.terminator-Tuple{Reactant.MLIR.IR.Block}","page":"API reference","title":"Reactant.MLIR.IR.terminator","text":"terminator(block)\n\nReturns the terminator operation in the block or nothing if no terminator.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.type!-Tuple{Any, Any}","page":"API reference","title":"Reactant.MLIR.IR.type!","text":"set_type!(value, type)\n\nSets the type of the block argument to the given type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.type-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.type","text":"type(attribute)\n\nGets the type of this attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.type-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.IR.type","text":"type(value)\n\nReturns the type of the value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Attribute}","page":"API reference","title":"Reactant.MLIR.IR.typeid","text":"typeid(attribute)\n\nGets the type id of the attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.typeid","text":"typeid(op)\n\nGets the type id of the operation. Returns null if the operation does not have a registered operation description.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.typeid-Tuple{Reactant.MLIR.IR.Type}","page":"API reference","title":"Reactant.MLIR.IR.typeid","text":"typeid(type)\n\nGets the type ID of the type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.value-Tuple{Reactant.MLIR.IR.AffineExpr}","page":"API reference","title":"Reactant.MLIR.IR.value","text":"value(affineExpr)\n\nReturns the value of the given affine constant expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.verify-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.verify","text":"verify(op)\n\nVerify the operation and return true if it passes, false if it fails.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.IR.verifyall-Tuple{Reactant.MLIR.IR.Operation}","page":"API reference","title":"Reactant.MLIR.IR.verifyall","text":"verifyall(operation; debug=false)\n\nPrints the operations which could not be verified.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo._asin_acos_kernel-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo._asin_acos_kernel","text":"_asin_acos_kernel\n\nReturns AsinAcosKernel(operand) element-wise.\n\nIf   w = asinacoskernel(z)   w' = _asinacos_kernel(I * z) then   asin(z) = complex(atan2(z.real, w.real), sign(z.imag) * w.imag)   acos(z) = complex(atan2(w.real, z.real), -sign(z.imag) * w.imag)   asinh(z) = complex(sign(z.real) * w'.imag, atan2(z.imag, w'.real))   acosh(z) = complex(w.imag, sign(z.imag) * atan2(w.real, z.real))\n\nThis op is used as an intermediate value in decompositions and should never be constructed directly by frameworks or consumed by backends.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.acos-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.acos","text":"acos\n\nReturns Acos(operand) element-wise.\n\n$\n\n\\acos(x) = 2 * \\atan(\\sqrt(1 - x^2) / (1 + x)) if x != -1          = pi                                  if x == -1 $\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.acosh-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.acosh","text":"acosh\n\nReturns Acosh(operand) element-wise.\n\n$\n\n\\acosh(x) = log(x + sqrt(x^2 - 1))      if x >= -1 \\acosh(x) = nan                         if x < -1 $\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.asin-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.asin","text":"asin\n\nReturns Asin(operand) element-wise.\n\n$\n\n\\asin(x) = 2 * atan(x / (1 + sqrt(1 - x^2))) $\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.asinh-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.asinh","text":"asinh\n\nReturns Asinh(operand) element-wise.\n\n$\n\n\\asinh(x) = log(x + sqrt(x^2 + 1)) $\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.atan-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.atan","text":"atan\n\nReturns Atan(operand) element-wise.\n\n$\n\n\\atan(x) = \\atan2(x, 1) $\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.atanh-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.atanh","text":"atanh\n\nReturns Atanh(operand) element-wise.\n\n$\n\n\\atanh(x) = 0.5 * log((1 + x) / (1 - x)) if abs(x) <= 1           = nan                          otherwise $\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.bessel_i1e-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.bessel_i1e","text":"bessel_i1e\n\nReturns bessel_i1e(operand) element-wise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_add-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_add","text":"broadcast_add\n\nReturns lhs + rhs element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_and-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_and","text":"broadcast_and\n\nReturns logical_and(lhs, rhs) element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_atan2-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_atan2","text":"broadcast_atan2\n\nReturns atan2(lhs/rhs) element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_compare-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_compare","text":"broadcast_compare\n\nCompares lhs and rhs elementwise according to comparison_direction and compare_type. If unspecified, compare_type is FLOAT for float element types, SIGNED for signed element types and UNSIGNED for unsigned element types.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisecomparison_operations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_complex-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_complex","text":"broadcast_complex\n\nPerforms element-wise conversion of a pair of real and imaginary values to a complex value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_divide-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_divide","text":"broadcast_divide\n\nReturns lhs / rhs element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_maximum-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_maximum","text":"broadcast_maximum\n\nReturns max(lhs, rhs) element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_minimum-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_minimum","text":"broadcast_minimum\n\nReturns min(lhs, rhs) element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_multiply-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_multiply","text":"broadcast_multiply\n\nReturns lhs * rhs element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_next_after-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_next_after","text":"broadcast_next_after\n\nReturns the next representable value of lhs in the direction of rhs, element-wise. It can also return a subnormal number.\n\nEquivalent to the C++ std::nextafter function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_or-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_or","text":"broadcast_or\n\nReturns logical_or(lhs, rhs) element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_polygamma-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_polygamma","text":"broadcast_polygamma\n\nReturns Polygamma(operand, operand) element-wise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_power-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_power","text":"broadcast_power\n\nReturns lhs ^ rhs element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_remainder-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_remainder","text":"broadcast_remainder\n\nReturns lhs % rhs element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_select","text":"broadcast_select\n\nConstructs an output array from elements of two input arrays, based on the values of a predicate array.\n\nSee https://www.tensorflow.org/xla/operation_semantics#select\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_shift_left-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_shift_left","text":"broadcast_shift_left\n\nReturns lhs << rhs element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_shift_right_arithmetic-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_shift_right_arithmetic","text":"broadcast_shift_right_arithmetic\n\nReturns lhs >> rhs element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_shift_right_logical-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_shift_right_logical","text":"broadcast_shift_right_logical\n\nReturns lhs >> rhs element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_subtract-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_subtract","text":"broadcast_subtract\n\nReturns lhs - rhs element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_xor-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_xor","text":"broadcast_xor\n\nReturns logical_xor(lhs, rhs) element-wise.\n\nSee https://www.tensorflow.org/xla/operationsemantics#element-wisebinaryarithmeticoperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.broadcast_zeta-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.broadcast_zeta","text":"broadcast_zeta\n\nReturns Zeta(operand, operand) element-wise.\n\n$\n\n(\\zeta(x, q) = \\sum_{n=0}^{\\infty} (q + n)^{-x}) $\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.conj-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.conj","text":"conj\n\nReturns Conj(operand) element-wise.\n\n$\n\n\\conj(x) = (\\real(x), \\neg(\\imag(x))) $\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.constant-Tuple{}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.constant","text":"constant\n\nRepresents a constant value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.constant_like-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.constant_like","text":"constant_like\n\nReturns a splat constant of the same shape as the operand.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.cosh-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.cosh","text":"cosh\n\nReturns Cosh(operand) element-wise.\n\n$\n\n\\cosh(x) = (e^x + e^-x) / 2 $\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.digamma-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.digamma","text":"digamma\n\nReturns Digamma(operand) element-wise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.erf-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.erf","text":"erf\n\nComputes the Gauss error function of x element-wise.\n\nerf(x) = erfimpl(x)            if |x| < 1        = 1 - erfcimpl(x)       otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.erf_inv-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.erf_inv","text":"erf_inv\n\nReturns ErfInv(operand) element-wise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.erfc-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.erfc","text":"erfc\n\nComputes an approximation of the error function complement (1 - erf(x)).\n\nerfc(x) = erfcimpl(x)           if |x| > 1         = 1 - erfimpl(x)        otherwise\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.is_inf-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.is_inf","text":"is_inf\n\nReturns if a value is +/-inf element-wise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.is_neg_inf-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.is_neg_inf","text":"is_neg_inf\n\nReturns if a value is -inf element-wise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.is_pos_inf-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.is_pos_inf","text":"is_pos_inf\n\nReturns if a value is +inf element-wise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.lgamma-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.lgamma","text":"lgamma\n\nReturns Lgamma(operand) element-wise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.next_after-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.next_after","text":"next_after\n\nReturns the next representable value of x in the direction of y, element-wise. It can also return a subnormal number.\n\nEquivalent to the C++ std::nextafter function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.polygamma-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.polygamma","text":"polygamma\n\nReturns Polygamma(operand, operand) element-wise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.sinh-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.sinh","text":"sinh\n\nReturns Sinh(operand) element-wise.\n\n$\n\n\\sinh(x) = (e^x - e^-x) / 2                     if |x| < 1          = e^(x + log(1/2)) - e^(-x + log(1/2)) otherwise. $\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.tan-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.tan","text":"tan\n\nReturns Tan(operand) element-wise.\n\n$\n\n\\tan(x) = \\sin(x) / \\cos(x) $\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.top_k-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.top_k","text":"top_k\n\nIf the input is a vector (rank-1), finds the k largest entries in the vector and outputs their values and indices as vectors.  Thus values[j] is the j-th largest entry in input, and its index is indices[j].\n\nFor matrices (resp. higher rank input), computes the top k entries in each row (resp. vector along the last dimension).  Thus,\n\nvalues.shape = indices.shape = input.shape[:-1] + [k]\n\nIf two elements are equal, the lower-index element appears first.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.chlo.zeta-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.chlo.zeta","text":"zeta\n\nReturns Zeta(operand, operand) element-wise.\n\n$\n\n(\\zeta(x, q) = \\sum_{n=0}^{\\infty} (q + n)^{-x}) $\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.abs-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.abs","text":"abs\n\nPerforms element-wise abs operation on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#abs\n\nExample\n\n%result = stablehlo.abs %operand : tensor<3xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.add-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.add","text":"add\n\nPerforms element-wise addition of two tensors lhs and rhs and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#add\n\nExample\n\n%result = stablehlo.add %lhs, %rhs : tensor<2x2xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.after_all-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.after_all","text":"after_all\n\nEnsures that the operations producing the inputs are executed before any operations that depend on result.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#after_all\n\nExample\n\n%result = stablehlo.after_all %input0, %input1 : !stablehlo.token\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.all_gather-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.all_gather","text":"all_gather\n\nWithin each process group in the process grid, concatenates the values of the operand tensor from each process along all_gather_dim and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#all_gather\n\nExample\n\n%result:2 = \"stablehlo.all_gather\"(%operand0, %operand1) {\n  all_gather_dim = 1 : i64,\n  replica_groups = dense<[[0, 1]]> : tensor<1x2xi64>,\n  channel_handle = #stablehlo.channel_handle<handle = 0, type = 0>\n} : (tensor<2x2xi64>, tensor<2x2xi64>) -> (tensor<2x4xi64>, tensor<2x4xi64>)\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.all_reduce-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.all_reduce","text":"all_reduce\n\nWithin each process group in the process grid, applies a reduction function computation to the values of the operand tensor from each process and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#all_reduce\n\nExample\n\n%result:2 = \"stablehlo.all_reduce\"(%operand0, %operand0) ({\n  ^bb0(%arg0: tensor<i64>, %arg1: tensor<i64>):\n  %0 = \"stablehlo.add\"(%arg0, %arg1) : (tensor<i64>, tensor<i64>) -> tensor<i64>\n  \"stablehlo.return\"(%0) : (tensor<i64>) -> ()\n}) {\n  replica_groups = dense<[[0, 1]]> : tensor<1x2xi64>,\n  channel_handle = #stablehlo.channel_handle<handle = 0, type = 0>\n} : (tensor<4xi64>, tensor<4xi64>) -> (tensor<4xi64>, tensor<4xi64>)\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.all_to_all-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.all_to_all","text":"all_to_all\n\nWithin each process group in the process grid, splits the values of the operand tensor along split_dimension into parts, scatters the split parts between the processes, concatenates the scattered parts along concat_dimension and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#alltoall\n\nExample\n\n%result:2 = \"stablehlo.all_to_all\"(%operand1, %operand2) {\n  split_dimension = 1 : i64,\n  concat_dimension = 0 : i64,\n  split_count = 2 : i64,\n  replica_groups = dense<[[0, 1]]> : tensor<1x2xi64>\n} : (tensor<2x4xi64>, tensor<2x4xi64>) -> (tensor<4x2xi64>, tensor<4x2xi64>)\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.and-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.and","text":"and\n\nPerforms element-wise AND of two tensors lhs and rhs and produces a result tensor\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#and\n\nExample\n\n%result = stablehlo.and %lhs, %rhs : tensor<2x2xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.atan2-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.atan2","text":"atan2\n\nPerforms element-wise atan2 operation on lhs and rhs tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#atan2\n\nExample\n\n%result = stablehlo.atan2 %lhs, %rhs : tensor<3xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.batch_norm_grad-NTuple{5, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.batch_norm_grad","text":"batch_norm_grad\n\nComputes gradients of several inputs of BatchNormTrainingOp backpropagating from grad_output, and produces grad_operand, grad_scale and grad_offset tensors.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#batchnormgrad\n\nExample\n\n%grad_operand, %grad_scale, %grad_offset =\n\"stablehlo.batch_norm_grad\"(%operand, %scale, %mean, %variance, %grad_output) {\n  epsilon = 0.0 : f32,\n  feature_index = 2 : i64\n} : (tensor<2x2x2xf64>, tensor<2xf64>, tensor<2xf64>, tensor<2xf64>,\n     tensor<2x2x2xf64>) -> (tensor<2x2x2xf64>, tensor<2xf64>, tensor<2xf64>)\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.batch_norm_inference-NTuple{5, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.batch_norm_inference","text":"batch_norm_inference\n\nNormalizes the operand tensor across all dimensions except for the feature_index dimension and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#batchnorminference\n\nExample\n\n%result = \"stablehlo.batch_norm_inference\"(%operand, %scale, %offset, %mean, %variance) {\n  epsilon = 0.0 : f32,\n  feature_index = 2 : i64\n} : (tensor<2x2x2xf64>, tensor<2xf64>, tensor<2xf64>, tensor<2xf64>, tensor<2xf64>) -> tensor<2x2x2xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.batch_norm_training-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.batch_norm_training","text":"batch_norm_training\n\nComputes mean and variance across batch and spatial dimensions and normalizes the operand tensor, for each feature in the feature_index dimension and produces output, batch_mean and batch_var tensors.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#batchnormtraining\n\nExample\n\n%output, %batch_mean, %batch_var = \"stablehlo.batch_norm_training\"(%operand, %scale, %offset) {\n  epsilon = 0.0 : f32,\n  feature_index = 2 : i64\n} : (tensor<2x2x2xf64>, tensor<2xf64>, tensor<2xf64>) ->\n    (tensor<2x2x2xf64>, tensor<2xf64>, tensor<2xf64>)\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.bitcast_convert-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.bitcast_convert","text":"bitcast_convert\n\nPerforms a bitcast operation on operand tensor and produces a result tensor where the bits of the entire operand tensor are reinterpreted using the type of the result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#bitcast_convert\n\nExample\n\n%result = stablehlo.bitcast_convert %operand : (tensor<f64>) -> tensor<4xf16>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.broadcast-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.broadcast","text":"broadcast\n\nThis operation is on its way out of StableHLO, so it is not included in the StableHLO specification: https://github.com/openxla/stablehlo/issues/3.\n\nInformally, this operation does the same thing as XLA's Broadcast: https://www.tensorflow.org/xla/operation_semantics#broadcast\n\nExample\n\n%result = stablehlo.broadcast %operand, sizes = [1, 2] : (tensor<3xi32>) -> tensor<1x2x3xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.broadcast_in_dim-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.broadcast_in_dim","text":"broadcast_in_dim\n\nExpands the dimensions and/or rank of an input tensor by duplicating the data in the operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#broadcastindim\n\nExample\n\n%result = stablehlo.broadcast_in_dim %operand, dims = [2, 1] : (tensor<1x3xi32>) -> tensor<2x3x2xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.case-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.case","text":"case\n\nProduces the output from executing exactly one function from branches depending on the value of index.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#case\n\nExample\n\n%result0, %result1 = \"stablehlo.case\"(%index) ({\n  stablehlo.return %result_branch0, %result_branch0 : tensor<2xi64>, tensor<2xi64>\n}, {\n  stablehlo.return %result_branch1, %result_branch1 : tensor<2xi64>, tensor<2xi64>\n}) : (tensor<i32>) -> (tensor<2xi64>, tensor<2xi64>)\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.cbrt-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.cbrt","text":"cbrt\n\nPerforms element-wise cubic root operation on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#cbrt\n\nExample\n\n%result = stablehlo.cbrt %operand : tensor<4xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.ceil-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.ceil","text":"ceil\n\nPerforms element-wise ceil of operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#ceil\n\nExample\n\n%result = stablehlo.ceil %operand : tensor<5xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.cholesky-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.cholesky","text":"cholesky\n\nComputes the Cholesky decomposition of a batch of matrices.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#cholesky\n\nExample\n\n%result = stablehlo.cholesky %a, lower = true : tensor<3x3xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.clamp-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.clamp","text":"clamp\n\nClamps every element of the operand tensor between a minimum and maximum value and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#clamp\n\nExample\n\n%result = stablehlo.clamp %min, %operand, %max : tensor<3xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.collective_broadcast-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.collective_broadcast","text":"collective_broadcast\n\nWithin each process group in the process grid, send the value of the operand tensor from the source process to the target processes and produce a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#collective_broadcast\n\nExample\n\n%result = \"stablehlo.collective_broadcast\"(%operand) {\n  replica_groups = dense<[[0, 1]]> : tensor<1x2xi64>,\n  channel_handle = #stablehlo.channel_handle<handle = 0, type = 0>\n} : (tensor<1x2xi64>) -> tensor<1x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.collective_permute-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.collective_permute","text":"collective_permute\n\nWithin each process group in the process grid, sends the value of the operand tensor from the source process to the target process and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#collective_permute\n\nExample\n\n%result = \"stablehlo.collective_permute\"(%operand) {\n  source_target_pairs = dense<[[0, 1], [1, 2]]> : tensor<2x2xi64>,\n  channel_handle = #stablehlo.channel_handle<handle = 0, type = 0>\n} : (tensor<2x2xi64>) -> tensor<2x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.compare-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.compare","text":"compare\n\nPerforms element-wise comparison of lhs and rhs tensors according to comparison_direction and compare_type, and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#compare\n\nExample\n\n%result = stablehlo.compare LT, %lhs, %rhs, FLOAT : (tensor<2xf32>, tensor<2xf32>) -> tensor<2xi1>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.complex-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.complex","text":"complex\n\nPerforms element-wise conversion to a complex value from a pair of real and imaginary values, lhs and rhs, and produces a result tensor. See: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#complex\n\nExample\n\n%result = stablehlo.complex %lhs, %rhs : tensor<2xcomplex<f64>>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.composite-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.composite","text":"composite\n\nEncapsulates an operation made up (composed) of other StableHLO operations, taking inputs and composite_attributes and producing results. The semantics of the op are implemented by the decomposition attribute. The composite op can be replaced with its decomposition without changing program semantics. In cases where inlining the decomposition does not provide the same op semantics, prefer using custom_call.\n\nThe version field (defaults to 0) is used to denote when a composite's semantics change.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#composite\n\nExample\n\n%results = stablehlo.composite \"my.op\" %input0, %input1 {\n  composite_attributes = {\n    my_attribute = \"my_value\"\n  },\n  decomposition = @my_op,\n  version = 1 : i32\n} : (tensor<f32>, tensor<f32>) -> tensor<f32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.concatenate-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.concatenate","text":"concatenate\n\nConcatenates a variadic number of tensors in inputs along dimension dimension in the same order as the given arguments and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#concatenate\n\nExample\n\n%result = stablehlo.concatenate %input0, %input1, dim = 0 : (tensor<3x2xi64>, tensor<1x2xi64>) -> tensor<4x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.constant-Tuple{}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.constant","text":"constant\n\nProduces an output tensor from a constant value.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#constant\n\nExample\n\n%output = stablehlo.constant dense<[[0.0, 1.0], [2.0, 3.0]]> : tensor<2x2xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.convert-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.convert","text":"convert\n\nPerforms an element-wise conversion from one element type to another on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#convert\n\nExample\n\n%result = stablehlo.convert %operand : (tensor<3xi64>) -> tensor<3xcomplex<f64>>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.convolution-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.convolution","text":"convolution\n\nComputes dot products between windows of lhs and slices of rhs and produces result.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#convolution\n\nExample\n\n%result = stablehlo.convolution(%lhs, %rhs)\n  dim_numbers = [b, 0, 1, f]x[0, 1, i, o]->[b, 0, 1, f],\n  window = {\n    stride = [4, 4],\n    pad = [[0, 0], [0, 0]],\n    lhs_dilate = [2, 2],\n    rhs_dilate = [1, 1],\n    reverse = [0, 0]\n  } {\n    feature_group_count = 1 : i64,\n    batch_group_count = 1 : i64,\n    precision_config = [#stablehlo<precision DEFAULT>, #stablehlo<precision DEFAULT>]\n  } :\n(tensor<1x4x4x1xi64>, tensor<3x3x1x1xi64>) -> tensor<1x2x2x1xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.cosine-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.cosine","text":"cosine\n\nPerforms element-wise cosine operation on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#cosine\n\nExample\n\n%result = stablehlo.cosine %operand : tensor<2xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.count_leading_zeros-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.count_leading_zeros","text":"count_leading_zeros\n\nPerforms element-wise count of the number of leading zero bits in the operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#countleadingzeros\n\nExample\n\n%result = stablehlo.count_leading_zeros %operand : tensor<2x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.create_token-Tuple{}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.create_token","text":"create_token\n\nThis operation is on its way out of StableHLO, so it is not included in the StableHLO specification: https://github.com/openxla/stablehlo/issues/3.\n\nInformally, this operation does the same thing as AfterAllOp with 0 inputs: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#after_all\n\nExample\n\n%output = stablehlo.create_token : !stablehlo.token\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.cross_replica_sum-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.cross_replica_sum","text":"cross_replica_sum\n\nThis operation is on its way out of StableHLO, so it is not included in the StableHLO specification: https://github.com/openxla/stablehlo/issues/3.\n\nInformally, this operation does the same thing as AllReduceOp with channel_id = 0, use_global_device_ids = false and computation implementing addition: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#all_reduce\n\nExample\n\n%result = \"stablehlo.cross-replica-sum\"(%operand) {\n  replica_groups = dense<[[0, 1]]> : tensor<1x2xi64>\n} : (tensor<4xf32>) -> tensor<4xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.custom_call-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.custom_call","text":"custom_call\n\nEncapsulates an implementation-defined operation call_target_name that takes inputs and called_computations and produces results.\n\nDepending on the API version there are two ways to pass extra bits of static information to the external function:\n\nUse API_VERSION_TYPED_FFI which allows passing a dictionary attribute.\nUse a previous API version with a StringAttr to encode backend config.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#custom_call\n\nExample\n\n%results = stablehlo.custom_call @foo(%input0) {\n  backend_config = {bar = 42 : i32},\n  api_version = 4 : i32,\n  called_computations = [@foo]\n} : (tensor<f64>) -> tensor<f64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.divide-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.divide","text":"divide\n\nPerforms element-wise division of dividend lhs and divisor rhs tensors and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#divide\n\nExample\n\n%result = stablehlo.divide %lhs, %rhs : tensor<4xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.dot-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.dot","text":"dot\n\nThis operation is on its way out of StableHLO, so it is not included in the StableHLO specification: https://github.com/openxla/stablehlo/issues/3.\n\nInformally, this operation does the same thing as XLA's Dot: https://www.tensorflow.org/xla/operation_semantics#dot\n\nExample\n\n%0 = stablehlo.dot %arg0, %arg1 : (tensor<1x2xi32>, tensor<2x1xi32>) -> tensor<1x1xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.dot_general-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.dot_general","text":"dot_general\n\nComputes dot products between slices of lhs and slices of rhs and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dot_general\n\nExample\n\n%result = stablehlo.dot_general %lhs, %rhs,\n  batching_dims = [0] x [0],\n  contracting_dims = [2] x [1],\n  precision = [DEFAULT, DEFAULT],\n  algorithm = <lhs_precision_type = tf32, rhs_precision_type = tf32, accumulation_type = f32, lhs_component_count = 1, rhs_component_count = 1, num_primitive_operations = 1, allow_imprecise_accumulation = false>\n  : (tensor<2x2x2xi64>, tensor<2x2x2xi64>) -> tensor<2x2x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.dynamic_broadcast_in_dim-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.dynamic_broadcast_in_dim","text":"dynamic_broadcast_in_dim\n\nThis operation is functionally identical to broadcastindim op, but the result shape is specified dynamically via output_dimensions.\n\nIt also accepts optional attributes to express static knowledge about the expanding behavior of dimensions. If not specified, all dimensions are assumed to be possibly expanding. The sets of dimensions that are known to be expanding and the set of dimensions that are known to be non-expanding must be disjoint and they must be a subset of the operand's dimensions.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamicbroadcastin_dim\n\nExample\n\n%operand = stablehlo.constant dense<[[1, 2, 3]]> : tensor<1x3xi64>\n%output_dimensions = stablehlo.constant dense<[2, 3, 2]> : tensor<3xi64>\n%result = \"stablehlo.dynamic_broadcast_in_dim\"(%operand, %output_dimensions) {\n  broadcast_dimensions = array<i64: 2, 1>,\n  known_expanding_dimensions = array<i64: 0>,\n  known_non_expanding_dimensions = array<i64: 1>\n} : (tensor<1x3xi64>, tensor<3xi64>) -> tensor<2x3x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.dynamic_conv-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.dynamic_conv","text":"dynamic_conv\n\nThis operation is functionally identical to convolution op, but the padding is specified dynamically via padding.\n\nExample\n\n%padding = stablehlo.constant dense<2> : tensor<2x2xi64>\n%result = \"stablehlo.dynamic_conv\"(%lhs, %rhs, %padding) {\n  window_strides = array<i64: 4, 4>,\n  lhs_dilation = array<i64: 2, 2>,\n  rhs_dilation = array<i64: 1, 1>,\n  window_reversal = array<i1: false, false>,\n  dimension_numbers = #stablehlo.conv<[b, 0, 1, f]x[0, 1, i, o]->[b, 0, 1, f]>,\n  batch_group_count = 1 : i64,\n  feature_group_count = 1 : i64,\n  precision_config = [#stablehlo<precision DEFAULT>, #stablehlo<precision DEFAULT>]\n} : (tensor<1x4x4x1xi64>, tensor<3x3x1x1xi64>, tensor<2x2xi64>) -> tensor<1x2x2x1xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.dynamic_gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.dynamic_gather","text":"dynamic_gather\n\nThis operation is functionally identical to gather op, with the slice_sizes specified dynamically as an operand.\n\nExample\n\n%slice_sizes = stablehlo.constant dense<[1, 2, 2]> : tensor<3xi64>\n%result = \"stablehlo.dynamic_gather\"(%operand, %start_indices, %slice_sizes) {\n  dimension_numbers = #stablehlo.gather<\n    offset_dims = [2, 3],\n    collapsed_slice_dims = [0],\n    start_index_map = [0, 2],\n    index_vector_dim = 2>,\n  indices_are_sorted = false\n} : (tensor<3x4x2xi64>, tensor<2x3x2xi64>, tensor<3xi64>) -> tensor<2x3x2x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.dynamic_iota-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.dynamic_iota","text":"dynamic_iota\n\nThis operation is functionally identical to iota op, but the result shape is specified dynamically via output_shape.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_iota\n\nExample\n\n%output_shape = stablehlo.constant dense<[4, 5]> : tensor<2xi64>\n%0 = stablehlo.dynamic_iota %output_shape, dim = 0 : (tensor<2xi64>) -> tensor<4x5xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.dynamic_pad-NTuple{5, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.dynamic_pad","text":"dynamic_pad\n\nThis operation is functionally identical to pad https://github.com/openxla/stablehlo/pull/2306#discussionr1595669709 op, but with `edgepaddinglow,edgepaddinghighandinteriorpadding` specified dynamically as values.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_pad\n\nExample\n\n%edge_padding_low = stablehlo.constant dense<[0, 1]> : tensor<2xi32>\n%edge_padding_high = stablehlo.constant dense<[2, 1]> : tensor<2xi32>\n%interior_padding = stablehlo.constant dense<[1, 2]> : tensor<2xi32>\n%result = stablehlo.dynamic_pad %operand, %padding_value,\n            %edge_padding_low, %edge_padding_high, %interior_padding\n            : (tensor<2x3xi64>, tensor<i64>, tensor<2xi64>, tensor<2xi64>, tensor<2xi64>) -> tensor<5x9xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.dynamic_reshape-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.dynamic_reshape","text":"dynamic_reshape\n\nThis operation is functionally identical to reshape op, but the result shape is specified dynamically via output_shape.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_reshape\n\nExample\n\n%output_shape = stablehlo.constant dense<[3, 2]> : tensor<2xi64>\n%result = stablehlo.dynamic_reshape %operand, %output_shape : (tensor<2x3xi64>, tensor<2xi64>) -> tensor<3x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.dynamic_slice-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.dynamic_slice","text":"dynamic_slice\n\nExtracts a slice from the operand using dynamically-computed starting indices and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamic_slice\n\nExample\n\n%result = stablehlo.dynamic_slice %operand, %start_indices0, %start_indices1, sizes = [2, 2]\n  : (tensor<4x4xi32>, tensor<i64>, tensor<i64>) -> tensor<2x2xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.dynamic_update_slice-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.dynamic_update_slice","text":"dynamic_update_slice\n\nProduces a result tensor which is equal to the operand tensor except that the slice starting at start_indices is updated with the values in update.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dynamicupdateslice\n\nExample\n\n%result = stablehlo.dynamic_update_slice %operand, %update, %start_indices0, %start_indices1\n  : (tensor<4x4xi32>, tensor<2x2xi32>, tensor<i64>, tensor<i64>) -> tensor<4x4xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.einsum-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.einsum","text":"einsum\n\nThis operation is on its way out of StableHLO, so it is not included in the StableHLO specification: https://github.com/openxla/stablehlo/issues/3.\n\nInformally, this operation does the same thing as TF's einsum: https://www.tensorflow.org/api_docs/python/tf/einsum\n\nExample\n\n%result = \"stablehlo.einsum\"(%lhs, %rhs) {\n  einsum_config = \"ab,bc->ac\"\n} : (tensor<4x16xf32>, tensor<16x4xf32>) -> tensor<4x4xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.exponential-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.exponential","text":"exponential\n\nPerforms element-wise exponential operation on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#exponential\n\nExample\n\n%result = stablehlo.exponential %operand : tensor<2x2xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.exponential_minus_one-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.exponential_minus_one","text":"exponential_minus_one\n\nPerforms element-wise exponential minus one operation on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#exponentialminusone\n\nExample\n\n%result = stablehlo.exponential_minus_one %operand : tensor<2xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.fft-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.fft","text":"fft\n\nPerforms the forward and inverse Fourier transforms for real and complex inputs/outputs.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#fft\n\nExample\n\n%result = stablehlo.fft %operand, type = FFT, length = [4] : (tensor<4xcomplex<f32>>) -> tensor<4xcomplex<f32>>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.floor-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.floor","text":"floor\n\nPerforms element-wise floor of operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#floor\n\nExample\n\n%result = stablehlo.floor %operand : tensor<2xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.gather","text":"gather\n\nGathers slices from operand tensor from offsets specified in start_indices and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#gather\n\nExample\n\n%result = \"stablehlo.gather\"(%operand, %start_indices) {\n  dimension_numbers = #stablehlo.gather<\n    offset_dims = [3, 4],\n    collapsed_slice_dims = [1],\n    operand_batching_dims = [0],\n    start_indices_batching_dims = [1],\n    start_index_map = [2, 1],\n    index_vector_dim = 3>,\n  slice_sizes = array<i64: 1, 1, 2, 2>,\n  indices_are_sorted = false\n} : (tensor<2x3x4x2xi64>, tensor<2x2x3x2xi64>) -> tensor<2x2x3x2x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.get_dimension_size-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.get_dimension_size","text":"get_dimension_size\n\nProduces the size of the given dimension of the operand.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#getdimensionsize\n\nExample\n\n%result = stablehlo.get_dimension_size %operand, dim = 1 : (tensor<2x3xi64>) -> tensor<i32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.get_tuple_element-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.get_tuple_element","text":"get_tuple_element\n\nExtracts element at index position of the operand tuple and produces a result.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#gettupleelement\n\nExample\n\n%result = stablehlo.get_tuple_element %operand[0] : (tuple<tensor<2xf64>, tuple<tensor<i64>>>) -> tensor<2xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.if_-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.if_","text":"if_\n\nProduces the output from executing exactly one branch from true_branch or false_branch depending on the value of pred.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#if\n\nExample\n\n%result = \"stablehlo.if\"(%pred) ({   \"stablehlo.return\"(%resulttruebranch) : (tensor<i32>) -> () }, {   \"stablehlo.return\"(%resultfalsebranch) : (tensor<i32>) -> () }) : (tensor<i1>) -> tensor<i32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.imag-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.imag","text":"imag\n\nExtracts the imaginary part, element-wise, from the operand and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#imag\n\nExample\n\n%result = stablehlo.imag %operand : (tensor<2xcomplex<f32>>) -> tensor<2xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.infeed-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.infeed","text":"infeed\n\nReads data from the infeed and produces results.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#infeed\n\nExample\n\n%results0:2 = \"stablehlo.infeed\"(%token) :\n    (!stablehlo.token) -> (tensor<2x2xi64>, !stablehlo.token)\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.iota-Tuple{}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.iota","text":"iota\n\nFills an output tensor with values in increasing order starting from zero along the iota_dimension dimension.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#iota\n\nExample\n\n%output = stablehlo.iota dim = 0 : tensor<4x5xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.is_finite-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.is_finite","text":"is_finite\n\nPerforms element-wise check whether the value in x is finite (i.e. is neither +Inf, -Inf, nor NaN) and produces a y tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#is_finite\n\nExample\n\n%y = stablehlo.is_finite %x : (tensor<7xf64>) -> tensor<7xi1>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.log-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.log","text":"log\n\nPerforms element-wise logarithm operation on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#log\n\nExample\n\n%result = stablehlo.log %operand : tensor<2x2xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.log_plus_one-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.log_plus_one","text":"log_plus_one\n\nPerforms element-wise logarithm plus one operation on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#logplusone\n\nExample\n\n%result = stablehlo.log_plus_one %operand : tensor<5xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.logistic-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.logistic","text":"logistic\n\nPerforms element-wise logistic operation on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#logistic\n\nExample\n\n%result = stablehlo.logistic %operand : tensor<2x2xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.map-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.map","text":"map\n\nApplies a map function computation to inputs along the dimensions and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#map\n\nExample\n\n%result = \"stablehlo.map\"(%input0, %input1) ({\n  ^bb0(%arg0: tensor<i64>, %arg1: tensor<i64>):\n    %0 = stablehlo.multiply %arg0, %arg1 : tensor<i64>\n    stablehlo.return %0 : tensor<i64>\n}) {\n  dimensions = array<i64: 0, 1>\n} : (tensor<2x2xi64>, tensor<2x2xi64>) -> tensor<2x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.maximum-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.maximum","text":"maximum\n\nPerforms element-wise max operation on tensors lhs and rhs and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#maximum\n\nExample\n\n%result = stablehlo.maximum %lhs, %rhs : tensor<4xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.minimum-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.minimum","text":"minimum\n\nPerforms element-wise min operation on tensors lhs and rhs and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#minimum\n\nExample\n\n%result = stablehlo.minimum %lhs, %rhs : tensor<4xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.multiply-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.multiply","text":"multiply\n\nPerforms element-wise product of two tensors lhs and rhs and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#multiply\n\nExample\n\n%result = stablehlo.multiply %lhs, %rhs : tensor<2xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.negate-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.negate","text":"negate\n\nPerforms element-wise negation of operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#negate\n\nExample\n\n%result = stablehlo.negate %operand : tensor<2x3xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.not-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.not","text":"not\n\nPerforms element-wise NOT of tensor operand of type integer and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#not\n\nExample\n\n%result = stablehlo.not %operand : tensor<5x3x1xi1>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.optimization_barrier-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.optimization_barrier","text":"optimization_barrier\n\nEnsures that the operations that produce the operand are executed before any operations that depend on the result and prevents compiler transformations from moving operations across the barrier. Other than that, the operation is an identity, i.e. result = operand.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#optimization_barrier\n\nExample\n\n%result0, %result1 = stablehlo.optimization_barrier %operand0, %operand1 : tensor<f32>, tensor<f32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.or-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.or","text":"or\n\nPerforms element-wise OR of two tensors lhs and rhs and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#or\n\nExample\n\n%result = stablehlo.or %lhs, %rhs : tensor<2xi1>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.outfeed-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.outfeed","text":"outfeed\n\nWrites inputs to the outfeed and produces a result token.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#outfeed\n\nExample\n\n%result = \"stablehlo.outfeed\"(%input0, %token) :\n    (tensor<2x2x2xi64>, !stablehlo.token) -> !stablehlo.token\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.pad-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.pad","text":"pad\n\nExpands operand by padding around the tensor as well as between the elements of the tensor with the given padding_value.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#pad\n\nExample\n\n%0 = stablehlo.pad %arg0, %arg1, low = [0, 1], high = [2, 1], interior = [1, 2]\n  : (tensor<2x3xi32>, tensor<i32>) -> tensor<5x9xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.partition_id-Tuple{}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.partition_id","text":"partition_id\n\nProduces partition_id of the current process.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#partition_id\n\nExample\n\n%result = stablehlo.partition_id : tensor<ui32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.popcnt-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.popcnt","text":"popcnt\n\nPerforms element-wise count of the number of bits set in the operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#popcnt\n\nExample\n\n%result = stablehlo.popcnt %operand : tensor<4xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.power-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.power","text":"power\n\nPerforms element-wise exponentiation of lhs tensor by rhs tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#power\n\nExample\n\n%result = stablehlo.power %lhs, %rhs : tensor<6xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.real-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.real","text":"real\n\nExtracts the real part, element-wise, from the operand and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#real\n\nExample\n\n%result = stablehlo.real %operand : (tensor<2xcomplex<f32>>) -> tensor<2xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.real_dynamic_slice-NTuple{4, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.real_dynamic_slice","text":"real_dynamic_slice\n\nThis operation is a work in progress, so it is not yet included in the StableHLO specification: https://github.com/openxla/stablehlo/issues/8.\n\nInformally, this operation does the same thing as SliceOp except that start_indices, limit_indices and strides are specified dynamically: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#slice\n\nExample\n\n%result = stablehlo.real_dynamic_slice %operand,\n            %start_indices, %limit_indices, %strides\n       : (tensor<256x?xf32>, tensor<2xindex>, tensor<2xindex>, tensor<2xindex>) -> tensor<256x?xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.recv-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.recv","text":"recv\n\nReceives data from a channel with channel_id and produces results.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#recv\n\nExample\n\n%results:2 = \"stablehlo.recv\"(%token) {\n  channel_handle = #stablehlo.channel_handle<handle = 1, type = 3>,\n  is_host_transfer = true\n} : (!stablehlo.token) -> (tensor<2x2xi64>, !stablehlo.token)\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.reduce-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.reduce","text":"reduce\n\nApplies a reduction function body to inputs and init_values along the dimensions and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reduce\n\nExample\n\n%result = \"stablehlo.reduce\"(%input, %init_value) ({\n  ^bb0(%arg0: tensor<i64>, %arg1: tensor<i64>):\n    %0 = stablehlo.add %arg0, %arg1 : tensor<i64>\n    stablehlo.return %0 : tensor<i64>\n}) {\n  dimensions = array<i64: 1>\n} : (tensor<1x6xi64>, tensor<i64>) -> tensor<1xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.reduce_precision-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.reduce_precision","text":"reduce_precision\n\nPerforms element-wise conversion of operand to another floating-point type that uses exponent_bits and mantissa_bits and back to the original floating-point type and produces an output tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reduce_precision\n\nExample\n\n%output = stablehlo.reduce_precision %operand, format = e5m10 : tensor<6xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.reduce_scatter-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.reduce_scatter","text":"reduce_scatter\n\nWithin each process group in the process grid, performs reduction, using computations, over the values of the operand tensor from each process, splits the reduction result along scatter_dimension into parts, and scatters the split parts between the processes to produce the result.\n\nSee:\nhttps://github.com/openxla/stablehlo/blob/main/docs/spec.md#reduce_scatter\n\nExample:\n```mlir\n%result = \"stablehlo.reduce_scatter\"(%operand) ({\n\n^bb0(%arg0: tensor<i64>, %arg1: tensor<i64>):  %0 = stablehlo.add %arg0, %arg1 : tensor<i64>  stablehlo.return %0 : tensor<i64>     }) {  scatterdimension = 1 : i64,  replicagroups = dense<[[0, 1]]> : tensor<1x2xi64>,  channelhandle = #stablehlo.channelhandle<handle = 0, type = 0>     } : (tensor<2x4xi64>) -> tensor<2x2xi64>     ```\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.reduce_window-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.reduce_window","text":"reduce_window\n\nApplies a reduction function body to windows of inputs and init_values and produces results.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reduce_window\n\nExample\n\n%result = \"stablehlo.reduce_window\"(%input, %init_value) ({\n  ^bb0(%arg0: tensor<i64>, %arg1: tensor<i64>):\n    %0 = stablehlo.add %arg0, %arg1 : tensor<i64>\n    stablehlo.return %0 : tensor<i64>\n}) {\n  window_dimensions = array<i64: 2, 1>,\n  window_strides = array<i64: 4, 1>,\n  base_dilations = array<i64: 2, 1>,\n  window_dilations = array<i64: 3, 1>,\n  padding = dense<[[2, 1], [0, 0]]> : tensor<2x2xi64>\n} : (tensor<3x2xi64>, tensor<i64>) -> tensor<2x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.remainder-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.remainder","text":"remainder\n\nPerforms element-wise remainder of dividend lhs and divisor rhs tensors and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#remainder\n\nExample\n\n%result = stablehlo.remainder %lhs, %rhs : tensor<4xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.replica_id-Tuple{}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.replica_id","text":"replica_id\n\nProduces replica_id of the current process.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#replica_id\n\nExample\n\n%result = stablehlo.replica_id : tensor<ui32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.reshape-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.reshape","text":"reshape\n\nPerforms reshape of operand tensor to a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reshape\n\nExample\n\n%result = stablehlo.reshape %operand : (tensor<2xf32>) -> tensor<1x2xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.reverse-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.reverse","text":"reverse\n\nReverses the order of elements in the operand along the specified dimensions and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#reverse\n\nExample\n\n%result = stablehlo.reverse %operand, dims = [1] : tensor<3x2xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.rng-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.rng","text":"rng\n\nGenerates random numbers using the rng_distribution algorithm and produces a result tensor of a given shape shape.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#rng\n\nExample\n\n%result = stablehlo.rng %a, %b, %shape, distribution = NORMAL : (tensor<i32>, tensor<i32>, tensor<2xi64>) -> tensor<3x3xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.rng_bit_generator-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.rng_bit_generator","text":"rng_bit_generator\n\nReturns an output filled with uniform random data and an updated output state output_state given an initial state initial_state using the pseudorandom number generator algorithm rng_algorithm.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#rngbitgenerator\n\nExample\n\n%output_state, %output = stablehlo.rng_bit_generator %initial_state, algorithm = THREE_FRY : (tensor<2xui64>) -> (tensor<2xui64>, tensor<2x2xui64>)\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.round_nearest_afz-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.round_nearest_afz","text":"round_nearest_afz\n\nPerforms element-wise rounding towards the nearest integer, breaking ties away from zero, on the operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#roundnearestafz\n\nExample\n\n%result = stablehlo.round_nearest_afz %operand : tensor<5xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.round_nearest_even-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.round_nearest_even","text":"round_nearest_even\n\nPerforms element-wise rounding towards the nearest integer, breaking ties towards the even integer, on the operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#roundnearesteven\n\nExample\n\n%result = stablehlo.round_nearest_even %operand : tensor<5xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.rsqrt-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.rsqrt","text":"rsqrt\n\nPerforms element-wise reciprocal square root operation on operand tensor and produces a result tensor, implementing the rSqrt operation from the IEEE-754 specification.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#rsqrt\n\nExample\n\n%result = stablehlo.rsqrt %operand : tensor<2x2xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.scatter-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.scatter","text":"scatter\n\nProduces results tensors which are equal to inputs tensors except that several slices specified by scatter_indices are updated with the values updates using update_computation.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#scatter\n\nExample:    mlir    %result = \"stablehlo.scatter\"(%input, %scatter_indices, %update) ({  ^bb0(%arg0: tensor<i64>, %arg1: tensor<i64>):    %0 = stablehlo.add %arg0, %arg1 : tensor<i64>    stablehlo.return %0 : tensor<i64>    }) {  scatter_dimension_numbers = #stablehlo.scatter<    update_window_dims = [3, 4],    inserted_window_dims = [1],    input_batching_dims = [0],    scatter_indices_batching_dims = [1],    scatter_dims_to_operand_dims = [2, 1],    index_vector_dim = 3>,  indices_are_sorted = false,  unique_indices = false    } : (tensor<2x3x4x2xi64>, tensor<2x2x3x2xi64>, tensor<2x2x3x2x2xi64>) -> tensor<2x3x4x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.select","text":"select\n\nProduces a result tensor where each element is selected from on_true or on_false tensor based on the value of the corresponding element of pred.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#select\n\nExample\n\n%result = stablehlo.select %pred, %on_true, %on_false : tensor<2x2xi1>, tensor<2x2xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.select_and_scatter-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.select_and_scatter","text":"select_and_scatter\n\nScatters the values from the source tensor using scatter based on the outcome of reduce_window of the input tensor using select and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#selectandscatter\n\nExample\n\n%result = \"stablehlo.select_and_scatter\"(%operand, %source, %init_value) ({\n  ^bb0(%arg0: tensor<i64>, %arg1: tensor<i64>):\n    %0 = stablehlo.compare GE, %arg0, %arg1 : (tensor<i64>, tensor<i64>) -> tensor<i1>\n    stablehlo.return %0 : tensor<i1>\n}, {\n  ^bb0(%arg0: tensor<i64>, %arg1: tensor<i64>):\n    %0 = stablehlo.add %arg0, %arg1 : tensor<i64>\n    stablehlo.return %0 : tensor<i64>\n}) {\n  window_dimensions = dense<[3, 1]> : tensor<2xi64>,\n  window_strides = dense<[2, 1]> : tensor<2xi64>,\n  padding = dense<[[0, 1], [0, 0]]> : tensor<2x2xi64>\n} : (tensor<4x2xi64>, tensor<2x2xi64>, tensor<i64>) -> tensor<4x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.send-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.send","text":"send\n\nSends inputs to a channel channel_id and produces a result token.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#send\n\nExample\n\n%result = \"stablehlo.send\"(%operand, %token) {\n  channel_handle = #stablehlo.channel_handle<handle = 1, type = 2>,\n  is_host_transfer = true\n} : (tensor<2x2xi64>, !stablehlo.token) -> !stablehlo.token\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.set_dimension_size-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.set_dimension_size","text":"set_dimension_size\n\nThis operation is a work in progress, so it is not yet included in the StableHLO specification: https://github.com/openxla/stablehlo/issues/8.\n\nInformally, this operation does the same thing as XLA's SetDimensionSize: https://www.tensorflow.org/xla/operation_semantics#setdimensionsize\n\nExample\n\n%0 = stablehlo.set_dimension_size %arg0, %arg1, dim = 1 : (tensor<4x2xf32>, tensor<i32>) -> tensor<4x2xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.shift_left-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.shift_left","text":"shift_left\n\nPerforms element-wise left-shift operation on the lhs tensor by rhs number of bits and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#shift_left\n\nExample\n\n%result = stablehlo.shift_left %lhs, %rhs : tensor<3xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.shift_right_arithmetic-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.shift_right_arithmetic","text":"shift_right_arithmetic\n\nPerforms element-wise arithmetic right-shift operation on the lhs tensor by rhs number of bits and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#shiftrightarithmetic\n\nExample\n\n%result = stablehlo.shift_right_arithmetic %lhs, %rhs : tensor<3xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.shift_right_logical-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.shift_right_logical","text":"shift_right_logical\n\nPerforms element-wise logical right-shift operation on the lhs tensor by rhs number of bits and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#shiftrightlogical\n\nExample\n\n%result = stablehlo.shift_right_logical %lhs, %rhs : tensor<3xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.sign-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.sign","text":"sign\n\nReturns the sign of the operand element-wise and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#sign\n\nExample\n\n%result = stablehlo.sign %operand : tensor<5xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.sine-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.sine","text":"sine\n\nPerforms element-wise sine operation on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#sine\n\nExample\n\n%result = stablehlo.sine %operand : tensor<2xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.slice-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.slice","text":"slice\n\nExtracts a slice from the operand using statically-computed starting indices and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#slice\n\nExample\n\n%result = stablehlo.slice %operand [1:3, 4:8:2]\n   : (tensor<3x8xi64>) -> tensor<2x2xi64>\n\n// Same in generic form: the `1:3` above is mapped to the first entry in\n// `start_indices` and `limit_indices`, while `strides` is implicitly 1.\n// The `4:8:2` above is parsed into the second entry of `start_indices`,\n// `limit_indices` and `strides` respectively.\n%result = \"stablehlo.slice\" (%operand) {\n  start_indices = array<i64: 1, 4>,\n  limit_indices = array<i64: 3, 8>,\n  strides = array<i64: 1, 2>\n} : (tensor<3x8xi64>) -> tensor<2x2xi64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.sort-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.sort","text":"sort\n\nSorts a variadic number of tensors in inputs together, according to a custom comparator, along the given dimension and produces a variadic number of tensors as results.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#sort\n\nExample\n\n```mlir %result0, %result1 = \"stablehlo.sort\"(%input0, %input1) ({   ^bb0(%arg0: tensor<i64>, %arg1: tensor<i64>, %arg2: tensor<i64>, %arg3: tensor<i64>):     %predicate = stablehlo.compare GT, %arg0, %arg1 : (tensor<i64>, tensor<i64>) -> tensor<i1>     stablehlo.return %predicate : tensor<i1> }) {   dimension = 0 : i64,   is_stable = true } : (tensor<2x3xi64>, tensor<2x3xi64>) -> (tensor<2x3xi64>, tensor<2x3xi64>)\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.sqrt-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.sqrt","text":"sqrt\n\nPerforms element-wise square root operation on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#sqrt\n\nExample\n\n%result = stablehlo.sqrt %operand : tensor<2x2xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.subtract-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.subtract","text":"subtract\n\nPerforms element-wise subtraction of two tensors lhs and rhs and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#subtract\n\nExample\n\n%result = stablehlo.subtract %lhs, %rhs : tensor<2xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.tan-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.tan","text":"tan\n\nPerforms element-wise tangent operation on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#tan\n\nExample\n\n%result = stablehlo.tan %operand : tensor<2x2xf64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.tanh-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.tanh","text":"tanh\n\nPerforms element-wise hyperbolic tangent operation on operand tensor and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#tanh\n\nExample\n\n%result = stablehlo.tanh %operand : tensor<2xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.torch_index_select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.torch_index_select","text":"torch_index_select\n\nThis operation is on its way out of StableHLO, so it is not included in the StableHLO specification: https://github.com/openxla/stablehlo/issues/3.\n\nInformally, this operation does the same thing as PyTorch's indexselect, augmented with support for batch dimensions: https://pytorch.org/docs/stable/generated/torch.indexselect.html.\n\nThe batch_dims attribute specifies the number of major batch dimensions (0 or more) that act like a multidimensional loop over both the operand and the index.\n\nExample\n\n%result = \"stablehlo.torch_index_select\"(%operand, %index) {\n  dim = 2 : i64,\n  batch_dims = 1 : i64\n} : (tensor<8x128x3072x64xf32>, tensor<8x16x1024xi32>) -> tensor<8x128x16x1024x64xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.transpose-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.transpose","text":"transpose\n\nPermutes the dimensions of operand tensor using permutation and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#transpose\n\nExample\n\n%0 = stablehlo.transpose %arg0, dims = [2, 1, 0] : (tensor<1x2x3xi32>) -> tensor<3x2x1xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.triangular_solve-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.triangular_solve","text":"triangular_solve\n\nSolves batches of systems of linear equations with lower or upper triangular coefficient matrices.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#triangular_solve\n\nExample\n\n%result = \"stablehlo.triangular_solve\"(%a, %b) {\n  left_side = true,\n  lower = true,\n  unit_diagonal = false,\n  transpose_a = #stablehlo<transpose NO_TRANSPOSE>\n} : (tensor<3x3xf32>, tensor<3x3xf32>) -> tensor<3x3xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.tuple-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.tuple","text":"tuple\n\nProduces a result tuple from values val.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#tuple\n\nExample\n\n%result = stablehlo.tuple %val0, %val1 : tuple<tensor<2xf64>, tuple<tensor<i64>>>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.unary_einsum-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.unary_einsum","text":"unary_einsum\n\nThis operation is on its way out of StableHLO, so it is not included in the StableHLO specification: https://github.com/openxla/stablehlo/issues/3.\n\nInformally, this operation does the same thing as TF's einsum: https://www.tensorflow.org/api_docs/python/tf/einsum\n\nExample\n\n%result = \"stablehlo.unary_einsum\"(%operand) {\n  einsum_config = \"ab->a\"\n} : (tensor<4x16xf32>) -> tensor<4xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.uniform_dequantize-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.uniform_dequantize","text":"uniform_dequantize\n\nPerforms element-wise conversion of quantized tensor operand to a floating-point tensor result according to the quantization parameters defined by the operand type.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#uniform_dequantize\n\nExample\n\n%result = stablehlo.uniform_dequantize %operand : (tensor<2x!quant.uniform<i8:f32:0, {0.1:-30,0.5:-20}>>) -> tensor<2xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.uniform_quantize-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.uniform_quantize","text":"uniform_quantize\n\nPerforms element-wise conversion of floating-point tensor or quantized tensor operand to a quantized tensor result according to the quantization parameters defined by the result type.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#uniform_quantize\n\nExample\n\n%result = stablehlo.uniform_quantize %operand : (tensor<2xf32>) -> tensor<2x!quant.uniform<i8:f32:0, {0.1:-30,0.5:-20}>>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.while_-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.while_","text":"while_\n\nProduces the output from executing body function 0 or more times while the cond function outputs true.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#while\n\nExample\n\n%results0, %results1 = stablehlo.while(%arg0 = %init_i, %arg1 = %init_sum) : tensor<i64>, tensor<i64>\ncond {\n  %cond = stablehlo.compare LT, %arg0, %ten : (tensor<i64>, tensor<i64>) -> tensor<i1>\n  stablehlo.return %cond : tensor<i1>\n} do {\n  %new_sum = stablehlo.add %arg1, %one : tensor<i64>\n  %new_i = stablehlo.add %arg0, %one : tensor<i64>\n  stablehlo.return %new_i, %new_sum : tensor<i64>, tensor<i64>\n}\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.stablehlo.xor-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.stablehlo.xor","text":"xor\n\nPerforms element-wise XOR of two tensors lhs and rhs and produces a result tensor.\n\nSee: https://github.com/openxla/stablehlo/blob/main/docs/spec.md#xor\n\nExample\n\n%result = stablehlo.xor %lhs, %rhs : tensor<2xi32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.enzyme.addTo-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.enzyme.addTo","text":"addTo\n\nTODO\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.addf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.addf","text":"addf\n\nThe addf operation takes two operands and returns one result, each of these is required to be the same type. This type may be a floating point scalar type, a vector whose element type is a floating point type, or a floating point tensor.\n\nExample\n\n// Scalar addition.\n%a = arith.addf %b, %c : f64\n\n// SIMD vector addition, e.g. for Intel SSE.\n%f = arith.addf %g, %h : vector<4xf32>\n\n// Tensor addition.\n%x = arith.addf %y, %z : tensor<4x?xbf16>\n\nTODO: In the distant future, this will accept optional attributes for fast math, contraction, rounding mode, and other controls.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.addi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.addi","text":"addi\n\nPerforms N-bit addition on the operands. The operands are interpreted as  unsigned bitvectors. The result is represented by a bitvector containing the  mathematical value of the addition modulo 2^n, where n is the bitwidth.  Because arith integers use a two's complement representation, this operation  is applicable on both signed and unsigned integer operands.\n\nThe addi operation takes two operands and returns one result, each of these is required to be the same type. This type may be an integer scalar type,  a vector whose element type is integer, or a tensor of integers.\n\nThis op supports nuw/nsw overflow flags which stands stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", respectively. If the nuw and/or nsw flags are present, and an unsigned/signed overflow occurs (respectively), the result is poison.\n\nExample\n\n// Scalar addition.\n%a = arith.addi %b, %c : i64\n\n// Scalar addition with overflow flags.\n%a = arith.addi %b, %c overflow<nsw, nuw> : i64\n\n// SIMD vector element-wise addition.\n%f = arith.addi %g, %h : vector<4xi32>\n\n// Tensor element-wise addition.\n%x = arith.addi %y, %z : tensor<4x?xi8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.addui_extended-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.addui_extended","text":"addui_extended\n\nPerforms (N+1)-bit addition on zero-extended operands. Returns two results: the N-bit sum (same type as both operands), and the overflow bit (boolean-like), where 1 indicates unsigned addition overflow, while 0 indicates no overflow.\n\nExample\n\n// Scalar addition.\n%sum, %overflow = arith.addui_extended %b, %c : i64, i1\n\n// Vector element-wise addition.\n%d:2 = arith.addui_extended %e, %f : vector<4xi32>, vector<4xi1>\n\n// Tensor element-wise addition.\n%x:2 = arith.addui_extended %y, %z : tensor<4x?xi8>, tensor<4x?xi1>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.andi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.andi","text":"andi\n\nThe andi operation takes two operands and returns one result, each of these is required to be the same type. This type may be an integer scalar type, a vector whose element type is integer, or a tensor of integers. It has no standard attributes.\n\nExample\n\n// Scalar integer bitwise and.\n%a = arith.andi %b, %c : i64\n\n// SIMD vector element-wise bitwise integer and.\n%f = arith.andi %g, %h : vector<4xi32>\n\n// Tensor element-wise bitwise integer and.\n%x = arith.andi %y, %z : tensor<4x?xi8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.bitcast-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.bitcast","text":"bitcast\n\nBitcast an integer or floating point value to an integer or floating point value of equal bit width. When operating on vectors, casts elementwise.\n\nNote that this implements a logical bitcast independent of target endianness. This allows constant folding without target information and is consitent with the bitcast constant folders in LLVM (see https://github.com/llvm/llvm-project/blob/18c19414eb/llvm/lib/IR/ConstantFold.cpp#L168) For targets where the source and target type have the same endianness (which is the standard), this cast will also change no bits at runtime, but it may still require an operation, for example if the machine has different floating point and integer register files. For targets that have a different endianness for the source and target types (e.g. float is big-endian and integer is little-endian) a proper lowering would add operations to swap the order of words in addition to the bitcast.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.ceildivsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.ceildivsi","text":"ceildivsi\n\nSigned integer division. Rounds towards positive infinity, i.e. 7 / -2 = -3.\n\nDivison by zero, or signed division overflow (minimum value divided by -1)  is undefined behavior. When applied to vector and tensor values, the  behavior is undefined if any of its elements are divided by zero or has a  signed division overflow.\n\nExample\n\n// Scalar signed integer division.\n%a = arith.ceildivsi %b, %c : i64\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.ceildivui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.ceildivui","text":"ceildivui\n\nUnsigned integer division. Rounds towards positive infinity. Treats the leading bit as the most significant, i.e. for i16 given two's complement representation, 6 / -2 = 6 / (2^16 - 2) = 1. \n\nDivision by zero is undefined behavior. When applied to vector and  tensor values, the behavior is undefined if any elements are divided by  zero.\n\nExample\n\n// Scalar unsigned integer division.\n%a = arith.ceildivui %b, %c : i64\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.cmpf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.cmpf","text":"cmpf\n\nThe cmpf operation compares its two operands according to the float comparison rules and the predicate specified by the respective attribute. The predicate defines the type of comparison: (un)orderedness, (in)equality and signed less/greater than (or equal to) as well as predicates that are always true or false.  The operands must have the same type, and this type must be a float type, or a vector or tensor thereof.  The result is an i1, or a vector/tensor thereof having the same shape as the inputs. Unlike cmpi, the operands are always treated as signed. The u prefix indicates unordered comparison, not unsigned comparison, so \"une\" means unordered or not equal. For the sake of readability by humans, custom assembly form for the operation uses a string-typed attribute for the predicate.  The value of this attribute corresponds to lower-cased name of the predicate constant, e.g., \"one\" means \"ordered not equal\".  The string representation of the attribute is merely a syntactic sugar and is converted to an integer attribute by the parser.\n\nExample\n\n%r1 = arith.cmpf oeq, %0, %1 : f32\n%r2 = arith.cmpf ult, %0, %1 : tensor<42x42xf64>\n%r3 = \"arith.cmpf\"(%0, %1) {predicate: 0} : (f8, f8) -> i1\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.cmpi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.cmpi","text":"cmpi\n\nThe cmpi operation is a generic comparison for integer-like types. Its two arguments can be integers, vectors or tensors thereof as long as their types match. The operation produces an i1 for the former case, a vector or a tensor of i1 with the same shape as inputs in the other cases.\n\nIts first argument is an attribute that defines which type of comparison is performed. The following comparisons are supported:\n\nequal (mnemonic: \"eq\"; integer value: 0)\nnot equal (mnemonic: \"ne\"; integer value: 1)\nsigned less than (mnemonic: \"slt\"; integer value: 2)\nsigned less than or equal (mnemonic: \"sle\"; integer value: 3)\nsigned greater than (mnemonic: \"sgt\"; integer value: 4)\nsigned greater than or equal (mnemonic: \"sge\"; integer value: 5)\nunsigned less than (mnemonic: \"ult\"; integer value: 6)\nunsigned less than or equal (mnemonic: \"ule\"; integer value: 7)\nunsigned greater than (mnemonic: \"ugt\"; integer value: 8)\nunsigned greater than or equal (mnemonic: \"uge\"; integer value: 9)\n\nThe result is 1 if the comparison is true and 0 otherwise. For vector or tensor operands, the comparison is performed elementwise and the element of the result indicates whether the comparison is true for the operand elements with the same indices as those of the result.\n\nNote: while the custom assembly form uses strings, the actual underlying attribute has integer type (or rather enum class in C++ code) as seen from the generic assembly form. String literals are used to improve readability of the IR by humans.\n\nThis operation only applies to integer-like operands, but not floats. The main reason being that comparison operations have diverging sets of attributes: integers require sign specification while floats require various floating point-related particularities, e.g., -ffast-math behavior, IEEE754 compliance, etc (rationale). The type of comparison is specified as attribute to avoid introducing ten similar operations, taking into account that they are often implemented using the same operation downstream (rationale). The separation between signed and unsigned order comparisons is necessary because of integers being signless. The comparison operation must know how to interpret values with the foremost bit being set: negatives in two's complement or large positives (rationale).\n\nExample\n\n// Custom form of scalar \"signed less than\" comparison.\n%x = arith.cmpi slt, %lhs, %rhs : i32\n\n// Generic form of the same operation.\n%x = \"arith.cmpi\"(%lhs, %rhs) {predicate = 2 : i64} : (i32, i32) -> i1\n\n// Custom form of vector equality comparison.\n%x = arith.cmpi eq, %lhs, %rhs : vector<4xi64>\n\n// Generic form of the same operation.\n%x = \"arith.cmpi\"(%lhs, %rhs) {predicate = 0 : i64}\n    : (vector<4xi64>, vector<4xi64>) -> vector<4xi1>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.constant-Tuple{}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.constant","text":"constant\n\nThe constant operation produces an SSA value equal to some integer or floating-point constant specified by an attribute. This is the way MLIR forms simple integer and floating point constants.\n\nExample\n\n// Integer constant\n%1 = arith.constant 42 : i32\n\n// Equivalent generic form\n%1 = \"arith.constant\"() {value = 42 : i32} : () -> i32\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.divsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.divsi","text":"divsi\n\nSigned integer division. Rounds towards zero. Treats the leading bit as sign, i.e. 6 / -2 = -3.\n\nDivison by zero, or signed division overflow (minimum value divided by -1)  is undefined behavior. When applied to vector and tensor values, the  behavior is undefined if any of its elements are divided by zero or has a  signed division overflow.\n\nExample\n\n// Scalar signed integer division.\n%a = arith.divsi %b, %c : i64\n\n// SIMD vector element-wise division.\n%f = arith.divsi %g, %h : vector<4xi32>\n\n// Tensor element-wise integer division.\n%x = arith.divsi %y, %z : tensor<4x?xi8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.divui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.divui","text":"divui\n\nUnsigned integer division. Rounds towards zero. Treats the leading bit as the most significant, i.e. for i16 given two's complement representation, 6 / -2 = 6 / (2^16 - 2) = 0.\n\nDivision by zero is undefined behavior. When applied to vector and  tensor values, the behavior is undefined if any elements are divided by  zero.\n\nExample\n\n// Scalar unsigned integer division.\n%a = arith.divui %b, %c : i64\n\n// SIMD vector element-wise division.\n%f = arith.divui %g, %h : vector<4xi32>\n\n// Tensor element-wise integer division.\n%x = arith.divui %y, %z : tensor<4x?xi8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.extf-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.extf","text":"extf\n\nCast a floating-point value to a larger floating-point-typed value. The destination type must to be strictly wider than the source type. When operating on vectors, casts elementwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.extsi-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.extsi","text":"extsi\n\nThe integer sign extension operation takes an integer input of width M and an integer destination type of width N. The destination bit-width must be larger than the input bit-width (N > M). The top-most (N - M) bits of the output are filled with copies of the most-significant bit of the input.\n\nExample\n\n%1 = arith.constant 5 : i3      // %1 is 0b101\n%2 = arith.extsi %1 : i3 to i6  // %2 is 0b111101\n%3 = arith.constant 2 : i3      // %3 is 0b010\n%4 = arith.extsi %3 : i3 to i6  // %4 is 0b000010\n\n%5 = arith.extsi %0 : vector<2 x i32> to vector<2 x i64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.extui-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.extui","text":"extui\n\nThe integer zero extension operation takes an integer input of width M and an integer destination type of width N. The destination bit-width must be larger than the input bit-width (N > M). The top-most (N - M) bits of the output are filled with zeros.\n\nExample\n\n  %1 = arith.constant 5 : i3      // %1 is 0b101\n  %2 = arith.extui %1 : i3 to i6  // %2 is 0b000101\n  %3 = arith.constant 2 : i3      // %3 is 0b010\n  %4 = arith.extui %3 : i3 to i6  // %4 is 0b000010\n\n  %5 = arith.extui %0 : vector<2 x i32> to vector<2 x i64>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.floordivsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.floordivsi","text":"floordivsi\n\nSigned integer division. Rounds towards negative infinity, i.e. 5 / -2 = -3.\n\nDivison by zero, or signed division overflow (minimum value divided by -1)  is undefined behavior. When applied to vector and tensor values, the  behavior is undefined if any of its elements are divided by zero or has a  signed division overflow.\n\nExample\n\n// Scalar signed integer division.\n%a = arith.floordivsi %b, %c : i64\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.fptosi-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.fptosi","text":"fptosi\n\nCast from a value interpreted as floating-point to the nearest (rounding towards zero) signed integer value. When operating on vectors, casts elementwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.fptoui-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.fptoui","text":"fptoui\n\nCast from a value interpreted as floating-point to the nearest (rounding towards zero) unsigned integer value. When operating on vectors, casts elementwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.index_cast-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.index_cast","text":"index_cast\n\nCasts between scalar or vector integers and corresponding 'index' scalar or vectors. Index is an integer of platform-specific bit width. If casting to a wider integer, the value is sign-extended. If casting to a narrower integer, the value is truncated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.index_castui-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.index_castui","text":"index_castui\n\nCasts between scalar or vector integers and corresponding 'index' scalar or vectors. Index is an integer of platform-specific bit width. If casting to a wider integer, the value is zero-extended. If casting to a narrower integer, the value is truncated.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.maximumf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.maximumf","text":"maximumf\n\nReturns the maximum of the two arguments, treating -0.0 as less than +0.0. If one of the arguments is NaN, then the result is also NaN.\n\nExample\n\n// Scalar floating-point maximum.\n%a = arith.maximumf %b, %c : f64\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.maxnumf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.maxnumf","text":"maxnumf\n\nReturns the maximum of the two arguments. If the arguments are -0.0 and +0.0, then the result is either of them. If one of the arguments is NaN, then the result is the other argument.\n\nExample\n\n// Scalar floating-point maximum.\n%a = arith.maxnumf %b, %c : f64\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.minimumf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.minimumf","text":"minimumf\n\nReturns the minimum of the two arguments, treating -0.0 as less than +0.0. If one of the arguments is NaN, then the result is also NaN.\n\nExample\n\n// Scalar floating-point minimum.\n%a = arith.minimumf %b, %c : f64\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.minnumf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.minnumf","text":"minnumf\n\nReturns the minimum of the two arguments. If the arguments are -0.0 and +0.0, then the result is either of them. If one of the arguments is NaN, then the result is the other argument.\n\nExample\n\n// Scalar floating-point minimum.\n%a = arith.minnumf %b, %c : f64\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.mulf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.mulf","text":"mulf\n\nThe mulf operation takes two operands and returns one result, each of these is required to be the same type. This type may be a floating point scalar type, a vector whose element type is a floating point type, or a floating point tensor.\n\nExample\n\n// Scalar multiplication.\n%a = arith.mulf %b, %c : f64\n\n// SIMD pointwise vector multiplication, e.g. for Intel SSE.\n%f = arith.mulf %g, %h : vector<4xf32>\n\n// Tensor pointwise multiplication.\n%x = arith.mulf %y, %z : tensor<4x?xbf16>\n\nTODO: In the distant future, this will accept optional attributes for fast math, contraction, rounding mode, and other controls.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.muli-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.muli","text":"muli\n\nPerforms N-bit multiplication on the operands. The operands are interpreted as unsigned bitvectors. The result is represented by a bitvector containing the mathematical value of the multiplication modulo 2^n, where n is the bitwidth. Because arith integers use a two's complement representation, this operation is applicable on both signed and unsigned integer operands.\n\nThe muli operation takes two operands and returns one result, each of these is required to be the same type. This type may be an integer scalar type, a vector whose element type is integer, or a tensor of integers.\n\nThis op supports nuw/nsw overflow flags which stands stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", respectively. If the nuw and/or nsw flags are present, and an unsigned/signed overflow occurs (respectively), the result is poison.\n\nExample\n\n// Scalar multiplication.\n%a = arith.muli %b, %c : i64\n\n// Scalar multiplication with overflow flags.\n%a = arith.muli %b, %c overflow<nsw, nuw> : i64\n\n// SIMD vector element-wise multiplication.\n%f = arith.muli %g, %h : vector<4xi32>\n\n// Tensor element-wise multiplication.\n%x = arith.muli %y, %z : tensor<4x?xi8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.mulsi_extended-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.mulsi_extended","text":"mulsi_extended\n\nPerforms (2*N)-bit multiplication on sign-extended operands. Returns two N-bit results: the low and the high halves of the product. The low half has the same value as the result of regular multiplication arith.muli with the same operands.\n\nExample\n\n// Scalar multiplication.\n%low, %high = arith.mulsi_extended %a, %b : i32\n\n// Vector element-wise multiplication.\n%c:2 = arith.mulsi_extended %d, %e : vector<4xi32>\n\n// Tensor element-wise multiplication.\n%x:2 = arith.mulsi_extended %y, %z : tensor<4x?xi8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.mului_extended-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.mului_extended","text":"mului_extended\n\nPerforms (2*N)-bit multiplication on zero-extended operands. Returns two N-bit results: the low and the high halves of the product. The low half has the same value as the result of regular multiplication arith.muli with the same operands.\n\nExample\n\n// Scalar multiplication.\n%low, %high = arith.mului_extended %a, %b : i32\n\n// Vector element-wise multiplication.\n%c:2 = arith.mului_extended %d, %e : vector<4xi32>\n\n// Tensor element-wise multiplication.\n%x:2 = arith.mului_extended %y, %z : tensor<4x?xi8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.negf-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.negf","text":"negf\n\nThe negf operation computes the negation of a given value. It takes one operand and returns one result of the same type. This type may be a float scalar type, a vector whose element type is float, or a tensor of floats. It has no standard attributes.\n\nExample\n\n// Scalar negation value.\n%a = arith.negf %b : f64\n\n// SIMD vector element-wise negation value.\n%f = arith.negf %g : vector<4xf32>\n\n// Tensor element-wise negation value.\n%x = arith.negf %y : tensor<4x?xf8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.ori-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.ori","text":"ori\n\nThe ori operation takes two operands and returns one result, each of these is required to be the same type. This type may be an integer scalar type, a vector whose element type is integer, or a tensor of integers. It has no standard attributes.\n\nExample\n\n// Scalar integer bitwise or.\n%a = arith.ori %b, %c : i64\n\n// SIMD vector element-wise bitwise integer or.\n%f = arith.ori %g, %h : vector<4xi32>\n\n// Tensor element-wise bitwise integer or.\n%x = arith.ori %y, %z : tensor<4x?xi8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.remf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.remf","text":"remf\n\nReturns the floating point division remainder. The remainder has the same sign as the dividend (lhs operand).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.remsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.remsi","text":"remsi\n\nSigned integer division remainder. Treats the leading bit as sign, i.e. 6 % -2 = 0.\n\nDivision by zero is undefined behavior. When applied to vector and  tensor values, the behavior is undefined if any elements are divided by  zero.\n\nExample\n\n// Scalar signed integer division remainder.\n%a = arith.remsi %b, %c : i64\n\n// SIMD vector element-wise division remainder.\n%f = arith.remsi %g, %h : vector<4xi32>\n\n// Tensor element-wise integer division remainder.\n%x = arith.remsi %y, %z : tensor<4x?xi8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.remui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.remui","text":"remui\n\nUnsigned integer division remainder. Treats the leading bit as the most significant, i.e. for i16, 6 % -2 = 6 % (2^16 - 2) = 6.\n\nDivision by zero is undefined behavior. When applied to vector and  tensor values, the behavior is undefined if any elements are divided by  zero.\n\nExample\n\n// Scalar unsigned integer division remainder.\n%a = arith.remui %b, %c : i64\n\n// SIMD vector element-wise division remainder.\n%f = arith.remui %g, %h : vector<4xi32>\n\n// Tensor element-wise integer division remainder.\n%x = arith.remui %y, %z : tensor<4x?xi8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.select","text":"select\n\nThe arith.select operation chooses one value based on a binary condition supplied as its first operand.\n\nIf the value of the first operand (the condition) is 1, then the second operand is returned, and the third operand is ignored, even if it was poison.\n\nIf the value of the first operand (the condition) is 0, then the third operand is returned, and the second operand is ignored, even if it was poison.\n\nIf the value of the first operand (the condition) is poison, then the operation returns poison.\n\nThe operation applies to vectors and tensors elementwise given the shape of all operands is identical. The choice is made for each element individually based on the value at the same position as the element in the condition operand. If an i1 is provided as the condition, the entire vector or tensor is chosen.\n\nExample\n\n// Custom form of scalar selection.\n%x = arith.select %cond, %true, %false : i32\n\n// Generic form of the same operation.\n%x = \"arith.select\"(%cond, %true, %false) : (i1, i32, i32) -> i32\n\n// Element-wise vector selection.\n%vx = arith.select %vcond, %vtrue, %vfalse : vector<42xi1>, vector<42xf32>\n\n// Full vector selection.\n%vx = arith.select %cond, %vtrue, %vfalse : vector<42xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.shli-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.shli","text":"shli\n\nThe shli operation shifts the integer value of the first operand to the left  by the integer value of the second operand. The second operand is interpreted as  unsigned. The low order bits are filled with zeros. If the value of the second  operand is greater or equal than the bitwidth of the first operand, then the operation returns poison.\n\nThis op supports nuw/nsw overflow flags which stands stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", respectively. If the nuw and/or nsw flags are present, and an unsigned/signed overflow occurs (respectively), the result is poison.\n\nExample\n\n%1 = arith.constant 5 : i8  // %1 is 0b00000101\n%2 = arith.constant 3 : i8\n%3 = arith.shli %1, %2 : i8 // %3 is 0b00101000\n%4 = arith.shli %1, %2 overflow<nsw, nuw> : i8  \n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.shrsi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.shrsi","text":"shrsi\n\nThe shrsi operation shifts an integer value of the first operand to the right  by the value of the second operand. The first operand is interpreted as signed,  and the second operand is interpreter as unsigned. The high order bits in the  output are filled with copies of the most-significant bit of the shifted value  (which means that the sign of the value is preserved). If the value of the second  operand is greater or equal than bitwidth of the first operand, then the operation returns poison.\n\nExample\n\n%1 = arith.constant 160 : i8               // %1 is 0b10100000\n%2 = arith.constant 3 : i8\n%3 = arith.shrsi %1, %2 : (i8, i8) -> i8   // %3 is 0b11110100\n%4 = arith.constant 96 : i8                   // %4 is 0b01100000\n%5 = arith.shrsi %4, %2 : (i8, i8) -> i8   // %5 is 0b00001100\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.shrui-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.shrui","text":"shrui\n\nThe shrui operation shifts an integer value of the first operand to the right  by the value of the second operand. The first operand is interpreted as unsigned, and the second operand is interpreted as unsigned. The high order bits are always  filled with zeros. If the value of the second operand is greater or equal than the bitwidth of the first operand, then the operation returns poison.\n\nExample\n\n%1 = arith.constant 160 : i8               // %1 is 0b10100000\n%2 = arith.constant 3 : i8\n%3 = arith.shrui %1, %2 : (i8, i8) -> i8   // %3 is 0b00010100\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.sitofp-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.sitofp","text":"sitofp\n\nCast from a value interpreted as a signed integer to the corresponding floating-point value. If the value cannot be exactly represented, it is rounded using the default rounding mode. When operating on vectors, casts elementwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.subf-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.subf","text":"subf\n\nThe subf operation takes two operands and returns one result, each of these is required to be the same type. This type may be a floating point scalar type, a vector whose element type is a floating point type, or a floating point tensor.\n\nExample\n\n// Scalar subtraction.\n%a = arith.subf %b, %c : f64\n\n// SIMD vector subtraction, e.g. for Intel SSE.\n%f = arith.subf %g, %h : vector<4xf32>\n\n// Tensor subtraction.\n%x = arith.subf %y, %z : tensor<4x?xbf16>\n\nTODO: In the distant future, this will accept optional attributes for fast math, contraction, rounding mode, and other controls.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.subi-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.subi","text":"subi\n\nPerforms N-bit subtraction on the operands. The operands are interpreted as unsigned bitvectors. The result is represented by a bitvector containing the mathematical value of the subtraction modulo 2^n, where n is the bitwidth. Because arith integers use a two's complement representation, this operation is applicable on both signed and unsigned integer operands.\n\nThe subi operation takes two operands and returns one result, each of these is required to be the same type. This type may be an integer scalar type, a vector whose element type is integer, or a tensor of integers.\n\nThis op supports nuw/nsw overflow flags which stands stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", respectively. If the nuw and/or nsw flags are present, and an unsigned/signed overflow occurs (respectively), the result is poison.\n\nExample\n\n// Scalar subtraction.\n%a = arith.subi %b, %c : i64\n\n// Scalar subtraction with overflow flags.\n%a = arith.subi %b, %c overflow<nsw, nuw> : i64\n\n// SIMD vector element-wise subtraction.\n%f = arith.subi %g, %h : vector<4xi32>\n\n// Tensor element-wise subtraction.\n%x = arith.subi %y, %z : tensor<4x?xi8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.truncf-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.truncf","text":"truncf\n\nTruncate a floating-point value to a smaller floating-point-typed value. The destination type must be strictly narrower than the source type. If the value cannot be exactly represented, it is rounded using the provided rounding mode or the default one if no rounding mode is provided. When operating on vectors, casts elementwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.trunci-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.trunci","text":"trunci\n\nThe integer truncation operation takes an integer input of width M and an integer destination type of width N. The destination bit-width must be smaller than the input bit-width (N < M). The top-most (N - M) bits of the input are discarded.\n\nExample\n\n  %1 = arith.constant 21 : i5     // %1 is 0b10101\n  %2 = arith.trunci %1 : i5 to i4 // %2 is 0b0101\n  %3 = arith.trunci %1 : i5 to i3 // %3 is 0b101\n\n  %5 = arith.trunci %0 : vector<2 x i32> to vector<2 x i16>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.uitofp-Tuple{Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.uitofp","text":"uitofp\n\nCast from a value interpreted as unsigned integer to the corresponding floating-point value. If the value cannot be exactly represented, it is rounded using the default rounding mode. When operating on vectors, casts elementwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.arith.xori-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}","page":"API reference","title":"Reactant.MLIR.Dialects.arith.xori","text":"xori\n\nThe xori operation takes two operands and returns one result, each of these is required to be the same type. This type may be an integer scalar type, a vector whose element type is integer, or a tensor of integers. It has no standard attributes.\n\nExample\n\n// Scalar integer bitwise xor.\n%a = arith.xori %b, %c : i64\n\n// SIMD vector element-wise bitwise integer xor.\n%f = arith.xori %g, %h : vector<4xi32>\n\n// Tensor element-wise bitwise integer xor.\n%x = arith.xori %y, %z : tensor<4x?xi8>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.func.call-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.func.call","text":"call\n\nThe func.call operation represents a direct call to a function that is within the same symbol scope as the call. The operands and result types of the call must match the specified function type. The callee is encoded as a symbol reference attribute named \"callee\".\n\nExample\n\n%2 = func.call @my_add(%0, %1) : (f32, f32) -> f32\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.func.call_indirect-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.func.call_indirect","text":"call_indirect\n\nThe func.call_indirect operation represents an indirect call to a value of function type. The operands and result types of the call must match the specified function type.\n\nFunction values can be created with the func.constant operation.\n\nExample\n\n%func = func.constant @my_func : (tensor<16xf32>, tensor<16xf32>) -> tensor<16xf32>\n%result = func.call_indirect %func(%0, %1) : (tensor<16xf32>, tensor<16xf32>) -> tensor<16xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.func.constant-Tuple{}","page":"API reference","title":"Reactant.MLIR.Dialects.func.constant","text":"constant\n\nThe func.constant operation produces an SSA value from a symbol reference to a func.func operation\n\nExample\n\n// Reference to function @myfn.\n%2 = func.constant @myfn : (tensor<16xf32>, f32) -> tensor<16xf32>\n\n// Equivalent generic forms\n%2 = \"func.constant\"() { value = @myfn } : () -> ((tensor<16xf32>, f32) -> tensor<16xf32>)\n\nMLIR does not allow direct references to functions in SSA operands because the compiler is multithreaded, and disallowing SSA values to directly reference a function simplifies this (rationale).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.func.func_-Tuple{}","page":"API reference","title":"Reactant.MLIR.Dialects.func.func_","text":"func_\n\nOperations within the function cannot implicitly capture values defined outside of the function, i.e. Functions are IsolatedFromAbove. All external references must use function arguments or attributes that establish a symbolic connection (e.g. symbols referenced by name via a string attribute like SymbolRefAttr). An external function declaration (used when referring to a function declared in some other module) has no body. While the MLIR textual form provides a nice inline syntax for function arguments, they are internally represented as “block arguments” to the first block in the region.\n\nOnly dialect attribute names may be specified in the attribute dictionaries for function arguments, results, or the function itself.\n\nExample\n\n// External function definitions.\nfunc.func private @abort()\nfunc.func private @scribble(i32, i64, memref<? x 128 x f32, #layout_map0>) -> f64\n\n// A function that returns its argument twice:\nfunc.func @count(%x: i64) -> (i64, i64)\n  attributes {fruit: \"banana\"} {\n  return %x, %x: i64, i64\n}\n\n// A function with an argument attribute\nfunc.func private @example_fn_arg(%x: i32 {swift.self = unit})\n\n// A function with a result attribute\nfunc.func private @example_fn_result() -> (f64 {dialectName.attrName = 0 : i64})\n\n// A function with an attribute\nfunc.func private @example_fn_attr() attributes {dialectName.attrName = false}\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.func.return_-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.func.return_","text":"return_\n\nThe func.return operation represents a return operation within a function. The operation takes variable number of operands and produces no results. The operand number and types must match the signature of the function that contains the operation.\n\nExample\n\nfunc.func @foo() : (i32, f8) {\n  ...\n  return %0, %1 : i32, f8\n}\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.apply-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.apply","text":"apply\n\nThe affine.apply operation applies an affine mapping to a list of SSA values, yielding a single SSA value. The number of dimension and symbol arguments to affine.apply must be equal to the respective number of dimensional and symbolic inputs to the affine mapping; the affine mapping has to be one-dimensional, and so the affine.apply operation always returns one value. The input operands and result must all have ‘index’ type.\n\nExample\n\n#map10 = affine_map<(d0, d1) -> (d0 floordiv 8 + d1 floordiv 128)>\n...\n%1 = affine.apply #map10 (%s, %t)\n\n// Inline example.\n%2 = affine.apply affine_map<(i)[s0] -> (i+s0)> (%42)[%n]\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.delinearize_index-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.delinearize_index","text":"delinearize_index\n\nThe affine.delinearize_index operation takes a single index value and calculates the multi-index according to the given basis.\n\nExample\n\n%indices:3 = affine.delinearize_index %linear_index into (%c16, %c224, %c224) : index, index, index\n\nIn the above example, %indices:3 conceptually holds the following:\n\n#map0 = affine_map<()[s0] -> (s0 floordiv 50176)>\n#map1 = affine_map<()[s0] -> ((s0 mod 50176) floordiv 224)>\n#map2 = affine_map<()[s0] -> (s0 mod 224)>\n%indices_0 = affine.apply #map0()[%linear_index]\n%indices_1 = affine.apply #map1()[%linear_index]\n%indices_2 = affine.apply #map2()[%linear_index]\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.for_-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.for_","text":"for_\n\nSyntax\n\noperation   ::= `affine.for` ssa-id `=` lower-bound `to` upper-bound\n                (`step` integer-literal)? `{` op* `}`\n\nlower-bound ::= `max`? affine-map-attribute dim-and-symbol-use-list | shorthand-bound\nupper-bound ::= `min`? affine-map-attribute dim-and-symbol-use-list | shorthand-bound\nshorthand-bound ::= ssa-id | `-`? integer-literal\n\nThe affine.for operation represents an affine loop nest. It has one region containing its body. This region must contain one block that terminates with affine.yield. Note: when affine.for is printed in custom format, the terminator is omitted. The block has one argument of index type that represents the induction variable of the loop.\n\nThe affine.for operation executes its body a number of times iterating from a lower bound to an upper bound by a stride. The stride, represented by step, is a positive constant integer which defaults to \"1\" if not present. The lower and upper bounds specify a half-open range: the range includes the lower bound but does not include the upper bound.\n\nThe lower and upper bounds of a affine.for operation are represented as an application of an affine mapping to a list of SSA values passed to the map. The same restrictions hold for these SSA values as for all bindings of SSA values to dimensions and symbols.\n\nThe affine mappings for the bounds may return multiple results, in which case the max/min keywords are required (for the lower/upper bound respectively), and the bound is the maximum/minimum of the returned values. There is no semantic ambiguity, but MLIR syntax requires the use of these keywords to make things more obvious to human readers.\n\nMany upper and lower bounds are simple, so MLIR accepts two custom form syntaxes: the form that accepts a single 'ssa-id' (e.g. %N) is shorthand for applying that SSA value to a function that maps a single symbol to itself, e.g., ()[s]->(s)()[%N]. The integer literal form (e.g. -42) is shorthand for a nullary mapping function that returns the constant value (e.g. ()->(-42)()).\n\nExample showing reverse iteration of the inner loop:\n\n#map57 = affine_map<(d0)[s0] -> (s0 - d0 - 1)>\n\nfunc.func @simple_example(%A: memref<?x?xf32>, %B: memref<?x?xf32>) {\n  %N = dim %A, 0 : memref<?x?xf32>\n  affine.for %i = 0 to %N step 1 {\n    affine.for %j = 0 to %N {   // implicitly steps by 1\n      %0 = affine.apply #map57(%j)[%N]\n      %tmp = call @F1(%A, %i, %0) : (memref<?x?xf32>, index, index)->(f32)\n      call @F2(%tmp, %B, %i, %0) : (f32, memref<?x?xf32>, index, index)->()\n    }\n  }\n  return\n}\n\naffine.for can also operate on loop-carried variables (iter_args) and return the final values after loop termination. The initial values of the variables are passed as additional SSA operands to the affine.for following the operands for the loop's lower and upper bounds. The operation's region has equivalent arguments for each variable representing the value of the variable at the current iteration.\n\nThe region must terminate with an affine.yield that passes all the current iteration variables to the next iteration, or to the affine.for's results if at the last iteration. For affine.for's that execute zero iterations, the initial values of the loop-carried variables (corresponding to the SSA operands) will be the op's results.\n\nFor example, to sum-reduce a memref:\n\nfunc.func @reduce(%buffer: memref<1024xf32>) -> (f32) {\n  // Initial sum set to 0.\n  %sum_0 = arith.constant 0.0 : f32\n  // iter_args binds initial values to the loop's region arguments.\n  %sum = affine.for %i = 0 to 10 step 2\n      iter_args(%sum_iter = %sum_0) -> (f32) {\n    %t = affine.load %buffer[%i] : memref<1024xf32>\n    %sum_next = arith.addf %sum_iter, %t : f32\n    // Yield current iteration sum to next iteration %sum_iter or to %sum\n    // if final iteration.\n    affine.yield %sum_next : f32\n  }\n  return %sum : f32\n}\n\n%res:2 = affine.for %i = 0 to 128 iter_args(%arg0 = %init0, %arg1 = %init1)\n           -> (index, index) {\n  %y0 = arith.addi %arg0, %c1 : index\n  %y1 = arith.addi %arg1, %c2 : index\n  affine.yield %y0, %y1 : index, index\n}\n\nIf the affine.for defines any values, a yield terminator must be explicitly present. The number and types of the \"affine.for\" results must match the initial values in the iter_args binding and the yield operands.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.if_-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.if_","text":"if_\n\nSyntax\n\noperation  ::= `affine.if` if-op-cond `{` op* `}` (`else` `{` op* `}`)?\nif-op-cond ::= integer-set-attr dim-and-symbol-use-list\n\nThe affine.if operation restricts execution to a subset of the loop iteration space defined by an integer set (a conjunction of affine constraints). A single affine.if may end with an optional else clause.\n\nThe condition of the affine.if is represented by an integer set (a conjunction of affine constraints), and the SSA values bound to the dimensions and symbols in the integer set. The same restrictions hold for these SSA values as for all bindings of SSA values to dimensions and symbols.\n\nThe affine.if operation contains two regions for the \"then\" and \"else\" clauses.  affine.if may return results that are defined in its regions. The values defined are determined by which execution path is taken.  Each region of the affine.if must contain a single block with no arguments, and be terminated by affine.yield.  If affine.if defines no values, the affine.yield can be left out, and will be inserted implicitly. Otherwise, it must be explicit.  If no values are defined, the else block may be empty (i.e. contain no blocks).\n\nExample\n\n#set = affine_set<(d0, d1)[s0]: (d0 - 10 >= 0, s0 - d0 - 9 >= 0,\n                                 d1 - 10 >= 0, s0 - d1 - 9 >= 0)>\nfunc.func @reduced_domain_example(%A, %X, %N) : (memref<10xi32>, i32, i32) {\n  affine.for %i = 0 to %N {\n     affine.for %j = 0 to %N {\n       %0 = affine.apply #map42(%j)\n       %tmp = call @S1(%X, %i, %0)\n       affine.if #set(%i, %j)[%N] {\n          %1 = affine.apply #map43(%i, %j)\n          call @S2(%tmp, %A, %i, %1)\n       }\n    }\n  }\n  return\n}\n\nExample with an explicit yield (initialization with edge padding):\n\n#interior = affine_set<(i, j) : (i - 1 >= 0, j - 1 >= 0,  10 - i >= 0, 10 - j >= 0)> (%i, %j)\nfunc.func @pad_edges(%I : memref<10x10xf32>) -> (memref<12x12xf32) {\n  %O = alloc memref<12x12xf32>\n  affine.parallel (%i, %j) = (0, 0) to (12, 12) {\n    %1 = affine.if #interior (%i, %j) {\n      %2 = load %I[%i - 1, %j - 1] : memref<10x10xf32>\n      affine.yield %2\n    } else {\n      %2 = arith.constant 0.0 : f32\n      affine.yield %2 : f32\n    }\n    affine.store %1, %O[%i, %j] : memref<12x12xf32>\n  }\n  return %O\n}\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.load","text":"load\n\nSyntax\n\noperation ::= ssa-id `=` `affine.load` ssa-use `[` multi-dim-affine-map-of-ssa-ids `]` `:` memref-type\n\nThe affine.load op reads an element from a memref, where the index for each memref dimension is an affine expression of loop induction variables and symbols. The output of affine.load is a new value with the same type as the elements of the memref. An affine expression of loop IVs and symbols must be specified for each dimension of the memref. The keyword symbol can be used to indicate SSA identifiers which are symbolic.\n\nExample 1:\n\n%1 = affine.load %0[%i0 + 3, %i1 + 7] : memref<100x100xf32>\n\nExample 2: Uses symbol keyword for symbols %n and %m.\n\n%1 = affine.load %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref<100x100xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.max-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.max","text":"max\n\nThe affine.max operation computes the maximum value result from a multi-result affine map.\n\nExample\n\n%0 = affine.max (d0) -> (1000, d0 + 512) (%i0) : index\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.min-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.min","text":"min\n\nSyntax\n\noperation ::= ssa-id `=` `affine.min` affine-map-attribute dim-and-symbol-use-list\n\nThe affine.min operation applies an affine mapping to a list of SSA values, and returns the minimum value of all result expressions. The number of dimension and symbol arguments to affine.min must be equal to the respective number of dimensional and symbolic inputs to the affine mapping; the affine.min operation always returns one value. The input operands and result must all have 'index' type.\n\nExample\n\n%0 = affine.min affine_map<(d0)[s0] -> (1000, d0 + 512, s0)> (%arg0)[%arg1]\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.parallel-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.parallel","text":"parallel\n\nThe affine.parallel operation represents a hyper-rectangular affine parallel band, defining zero or more SSA values for its induction variables. It has one region capturing the parallel band body. The induction variables are represented as arguments of this region. These SSA values always have type index, which is the size of the machine word. The strides, represented by steps, are positive constant integers which defaults to \"1\" if not present. The lower and upper bounds specify a half-open range: the range includes the lower bound but does not include the upper bound. The body region must contain exactly one block that terminates with affine.yield.\n\nThe lower and upper bounds of a parallel operation are represented as an application of an affine mapping to a list of SSA values passed to the map. The same restrictions hold for these SSA values as for all bindings of SSA values to dimensions and symbols. The list of expressions in each map is interpreted according to the respective bounds group attribute. If a single expression belongs to the group, then the result of this expression is taken as a lower(upper) bound of the corresponding loop induction variable. If multiple expressions belong to the group, then the lower(upper) bound is the max(min) of these values obtained from these expressions. The loop band has as many loops as elements in the group bounds attributes.\n\nEach value yielded by affine.yield will be accumulated/reduced via one of the reduction methods defined in the AtomicRMWKind enum.  The order of reduction is unspecified, and lowering may produce any valid ordering. Loops with a 0 trip count will produce as a result the identity value associated with each reduction (i.e. 0.0 for addf, 1.0 for mulf).  Assign reductions for loops with a trip count != 1 produces undefined results.\n\nNote: Calling AffineParallelOp::build will create the required region and block, and insert the required terminator if it is trivial (i.e. no values are yielded).  Parsing will also create the required region, block, and terminator, even when they are missing from the textual representation.\n\nExample (3x3 valid convolution):\n\nfunc.func @conv_2d(%D : memref<100x100xf32>, %K : memref<3x3xf32>) -> (memref<98x98xf32>) {\n  %O = memref.alloc() : memref<98x98xf32>\n  affine.parallel (%x, %y) = (0, 0) to (98, 98) {\n    %0 = affine.parallel (%kx, %ky) = (0, 0) to (2, 2) reduce (\"addf\") -> f32 {\n      %1 = affine.load %D[%x + %kx, %y + %ky] : memref<100x100xf32>\n      %2 = affine.load %K[%kx, %ky] : memref<3x3xf32>\n      %3 = arith.mulf %1, %2 : f32\n      affine.yield %3 : f32\n    }\n    affine.store %0, %O[%x, %y] : memref<98x98xf32>\n  }\n  return %O : memref<98x98xf32>\n}\n\nExample (tiling by potentially imperfectly dividing sizes):\n\naffine.parallel (%ii, %jj) = (0, 0) to (%N, %M) step (32, 32) {\n  affine.parallel (%i, %j) = (%ii, %jj)\n                          to (min(%ii + 32, %N), min(%jj + 32, %M)) {\n    call @f(%i, %j) : (index, index) -> ()\n  }\n}\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.prefetch-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.prefetch","text":"prefetch\n\nThe affine.prefetch op prefetches data from a memref location described with an affine subscript similar to affine.load, and has three attributes: a read/write specifier, a locality hint, and a cache type specifier as shown below:\n\naffine.prefetch %0[%i, %j + 5], read, locality<3>, data : memref<400x400xi32>\n\nThe read/write specifier is either 'read' or 'write', the locality hint specifier ranges from locality<0> (no locality) to locality<3> (extremely local keep in cache). The cache type specifier is either 'data' or 'instr' and specifies whether the prefetch is performed on data cache or on instruction cache.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.store-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.store","text":"store\n\nSyntax\n\noperation ::= `affine.store` ssa-use, ssa-use `[` multi-dim-affine-map-of-ssa-ids `]` `:` memref-type\n\nThe affine.store op writes an element to a memref, where the index for each memref dimension is an affine expression of loop induction variables and symbols. The affine.store op stores a new value which is the same type as the elements of the memref. An affine expression of loop IVs and symbols must be specified for each dimension of the memref. The keyword symbol can be used to indicate SSA identifiers which are symbolic.\n\nExample 1:\n\naffine.store %v0, %0[%i0 + 3, %i1 + 7] : memref<100x100xf32>\n\nExample 2: Uses symbol keyword for symbols %n and %m.\n\naffine.store %v0, %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref<100x100xf32>\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.vector_load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.vector_load","text":"vector_load\n\nThe affine.vector_load is the vector counterpart of affine.load. It reads a slice from a MemRef, supplied as its first operand, into a vector of the same base elemental type. The index for each memref dimension is an affine expression of loop induction variables and symbols. These indices determine the start position of the read within the memref. The shape of the return vector type determines the shape of the slice read from the memref. This slice is contiguous along the respective dimensions of the shape. Strided vector loads will be supported in the future. An affine expression of loop IVs and symbols must be specified for each dimension of the memref. The keyword symbol can be used to indicate SSA identifiers which are symbolic.\n\nExample 1: 8-wide f32 vector load.\n\n%1 = affine.vector_load %0[%i0 + 3, %i1 + 7] : memref<100x100xf32>, vector<8xf32>\n\nExample 2: 4-wide f32 vector load. Uses symbol keyword for symbols %n and %m.\n\n%1 = affine.vector_load %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref<100x100xf32>, vector<4xf32>\n\nExample 3: 2-dim f32 vector load.\n\n%1 = affine.vector_load %0[%i0, %i1] : memref<100x100xf32>, vector<2x8xf32>\n\nTODOs:\n\nAdd support for strided vector loads.\nConsider adding a permutation map to permute the slice that is read from memory\n\n(see vector.transfer_read).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.vector_store-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.vector_store","text":"vector_store\n\nThe affine.vector_store is the vector counterpart of affine.store. It writes a vector, supplied as its first operand, into a slice within a MemRef of the same base elemental type, supplied as its second operand. The index for each memref dimension is an affine expression of loop induction variables and symbols. These indices determine the start position of the write within the memref. The shape of th input vector determines the shape of the slice written to the memref. This slice is contiguous along the respective dimensions of the shape. Strided vector stores will be supported in the future. An affine expression of loop IVs and symbols must be specified for each dimension of the memref. The keyword symbol can be used to indicate SSA identifiers which are symbolic.\n\nExample 1: 8-wide f32 vector store.\n\naffine.vector_store %v0, %0[%i0 + 3, %i1 + 7] : memref<100x100xf32>, vector<8xf32>\n\nExample 2: 4-wide f32 vector store. Uses symbol keyword for symbols %n and %m.\n\naffine.vector_store %v0, %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref<100x100xf32>, vector<4xf32>\n\nExample 3: 2-dim f32 vector store.\n\naffine.vector_store %v0, %0[%i0, %i1] : memref<100x100xf32>, vector<2x8xf32>\n\nTODOs:\n\nAdd support for strided vector stores.\nConsider adding a permutation map to permute the slice that is written to memory\n\n(see vector.transfer_write).\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.affine.yield-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.affine.yield","text":"yield\n\nThe affine.yield yields zero or more SSA values from an affine op region and terminates the region. The semantics of how the values yielded are used is defined by the parent operation. If affine.yield has any operands, the operands must match the parent operation's results. If the parent operation defines no values, then the affine.yield may be left out in the custom syntax and the builders will insert one implicitly. Otherwise, it has to be present in the syntax to indicate which values are yielded.\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.builtin.module_-Tuple{}","page":"API reference","title":"Reactant.MLIR.Dialects.builtin.module_","text":"module_\n\nA module represents a top-level container operation. It contains a single graph region containing a single block which can contain any operations and does not have a terminator. Operations within this region cannot implicitly capture values defined outside the module, i.e. Modules are IsolatedFromAbove. Modules have an optional symbol name which can be used to refer to them in operations.\n\nExample\n\nmodule {\n  func.func @foo()\n}\n\n\n\n\n\n","category":"method"},{"location":"api/#Reactant.MLIR.Dialects.builtin.unrealized_conversion_cast-Tuple{Vector{Reactant.MLIR.IR.Value}}","page":"API reference","title":"Reactant.MLIR.Dialects.builtin.unrealized_conversion_cast","text":"unrealized_conversion_cast\n\nAn unrealized_conversion_cast operation represents an unrealized conversion from one set of types to another, that is used to enable the inter-mixing of different type systems. This operation should not be attributed any special representational or execution semantics, and is generally only intended to be used to satisfy the temporary intermixing of type systems during the conversion of one type system to another.\n\nThis operation may produce results of arity 1-N, and accept as input operands of arity 0-N.\n\nExample\n\n// An unrealized 0-1 conversion. These types of conversions are useful in\n// cases where a type is removed from the type system, but not all uses have\n// been converted. For example, imagine we have a tuple type that is\n// expanded to its element types. If only some uses of an empty tuple type\n// instance are converted we still need an instance of the tuple type, but\n// have no inputs to the unrealized conversion.\n%result = unrealized_conversion_cast to !bar.tuple_type<>\n\n// An unrealized 1-1 conversion.\n%result1 = unrealized_conversion_cast %operand : !foo.type to !bar.lowered_type\n\n// An unrealized 1-N conversion.\n%results2:2 = unrealized_conversion_cast %tuple_operand : !foo.tuple_type<!foo.type, !foo.type> to !foo.type, !foo.type\n\n// An unrealized N-1 conversion.\n%result3 = unrealized_conversion_cast %operand, %operand : !foo.type, !foo.type to !bar.tuple_type<!foo.type, !foo.type>\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Reactant\nDocTestSetup = quote\n    using Reactant\nend","category":"page"},{"location":"#Reactant","page":"Home","title":"Reactant","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Reactant.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is truly something which we should write docs for.","category":"page"}]
}
