import{_ as l,C as p,c as d,o as r,j as i,a as t,al as n,G as a,w as o}from"./chunks/framework.DhFgI7bz.js";const z=JSON.parse('{"title":"Core Reactant API","description":"","frontmatter":{},"headers":[],"relativePath":"api/api.md","filePath":"api/api.md","lastUpdated":null}'),c={name:"api/api.md"},h={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"},u={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},E={class:"jldocstring custom-block"},_={class:"jldocstring custom-block"},C={class:"jldocstring custom-block"},F={class:"jldocstring custom-block"},A={class:"jldocstring custom-block"};function v(D,e,R,w,j,I){const s=p("Badge");return r(),d("div",null,[e[52]||(e[52]=i("h1",{id:"Core-Reactant-API",tabindex:"-1"},[t("Core Reactant API "),i("a",{class:"header-anchor",href:"#Core-Reactant-API","aria-label":'Permalink to "Core Reactant API {#Core-Reactant-API}"'},"â€‹")],-1)),e[53]||(e[53]=i("h2",{id:"Compile-API",tabindex:"-1"},[t("Compile API "),i("a",{class:"header-anchor",href:"#Compile-API","aria-label":'Permalink to "Compile API {#Compile-API}"'},"â€‹")],-1)),i("details",h,[i("summary",null,[e[0]||(e[0]=i("a",{id:"Reactant.Compiler.@compile",href:"#Reactant.Compiler.@compile"},[i("span",{class:"jlbinding"},"Reactant.Compiler.@compile")],-1)),e[1]||(e[1]=t()),a(s,{type:"info",class:"jlObjectType jlMacro",text:"Macro"})]),e[3]||(e[3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@compile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [optimize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] [no_nan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] [sync </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compile the function <code>f</code> with arguments <code>args</code> and return the compiled function.</p><p><strong>Options</strong></p><ul><li><p><code>optimize</code>: Optimizations passes to run on the traced MLIR code. Valid types of values are:</p><ul><li><p>Bool (true/false): whether to run the optimization passes or not. Defaults to <code>true</code>.</p></li><li><p>String: a custom string with the passes to run. The string should be a comma-separated list of MLIR passes. For example, <code>&quot;canonicalize,enzyme-hlo-opt&quot;</code>.</p></li><li><p>Symbol: a predefined set of passes to run. Valid options are:</p><ol><li><p><code>:all</code>: Default set of optimization passes. The exact set of passes are not fixed and may change in future versions of Reactant. It is recommended to use this option for most users.</p></li><li><p><code>:none</code>: No optimization passes will be run.</p></li><li><p>Other predefined options are: <code>:before_kernel</code>, <code>:before_jit</code>, <code>:before_raise</code>, <code>:before_enzyme</code>, <code>:after_enzyme</code>, <code>:just_batch</code>, <code>:canonicalize</code>, <code>:only_enzyme</code>.</p></li></ol></li></ul></li><li><p><code>no_nan</code>: If <code>true</code>, the optimization passes will assume that the function does not produce NaN values. This can lead to more aggressive optimizations <strong>(and potentially incorrect results if the function does produce NaN values)</strong>.</p></li><li><p><code>client</code>: XLA Client used for compilation. If not specified, the default client is used.</p></li><li><p><code>raise</code>: If <code>true</code>, the function will be compiled with the raising pass, which raises CUDA and KernelAbstractions kernels to HLO. Defaults to <code>false</code>, but is automatically activated if the inputs are sharded.</p></li><li><p><code>raise_first</code>: If <code>true</code>, the raising pass will be run before the optimization passes. Defaults to <code>false</code>.</p></li><li><p><code>shardy_passes</code>: Defaults to <code>:to_mhlo_shardings</code>. Other options are:</p><ul><li><p><code>:none</code>: No sharding passes will be run. Shardy + MHLO shardings are handled by XLA.</p></li><li><p><code>:post_sdy_propagation</code>: Runs the Shardy propagation passes. MHLO shardings are handled by XLA.</p></li><li><p><a href="/Reactant.jl/previews/PR1352/api/sharding#Reactant.Sharding.ShardyPropagationOptions"><code>Sharding.ShardyPropagationOptions</code></a>: Custom sharding propagation options. MHLO shardings are handled by XLA.</p></li><li><p><code>:to_mhlo_shardings</code>: Runs the Shardy propagation passes and then exports the shardings to MHLO. All passes are run via MLIR pass pipeline and don&#39;t involve XLA.</p></li></ul></li><li><p><code>assert_nonallocating</code>: If <code>true</code>, we make sure that no new buffers are returned by the function. Any buffer returned must be donated from the inputs. Defaults to <code>false</code>.</p></li><li><p><code>donated_args</code>: If <code>:auto</code>, the function will automatically donate the arguments that are not preserved in the function body. If <code>:none</code>, no arguments will be donated. Defaults to <code>:auto</code>.</p></li><li><p><code>transpose_propagate</code>: If <code>:up</code>, <code>stablehlo.transpose</code> operations will be propagated up the computation graph. If <code>:down</code>, they will be propagated down. Defaults to <code>:up</code>.</p></li><li><p><code>reshape_propagate</code>: If <code>:up</code>, <code>stablehlo.reshape</code> operations will be propagated up the computation graph. If <code>:down</code>, they will be propagated down. Defaults to <code>:up</code>.</p></li><li><p><code>optimize_then_pad</code>: If <code>true</code>, the function will be optimized before padding (for non-divisible sharding axes) is applied. Defaults to <code>true</code>. <em>(Only for Sharded Inputs)</em></p></li><li><p><code>optimize_communications</code>: If <code>true</code>, additional passes for optimizing communication in sharded computations will be run. Defaults to <code>true</code>. <em>(Only for Sharded Inputs)</em></p></li><li><p><code>cudnn_hlo_optimize</code>: Run cuDNN specific HLO optimizations. This is only relevant for GPU backends and is <code>false</code> by default. <strong>Experimental and not heavily tested.</strong> <em>(Only for CUDA backend)</em></p></li><li><p><code>sync</code>: Reactant computations are asynchronous by default. If <code>true</code>, the computation will be executed synchronously, blocking till the computation is complete. This is recommended when benchmarking.</p></li></ul><p>See also <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@jit"><code>@jit</code></a>, <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_hlo"><code>@code_hlo</code></a>, <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_mhlo"><code>@code_mhlo</code></a>, <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_xla"><code>@code_xla</code></a>.</p>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[2]||(e[2]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/src/Compiler.jl#L2285-L2296",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[2]})]),i("details",k,[i("summary",null,[e[4]||(e[4]=i("a",{id:"Reactant.Compiler.@jit",href:"#Reactant.Compiler.@jit"},[i("span",{class:"jlbinding"},"Reactant.Compiler.@jit")],-1)),e[5]||(e[5]=t()),a(s,{type:"info",class:"jlObjectType jlMacro",text:"Macro"})]),e[7]||(e[7]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@jit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [optimize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] [no_nan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] [sync </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Run @compile f(args..) then immediately execute it. Most users should use <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@compile"><code>@compile</code></a> instead to cache the compiled function and execute it later.</p><p><strong>Options</strong></p><ul><li><p><code>optimize</code>: Optimizations passes to run on the traced MLIR code. Valid types of values are:</p><ul><li><p>Bool (true/false): whether to run the optimization passes or not. Defaults to <code>true</code>.</p></li><li><p>String: a custom string with the passes to run. The string should be a comma-separated list of MLIR passes. For example, <code>&quot;canonicalize,enzyme-hlo-opt&quot;</code>.</p></li><li><p>Symbol: a predefined set of passes to run. Valid options are:</p><ol><li><p><code>:all</code>: Default set of optimization passes. The exact set of passes are not fixed and may change in future versions of Reactant. It is recommended to use this option for most users.</p></li><li><p><code>:none</code>: No optimization passes will be run.</p></li><li><p>Other predefined options are: <code>:before_kernel</code>, <code>:before_jit</code>, <code>:before_raise</code>, <code>:before_enzyme</code>, <code>:after_enzyme</code>, <code>:just_batch</code>, <code>:canonicalize</code>, <code>:only_enzyme</code>.</p></li></ol></li></ul></li><li><p><code>no_nan</code>: If <code>true</code>, the optimization passes will assume that the function does not produce NaN values. This can lead to more aggressive optimizations <strong>(and potentially incorrect results if the function does produce NaN values)</strong>.</p></li><li><p><code>client</code>: XLA Client used for compilation. If not specified, the default client is used.</p></li><li><p><code>raise</code>: If <code>true</code>, the function will be compiled with the raising pass, which raises CUDA and KernelAbstractions kernels to HLO. Defaults to <code>false</code>, but is automatically activated if the inputs are sharded.</p></li><li><p><code>raise_first</code>: If <code>true</code>, the raising pass will be run before the optimization passes. Defaults to <code>false</code>.</p></li><li><p><code>shardy_passes</code>: Defaults to <code>:to_mhlo_shardings</code>. Other options are:</p><ul><li><p><code>:none</code>: No sharding passes will be run. Shardy + MHLO shardings are handled by XLA.</p></li><li><p><code>:post_sdy_propagation</code>: Runs the Shardy propagation passes. MHLO shardings are handled by XLA.</p></li><li><p><a href="/Reactant.jl/previews/PR1352/api/sharding#Reactant.Sharding.ShardyPropagationOptions"><code>Sharding.ShardyPropagationOptions</code></a>: Custom sharding propagation options. MHLO shardings are handled by XLA.</p></li><li><p><code>:to_mhlo_shardings</code>: Runs the Shardy propagation passes and then exports the shardings to MHLO. All passes are run via MLIR pass pipeline and don&#39;t involve XLA.</p></li></ul></li><li><p><code>assert_nonallocating</code>: If <code>true</code>, we make sure that no new buffers are returned by the function. Any buffer returned must be donated from the inputs. Defaults to <code>false</code>.</p></li><li><p><code>donated_args</code>: If <code>:auto</code>, the function will automatically donate the arguments that are not preserved in the function body. If <code>:none</code>, no arguments will be donated. Defaults to <code>:auto</code>.</p></li><li><p><code>transpose_propagate</code>: If <code>:up</code>, <code>stablehlo.transpose</code> operations will be propagated up the computation graph. If <code>:down</code>, they will be propagated down. Defaults to <code>:up</code>.</p></li><li><p><code>reshape_propagate</code>: If <code>:up</code>, <code>stablehlo.reshape</code> operations will be propagated up the computation graph. If <code>:down</code>, they will be propagated down. Defaults to <code>:up</code>.</p></li><li><p><code>optimize_then_pad</code>: If <code>true</code>, the function will be optimized before padding (for non-divisible sharding axes) is applied. Defaults to <code>true</code>. <em>(Only for Sharded Inputs)</em></p></li><li><p><code>optimize_communications</code>: If <code>true</code>, additional passes for optimizing communication in sharded computations will be run. Defaults to <code>true</code>. <em>(Only for Sharded Inputs)</em></p></li><li><p><code>cudnn_hlo_optimize</code>: Run cuDNN specific HLO optimizations. This is only relevant for GPU backends and is <code>false</code> by default. <strong>Experimental and not heavily tested.</strong> <em>(Only for CUDA backend)</em></p></li><li><p><code>sync</code>: Reactant computations are asynchronous by default. If <code>true</code>, the computation will be executed synchronously, blocking till the computation is complete. This is recommended when benchmarking.</p></li></ul><p>See also <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@compile"><code>@compile</code></a>, <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_hlo"><code>@code_hlo</code></a>, <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_mhlo"><code>@code_mhlo</code></a>, <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_xla"><code>@code_xla</code></a>.</p>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[6]||(e[6]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/src/Compiler.jl#L2302-L2314",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[6]})]),e[54]||(e[54]=i("h2",{id:"ReactantCore-API",tabindex:"-1"},[t("ReactantCore API "),i("a",{class:"header-anchor",href:"#ReactantCore-API","aria-label":'Permalink to "ReactantCore API {#ReactantCore-API}"'},"â€‹")],-1)),i("details",u,[i("summary",null,[e[8]||(e[8]=i("a",{id:"ReactantCore.within_compile",href:"#ReactantCore.within_compile"},[i("span",{class:"jlbinding"},"ReactantCore.within_compile")],-1)),e[9]||(e[9]=t()),a(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[11]||(e[11]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">within_compile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Returns true if this function is executed in a Reactant compilation context, otherwise false.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[10]||(e[10]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/lib/ReactantCore/src/ReactantCore.jl#L37-L41",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[10]})]),i("details",g,[i("summary",null,[e[12]||(e[12]=i("a",{id:"ReactantCore.@trace",href:"#ReactantCore.@trace"},[i("span",{class:"jlbinding"},"ReactantCore.@trace")],-1)),e[13]||(e[13]=t()),a(s,{type:"info",class:"jlObjectType jlMacro",text:"Macro"})]),e[15]||(e[15]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@trace</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>Converts certain expressions like control flow into a Reactant friendly form. Importantly, if no traced value is found inside the expression, then there is no overhead.</p><p><strong>Currently Supported</strong></p><ul><li><p><code>if</code> conditions (with <code>elseif</code> and other niceties) (<code>@trace if ...</code>)</p></li><li><p><code>if</code> statements with a preceeding assignment (<code>@trace a = if ...</code>) (note the positioning of the macro needs to be before the assignment and not before the <code>if</code>)</p></li><li><p><code>for</code> statements with a single induction variable iterating over a syntactic <code>StepRange</code> of integers.</p></li></ul><p><strong>Special Considerations</strong></p><ul><li>Apply <code>@trace</code> only at the outermost <code>if</code>. Nested <code>if</code> statements will be automatically expanded into the correct form.</li></ul><p><strong>Extended Help</strong></p><p><strong>Caveats (Deviations from Core Julia Semantics)</strong></p><p><strong>New variables introduced</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@trace</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>In the outer scope <code>p</code> is not defined if <code>x â‰¤ 0</code>. However, for the traced version, it is defined and set to a dummy value.</p><p><strong>Short Circuiting Operations</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@trace</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> z </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p><code>&amp;&amp;</code> and <code>||</code> are short circuiting operations. In the traced version, we replace them with <code>&amp;</code> and <code>|</code> respectively.</p><p><strong>Type-Unstable Branches</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@trace</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0f0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>This will not compile since <code>y</code> is a <code>Float32</code> in one branch and a <code>Float64</code> in the other. You need to ensure that all branches have the same type.</p><p>Another example is the following for loop which changes the type of <code>x</code> between iterations.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # ConcreteRArray{Int64, 1}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1f0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5f0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10f0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ConcreteRArray{Float32, 1}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p><strong>Certain Symbols are Reserved</strong></p><p>Symbols like [ðŸ˜¦ðŸ˜ƒ, :nothing, :missing, :Inf, :Inf16, :Inf32, :Inf64, :Base, :Core] are not allowed as variables in <code>@trace</code> expressions. While certain cases might work but these are not guaranteed to work. For example, the following will not work:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    nothing</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    @trace</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div>`,22)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[14]||(e[14]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/lib/ReactantCore/src/ReactantCore.jl#L45-L132",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[14]})]),e[55]||(e[55]=i("h2",{id:"Inspect-Generated-HLO",tabindex:"-1"},[t("Inspect Generated HLO "),i("a",{class:"header-anchor",href:"#Inspect-Generated-HLO","aria-label":'Permalink to "Inspect Generated HLO {#Inspect-Generated-HLO}"'},"â€‹")],-1)),i("details",f,[i("summary",null,[e[16]||(e[16]=i("a",{id:"Reactant.Compiler.@code_hlo",href:"#Reactant.Compiler.@code_hlo"},[i("span",{class:"jlbinding"},"Reactant.Compiler.@code_hlo")],-1)),e[17]||(e[17]=t()),a(s,{type:"info",class:"jlObjectType jlMacro",text:"Macro"})]),e[19]||(e[19]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@code_hlo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [optimize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] [no_nan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Prints the compiled MLIR module for the function <code>f</code> with arguments <code>args</code>.</p><p><strong>Options</strong></p><ul><li><p><code>optimize</code>: Optimizations passes to run on the traced MLIR code. Valid types of values are:</p><ul><li><p>Bool (true/false): whether to run the optimization passes or not. Defaults to <code>true</code>.</p></li><li><p>String: a custom string with the passes to run. The string should be a comma-separated list of MLIR passes. For example, <code>&quot;canonicalize,enzyme-hlo-opt&quot;</code>.</p></li><li><p>Symbol: a predefined set of passes to run. Valid options are:</p><ol><li><p><code>:all</code>: Default set of optimization passes. The exact set of passes are not fixed and may change in future versions of Reactant. It is recommended to use this option for most users.</p></li><li><p><code>:none</code>: No optimization passes will be run.</p></li><li><p>Other predefined options are: <code>:before_kernel</code>, <code>:before_jit</code>, <code>:before_raise</code>, <code>:before_enzyme</code>, <code>:after_enzyme</code>, <code>:just_batch</code>, <code>:canonicalize</code>, <code>:only_enzyme</code>.</p></li></ol></li></ul></li><li><p><code>no_nan</code>: If <code>true</code>, the optimization passes will assume that the function does not produce NaN values. This can lead to more aggressive optimizations <strong>(and potentially incorrect results if the function does produce NaN values)</strong>.</p></li><li><p><code>client</code>: XLA Client used for compilation. If not specified, the default client is used.</p></li><li><p><code>raise</code>: If <code>true</code>, the function will be compiled with the raising pass, which raises CUDA and KernelAbstractions kernels to HLO. Defaults to <code>false</code>, but is automatically activated if the inputs are sharded.</p></li><li><p><code>raise_first</code>: If <code>true</code>, the raising pass will be run before the optimization passes. Defaults to <code>false</code>.</p></li><li><p><code>shardy_passes</code>: Defaults to <code>:to_mhlo_shardings</code>. Other options are:</p><ul><li><p><code>:none</code>: No sharding passes will be run. Shardy + MHLO shardings are handled by XLA.</p></li><li><p><code>:post_sdy_propagation</code>: Runs the Shardy propagation passes. MHLO shardings are handled by XLA.</p></li><li><p><a href="/Reactant.jl/previews/PR1352/api/sharding#Reactant.Sharding.ShardyPropagationOptions"><code>Sharding.ShardyPropagationOptions</code></a>: Custom sharding propagation options. MHLO shardings are handled by XLA.</p></li><li><p><code>:to_mhlo_shardings</code>: Runs the Shardy propagation passes and then exports the shardings to MHLO. All passes are run via MLIR pass pipeline and don&#39;t involve XLA.</p></li></ul></li><li><p><code>assert_nonallocating</code>: If <code>true</code>, we make sure that no new buffers are returned by the function. Any buffer returned must be donated from the inputs. Defaults to <code>false</code>.</p></li><li><p><code>donated_args</code>: If <code>:auto</code>, the function will automatically donate the arguments that are not preserved in the function body. If <code>:none</code>, no arguments will be donated. Defaults to <code>:auto</code>.</p></li><li><p><code>transpose_propagate</code>: If <code>:up</code>, <code>stablehlo.transpose</code> operations will be propagated up the computation graph. If <code>:down</code>, they will be propagated down. Defaults to <code>:up</code>.</p></li><li><p><code>reshape_propagate</code>: If <code>:up</code>, <code>stablehlo.reshape</code> operations will be propagated up the computation graph. If <code>:down</code>, they will be propagated down. Defaults to <code>:up</code>.</p></li><li><p><code>optimize_then_pad</code>: If <code>true</code>, the function will be optimized before padding (for non-divisible sharding axes) is applied. Defaults to <code>true</code>. <em>(Only for Sharded Inputs)</em></p></li><li><p><code>optimize_communications</code>: If <code>true</code>, additional passes for optimizing communication in sharded computations will be run. Defaults to <code>true</code>. <em>(Only for Sharded Inputs)</em></p></li><li><p><code>cudnn_hlo_optimize</code>: Run cuDNN specific HLO optimizations. This is only relevant for GPU backends and is <code>false</code> by default. <strong>Experimental and not heavily tested.</strong> <em>(Only for CUDA backend)</em></p></li></ul><p>See also <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_xla"><code>@code_xla</code></a>, <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_mhlo"><code>@code_mhlo</code></a>.</p>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[18]||(e[18]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/src/Compiler.jl#L2207-L2217",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[18]})]),i("details",y,[i("summary",null,[e[20]||(e[20]=i("a",{id:"Reactant.Compiler.@code_mhlo",href:"#Reactant.Compiler.@code_mhlo"},[i("span",{class:"jlbinding"},"Reactant.Compiler.@code_mhlo")],-1)),e[21]||(e[21]=t()),a(s,{type:"info",class:"jlObjectType jlMacro",text:"Macro"})]),e[23]||(e[23]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@code_mhlo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [optimize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] [no_nan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Similar to <code>@code_hlo</code>, but runs additional passes to export the stablehlo module to MHLO.</p><p><strong>Options</strong></p><ul><li><p><code>optimize</code>: Optimizations passes to run on the traced MLIR code. Valid types of values are:</p><ul><li><p>Bool (true/false): whether to run the optimization passes or not. Defaults to <code>true</code>.</p></li><li><p>String: a custom string with the passes to run. The string should be a comma-separated list of MLIR passes. For example, <code>&quot;canonicalize,enzyme-hlo-opt&quot;</code>.</p></li><li><p>Symbol: a predefined set of passes to run. Valid options are:</p><ol><li><p><code>:all</code>: Default set of optimization passes. The exact set of passes are not fixed and may change in future versions of Reactant. It is recommended to use this option for most users.</p></li><li><p><code>:none</code>: No optimization passes will be run.</p></li><li><p>Other predefined options are: <code>:before_kernel</code>, <code>:before_jit</code>, <code>:before_raise</code>, <code>:before_enzyme</code>, <code>:after_enzyme</code>, <code>:just_batch</code>, <code>:canonicalize</code>, <code>:only_enzyme</code>.</p></li></ol></li></ul></li><li><p><code>no_nan</code>: If <code>true</code>, the optimization passes will assume that the function does not produce NaN values. This can lead to more aggressive optimizations <strong>(and potentially incorrect results if the function does produce NaN values)</strong>.</p></li><li><p><code>client</code>: XLA Client used for compilation. If not specified, the default client is used.</p></li><li><p><code>raise</code>: If <code>true</code>, the function will be compiled with the raising pass, which raises CUDA and KernelAbstractions kernels to HLO. Defaults to <code>false</code>, but is automatically activated if the inputs are sharded.</p></li><li><p><code>raise_first</code>: If <code>true</code>, the raising pass will be run before the optimization passes. Defaults to <code>false</code>.</p></li><li><p><code>shardy_passes</code>: Defaults to <code>:to_mhlo_shardings</code>. Other options are:</p><ul><li><p><code>:none</code>: No sharding passes will be run. Shardy + MHLO shardings are handled by XLA.</p></li><li><p><code>:post_sdy_propagation</code>: Runs the Shardy propagation passes. MHLO shardings are handled by XLA.</p></li><li><p><a href="/Reactant.jl/previews/PR1352/api/sharding#Reactant.Sharding.ShardyPropagationOptions"><code>Sharding.ShardyPropagationOptions</code></a>: Custom sharding propagation options. MHLO shardings are handled by XLA.</p></li><li><p><code>:to_mhlo_shardings</code>: Runs the Shardy propagation passes and then exports the shardings to MHLO. All passes are run via MLIR pass pipeline and don&#39;t involve XLA.</p></li></ul></li><li><p><code>assert_nonallocating</code>: If <code>true</code>, we make sure that no new buffers are returned by the function. Any buffer returned must be donated from the inputs. Defaults to <code>false</code>.</p></li><li><p><code>donated_args</code>: If <code>:auto</code>, the function will automatically donate the arguments that are not preserved in the function body. If <code>:none</code>, no arguments will be donated. Defaults to <code>:auto</code>.</p></li><li><p><code>transpose_propagate</code>: If <code>:up</code>, <code>stablehlo.transpose</code> operations will be propagated up the computation graph. If <code>:down</code>, they will be propagated down. Defaults to <code>:up</code>.</p></li><li><p><code>reshape_propagate</code>: If <code>:up</code>, <code>stablehlo.reshape</code> operations will be propagated up the computation graph. If <code>:down</code>, they will be propagated down. Defaults to <code>:up</code>.</p></li><li><p><code>optimize_then_pad</code>: If <code>true</code>, the function will be optimized before padding (for non-divisible sharding axes) is applied. Defaults to <code>true</code>. <em>(Only for Sharded Inputs)</em></p></li><li><p><code>optimize_communications</code>: If <code>true</code>, additional passes for optimizing communication in sharded computations will be run. Defaults to <code>true</code>. <em>(Only for Sharded Inputs)</em></p></li><li><p><code>cudnn_hlo_optimize</code>: Run cuDNN specific HLO optimizations. This is only relevant for GPU backends and is <code>false</code> by default. <strong>Experimental and not heavily tested.</strong> <em>(Only for CUDA backend)</em></p></li></ul><p>See also <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_xla"><code>@code_xla</code></a>, <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_hlo"><code>@code_hlo</code></a>.</p>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[22]||(e[22]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/src/Compiler.jl#L2232-L2242",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[22]})]),i("details",m,[i("summary",null,[e[24]||(e[24]=i("a",{id:"Reactant.Compiler.@code_xla",href:"#Reactant.Compiler.@code_xla"},[i("span",{class:"jlbinding"},"Reactant.Compiler.@code_xla")],-1)),e[25]||(e[25]=t()),a(s,{type:"info",class:"jlObjectType jlMacro",text:"Macro"})]),e[27]||(e[27]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@code_xla</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [optimize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] [no_nan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Similar to <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_hlo"><code>@code_hlo</code></a>, but runs additional XLA passes and exports MLIR to XLA HLO. This is the post optimizations XLA HLO module.</p><p><strong>Options</strong></p><ul><li><p><code>optimize</code>: Optimizations passes to run on the traced MLIR code. Valid types of values are:</p><ul><li><p>Bool (true/false): whether to run the optimization passes or not. Defaults to <code>true</code>.</p></li><li><p>String: a custom string with the passes to run. The string should be a comma-separated list of MLIR passes. For example, <code>&quot;canonicalize,enzyme-hlo-opt&quot;</code>.</p></li><li><p>Symbol: a predefined set of passes to run. Valid options are:</p><ol><li><p><code>:all</code>: Default set of optimization passes. The exact set of passes are not fixed and may change in future versions of Reactant. It is recommended to use this option for most users.</p></li><li><p><code>:none</code>: No optimization passes will be run.</p></li><li><p>Other predefined options are: <code>:before_kernel</code>, <code>:before_jit</code>, <code>:before_raise</code>, <code>:before_enzyme</code>, <code>:after_enzyme</code>, <code>:just_batch</code>, <code>:canonicalize</code>, <code>:only_enzyme</code>.</p></li></ol></li></ul></li><li><p><code>no_nan</code>: If <code>true</code>, the optimization passes will assume that the function does not produce NaN values. This can lead to more aggressive optimizations <strong>(and potentially incorrect results if the function does produce NaN values)</strong>.</p></li><li><p><code>client</code>: XLA Client used for compilation. If not specified, the default client is used.</p></li><li><p><code>raise</code>: If <code>true</code>, the function will be compiled with the raising pass, which raises CUDA and KernelAbstractions kernels to HLO. Defaults to <code>false</code>, but is automatically activated if the inputs are sharded.</p></li><li><p><code>raise_first</code>: If <code>true</code>, the raising pass will be run before the optimization passes. Defaults to <code>false</code>.</p></li><li><p><code>shardy_passes</code>: Defaults to <code>:to_mhlo_shardings</code>. Other options are:</p><ul><li><p><code>:none</code>: No sharding passes will be run. Shardy + MHLO shardings are handled by XLA.</p></li><li><p><code>:post_sdy_propagation</code>: Runs the Shardy propagation passes. MHLO shardings are handled by XLA.</p></li><li><p><a href="/Reactant.jl/previews/PR1352/api/sharding#Reactant.Sharding.ShardyPropagationOptions"><code>Sharding.ShardyPropagationOptions</code></a>: Custom sharding propagation options. MHLO shardings are handled by XLA.</p></li><li><p><code>:to_mhlo_shardings</code>: Runs the Shardy propagation passes and then exports the shardings to MHLO. All passes are run via MLIR pass pipeline and don&#39;t involve XLA.</p></li></ul></li><li><p><code>assert_nonallocating</code>: If <code>true</code>, we make sure that no new buffers are returned by the function. Any buffer returned must be donated from the inputs. Defaults to <code>false</code>.</p></li><li><p><code>donated_args</code>: If <code>:auto</code>, the function will automatically donate the arguments that are not preserved in the function body. If <code>:none</code>, no arguments will be donated. Defaults to <code>:auto</code>.</p></li><li><p><code>transpose_propagate</code>: If <code>:up</code>, <code>stablehlo.transpose</code> operations will be propagated up the computation graph. If <code>:down</code>, they will be propagated down. Defaults to <code>:up</code>.</p></li><li><p><code>reshape_propagate</code>: If <code>:up</code>, <code>stablehlo.reshape</code> operations will be propagated up the computation graph. If <code>:down</code>, they will be propagated down. Defaults to <code>:up</code>.</p></li><li><p><code>optimize_then_pad</code>: If <code>true</code>, the function will be optimized before padding (for non-divisible sharding axes) is applied. Defaults to <code>true</code>. <em>(Only for Sharded Inputs)</em></p></li><li><p><code>optimize_communications</code>: If <code>true</code>, additional passes for optimizing communication in sharded computations will be run. Defaults to <code>true</code>. <em>(Only for Sharded Inputs)</em></p></li><li><p><code>cudnn_hlo_optimize</code>: Run cuDNN specific HLO optimizations. This is only relevant for GPU backends and is <code>false</code> by default. <strong>Experimental and not heavily tested.</strong> <em>(Only for CUDA backend)</em></p></li></ul><p>See also <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_mhlo"><code>@code_mhlo</code></a>, <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@code_hlo"><code>@code_hlo</code></a>.</p>',5)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[26]||(e[26]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/src/Compiler.jl#L2257-L2268",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[26]})]),e[56]||(e[56]=i("h2",{id:"Profile-XLA",tabindex:"-1"},[t("Profile XLA "),i("a",{class:"header-anchor",href:"#Profile-XLA","aria-label":'Permalink to "Profile XLA {#Profile-XLA}"'},"â€‹")],-1)),e[57]||(e[57]=i("p",null,[t("Reactant can hook into XLA's profiler to generate compilation and execution traces. See the "),i("a",{href:"/Reactant.jl/previews/PR1352/tutorials/profiling#profiling"},"profiling tutorial"),t(" for more details.")],-1)),i("details",b,[i("summary",null,[e[28]||(e[28]=i("a",{id:"Reactant.Profiler.with_profiler",href:"#Reactant.Profiler.with_profiler"},[i("span",{class:"jlbinding"},"Reactant.Profiler.with_profiler")],-1)),e[29]||(e[29]=t()),a(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[31]||(e[31]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">with_profiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, trace_output_dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; trace_device</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, trace_host</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, create_perfetto_link</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Runs the provided function under a profiler for XLA (similar to <a href="https://jax.readthedocs.io/en/latest/profiling.html" target="_blank" rel="noreferrer">JAX&#39;s profiler</a>). The traces will be exported in the provided folder and can be seen using tools like <a href="https://ui.perfetto.dev" target="_blank" rel="noreferrer">perfetto.dev</a>. It will return the return values from the function. The <code>create_perfetto_link</code> parameter can be used to automatically generate a perfetto url to visualize the trace.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">compiled_func </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> with_profiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./traces&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    @compile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sync</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myfunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y, z)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">with_profiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./traces/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    compiled_func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y, z)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">Note</p><p>When profiling compiled functions make sure to <a href="/Reactant.jl/previews/PR1352/api/api#Reactant.Compiler.@compile"><code>Reactant.Compiler.@compile</code></a> with the <code>sync=true</code> option so that the compiled execution is captured by the profiler.</p></div>`,4)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[30]||(e[30]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/src/Profiler.jl#L6-L28",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[30]})]),i("details",E,[i("summary",null,[e[32]||(e[32]=i("a",{id:"Reactant.Profiler.annotate",href:"#Reactant.Profiler.annotate"},[i("span",{class:"jlbinding"},"Reactant.Profiler.annotate")],-1)),e[33]||(e[33]=t()),a(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[35]||(e[35]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">annotate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, name, [level</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TRACE_ME_LEVEL_CRITICAL])</span></span></code></pre></div><p>Generate an annotation in the current trace.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[34]||(e[34]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/src/Profiler.jl#L70-L74",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[34]})]),i("details",_,[i("summary",null,[e[36]||(e[36]=i("a",{id:"Reactant.Profiler.@annotate",href:"#Reactant.Profiler.@annotate"},[i("span",{class:"jlbinding"},"Reactant.Profiler.@annotate")],-1)),e[37]||(e[37]=t()),a(s,{type:"info",class:"jlObjectType jlMacro",text:"Macro"})]),e[39]||(e[39]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@annotate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [name] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b, c)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>The created function will generate an annotation in the captured XLA profiles.</p>`,2)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[38]||(e[38]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/src/Profiler.jl#L86-L92",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[38]})]),e[58]||(e[58]=i("h2",{id:"Devices",tabindex:"-1"},[t("Devices "),i("a",{class:"header-anchor",href:"#Devices","aria-label":'Permalink to "Devices {#Devices}"'},"â€‹")],-1)),i("details",C,[i("summary",null,[e[40]||(e[40]=i("a",{id:"Reactant.devices",href:"#Reactant.devices"},[i("span",{class:"jlbinding"},"Reactant.devices")],-1)),e[41]||(e[41]=t()),a(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[43]||(e[43]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">devices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">devices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">XLA.AbstractClient</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> XLA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">default_backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Return a list of devices available for the given client.</p>`,2)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[42]||(e[42]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/src/Devices.jl#L1-L6",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[42]})]),i("details",F,[i("summary",null,[e[44]||(e[44]=i("a",{id:"Reactant.addressable_devices",href:"#Reactant.addressable_devices"},[i("span",{class:"jlbinding"},"Reactant.addressable_devices")],-1)),e[45]||(e[45]=t()),a(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[47]||(e[47]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">addressable_devices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">addressable_devices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">XLA.AbstractClient</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> XLA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">default_backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Return a list of addressable devices available for the given client.</p>`,2)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[46]||(e[46]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/src/Devices.jl#L11-L16",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[46]})]),e[59]||(e[59]=i("h2",{id:"Internal-utils",tabindex:"-1"},[t("Internal utils "),i("a",{class:"header-anchor",href:"#Internal-utils","aria-label":'Permalink to "Internal utils {#Internal-utils}"'},"â€‹")],-1)),i("details",A,[i("summary",null,[e[48]||(e[48]=i("a",{id:"ReactantCore.materialize_traced_array",href:"#ReactantCore.materialize_traced_array"},[i("span",{class:"jlbinding"},"ReactantCore.materialize_traced_array")],-1)),e[49]||(e[49]=t()),a(s,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[51]||(e[51]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">materialize_traced_array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(AbstractArray{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TracedRNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TracedRArray</span></span></code></pre></div><p>Given an AbstractArray{TracedRNumber}, return or create an equivalent TracedRArray.</p>',2)),a(s,{type:"info",class:"source-link",text:"source"},{default:o(()=>e[50]||(e[50]=[i("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/00556c1c2abec41dbd1ebabb5c1a7cc34ce2f646/lib/ReactantCore/src/ReactantCore.jl#L542-L547",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[50]})])])}const T=l(c,[["render",v]]);export{z as __pageData,T as default};
