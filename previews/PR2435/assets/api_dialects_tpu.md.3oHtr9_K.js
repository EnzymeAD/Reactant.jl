import{_ as i,C as c,o as r,c as d,j as t,a as l,E as s,al as n,w as o}from"./chunks/framework.FoMomreN.js";const A=JSON.parse('{"title":"TPU Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/tpu.md","filePath":"api/dialects/tpu.md","lastUpdated":null}'),u={name:"api/dialects/tpu.md"},p={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},R={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},_={class:"jldocstring custom-block"};function L(M,e,D,v,x,V){const a=c("Badge");return r(),d("div",null,[e[59]||(e[59]=t("h1",{id:"TPU-Dialect",tabindex:"-1"},[l("TPU Dialect "),t("a",{class:"header-anchor",href:"#TPU-Dialect","aria-label":'Permalink to "TPU Dialect {#TPU-Dialect}"'},"â€‹")],-1)),e[60]||(e[60]=t("p",null,[l("Refer to the "),t("a",{href:"https://github.com/jax-ml/jax/blob/main/jaxlib/mosaic/dialect/tpu/tpu.td",target:"_blank",rel:"noreferrer"},"official documentation"),l(" for more details.")],-1)),t("details",p,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.tpu.assume_multiple-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.assume_multiple-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.assume_multiple")],-1)),e[1]||(e[1]=l()),s(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=n('<p><code>assume_multiple</code></p><p>This operation is a hint to the compiler that the input <code>value</code> is guaranteed to be a multiple of <code>multiple</code>. This can be used to satisfy divisibility checks in some compiler passes.</p><p>The result is the same as the input <code>value</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%val = tpu.assume_multiple %arg0, 16 : index</span></span></code></pre></div>',5)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L73-L87",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",m,[t("summary",null,[e[4]||(e[4]=t("a",{id:"Reactant.MLIR.Dialects.tpu.barrier-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.barrier-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.barrier")],-1)),e[5]||(e[5]=l()),s(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[7]||(e[7]=t("p",null,[t("code",null,"barrier")],-1)),e[8]||(e[8]=t("p",null,"Performs barrier synchronization across all SC vector subcores at the specified barrier id.",-1)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[6]||(e[6]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L110-L115",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b,[t("summary",null,[e[9]||(e[9]=t("a",{id:"Reactant.MLIR.Dialects.tpu.broadcast_in_sublanes-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.broadcast_in_sublanes-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.broadcast_in_sublanes")],-1)),e[10]||(e[10]=l()),s(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[12]||(e[12]=n("<p><code>broadcast_in_sublanes</code></p><p>For each sublane <code>i</code>, broadcasts the value in lane <code>lane + i</code> along the entire sublane. For packed type, imagine the data is compressed unpacked along sublane dimension, and the sublane count is multiplied by the packing factor. For example, for i16 with sublane count 8, <code>i</code> above is in [0, 8 * 2). If <code>lane + i</code> is not in [0, lane_count), then the value in sublane <code>i</code> is not defined (can be anything).</p>",2)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[11]||(e[11]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L173-L183",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",R,[t("summary",null,[e[13]||(e[13]=t("a",{id:"Reactant.MLIR.Dialects.tpu.create_subelement_mask-Tuple{}",href:"#Reactant.MLIR.Dialects.tpu.create_subelement_mask-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.create_subelement_mask")],-1)),e[14]||(e[14]=l()),s(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[16]||(e[16]=n('<p><code>create_subelement_mask</code></p><p>The &quot;half-sublanes&quot;, &quot;quarter-sublanes&quot;, etc. (unit is determined by the type of <code>output</code>) of the mask are masked in the range specified by <code>from</code> and <code>to</code>.</p><ul><li><p>If <code>from &lt;= to</code>, the range <code>[from, to)</code> is set and the rest is unset.</p></li><li><p>If <code>to &lt;= from</code>, the range <code>[to, from)</code> is unset and the rest is set.</p></li></ul><p>All lanes are set identically.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%msk = tpu.create_subelement_mask 3, 9 : vector&lt;8x128x2xi1&gt;</span></span></code></pre></div><p>This creates a mask <code>%msk</code> where, for all <code>lane</code>s, <code>%msk[*][lane][*]</code> is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[[0, 0], [0, 1], [1, 1], [1, 1], [1, 0], [0, 0], [0, 0], [0, 0]]</span></span></code></pre></div><p>It is currently only supported:</p><ul><li><p>In TPU v4, for <code>num_subelems</code> of 1 and 2.</p></li><li><p>In TPU v5, for <code>num_subelems</code> of 1, 2, and 4.</p></li></ul>',10)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[15]||(e[15]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L249-L276",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[17]||(e[17]=t("a",{id:"Reactant.MLIR.Dialects.tpu.dynamic_gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.dynamic_gather-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.dynamic_gather")],-1)),e[18]||(e[18]=l()),s(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[20]||(e[20]=n("<p><code>dynamic_gather</code></p><p>Gathers elements from <code>source</code> using <code>indices</code>.</p><p>The specified <code>dimensions</code> of <code>source</code> are collapsed together and indexed by <code>indices</code>.</p><p>Given a shape <code>N0 x N1 x ...</code>, the <code>output[i0, i1, ...]</code> is given by <code>collapsed_source[j0, j1, ..., indices[i0, i1, ...] mod M]</code> where</p><ul><li><p><code>collapsed_source</code> is the result of collapsing <code>dimensions</code> of <code>source</code> into a new trailing dimension of size <code>M</code>.</p></li><li><p><code>jk</code> is the subsequence of <code>in</code> for <code>n</code> not in <code>dimensions</code>.</p></li></ul><p>When a single dimension is specified, this is similar to <code>np.take_along_axis</code>.</p>",6)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[19]||(e[19]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L335-L351",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[21]||(e[21]=t("a",{id:"Reactant.MLIR.Dialects.tpu.iota-Tuple{}",href:"#Reactant.MLIR.Dialects.tpu.iota-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.iota")],-1)),e[22]||(e[22]=l()),s(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[24]||(e[24]=n(`<p><code>iota</code></p><p>Creates a vector that with values that start at 0 and increase along a dimension resulting from collapsing the given <code>dimensions</code> together in row-major order.</p><p><strong>Example</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>tpu.iota {dimensions = array&lt;i32: 2, 0&gt;} : vector&lt;4x3x2xi16&gt;</span></span></code></pre></div><p>This produces a vector with the following values:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[[[0, 4], [0, 4], [0, 4]]</span></span>
<span class="line"><span> [[1, 5], [1, 5], [1, 5]]</span></span>
<span class="line"><span> [[2, 6], [2, 6], [2, 6]]</span></span>
<span class="line"><span> [[3, 7], [3, 7], [3, 7]]]</span></span></code></pre></div>`,6)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[23]||(e[23]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L622-L640",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",h,[t("summary",null,[e[25]||(e[25]=t("a",{id:"Reactant.MLIR.Dialects.tpu.load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tpu.load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.load")],-1)),e[26]||(e[26]=l()),s(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[28]||(e[28]=n("<p><code>load</code></p><p>Similar to <code>vector::LoadOp</code> but with <code>sublane_mask</code> and <code>sublane_stride</code>. When <code>indices</code> are negative, it means loading from negative offset of <code>base</code> address.</p>",2)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[27]||(e[27]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L660-L666",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",T,[t("summary",null,[e[29]||(e[29]=t("a",{id:"Reactant.MLIR.Dialects.tpu.mask_cast-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.mask_cast-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.mask_cast")],-1)),e[30]||(e[30]=l()),s(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[32]||(e[32]=t("p",null,[t("code",null,"mask_cast")],-1)),e[33]||(e[33]=t("p",null,"Cast a mask register into a different packing.",-1)),e[34]||(e[34]=t("p",null,"If casting to a type with smaller packing, then values being packed together must be identical. For example, for 8x128x4xi1 -> 8x128x2xi1, input[i, j, 0] == input[i, j, 1] and input[i, j, 2] == input[i, j, 3] must hold for all i, j. Otherwise, the result is undefined.",-1)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[31]||(e[31]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L734-L743",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I,[t("summary",null,[e[35]||(e[35]=t("a",{id:"Reactant.MLIR.Dialects.tpu.pack_elementwise-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.tpu.pack_elementwise-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.pack_elementwise")],-1)),e[36]||(e[36]=l()),s(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[38]||(e[38]=n("<p><code>pack_elementwise</code></p><p>Packs multiple <code>sources</code> elementwise into a single vector of a narrower <code>target_type</code>.</p><p>The number of <code>sources</code> must equal the packing factor, which is the ratio of the element bitwidth of the <code>sources</code> to the element bitwidth of the <code>target_type</code>. Elements from the <code>sources</code> are interleaved and packed into each word of the <code>output</code>, ordered from lowest to highest bits, corresponding to their order in the <code>sources</code>.</p>",3)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[37]||(e[37]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L920-L930",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",k,[t("summary",null,[e[39]||(e[39]=t("a",{id:"Reactant.MLIR.Dialects.tpu.rotate-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.rotate-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.rotate")],-1)),e[40]||(e[40]=l()),s(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[42]||(e[42]=t("p",null,[t("code",null,"rotate")],-1)),e[43]||(e[43]=t("p",null,[l("Rotates the given vector by the given amount in the given dimension, i.e., for a 2D vector of shape (m, n), rotating dim 0 by "),t("code",null,"amount"),l(" will shift a row at index "),t("code",null,"i"),l(" to index "),t("code",null,"(i + amount) % m")],-1)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[41]||(e[41]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L1156-L1162",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y,[t("summary",null,[e[44]||(e[44]=t("a",{id:"Reactant.MLIR.Dialects.tpu.scan_count-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.scan_count-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.scan_count")],-1)),e[45]||(e[45]=l()),s(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[47]||(e[47]=t("p",null,[t("code",null,"scan_count")],-1)),e[48]||(e[48]=t("p",null,"ScanCountOp calculates the running duplicate occurrence count of the elements in the input vector, %values. The output vector, %counts, contains the running duplicate occurrence count for the corresponding element in the input vector, where the count is performed in ascending order of element indices. For example, if the elements of %values at indices 0, 5, and 7 had duplicate values, then the elements of %counts at indices 0, 5, and 7 would be 1, 2, and 3, respectively.",-1)),e[49]||(e[49]=t("p",null,"A mask vector, %in_mask, specifies which of the elements in the input vector are eligible for counting. An element in %values that has its mask set to 0 will always have a count of 1 in %counts, regardless of the position in the vector, or whether there were duplicates or not.",-1)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[46]||(e[46]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L1215-L1230",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",j,[t("summary",null,[e[50]||(e[50]=t("a",{id:"Reactant.MLIR.Dialects.tpu.sort",href:"#Reactant.MLIR.Dialects.tpu.sort"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.sort")],-1)),e[51]||(e[51]=l()),s(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[53]||(e[53]=t("p",null,[t("code",null,"sort")],-1)),e[54]||(e[54]=t("p",null,"tpu.sort performs a stable sort of key/value pairs in ascending or descending order based on keys. Masked-out keys and values are placed at the end of the output vectors. An output mask indicates which outputs correspond to the valid inputs.",-1)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[52]||(e[52]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L1418-L1425",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",_,[t("summary",null,[e[55]||(e[55]=t("a",{id:"Reactant.MLIR.Dialects.tpu.unpack_elementwise-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.tpu.unpack_elementwise-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.tpu.unpack_elementwise")],-1)),e[56]||(e[56]=l()),s(a,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[58]||(e[58]=n("<p><code>unpack_elementwise</code></p><p>Unpacks a single vector from <code>source</code>, which contains multiple <code>source_type</code> vectors packed elementwise.</p><p>The <code>index</code> selects which packed value to extract from each word of <code>source</code>. An <code>index</code> of 0 corresponds to the lowest bits. The extracted values are cast to the output element type.</p>",3)),s(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[57]||(e[57]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/215b95e8a077a67aaa4c2c2541a7ed907e0c47a9/src/mlir/Dialects/TPU.jl#L1700-L1709",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const P=i(u,[["render",L]]);export{A as __pageData,P as default};
