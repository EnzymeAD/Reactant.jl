import{_ as r,C as i,o as d,c as u,j as t,a as n,E as a,w as s,al as o}from"./chunks/framework.DaWDwmsw.js";const ne=JSON.parse('{"title":"Enzyme Dialect","description":"","frontmatter":{},"headers":[],"relativePath":"api/dialects/enzyme.md","filePath":"api/dialects/enzyme.md","lastUpdated":null}'),R={name:"api/dialects/enzyme.md"},p={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},c={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},L={class:"jldocstring custom-block"},M={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},z={class:"jldocstring custom-block"},D={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},V={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"},x={class:"jldocstring custom-block"},E={class:"jldocstring custom-block"},v={class:"jldocstring custom-block"},A={class:"jldocstring custom-block"},O={class:"jldocstring custom-block"},w={class:"jldocstring custom-block"},S={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},N={class:"jldocstring custom-block"},C={class:"jldocstring custom-block"},F={class:"jldocstring custom-block"},G={class:"jldocstring custom-block"},B={class:"jldocstring custom-block"},P={class:"jldocstring custom-block"},W={class:"jldocstring custom-block"},U={class:"jldocstring custom-block"},X={class:"jldocstring custom-block"},$={class:"jldocstring custom-block"},H={class:"jldocstring custom-block"},J={class:"jldocstring custom-block"},q={class:"jldocstring custom-block"},K={class:"jldocstring custom-block"},Q={class:"jldocstring custom-block"};function Y(Z,e,_,ee,te,le){const l=i("Badge");return d(),u("div",null,[e[203]||(e[203]=t("h1",{id:"Enzyme-Dialect",tabindex:"-1"},[n("Enzyme Dialect "),t("a",{class:"header-anchor",href:"#Enzyme-Dialect","aria-label":'Permalink to "Enzyme Dialect {#Enzyme-Dialect}"'},"â€‹")],-1)),t("details",p,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addRetvalToTrace-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.addRetvalToTrace-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addRetvalToTrace")],-1)),e[1]||(e[1]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[3]||(e[3]=t("p",null,[t("code",null,"addRetvalToTrace")],-1)),e[4]||(e[4]=t("p",null,"Add the function's return value(s) into the execution trace.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L16-L20",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",m,[t("summary",null,[e[5]||(e[5]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addSampleToTrace-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.addSampleToTrace-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addSampleToTrace")],-1)),e[6]||(e[6]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[8]||(e[8]=t("p",null,[t("code",null,"addSampleToTrace")],-1)),e[9]||(e[9]=t("p",null,"Add a sampled value into the execution trace.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[7]||(e[7]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L42-L46",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",c,[t("summary",null,[e[10]||(e[10]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addSubtrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.addSubtrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addSubtrace")],-1)),e[11]||(e[11]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[13]||(e[13]=t("p",null,[t("code",null,"addSubtrace")],-1)),e[14]||(e[14]=t("p",null,"Insert a subtrace into a parent trace.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[12]||(e[12]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L68-L72",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",f,[t("summary",null,[e[15]||(e[15]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addTo-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.addTo-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addTo")],-1)),e[16]||(e[16]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[18]||(e[18]=t("p",null,[t("code",null,"addTo")],-1)),e[19]||(e[19]=t("p",null,"TODO",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[17]||(e[17]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L94-L98",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",y,[t("summary",null,[e[20]||(e[20]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.addWeightToTrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.addWeightToTrace-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.addWeightToTrace")],-1)),e[21]||(e[21]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[23]||(e[23]=t("p",null,[t("code",null,"addWeightToTrace")],-1)),e[24]||(e[24]=t("p",null,"Add the aggregated log-probability weight to the execution trace.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[22]||(e[22]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L118-L122",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",b,[t("summary",null,[e[25]||(e[25]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.broadcast-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.broadcast-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.broadcast")],-1)),e[26]||(e[26]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[28]||(e[28]=t("p",null,[t("code",null,"broadcast")],-1)),e[29]||(e[29]=t("p",null,[n("Broadcast the operand by adding extra dimensions with sizes provided by the "),t("code",null,"shape"),n(" attribute to the front. For scalar operands, ranked tensor is created.")],-1)),e[30]||(e[30]=t("p",null,[n("NOTE: Only works for scalar and "),t("em",null,"ranked"),n(" tensor operands for now.")],-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[27]||(e[27]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L262-L269",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",I,[t("summary",null,[e[31]||(e[31]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.cholesky-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.cholesky-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.cholesky")],-1)),e[32]||(e[32]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[34]||(e[34]=t("p",null,[t("code",null,"cholesky")],-1)),e[35]||(e[35]=t("p",null,"Computes the Cholesky decomposition of a symmetric positive definite matrix A. Returns L such that A = L @ L^T (if lower=true) or A = U^T @ U (if lower=false).",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[33]||(e[33]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L289-L294",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",L,[t("summary",null,[e[36]||(e[36]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.concat-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.concat-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.concat")],-1)),e[37]||(e[37]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[39]||(e[39]=t("p",null,[t("code",null,"concat")],-1)),e[40]||(e[40]=t("p",null,"Concat list of input arguments into a generic value",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[38]||(e[38]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L315-L319",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",M,[t("summary",null,[e[41]||(e[41]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.dot-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.dot-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.dot")],-1)),e[42]||(e[42]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[44]||(e[44]=t("p",null,[t("code",null,"dot")],-1)),e[45]||(e[45]=t("p",null,[n("Computes a general dot product operation. To be lowered to "),t("code",null,"stablehlo.dot_general"),n(".")],-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[43]||(e[43]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L339-L343",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",g,[t("summary",null,[e[46]||(e[46]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.dump-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.dump-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.dump")],-1)),e[47]||(e[47]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[49]||(e[49]=t("p",null,[t("code",null,"dump")],-1)),e[50]||(e[50]=t("p",null,"Debug operation that dumps a tensor value with a label.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[48]||(e[48]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L377-L381",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",j,[t("summary",null,[e[51]||(e[51]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.dynamic_extract-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.dynamic_extract-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.dynamic_extract")],-1)),e[52]||(e[52]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[54]||(e[54]=t("p",null,[t("code",null,"dynamic_extract")],-1)),e[55]||(e[55]=t("p",null,"Extracts a slice at the specified dynamic index along the first dimension.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[53]||(e[53]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L401-L405",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",z,[t("summary",null,[e[56]||(e[56]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.dynamic_update-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.dynamic_update-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.dynamic_update")],-1)),e[57]||(e[57]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[59]||(e[59]=t("p",null,[t("code",null,"dynamic_update")],-1)),e[60]||(e[60]=t("p",null,"Returns a new tensor with the slice at the specified dynamic index replaced.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[58]||(e[58]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L425-L429",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",D,[t("summary",null,[e[61]||(e[61]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.extract-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.extract-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.extract")],-1)),e[62]||(e[62]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[64]||(e[64]=t("p",null,[t("code",null,"extract")],-1)),e[65]||(e[65]=t("p",null,"Extract value from batched operand at index",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[63]||(e[63]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L451-L455",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",T,[t("summary",null,[e[66]||(e[66]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.for_loop-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.for_loop-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.for_loop")],-1)),e[67]||(e[67]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[69]||(e[69]=t("p",null,[t("code",null,"for_loop")],-1)),e[70]||(e[70]=t("p",null,[n("A counted loop operation that iterates from "),t("code",null,"lowerBound"),n(" to "),t("code",null,"upperBound"),n(" by "),t("code",null,"step"),n(", carrying "),t("code",null,"iter_args"),n(" through each iteration. The iteration variable and iter_args are passed to the body region.")],-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[68]||(e[68]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L475-L481",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",V,[t("summary",null,[e[71]||(e[71]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.generate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.generate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.generate")],-1)),e[72]||(e[72]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[74]||(e[74]=o("<p><code>generate</code></p><p>Generate an execution trace and weight from a probabilistic function. If a <code>constraint</code> dict is provided AND the sample op&#39;s <code>symbol</code> is in the <code>constrained_symbols</code> array, we will use the corresponding constraint value instead of generating new samples from the probabilistic function. By convention, the 0th operand in <code>inputs</code> or <code>outputs</code> is the initial RNG state (seed).</p>",2)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[73]||(e[73]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L577-L586",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",k,[t("summary",null,[e[75]||(e[75]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getFlattenedSamplesFromTrace-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getFlattenedSamplesFromTrace-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getFlattenedSamplesFromTrace")],-1)),e[76]||(e[76]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[78]||(e[78]=t("p",null,[t("code",null,"getFlattenedSamplesFromTrace")],-1)),e[79]||(e[79]=t("p",null,"Get sampled values for multiple addresses from an execution trace and flatten them into a single position vector for HMC.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[77]||(e[77]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L656-L661",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",x,[t("summary",null,[e[80]||(e[80]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getSampleFromConstraint-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getSampleFromConstraint-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getSampleFromConstraint")],-1)),e[81]||(e[81]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[83]||(e[83]=t("p",null,[t("code",null,"getSampleFromConstraint")],-1)),e[84]||(e[84]=t("p",null,"Get sampled values from a constraint for a given symbol.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[82]||(e[82]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L702-L706",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",E,[t("summary",null,[e[85]||(e[85]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getSampleFromTrace-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getSampleFromTrace-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getSampleFromTrace")],-1)),e[86]||(e[86]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[88]||(e[88]=t("p",null,[t("code",null,"getSampleFromTrace")],-1)),e[89]||(e[89]=t("p",null,"Get the sampled value for a given symbol from an execution trace.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[87]||(e[87]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L728-L732",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",v,[t("summary",null,[e[90]||(e[90]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getSubconstraint-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getSubconstraint-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getSubconstraint")],-1)),e[91]||(e[91]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[93]||(e[93]=t("p",null,[t("code",null,"getSubconstraint")],-1)),e[94]||(e[94]=t("p",null,"Get a subconstraint from a constraint for a given symbol.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[92]||(e[92]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L754-L758",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",A,[t("summary",null,[e[95]||(e[95]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getSubtrace-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getSubtrace-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getSubtrace")],-1)),e[96]||(e[96]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[98]||(e[98]=t("p",null,[t("code",null,"getSubtrace")],-1)),e[99]||(e[99]=t("p",null,"Get a subtrace from a trace for a given symbol.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[97]||(e[97]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L780-L784",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",O,[t("summary",null,[e[100]||(e[100]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.getWeightFromTrace-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.getWeightFromTrace-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.getWeightFromTrace")],-1)),e[101]||(e[101]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[103]||(e[103]=t("p",null,[t("code",null,"getWeightFromTrace")],-1)),e[104]||(e[104]=t("p",null,"Get the accumulated log-probability weight from an execution trace.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[102]||(e[102]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L804-L808",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",w,[t("summary",null,[e[105]||(e[105]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.if_-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.if_-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.if_")],-1)),e[106]||(e[106]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[108]||(e[108]=t("p",null,[t("code",null,"if_")],-1)),e[109]||(e[109]=t("p",null,"A conditional operation that executes exactly one of two branches based on a boolean predicate.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[107]||(e[107]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L828-L833",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",S,[t("summary",null,[e[110]||(e[110]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.initTrace-Tuple{}",href:"#Reactant.MLIR.Dialects.enzyme.initTrace-Tuple{}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.initTrace")],-1)),e[111]||(e[111]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[113]||(e[113]=t("p",null,[t("code",null,"initTrace")],-1)),e[114]||(e[114]=t("p",null,"Initialize an execution trace for a probabilistic function.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[112]||(e[112]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L897-L901",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",h,[t("summary",null,[e[115]||(e[115]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.log_add_exp-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.log_add_exp-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.log_add_exp")],-1)),e[116]||(e[116]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[118]||(e[118]=t("p",null,[t("code",null,"log_add_exp")],-1)),e[119]||(e[119]=t("p",null,"Computes log(exp(x) + exp(y)).",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[117]||(e[117]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L940-L944",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",N,[t("summary",null,[e[120]||(e[120]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.logistic-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.logistic-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.logistic")],-1)),e[121]||(e[121]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[123]||(e[123]=t("p",null,[t("code",null,"logistic")],-1)),e[124]||(e[124]=t("p",null,"Computes the logistic (sigmoid) function: 1 / (1 + exp(-x)).",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[122]||(e[122]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L964-L968",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",C,[t("summary",null,[e[125]||(e[125]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.mcmc",href:"#Reactant.MLIR.Dialects.enzyme.mcmc"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.mcmc")],-1)),e[126]||(e[126]=n()),a(l,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[128]||(e[128]=t("p",null,[t("code",null,"mcmc")],-1)),e[129]||(e[129]=t("p",null,"Performs MCMC inference on a probabilistic function.",-1)),e[130]||(e[130]=t("p",null,"By default (num_warmup=0, num_samples=1, thinning=1), performs a single MCMC step and returns the resulting trace - backwards compatible with previous behavior.",-1)),e[131]||(e[131]=t("p",null,"When num_samples > 1, runs a full MCMC chain and returns a trace where sampled values have an additional batch dimension (first dim = num_samples / thinning).",-1)),e[132]||(e[132]=t("p",null,"Thinning controls the fraction of samples retained: when thinning=k, every k-th sample is kept, resulting in num_samples/k output samples.",-1)),e[133]||(e[133]=t("p",null,"Warmup iterations are discarded and used only for adaptation.",-1)),e[134]||(e[134]=t("p",null,"By convention, the 0th operand in inputs is the initial RNG state and the 0th operand in results is the updated RNG state.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[127]||(e[127]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L988-L1006",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",F,[t("summary",null,[e[135]||(e[135]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.mh-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.mh-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.mh")],-1)),e[136]||(e[136]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[138]||(e[138]=t("p",null,[t("code",null,"mh")],-1)),e[139]||(e[139]=t("p",null,"Perform a Metropolis-Hastings step on a probabilistic function. This operation proposes a new trace by regenerating selected addresses, computes the acceptance probability, and returns the updated trace. By convention, the 0th operand in inputs is the initial RNG state and the 0th operand in results is the updated RNG state.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[137]||(e[137]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1062-L1070",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",G,[t("summary",null,[e[140]||(e[140]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.popcount-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.popcount-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.popcount")],-1)),e[141]||(e[141]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[143]||(e[143]=t("p",null,[t("code",null,"popcount")],-1)),e[144]||(e[144]=t("p",null,"Returns the number of 1-bits elementwise.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[142]||(e[142]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1141-L1145",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",B,[t("summary",null,[e[145]||(e[145]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.random-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.random-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.random")],-1)),e[146]||(e[146]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[148]||(e[148]=t("p",null,[t("code",null,"random")],-1)),e[149]||(e[149]=t("p",null,"Generates random numbers using the rng_distribution algorithm and produces a result tensor.",-1)),e[150]||(e[150]=t("p",null,"If rng_distribution = UNIFORM, then the random numbers are generated following the uniform distribution over the interval [a, b). If a >= b, the behavior is undefined.",-1)),e[151]||(e[151]=t("p",null,"If rng_distribution = NORMAL, then the random numbers are generated following the normal distribution with mean = a and standard deviation = b. If b < 0, the behavior is undefined.",-1)),e[152]||(e[152]=t("p",null,"If rng_distribution = MULTINORMAL, then the random numbers are generated following the multivariate normal distribution with mean = a (scalar or vector) and covariance matrix = b. The parameter b should be a positive definite matrix.",-1)),e[153]||(e[153]=t("p",null,"By convention, the 0th operand in inputs is the initial RNG state and the 0th operand in results is the updated RNG state.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[147]||(e[147]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1184-L1204",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",P,[t("summary",null,[e[154]||(e[154]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.randomSplit-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.randomSplit-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.randomSplit")],-1)),e[155]||(e[155]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[157]||(e[157]=t("p",null,[t("code",null,"randomSplit")],-1)),e[158]||(e[158]=t("p",null,[n("Splits an RNG state into multiple independent RNG states. Reference: "),t("a",{href:"https://github.com/jax-ml/jax/blob/c25e095fcec9678a4ce5f723afce0c6a3c48a5e7/jax/_src/random.py#L281-L294",target:"_blank",rel:"noreferrer"},"https://github.com/jax-ml/jax/blob/c25e095fcec9678a4ce5f723afce0c6a3c48a5e7/jax/_src/random.py#L281-L294")],-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[156]||(e[156]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1232-L1237",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",W,[t("summary",null,[e[159]||(e[159]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.recover_sample-Tuple{Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.recover_sample-Tuple{Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.recover_sample")],-1)),e[160]||(e[160]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[162]||(e[162]=t("p",null,[t("code",null,"recover_sample")],-1)),e[163]||(e[163]=t("p",null,"Recover a sample from a flattened position vector.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[161]||(e[161]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1259-L1263",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",U,[t("summary",null,[e[164]||(e[164]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.regenerate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.regenerate-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.regenerate")],-1)),e[165]||(e[165]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[167]||(e[167]=t("p",null,[t("code",null,"regenerate")],-1)),e[168]||(e[168]=t("p",null,"Regenerate selected addresses in a probabilistic function while keeping other addresses fixed to their values in the given trace. By convention, the 0th operand in inputs is the initial RNG state and the 0th operand in results is the updated RNG state.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[166]||(e[166]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1283-L1290",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",X,[t("summary",null,[e[169]||(e[169]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.sample-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.sample-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.sample")],-1)),e[170]||(e[170]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[172]||(e[172]=t("p",null,[t("code",null,"sample")],-1)),e[173]||(e[173]=t("p",null,[n("Sample from a distribution. By convention, the 0th operand in "),t("code",null,"inputs"),n(" or "),t("code",null,"outputs"),n(" is the initial RNG state (seed).")],-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[171]||(e[171]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1323-L1328",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",$,[t("summary",null,[e[174]||(e[174]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.select-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.select")],-1)),e[175]||(e[175]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[177]||(e[177]=o("<p><code>select</code></p><p>Extended select operation that supports:</p><ul><li><p><code>tensor&lt;i1&gt;</code> conditions with differently-sized operands</p></li><li><p><code>!enzyme.Trace</code> operands</p></li><li><p>standard cases supported by <code>arith.select</code></p></li></ul>",3)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[176]||(e[176]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1361-L1368",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",H,[t("summary",null,[e[178]||(e[178]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.simulate-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.simulate-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.simulate")],-1)),e[179]||(e[179]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[181]||(e[181]=t("p",null,[t("code",null,"simulate")],-1)),e[182]||(e[182]=t("p",null,[n("Simulate a probabilistic function to generate execution trace by replacing all SampleOps with distribution calls and recording all sampled values into the trace. This op returns the trace, the weight (accumulated log-probability), and the other outputs. By convention, the 0th operand in "),t("code",null,"inputs"),n(" or "),t("code",null,"outputs"),n(" is the initial RNG state (seed).")],-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[180]||(e[180]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1413-L1421",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",J,[t("summary",null,[e[183]||(e[183]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.triangular_solve-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.triangular_solve-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.triangular_solve")],-1)),e[184]||(e[184]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[186]||(e[186]=t("p",null,[t("code",null,"triangular_solve")],-1)),e[187]||(e[187]=t("p",null,"Solves a system of linear equations with a triangular coefficient matrix. If left_side=true, solves op(A) @ X = B for X. If left_side=false, solves X @ op(A) = B for X. op(A) is determined by transpose_a: NO_TRANSPOSE, TRANSPOSE, or ADJOINT.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[185]||(e[185]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1469-L1476",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",q,[t("summary",null,[e[188]||(e[188]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.untracedCall-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.untracedCall-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.untracedCall")],-1)),e[189]||(e[189]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[191]||(e[191]=t("p",null,[t("code",null,"untracedCall")],-1)),e[192]||(e[192]=t("p",null,[n("Call a probabilistic function without tracing. By convention, the 0th operand in "),t("code",null,"inputs"),n(" or "),t("code",null,"outputs"),n(" is the initial RNG state (seed).")],-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[190]||(e[190]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1510-L1515",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",K,[t("summary",null,[e[193]||(e[193]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.update-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}",href:"#Reactant.MLIR.Dialects.enzyme.update-Tuple{Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.update")],-1)),e[194]||(e[194]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[196]||(e[196]=t("p",null,[t("code",null,"update")],-1)),e[197]||(e[197]=t("p",null,"Update selected addresses in a trace with new values from a position vector, re-evaluate the probabilistic function, and return the updated trace with the new weight (log probability) and updated RNG state. By convention, the 0th operand in inputs is the initial RNG state.",-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[195]||(e[195]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1538-L1545",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),t("details",Q,[t("summary",null,[e[198]||(e[198]=t("a",{id:"Reactant.MLIR.Dialects.enzyme.while_loop-Tuple{Vector{Reactant.MLIR.IR.Value}}",href:"#Reactant.MLIR.Dialects.enzyme.while_loop-Tuple{Vector{Reactant.MLIR.IR.Value}}"},[t("span",{class:"jlbinding"},"Reactant.MLIR.Dialects.enzyme.while_loop")],-1)),e[199]||(e[199]=n()),a(l,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),e[201]||(e[201]=t("p",null,[t("code",null,"while_loop")],-1)),e[202]||(e[202]=t("p",null,[n("A while loop operation that continues iterating as long as the condition evaluates to true. Intended to be lowered to "),t("code",null,"stablehlo.while"),n(".")],-1)),a(l,{type:"info",class:"source-link",text:"source"},{default:s(()=>[...e[200]||(e[200]=[t("a",{href:"https://github.com/EnzymeAD/Reactant.jl/blob/d7da397d64dfd17d06cfada796745a90f200ad88/src/mlir/Dialects/Enzyme.jl#L1579-L1584",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const se=r(R,[["render",Y]]);export{ne as __pageData,se as default};
