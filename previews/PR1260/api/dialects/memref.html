<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MemRef Dialect | Reactant.jl</title>
    <meta name="description" content="Documentation for Reactant.jl">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/Reactant.jl/previews/PR1260/assets/style.oLI8purn.css" as="style">
    <link rel="preload stylesheet" href="/Reactant.jl/previews/PR1260/vp-icons.css" as="style">
    
    <script type="module" src="/Reactant.jl/previews/PR1260/assets/app.1dHyDWzd.js"></script>
    <link rel="preload" href="/Reactant.jl/previews/PR1260/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Reactant.jl/previews/PR1260/assets/chunks/theme.D8zczAc7.js">
    <link rel="modulepreload" href="/Reactant.jl/previews/PR1260/assets/chunks/framework.B84r1DG9.js">
    <link rel="modulepreload" href="/Reactant.jl/previews/PR1260/assets/api_dialects_memref.md.DHzkTljZ.lean.js">
    <link rel="icon" href="/Reactant.jl/previews/PR1260/favicon.ico">
    <script src="/versions.js"></script>
    <script src="/Reactant.jl/previews/PR1260/siteinfo.js"></script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-a9a9e638><!--[--><!--]--><!--[--><span tabindex="-1" data-v-492508fc></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-492508fc>Skip to content</a><!--]--><!----><header class="VPNav" data-v-a9a9e638 data-v-f1e365da><div class="VPNavBar" data-v-f1e365da data-v-822684d1><div class="wrapper" data-v-822684d1><div class="container" data-v-822684d1><div class="title" data-v-822684d1><div class="VPNavBarTitle has-sidebar" data-v-822684d1 data-v-0f4f798b><a class="title" href="/Reactant.jl/previews/PR1260/" data-v-0f4f798b><!--[--><!--]--><!--[--><!--[--><!--[--><img class="VPImage dark logo" src="/Reactant.jl/previews/PR1260/logo.svg" alt data-v-35a7d0b8><!--]--><!--[--><img class="VPImage light logo" src="/Reactant.jl/previews/PR1260/logo.svg" alt data-v-35a7d0b8><!--]--><!--]--><!--]--><span data-v-0f4f798b>Reactant.jl</span><!--[--><!--]--></a></div></div><div class="content" data-v-822684d1><div class="content-body" data-v-822684d1><!--[--><!--]--><div class="VPNavBarSearch search" data-v-822684d1><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-822684d1 data-v-e6d46098><span id="main-nav-aria-label" class="visually-hidden" data-v-e6d46098> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Reactant.jl/previews/PR1260/" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Home</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>Getting Started</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/introduction" data-v-acbfed09><!--[--><span data-v-acbfed09>Introduction</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/introduction/configuration" data-v-acbfed09><!--[--><span data-v-acbfed09>Configuration</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link vp-external-link-icon VPNavBarMenuLink" href="https://enzymead.github.io/Reactant.jl/benchmarks/" target="_blank" rel="noreferrer" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Benchmarks</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>Tutorials</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/tutorials/" data-v-acbfed09><!--[--><span data-v-acbfed09>Overview</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/tutorials/profiling" data-v-acbfed09><!--[--><span data-v-acbfed09>Profiling</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/tutorials/multihost" data-v-acbfed09><!--[--><span data-v-acbfed09>Distributed</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/tutorials/local-build" data-v-acbfed09><!--[--><span data-v-acbfed09>Local build</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>API</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/api" data-v-acbfed09><!--[--><span data-v-acbfed09>Core Reactant API</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/sharding" data-v-acbfed09><!--[--><span data-v-acbfed09>Sharding</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/ops" data-v-acbfed09><!--[--><span data-v-acbfed09>Ops</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/config" data-v-acbfed09><!--[--><span data-v-acbfed09>Configuration</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuGroup" data-v-7dd3104a data-v-48c802d0><p class="title" data-v-48c802d0>MLIR Dialects</p><!--[--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/arith" data-v-acbfed09><!--[--><span data-v-acbfed09>ArithOps</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/affine" data-v-acbfed09><!--[--><span data-v-acbfed09>Affine</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/builtin" data-v-acbfed09><!--[--><span data-v-acbfed09>Builtin</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/chlo" data-v-acbfed09><!--[--><span data-v-acbfed09>Chlo</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/enzyme" data-v-acbfed09><!--[--><span data-v-acbfed09>Enzyme</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/enzymexla" data-v-acbfed09><!--[--><span data-v-acbfed09>EnzymeXLA</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/func" data-v-acbfed09><!--[--><span data-v-acbfed09>Func</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/gpu" data-v-acbfed09><!--[--><span data-v-acbfed09>GPU</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/llvm" data-v-acbfed09><!--[--><span data-v-acbfed09>LLVM</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/mpi" data-v-acbfed09><!--[--><span data-v-acbfed09>MPI</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link active" href="/Reactant.jl/previews/PR1260/api/dialects/memref" data-v-acbfed09><!--[--><span data-v-acbfed09>MemRef</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/nvvm" data-v-acbfed09><!--[--><span data-v-acbfed09>NVVM</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/shardy" data-v-acbfed09><!--[--><span data-v-acbfed09>Shardy</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/sparsetensor" data-v-acbfed09><!--[--><span data-v-acbfed09>SparseTensor</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/stablehlo" data-v-acbfed09><!--[--><span data-v-acbfed09>StableHLO</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/triton" data-v-acbfed09><!--[--><span data-v-acbfed09>Triton</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/tpu" data-v-acbfed09><!--[--><span data-v-acbfed09>TPU</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/dialects/vhlo" data-v-acbfed09><!--[--><span data-v-acbfed09>VHLO</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-7dd3104a data-v-48c802d0><p class="title" data-v-48c802d0>Low-Level API</p><!--[--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/mlirc" data-v-acbfed09><!--[--><span data-v-acbfed09>MLIR API</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/xla" data-v-acbfed09><!--[--><span data-v-acbfed09>XLA</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/Reactant.jl/previews/PR1260/api/internal" data-v-acbfed09><!--[--><span data-v-acbfed09>Internal API</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><!----><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-822684d1 data-v-af096f4a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-af096f4a data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-822684d1 data-v-164c457f data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://julialang.org/slack/" aria-label="slack" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-slack"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-822684d1 data-v-925effce data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-04f5c5e9><span class="vpi-more-horizontal icon" data-v-04f5c5e9></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><!----><!--[--><!--[--><!----><div class="group" data-v-925effce><div class="item appearance" data-v-925effce><p class="label" data-v-925effce>Appearance</p><div class="appearance-action" data-v-925effce><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-925effce data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div></div></div><div class="group" data-v-925effce><div class="item social-links" data-v-925effce><div class="VPSocialLinks social-links-list" data-v-925effce data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://julialang.org/slack/" aria-label="slack" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-slack"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--[--><!--[--><!--[--><a target="_blank" data-decoration="★" title="165 GitHub stars" href="https://github.com/EnzymeAD/Reactant.jl" data-v-b4d08338><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align:middle;margin-right:0.25rem;margin-left:0.5rem;" data-v-b4d08338><path d="M12 .297C5.375.297 0 5.673 0 12.3c0 5.292 3.438 9.8 8.207 11.387.6.11.793-.26.793-.577 0-.285-.01-1.04-.015-2.04-3.338.727-4.042-1.61-4.042-1.61-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.807 1.305 3.493.997.107-.774.42-1.305.762-1.605-2.665-.3-5.467-1.333-5.467-5.931 0-1.31.47-2.382 1.236-3.222-.123-.303-.535-1.52.117-3.166 0 0 1.01-.323 3.31 1.23.96-.267 1.98-.4 3-.405 1.02.005 2.04.138 3 .405 2.3-1.553 3.31-1.23 3.31-1.23.653 1.646.24 2.863.117 3.166.765.84 1.236 1.912 1.236 3.222 0 4.61-2.807 5.625-5.477 5.921.43.372.823 1.102.823 2.222 0 1.606-.015 2.902-.015 3.293 0 .32.192.693.8.577C20.565 22.1 24 17.588 24 12.297 24 5.673 18.627.297 12 .297z" data-v-b4d08338></path></svg><span data-v-b4d08338>0.2k</span></a><a class="mobile" target="_blank" title="165 GitHub stars" href="https://github.com/EnzymeAD/Reactant.jl" data-v-b4d08338><svg xmlns="http://www.w3.org/2000/svg" width="21" height="21" viewBox="0 0 21 21" fill="none" data-v-b4d08338><path d="M19.625 5.60534C18.7083 4.03477 17.4649 2.79135 15.8945 1.87479C14.3238 0.958185 12.6091 0.5 10.7492 0.5C8.88947 0.5 7.17422 0.958325 5.60388 1.87479C4.0333 2.7913 2.78997 4.03477 1.87332 5.60534C0.956814 7.17587 0.498535 8.89089 0.498535 10.7504C0.498535 12.984 1.15021 14.9926 2.4539 16.7766C3.75744 18.5607 5.44142 19.7952 7.50571 20.4803C7.746 20.5249 7.92388 20.4936 8.03954 20.387C8.15524 20.2804 8.21302 20.1467 8.21302 19.9868C8.21302 19.9601 8.21073 19.7199 8.20629 19.266C8.20171 18.8122 8.19956 18.4162 8.19956 18.0783L7.89256 18.1315C7.69682 18.1673 7.44989 18.1825 7.15178 18.1782C6.8538 18.174 6.54446 18.1428 6.22419 18.0847C5.90377 18.0272 5.60575 17.8937 5.32988 17.6846C5.05416 17.4755 4.85842 17.2018 4.74272 16.8639L4.60925 16.5568C4.52029 16.3523 4.38023 16.1251 4.18888 15.8761C3.99754 15.6269 3.80405 15.458 3.60831 15.369L3.51486 15.3021C3.45259 15.2577 3.39481 15.204 3.34138 15.1418C3.28799 15.0796 3.24802 15.0173 3.22132 14.955C3.19458 14.8926 3.21674 14.8414 3.28804 14.8012C3.35933 14.761 3.48817 14.7416 3.67512 14.7416L3.94196 14.7814C4.11993 14.8171 4.34007 14.9236 4.60266 15.1017C4.86511 15.2796 5.08085 15.5109 5.24994 15.7956C5.4547 16.1605 5.7014 16.4385 5.99072 16.6299C6.27982 16.8212 6.5713 16.9167 6.86488 16.9167C7.15846 16.9167 7.41203 16.8945 7.62567 16.8502C7.83908 16.8057 8.0393 16.7388 8.22625 16.6499C8.30633 16.0535 8.52437 15.5953 8.88017 15.275C8.37304 15.2217 7.9171 15.1414 7.51212 15.0347C7.10736 14.9278 6.6891 14.7544 6.25761 14.5139C5.82589 14.2738 5.46774 13.9756 5.18309 13.6198C4.89839 13.2639 4.66474 12.7966 4.48247 12.2183C4.3001 11.6399 4.20889 10.9726 4.20889 10.2163C4.20889 9.13941 4.56044 8.22304 5.26341 7.46665C4.93411 6.65705 4.96519 5.74947 5.35676 4.744C5.61482 4.66382 5.9975 4.72399 6.50463 4.92412C7.01186 5.12434 7.38323 5.29587 7.61912 5.43808C7.85502 5.58024 8.04402 5.70071 8.18642 5.79842C9.01411 5.56715 9.86825 5.45149 10.7491 5.45149C11.6299 5.45149 12.4843 5.56715 13.312 5.79842L13.8192 5.47823C14.166 5.26459 14.5756 5.06881 15.0469 4.89083C15.5185 4.71295 15.8791 4.66396 16.1284 4.74414C16.5286 5.74966 16.5643 6.65719 16.2349 7.46679C16.9378 8.22318 17.2895 9.13978 17.2895 10.2164C17.2895 10.9727 17.198 11.6421 17.0159 12.225C16.8336 12.808 16.5979 13.2749 16.3088 13.6265C16.0194 13.9781 15.659 14.274 15.2275 14.5141C14.7959 14.7544 14.3775 14.9278 13.9728 15.0347C13.5678 15.1415 13.1119 15.2219 12.6047 15.2752C13.0673 15.6755 13.2986 16.3073 13.2986 17.1704V19.9864C13.2986 20.1464 13.3542 20.2799 13.4656 20.3867C13.5768 20.4932 13.7524 20.5246 13.9927 20.4799C16.0573 19.7949 17.7413 18.5603 19.0448 16.7762C20.3481 14.9922 21 12.9837 21 10.75C20.9996 8.89075 20.541 7.17587 19.625 5.60534Z" fill="currentColor" data-v-b4d08338></path></svg></a><!--]--><div class="VPFlyout VPNolebaseEnhancedReadabilitiesMenu VPNolebaseEnhancedReadabilitiesMenuFlyout" aria-label="Enhanced Readability" role="menuitem" data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><span class="i-icon-park-outline:book-open option-icon" data-v-04f5c5e9></span><!----><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><!----><!--[--><!--]--></div></div></div><!--]--><!--]--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-822684d1 data-v-5dea55bf><span class="container" data-v-5dea55bf><span class="top" data-v-5dea55bf></span><span class="middle" data-v-5dea55bf></span><span class="bottom" data-v-5dea55bf></span></span></button></div></div></div></div><div class="divider" data-v-822684d1><div class="divider-line" data-v-822684d1></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-a9a9e638 data-v-070ab83d><div class="container" data-v-070ab83d><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-070ab83d><span class="vpi-align-left menu-icon" data-v-070ab83d></span><span class="menu-text" data-v-070ab83d>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-070ab83d data-v-168ddf5d><button data-v-168ddf5d>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-a9a9e638 data-v-18756405><div class="curtain" data-v-18756405></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-18756405><span class="visually-hidden" id="sidebar-aria-label" data-v-18756405> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0 collapsible has-active" data-v-9e426adc data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h2 class="text" data-v-a4b0d9bf>API Reference</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/api" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Reactant API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/sharding" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Sharding</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/ops" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Ops</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/config" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Configuration</p><!--]--></a><!----></div><!----></div><section class="VPSidebarItem level-1 collapsible has-active" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h3 class="text" data-v-a4b0d9bf>MLIR Dialects</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/arith" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>ArithOps</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/affine" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Affine</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/builtin" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Builtin</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/chlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Chlo</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/enzyme" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Enzyme</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/enzymexla" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>EnzymeXLA</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/func" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Func</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/gpu" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>GPU</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/llvm" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>LLVM</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/mpi" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MPI</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/memref" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MemRef</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/nvvm" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>NVVM</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/shardy" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Shardy</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/sparsetensor" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>SparseTensor</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/stablehlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>StableHLO</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/triton" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Triton</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/tpu" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>TPU</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/dialects/vhlo" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>VHLO</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 collapsible" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h3 class="text" data-v-a4b0d9bf>Low-Level API</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/mlirc" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>MLIR API</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/xla" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>XLA</p><!--]--></a><!----></div><!----></div><!--]--></div></section><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/Reactant.jl/previews/PR1260/api/internal" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Internal API</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-a9a9e638 data-v-91765379><div class="VPDoc has-sidebar has-aside" data-v-91765379 data-v-83890dd9><!--[--><!--]--><div class="container" data-v-83890dd9><div class="aside" data-v-83890dd9><div class="aside-curtain" data-v-83890dd9></div><div class="aside-container" data-v-83890dd9><div class="aside-content" data-v-83890dd9><div class="VPDocAside" data-v-83890dd9 data-v-6d7b3c46><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-6d7b3c46 data-v-b38bf2ff><div class="content" data-v-b38bf2ff><div class="outline-marker" data-v-b38bf2ff></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-b38bf2ff>On this page</div><ul class="VPDocOutlineItem root" data-v-b38bf2ff data-v-3f927ebe><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-6d7b3c46></div><!--[--><!--[--><!--[--><!--[--><!--[--><br><h2> Trusted by </h2><a class="enjoyer" href="https://lux.csail.mit.edu/" target="_blank"><img width="32" height="32" src="https://raw.githubusercontent.com/LuxDL/Lux.jl/refs/heads/main/assets/lux-logo.svg"><span><p class="extra-info">Scientific Computing</p><p class="heading">Lux.jl</p><p class="extra-info">Machine Learning</p></span></a><a class="enjoyer" href="https://bsc-quantic.github.io/Tenet.jl/stable/" target="_blank"><img width="32" height="32" src="https://raw.githubusercontent.com/bsc-quantic/Tenet.jl/refs/heads/master/docs/src/assets/logo.svg"><span><p class="extra-info">Quantum Simulation</p><p class="heading">Tenet.jl</p><p class="extra-info">Tensor Networks</p></span></a><!--]--><!--]--><!--]--><!--]--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-83890dd9><div class="content-container" data-v-83890dd9><!--[--><!--]--><main class="main" data-v-83890dd9><div style="position:relative;" class="vp-doc _Reactant_jl_previews_PR1260_api_dialects_memref" data-v-83890dd9><div><h1 id="MemRef-Dialect" tabindex="-1">MemRef Dialect <a class="header-anchor" href="#MemRef-Dialect" aria-label="Permalink to &quot;MemRef Dialect {#MemRef-Dialect}&quot;">​</a></h1><p>Refer to the <a href="https://mlir.llvm.org/docs/Dialects/MemRef/" target="_blank" rel="noreferrer">official documentation</a> for more details.</p><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.alloc-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.alloc-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.alloc</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>alloc</code></p><p>The <code>alloc</code> operation allocates a region of memory, as specified by its memref type.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = memref.alloc() : memref&lt;8x64xf32, 1&gt;</span></span></code></pre></div><p>The optional list of dimension operands are bound to the dynamic dimensions specified in its memref type. In the example below, the ssa value &#39;%d&#39; is bound to the second dimension of the memref (which is dynamic).</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = memref.alloc(%d) : memref&lt;8x?xf32, 1&gt;</span></span></code></pre></div><p>The optional list of symbol operands are bound to the symbols of the memrefs affine map. In the example below, the ssa value &#39;%s&#39; is bound to the symbol &#39;s0&#39; in the affine map specified in the allocs memref type.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = memref.alloc()[%s] : memref&lt;8x64xf32,</span></span>
<span class="line"><span>                          affine_map&lt;(d0, d1)[s0] -&gt; ((d0 + s0), d1)&gt;, 1&gt;</span></span></code></pre></div><p>This operation returns a single ssa value of memref type, which can be used by subsequent load and store operations.</p><p>The optional <code>alignment</code> attribute may be specified to ensure that the region of memory that will be indexed is aligned at the specified byte boundary.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = memref.alloc()[%s] {alignment = 8} :</span></span>
<span class="line"><span>  memref&lt;8x64xf32, affine_map&lt;(d0, d1)[s0] -&gt; ((d0 + s0), d1)&gt;, 1&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L244-L284" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.alloca-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.alloca-Tuple{Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.alloca</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>alloca</code></p><p>The <code>alloca</code> operation allocates memory on the stack, to be automatically released when control transfers back from the region of its closest surrounding operation with an <a href="./../Traits.md/#automaticallocationscope"><code>AutomaticAllocationScope</code></a> trait. The amount of memory allocated is specified by its memref and additional operands. For example:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = memref.alloca() : memref&lt;8x64xf32&gt;</span></span></code></pre></div><p>The optional list of dimension operands are bound to the dynamic dimensions specified in its memref type. In the example below, the SSA value &#39;%d&#39; is bound to the second dimension of the memref (which is dynamic).</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = memref.alloca(%d) : memref&lt;8x?xf32&gt;</span></span></code></pre></div><p>The optional list of symbol operands are bound to the symbols of the memref&#39;s affine map. In the example below, the SSA value &#39;%s&#39; is bound to the symbol &#39;s0&#39; in the affine map specified in the allocs memref type.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = memref.alloca()[%s] : memref&lt;8x64xf32,</span></span>
<span class="line"><span>                           affine_map&lt;(d0, d1)[s0] -&gt; ((d0 + s0), d1)&gt;&gt;</span></span></code></pre></div><p>This operation returns a single SSA value of memref type, which can be used by subsequent load and store operations. An optional alignment attribute, if specified, guarantees alignment at least to that boundary. If not specified, an alignment on any convenient boundary compatible with the type will be chosen.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L312-L348" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.alloca_scope-Tuple{}" href="#Reactant.MLIR.Dialects.memref.alloca_scope-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.alloca_scope</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>alloca_scope</code></p><p>The <code>memref.alloca_scope</code> operation represents an explicitly-delimited scope for the alloca allocations. Any <code>memref.alloca</code> operations that are used within this scope are going to be cleaned up automatically once the control-flow exits the nested region. For example:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>memref.alloca_scope {</span></span>
<span class="line"><span>  %myalloca = memref.alloca(): memref&lt;4x3xf32&gt;</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Here, <code>%myalloca</code> memref is valid within the explicitly delimited scope and is automatically deallocated at the end of the given region. Conceptually, <code>memref.alloca_scope</code> is a passthrough operation with <code>AutomaticAllocationScope</code> that spans the body of the region within the operation.</p><p><code>memref.alloca_scope</code> may also return results that are defined in the nested region. To return a value, one should use <code>memref.alloca_scope.return</code> operation:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result = memref.alloca_scope {</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>  memref.alloca_scope.return %value</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>If <code>memref.alloca_scope</code> returns no value, the <code>memref.alloca_scope.return</code> can be left out, and will be inserted implicitly.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L376-L409" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.alloca_scope_return-Tuple{Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.alloca_scope_return-Tuple{Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.alloca_scope_return</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>alloca_scope_return</code></p><p><code>memref.alloca_scope.return</code> operation returns zero or more SSA values from the region within <code>memref.alloca_scope</code>. If no values are returned, the return operation may be omitted. Otherwise, it has to be present to indicate which values are going to be returned. For example:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>memref.alloca_scope.return %value</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L429-L440" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.assume_alignment-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.assume_alignment-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.assume_alignment</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>assume_alignment</code></p><p>The <code>assume_alignment</code> operation takes a memref and an integer of alignment value, and internally annotates the buffer with the given alignment. If the buffer isn&#39;t aligned to the given alignment, the behavior is undefined.</p><p>This operation doesn&#39;t affect the semantics of a correct program. It&#39;s for optimization only, and the optimization is best-effort.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L16-L25" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.atomic_rmw-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.atomic_rmw-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.atomic_rmw</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>atomic_rmw</code></p><p>The <code>memref.atomic_rmw</code> operation provides a way to perform a read-modify-write sequence that is free from data races. The kind enumeration specifies the modification to perform. The value operand represents the new value to be applied during the modification. The memref operand represents the buffer that the read and write will be performed against, as accessed by the specified indices. The arity of the indices is the rank of the memref. The result represents the latest value that was stored.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%x = memref.atomic_rmw &quot;addf&quot; %value, %I[%i] : (f32, memref&lt;10xf32&gt;) -&gt; f32</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L45-L61" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.atomic_yield-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.atomic_yield-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.atomic_yield</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>atomic_yield</code></p><p>&quot;memref.atomic_yield&quot; yields an SSA value from a GenericAtomicRMWOp region.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L89-L94" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.cast-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.cast-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.cast</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>cast</code></p><p>The <code>memref.cast</code> operation converts a memref from one type to an equivalent type with a compatible shape. The source and destination types are compatible if:</p><p>a. Both are ranked memref types with the same element type, address space, and rank and:</p><ol><li><p>Both have the same layout or both have compatible strided layouts.</p></li><li><p>The individual sizes (resp. offset and strides in the case of strided memrefs) may convert constant dimensions to dynamic dimensions and vice-versa.</p></li></ol><p>If the cast converts any dimensions from an unknown to a known size, then it acts as an assertion that fails at runtime if the dynamic dimensions disagree with resultant destination size.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Assert that the input dynamic shape matches the destination static shape.</span></span>
<span class="line"><span>%2 = memref.cast %1 : memref&lt;?x?xf32&gt; to memref&lt;4x4xf32&gt;</span></span>
<span class="line"><span>// Erase static shape information, replacing it with dynamic information.</span></span>
<span class="line"><span>%3 = memref.cast %1 : memref&lt;4xf32&gt; to memref&lt;?xf32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// The same holds true for offsets and strides.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Assert that the input dynamic shape matches the destination static stride.</span></span>
<span class="line"><span>%4 = memref.cast %1 : memref&lt;12x4xf32, strided&lt;[?, ?], offset: ?&gt;&gt; to</span></span>
<span class="line"><span>                      memref&lt;12x4xf32, strided&lt;[4, 1], offset: 5&gt;&gt;</span></span>
<span class="line"><span>// Erase static offset and stride information, replacing it with</span></span>
<span class="line"><span>// dynamic information.</span></span>
<span class="line"><span>%5 = memref.cast %1 : memref&lt;12x4xf32, strided&lt;[4, 1], offset: 5&gt;&gt; to</span></span>
<span class="line"><span>                      memref&lt;12x4xf32, strided&lt;[?, ?], offset: ?&gt;&gt;</span></span></code></pre></div><p>b. Either or both memref types are unranked with the same element type, and address space.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Cast to concrete shape.</span></span>
<span class="line"><span>    %4 = memref.cast %1 : memref&lt;*xf32&gt; to memref&lt;4x?xf32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Erase rank information.</span></span>
<span class="line"><span>    %5 = memref.cast %1 : memref&lt;4x?xf32&gt; to memref&lt;*xf32&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L460-L509" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.collapse_shape-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.collapse_shape-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.collapse_shape</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>collapse_shape</code></p><p>The <code>memref.collapse_shape</code> op produces a new view with a smaller rank whose sizes are a reassociation of the original <code>view</code>. The operation is limited to such reassociations, where subsequent, contiguous dimensions are collapsed into a single dimension. Such reassociations never require additional allocs or copies.</p><p>Collapsing non-contiguous dimensions is undefined behavior. When a group of dimensions can be statically proven to be non-contiguous, collapses of such groups are rejected in the verifier on a best-effort basis. In the general case, collapses of dynamically-sized dims with dynamic strides cannot be proven to be contiguous or non-contiguous due to limitations in the memref type.</p><p>A reassociation is defined as a continuous grouping of dimensions and is represented with an array of DenseI64ArrayAttr attribute.</p><p>Note: Only the dimensions within a reassociation group must be contiguous. The remaining dimensions may be non-contiguous.</p><p>The result memref type can be zero-ranked if the source memref type is statically shaped with all dimensions being unit extent. In such a case, the reassociation indices must be empty.</p><p>Examples:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Dimension collapse (i, j) -&gt; i&#39; and k -&gt; k&#39;</span></span>
<span class="line"><span>%1 = memref.collapse_shape %0 [[0, 1], [2]] :</span></span>
<span class="line"><span>    memref&lt;?x?x?xf32, stride_spec&gt; into memref&lt;?x?xf32, stride_spec_2&gt;</span></span></code></pre></div><p>For simplicity, this op may not be used to cast dynamicity of dimension sizes and/or strides. I.e., a result dimension must be dynamic if and only if at least one dimension in the corresponding reassociation group is dynamic. Similarly, the stride of a result dimension must be dynamic if and only if the corresponding start dimension in the source type is dynamic.</p><p>Note: This op currently assumes that the inner strides are of the source/result layout map are the faster-varying ones.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L529-L571" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.copy-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.copy-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.copy</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>copy</code></p><p>Copies the data from the source to the destination memref.</p><p>Usage:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>memref.copy %arg0, %arg1 : memref&lt;?xf32&gt; to memref&lt;?xf32&gt;</span></span></code></pre></div><p>Source and destination are expected to have the same element type and shape. Otherwise, the result is undefined. They may have different layouts.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L114-L127" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.dealloc-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.dealloc-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.dealloc</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>dealloc</code></p><p>The <code>dealloc</code> operation frees the region of memory referenced by a memref which was originally created by the <code>alloc</code> operation. The <code>dealloc</code> operation should not be called on memrefs which alias an alloc&#39;d memref (e.g. memrefs returned by <code>view</code> operations).</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = memref.alloc() : memref&lt;8x64xf32, affine_map&lt;(d0, d1) -&gt; (d0, d1), 1&gt;&gt;</span></span>
<span class="line"><span>memref.dealloc %0 : memref&lt;8x64xf32,  affine_map&lt;(d0, d1) -&gt; (d0, d1), 1&gt;&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L591-L605" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.dim-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.dim-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.dim</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>dim</code></p><p>The <code>dim</code> operation takes a memref and a dimension operand of type <code>index</code>. It returns the size of the requested dimension of the given memref. If the dimension index is out of bounds the behavior is undefined.</p><p>The specified memref type is that of the first operand.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Always returns 4, can be constant folded:</span></span>
<span class="line"><span>%c0 = arith.constant 0 : index</span></span>
<span class="line"><span>%x = memref.dim %A, %c0 : memref&lt;4 x ? x f32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Returns the dynamic dimension of %A.</span></span>
<span class="line"><span>%c1 = arith.constant 1 : index</span></span>
<span class="line"><span>%y = memref.dim %A, %c1 : memref&lt;4 x ? x f32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Equivalent generic form:</span></span>
<span class="line"><span>%x = &quot;memref.dim&quot;(%A, %c0) : (memref&lt;4 x ? x f32&gt;, index) -&gt; index</span></span>
<span class="line"><span>%y = &quot;memref.dim&quot;(%A, %c1) : (memref&lt;4 x ? x f32&gt;, index) -&gt; index</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L625-L649" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.dma_start-Tuple{Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.dma_start-Tuple{Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.dma_start</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>dma_start</code></p><p><strong>Syntax</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>operation ::= `memref.dma_start` ssa-use`[`ssa-use-list`]` `,`</span></span>
<span class="line"><span>               ssa-use`[`ssa-use-list`]` `,` ssa-use `,`</span></span>
<span class="line"><span>               ssa-use`[`ssa-use-list`]` (`,` ssa-use `,` ssa-use)?</span></span>
<span class="line"><span>              `:` memref-type `,` memref-type `,` memref-type</span></span></code></pre></div><p>DmaStartOp starts a non-blocking DMA operation that transfers data from a source memref to a destination memref. The source and destination memref need not be of the same dimensionality, but need to have the same elemental type. The operands include the source and destination memref&#39;s each followed by its indices, size of the data transfer in terms of the number of elements (of the elemental type of the memref), a tag memref with its indices, and optionally at the end, a stride and a number_of_elements_per_stride arguments. The tag location is used by a DmaWaitOp to check for completion. The indices of the source memref, destination memref, and the tag memref have the same restrictions as any load/store. The optional stride arguments should be of &#39;index&#39; type, and specify a stride for the slower memory space (memory space with a lower memory space id), transferring chunks of number_of_elements_per_stride every stride until %num_elements are transferred. Either both or no stride arguments should be specified. If the source and destination locations overlap the behavior of this operation is not defined.</p><p>For example, a DmaStartOp operation that transfers 256 elements of a memref &#39;%src&#39; in memory space 0 at indices [%i, %j] to memref &#39;%dst&#39; in memory space 1 at indices [%k, %l], would be specified as follows:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%num_elements = arith.constant 256</span></span>
<span class="line"><span>%idx = arith.constant 0 : index</span></span>
<span class="line"><span>%tag = memref.alloc() : memref&lt;1 x i32, affine_map&lt;(d0) -&gt; (d0)&gt;, 4&gt;</span></span>
<span class="line"><span>dma_start %src[%i, %j], %dst[%k, %l], %num_elements, %tag[%idx] :</span></span>
<span class="line"><span>  memref&lt;40 x 128 x f32&gt;, affine_map&lt;(d0) -&gt; (d0)&gt;, 0&gt;,</span></span>
<span class="line"><span>  memref&lt;2 x 1024 x f32&gt;, affine_map&lt;(d0) -&gt; (d0)&gt;, 1&gt;,</span></span>
<span class="line"><span>  memref&lt;1 x i32&gt;, affine_map&lt;(d0) -&gt; (d0)&gt;, 2&gt;</span></span></code></pre></div><p>If %stride and %num_elt_per_stride are specified, the DMA is expected to transfer %num_elt_per_stride elements every %stride elements apart from memory space 0 until %num_elements are transferred.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>dma_start %src[%i, %j], %dst[%k, %l], %num_elements, %tag[%idx], %stride,</span></span>
<span class="line"><span>          %num_elt_per_stride :</span></span></code></pre></div><ul><li>TODO: add additional operands to allow source and destination striding, and</li></ul><p>multiple stride levels.</p><ul><li>TODO: Consider replacing src/dst memref indices with view memrefs.</li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L672-L727" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.dma_wait-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.dma_wait-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.dma_wait</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>dma_wait</code></p><p>DmaWaitOp blocks until the completion of a DMA operation associated with the tag element &#39;%tag[%index]&#39;. %tag is a memref, and %index has to be an index with the same restrictions as any load/store index. %num_elements is the number of elements associated with the DMA operation.</p><p><strong>Example</strong></p><p><code>mlir dma_start %src[%i, %j], %dst[%k, %l], %num_elements, %tag[%index] : memref&lt;2048 x f32&gt;, affine_map&lt;(d0) -&gt; (d0)&gt;, 0&gt;, memref&lt;256 x f32&gt;, affine_map&lt;(d0) -&gt; (d0)&gt;, 1&gt; memref&lt;1 x i32&gt;, affine_map&lt;(d0) -&gt; (d0)&gt;, 2&gt; ... ... dma_wait %tag[%index], %num_elements : memref&lt;1 x i32, affine_map&lt;(d0) -&gt; (d0)&gt;, 2&gt;</code></p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L747-L766" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.expand_shape-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.expand_shape-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.expand_shape</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>expand_shape</code></p><p>The <code>memref.expand_shape</code> op produces a new view with a higher rank whose sizes are a reassociation of the original <code>view</code>. The operation is limited to such reassociations, where a dimension is expanded into one or multiple contiguous dimensions. Such reassociations never require additional allocs or copies.</p><p>A reassociation is defined as a grouping of dimensions and is represented with an array of DenseI64ArrayAttr attributes.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%r = memref.expand_shape %0 [[0, 1], [2]] output_shape [%sz0, %sz1, 32]</span></span>
<span class="line"><span>    : memref&lt;?x32xf32&gt; into memref&lt;?x?x32xf32&gt;</span></span></code></pre></div><p>If an op can be statically proven to be invalid (e.g, an expansion from <code>memref&lt;10xf32&gt;</code> to <code>memref&lt;2x6xf32&gt;</code>), it is rejected by the verifier. If it cannot statically be proven invalid (e.g., the full example above; it is unclear whether the first source dimension is divisible by 5), the op is accepted by the verifier. However, if the op is in fact invalid at runtime, the behavior is undefined.</p><p>The source memref can be zero-ranked. In that case, the reassociation indices must be empty and the result shape may only consist of unit dimensions.</p><p>For simplicity, this op may not be used to cast dynamicity of dimension sizes and/or strides. I.e., if and only if a source dimension is dynamic, there must be a dynamic result dimension in the corresponding reassociation group. Same for strides.</p><p>The representation for the output shape supports a partially-static specification via attributes specified through the <code>static_output_shape</code> argument. A special sentinel value <code>ShapedType::kDynamic</code> encodes that the corresponding entry has a dynamic value. There must be exactly as many SSA inputs in <code>output_shape</code> as there are <code>ShapedType::kDynamic</code> entries in <code>static_output_shape</code>.</p><p>Note: This op currently assumes that the inner strides are of the source/result layout map are the faster-varying ones.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L788-L832" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.extract_aligned_pointer_as_index-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.extract_aligned_pointer_as_index-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.extract_aligned_pointer_as_index</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>extract_aligned_pointer_as_index</code></p><p>Extracts the underlying aligned pointer as an index.</p><p>This operation is useful for lowering to lower-level dialects while still avoiding the need to define a pointer type in higher-level dialects such as the memref dialect.</p><p>This operation is intended solely as step during lowering, it has no side effects. A reverse operation that creates a memref from an index interpreted as a pointer is explicitly discouraged.</p><p><strong>Example</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  %0 = memref.extract_aligned_pointer_as_index %arg : memref&lt;4x4xf32&gt; -&gt; index</span></span>
<span class="line"><span>  %1 = arith.index_cast %0 : index to i64</span></span>
<span class="line"><span>  %2 = llvm.inttoptr %1 : i64 to !llvm.ptr</span></span>
<span class="line"><span>  call @foo(%2) : (!llvm.ptr) -&gt;()</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L862-L883" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.extract_strided_metadata-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.extract_strided_metadata-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.extract_strided_metadata</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>extract_strided_metadata</code></p><p>Extracts a base buffer, offset and strides. This op allows additional layers of transformations and foldings to be added as lowering progresses from higher-level dialect to lower-level dialects such as the LLVM dialect.</p><p>The op requires a strided memref source operand. If the source operand is not a strided memref, then verification fails.</p><p>This operation is also useful for completeness to the existing memref.dim op. While accessing strides, offsets and the base pointer independently is not available, this is useful for composing with its natural complement op: <code>memref.reinterpret_cast</code>.</p><p>Intended Use Cases:</p><p>The main use case is to expose the logic for manipulate memref metadata at a higher level than the LLVM dialect. This makes lowering more progressive and brings the following benefits:</p><ul><li><p>not all users of MLIR want to lower to LLVM and the information to e.g. lower to library calls–-like libxsmm–-or to SPIR-V was not available.</p></li><li><p>foldings and canonicalizations can happen at a higher level in MLIR: before this op existed, lowering to LLVM would create large amounts of LLVMIR. Even when LLVM does a good job at folding the low-level IR from a performance perspective, it is unnecessarily opaque and inefficient to send unkempt IR to LLVM.</p></li></ul><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  %base, %offset, %sizes:2, %strides:2 =</span></span>
<span class="line"><span>    memref.extract_strided_metadata %memref :</span></span>
<span class="line"><span>      memref&lt;10x?xf32&gt;, index, index, index, index, index</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // After folding, the type of %m2 can be memref&lt;10x?xf32&gt; and further</span></span>
<span class="line"><span>  // folded to %memref.</span></span>
<span class="line"><span>  %m2 = memref.reinterpret_cast %base to</span></span>
<span class="line"><span>      offset: [%offset],</span></span>
<span class="line"><span>      sizes: [%sizes#0, %sizes#1],</span></span>
<span class="line"><span>      strides: [%strides#0, %strides#1]</span></span>
<span class="line"><span>    : memref&lt;f32&gt; to memref&lt;?x?xf32, offset: ?, strides: [?, ?]&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L906-L949" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.generic_atomic_rmw-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.generic_atomic_rmw-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.generic_atomic_rmw</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>generic_atomic_rmw</code></p><p>The <code>memref.generic_atomic_rmw</code> operation provides a way to perform a read-modify-write sequence that is free from data races. The memref operand represents the buffer that the read and write will be performed against, as accessed by the specified indices. The arity of the indices is the rank of the memref. The result represents the latest value that was stored. The region contains the code for the modification itself. The entry block has a single argument that represents the value stored in <code>memref[indices]</code> before the write is performed. No side-effecting ops are allowed in the body of <code>GenericAtomicRMWOp</code>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%x = memref.generic_atomic_rmw %I[%i] : memref&lt;10xf32&gt; {</span></span>
<span class="line"><span>  ^bb0(%current_value : f32):</span></span>
<span class="line"><span>    %c1 = arith.constant 1.0 : f32</span></span>
<span class="line"><span>    %inc = arith.addf %c1, %current_value : f32</span></span>
<span class="line"><span>    memref.atomic_yield %inc : f32</span></span>
<span class="line"><span>}</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L147-L170" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.get_global-Tuple{}" href="#Reactant.MLIR.Dialects.memref.get_global-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.get_global</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>get_global</code></p><p>The <code>memref.get_global</code> operation retrieves the memref pointing to a named global variable. If the global variable is marked constant, writing to the result memref (such as through a <code>memref.store</code> operation) is undefined.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%x = memref.get_global @foo : memref&lt;2xf32&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L980-L993" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.global_-Tuple{}" href="#Reactant.MLIR.Dialects.memref.global_-Tuple{}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.global_</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>global_</code></p><p>The <code>memref.global</code> operation declares or defines a named global memref variable. The backing memory for the variable is allocated statically and is described by the type of the variable (which should be a statically shaped memref type). The operation is a declaration if no <code>initial_value</code> is specified, else it is a definition. The <code>initial_value</code> can either be a unit attribute to represent a definition of an uninitialized global variable, or an elements attribute to represent the definition of a global variable with an initial value. The global variable can also be marked constant using the <code>constant</code> unit attribute. Writing to such constant global variables is undefined.</p><p>The global variable can be accessed by using the <code>memref.get_global</code> to retrieve the memref for the global variable. Note that the memref for such global variable itself is immutable (i.e., memref.get_global for a given global variable will always return the same memref descriptor).</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Private variable with an initial value.</span></span>
<span class="line"><span>memref.global &quot;private&quot; @x : memref&lt;2xf32&gt; = dense&lt;0.0,2.0&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Private variable with an initial value and an alignment (power of 2).</span></span>
<span class="line"><span>memref.global &quot;private&quot; @x : memref&lt;2xf32&gt; = dense&lt;0.0,2.0&gt; {alignment = 64}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Declaration of an external variable.</span></span>
<span class="line"><span>memref.global &quot;private&quot; @y : memref&lt;4xi32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Uninitialized externally visible variable.</span></span>
<span class="line"><span>memref.global @z : memref&lt;3xf16&gt; = uninitialized</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Externally visible constant variable.</span></span>
<span class="line"><span>memref.global constant @c : memref&lt;2xi32&gt; = dense&lt;1, 4&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L1013-L1050" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.load-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.load</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>load</code></p><p>The <code>load</code> op reads an element from a memref at the specified indices.</p><p>The number of indices must match the rank of the memref. The indices must be in-bounds: <code>0 &lt;= idx &lt; dim_size</code></p><p>The single result of <code>memref.load</code> is a value with the same type as the element type of the memref.</p><p>A set <code>nontemporal</code> attribute indicates that this load is not expected to be reused in the cache. For details, refer to the <a href="./LLVM load instruction">https://llvm.org/docs/LangRef.html#load-instruction</a>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = memref.load %A[%a, %b] : memref&lt;8x?xi32, #layout, memspace0&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L196-L216" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.memory_space_cast-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.memory_space_cast-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.memory_space_cast</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>memory_space_cast</code></p><p>This operation casts memref values between memory spaces. The input and result will be memrefs of the same types and shape that alias the same underlying memory, though, for some casts on some targets, the underlying values of the pointer stored in the memref may be affected by the cast.</p><p>The input and result must have the same shape, element type, rank, and layout.</p><p>If the source and target address spaces are the same, this operation is a noop.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Cast a GPU private memory attribution into a generic pointer</span></span>
<span class="line"><span>%2 = memref.memory_space_cast %1 : memref&lt;?xf32, 5&gt; to memref&lt;?xf32&gt;</span></span>
<span class="line"><span>// Cast a generic pointer to workgroup-local memory</span></span>
<span class="line"><span>%4 = memref.memory_space_cast %3 : memref&lt;5x4xi32&gt; to memref&lt;5x34xi32, 3&gt;</span></span>
<span class="line"><span>// Cast between two non-default memory spaces</span></span>
<span class="line"><span>%6 = memref.memory_space_cast %5</span></span>
<span class="line"><span>  : memref&lt;*xmemref&lt;?xf32&gt;, 5&gt; to memref&lt;*xmemref&lt;?xf32&gt;, 3&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L1086-L1110" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.prefetch-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.prefetch-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.prefetch</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>prefetch</code></p><p>The &quot;prefetch&quot; op prefetches data from a memref location described with subscript indices similar to memref.load, and with three attributes: a read/write specifier, a locality hint, and a cache type specifier as shown below:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>memref.prefetch %0[%i, %j], read, locality&lt;3&gt;, data : memref&lt;400x400xi32&gt;</span></span></code></pre></div><p>The read/write specifier is either &#39;read&#39; or &#39;write&#39;, the locality hint ranges from locality&lt;0&gt; (no locality) to locality&lt;3&gt; (extremely local keep in cache). The cache type specifier is either &#39;data&#39; or &#39;instr&#39; and specifies whether the prefetch is performed on data cache or on instruction cache.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L1130-L1147" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.rank-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.rank-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.rank</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>rank</code></p><p>The <code>memref.rank</code> operation takes a memref operand and returns its rank.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = memref.rank %arg0 : memref&lt;*xf32&gt;</span></span>
<span class="line"><span>%1 = memref.rank %arg1 : memref&lt;?x?xf32&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L1178-L1189" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.realloc" href="#Reactant.MLIR.Dialects.memref.realloc"><span class="jlbinding">Reactant.MLIR.Dialects.memref.realloc</span></a> <span class="VPBadge info jlObjectType jlFunction"><!--[-->Function<!--]--></span></summary><p><code>realloc</code></p><p>The <code>realloc</code> operation changes the size of a memory region. The memory region is specified by a 1D source memref and the size of the new memory region is specified by a 1D result memref type and an optional dynamic Value of <code>Index</code> type. The source and the result memref must be in the same memory space and have the same element type.</p><p>The operation may move the memory region to a new location. In this case, the content of the memory block is preserved up to the lesser of the new and old sizes. If the new size if larger, the value of the extended memory is undefined. This is consistent with the ISO C realloc.</p><p>The operation returns an SSA value for the memref.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%0 = memref.realloc %src : memref&lt;64xf32&gt; to memref&lt;124xf32&gt;</span></span></code></pre></div><p>The source memref may have a dynamic shape, in which case, the compiler will generate code to extract its size from the runtime data structure for the memref.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = memref.realloc %src : memref&lt;?xf32&gt; to memref&lt;124xf32&gt;</span></span></code></pre></div><p>If the result memref has a dynamic shape, a result dimension operand is needed to spefify its dynamic dimension. In the example below, the ssa value &#39;%d&#39; specifies the unknown dimension of the result memref.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%2 = memref.realloc %src(%d) : memref&lt;?xf32&gt; to memref&lt;?xf32&gt;</span></span></code></pre></div><p>An optional <code>alignment</code> attribute may be specified to ensure that the region of memory that will be indexed is aligned at the specified byte boundary. This is consistent with the fact that memref.alloc supports such an optional alignment attribute. Note that in ISO C standard, neither alloc nor realloc supports alignment, though there is aligned_alloc but not aligned_realloc.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%3 = memref.realloc %src {alignment = 8} : memref&lt;64xf32&gt; to memref&lt;124xf32&gt;</span></span></code></pre></div><p>Referencing the memref through the old SSA value after realloc is undefined behavior.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%new = memref.realloc %old : memref&lt;64xf32&gt; to memref&lt;124xf32&gt;</span></span>
<span class="line"><span>%4 = memref.load %new[%index]</span><span>   // ok</span></span>
<span class="line"><span>%5 = memref.load %old[%index]</span><span>   // undefined behavior</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L1210-L1267" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.reinterpret_cast-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.reinterpret_cast-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.reinterpret_cast</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>reinterpret_cast</code></p><p>Modify offset, sizes and strides of an unranked/ranked memref.</p><p>Example 1:</p><p>Consecutive <code>reinterpret_cast</code> operations on memref&#39;s with static dimensions.</p><p>We distinguish between <em>underlying memory</em> — the sequence of elements as they appear in the contiguous memory of the memref — and the <em>strided memref</em>, which refers to the underlying memory interpreted according to specified offsets, sizes, and strides.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result1 = memref.reinterpret_cast %arg0 to </span></span>
<span class="line"><span>  offset: [9],</span></span>
<span class="line"><span>  sizes: [4, 4],</span></span>
<span class="line"><span>  strides: [16, 2]</span></span>
<span class="line"><span>: memref&lt;8x8xf32, strided&lt;[8, 1], offset: 0&gt;&gt; to</span></span>
<span class="line"><span>  memref&lt;4x4xf32, strided&lt;[16, 2], offset: 9&gt;&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>%result2 = memref.reinterpret_cast %result1 to </span></span>
<span class="line"><span>  offset: [0],</span></span>
<span class="line"><span>  sizes: [2, 2],</span></span>
<span class="line"><span>  strides: [4, 2]</span></span>
<span class="line"><span>: memref&lt;4x4xf32, strided&lt;[16, 2], offset: 9&gt;&gt; to</span></span>
<span class="line"><span>  memref&lt;2x2xf32, strided&lt;[4, 2], offset: 0&gt;&gt;</span></span></code></pre></div><p>The underlying memory of <code>%arg0</code> consists of a linear sequence of integers from 1 to 64. Its memref has the following 8x8 elements:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[[1,  2,  3,  4,  5,  6,  7,  8],</span></span>
<span class="line"><span>[9,  10, 11, 12, 13, 14, 15, 16],</span></span>
<span class="line"><span>[17, 18, 19, 20, 21, 22, 23, 24],</span></span>
<span class="line"><span>[25, 26, 27, 28, 29, 30, 31, 32],</span></span>
<span class="line"><span>[33, 34, 35, 36, 37, 38, 39, 40],</span></span>
<span class="line"><span>[41, 42, 43, 44, 45, 46, 47, 48],</span></span>
<span class="line"><span>[49, 50, 51, 52, 53, 54, 55, 56],</span></span>
<span class="line"><span>[57, 58, 59, 60, 61, 62, 63, 64]]</span></span></code></pre></div><p>Following the first <code>reinterpret_cast</code>, the strided memref elements of <code>%result1</code> are:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[[10, 12, 14, 16],</span></span>
<span class="line"><span>[26, 28, 30, 32],</span></span>
<span class="line"><span>[42, 44, 46, 48],</span></span>
<span class="line"><span>[58, 60, 62, 64]]</span></span></code></pre></div><p>Note: The offset and strides are relative to the underlying memory of <code>%arg0</code>.</p><p>The second <code>reinterpret_cast</code> results in the following strided memref for <code>%result2</code>:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[[1, 3],</span></span>
<span class="line"><span>[5, 7]]</span></span></code></pre></div><p>Notice that it does not matter if you use %result1 or %arg0 as a source for the second <code>reinterpret_cast</code> operation. Only the underlying memory pointers will be reused.</p><p>The offset and stride are relative to the base underlying memory of the memref, starting at 1, not at 10 as seen in the output of <code>%result1</code>. This behavior contrasts with the <code>subview</code> operator, where values are relative to the strided memref (refer to <code>subview</code> examples). Consequently, the second <code>reinterpret_cast</code> behaves as if <code>%arg0</code> were passed directly as its argument.</p><p>Example 2:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>memref.reinterpret_cast %ranked to</span></span>
<span class="line"><span>  offset: [0],</span></span>
<span class="line"><span>  sizes: [%size0, 10],</span></span>
<span class="line"><span>  strides: [1, %stride1]</span></span>
<span class="line"><span>: memref&lt;?x?xf32&gt; to memref&lt;?x10xf32, strided&lt;[1, ?], offset: 0&gt;&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>memref.reinterpret_cast %unranked to</span></span>
<span class="line"><span>  offset: [%offset],</span></span>
<span class="line"><span>  sizes: [%size0, %size1],</span></span>
<span class="line"><span>  strides: [%stride0, %stride1]</span></span>
<span class="line"><span>: memref&lt;*xf32&gt; to memref&lt;?x?xf32, strided&lt;[?, ?], offset: ?&gt;&gt;</span></span></code></pre></div><p>This operation creates a new memref descriptor using the base of the source and applying the input arguments to the other metadata. In other words:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%dst = memref.reinterpret_cast %src to</span></span>
<span class="line"><span>  offset: [%offset],</span></span>
<span class="line"><span>  sizes: [%sizes],</span></span>
<span class="line"><span>  strides: [%strides]</span></span></code></pre></div><p>means that <code>%dst</code>&#39;s descriptor will be:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%dst.base = %src.base</span></span>
<span class="line"><span>%dst.aligned = %src.aligned</span></span>
<span class="line"><span>%dst.offset = %offset</span></span>
<span class="line"><span>%dst.sizes = %sizes</span></span>
<span class="line"><span>%dst.strides = %strides</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L1295-L1404" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.reshape-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.reshape-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.reshape</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>reshape</code></p><p>The <code>reshape</code> operation converts a memref from one type to an equivalent type with a provided shape. The data is never copied or modified. The source and destination types are compatible if both have the same element type, same number of elements, address space and identity layout map. The following combinations are possible:</p><p>a. Source type is ranked or unranked. Shape argument has static size. Result type is ranked.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Reshape statically-shaped memref.</span></span>
<span class="line"><span>%dst = memref.reshape %src(%shape)</span></span>
<span class="line"><span>         : (memref&lt;4x1xf32&gt;, memref&lt;1xi32&gt;) to memref&lt;4xf32&gt;</span></span>
<span class="line"><span>%dst0 = memref.reshape %src(%shape0)</span></span>
<span class="line"><span>         : (memref&lt;4x1xf32&gt;, memref&lt;2xi32&gt;) to memref&lt;2x2xf32&gt;</span></span>
<span class="line"><span>// Flatten unranked memref.</span></span>
<span class="line"><span>%dst = memref.reshape %src(%shape)</span></span>
<span class="line"><span>         : (memref&lt;*xf32&gt;, memref&lt;1xi32&gt;) to memref&lt;?xf32&gt;</span></span></code></pre></div><p>b. Source type is ranked or unranked. Shape argument has dynamic size. Result type is unranked.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Reshape dynamically-shaped 1D memref.</span></span>
<span class="line"><span>%dst = memref.reshape %src(%shape)</span></span>
<span class="line"><span>         : (memref&lt;?xf32&gt;, memref&lt;?xi32&gt;) to memref&lt;*xf32&gt;</span></span>
<span class="line"><span>// Reshape unranked memref.</span></span>
<span class="line"><span>%dst = memref.reshape %src(%shape)</span></span>
<span class="line"><span>         : (memref&lt;*xf32&gt;, memref&lt;?xi32&gt;) to memref&lt;*xf32&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L1442-L1476" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.store-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.store-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.store</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>store</code></p><p>The <code>store</code> op stores an element into a memref at the specified indices.</p><p>The number of indices must match the rank of the memref. The indices must be in-bounds: <code>0 &lt;= idx &lt; dim_size</code></p><p>A set <code>nontemporal</code> attribute indicates that this store is not expected to be reused in the cache. For details, refer to the <a href="./LLVM store instruction">https://llvm.org/docs/LangRef.html#store-instruction</a>.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>memref.store %val, %A[%a, %b] : memref&lt;8x?xi32, #layout, memspace0&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L1496-L1513" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.subview-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.subview-Tuple{Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.subview</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>subview</code></p><p>The <code>subview</code> operation converts a memref type to a memref type which represents a reduced-size view of the original memref as specified by the operation&#39;s offsets, sizes and strides arguments.</p><p>The <code>subview</code> operation supports the following arguments:</p><ul><li><p>source: the &quot;base&quot; memref on which to create a &quot;view&quot; memref.</p></li><li><p>offsets: memref-rank number of offsets into the &quot;base&quot; memref at which to create the &quot;view&quot; memref.</p></li><li><p>sizes: memref-rank number of sizes which specify the sizes of the result &quot;view&quot; memref type.</p></li><li><p>strides: memref-rank number of strides that compose multiplicatively with the base memref strides in each dimension.</p></li></ul><p>The representation based on offsets, sizes and strides support a partially-static specification via attributes specified through the <code>static_offsets</code>, <code>static_sizes</code> and <code>static_strides</code> arguments. A special sentinel value <code>ShapedType::kDynamic</code> encodes that the corresponding entry has a dynamic value.</p><p>A <code>subview</code> operation may additionally reduce the rank of the resulting view by removing dimensions that are statically known to be of size 1.</p><p>In the absence of rank reductions, the resulting memref type is computed as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>result_sizes[i] = size_operands[i]</span></span>
<span class="line"><span>result_strides[i] = src_strides[i] * stride_operands[i]</span></span>
<span class="line"><span>result_offset = src_offset + dot_product(offset_operands, src_strides)</span></span></code></pre></div><p>The offset, size and stride operands must be in-bounds with respect to the source memref. When possible, the static operation verifier will detect out-of-bounds subviews. Subviews that cannot be confirmed to be in-bounds or out-of-bounds based on compile-time information are valid. However, performing an out-of-bounds subview at runtime is undefined behavior.</p><p>Example 1:</p><p>Consecutive <code>subview</code> operations on memref&#39;s with static dimensions.</p><p>We distinguish between <em>underlying memory</em> — the sequence of elements as they appear in the contiguous memory of the memref — and the <em>strided memref</em>, which refers to the underlying memory interpreted according to specified offsets, sizes, and strides.</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%result1 = memref.subview %arg0[1, 1][4, 4][2, 2]</span></span>
<span class="line"><span>: memref&lt;8x8xf32, strided&lt;[8, 1], offset: 0&gt;&gt; to</span></span>
<span class="line"><span>  memref&lt;4x4xf32, strided&lt;[16, 2], offset: 9&gt;&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>%result2 = memref.subview %result1[1, 1][2, 2][2, 2]</span></span>
<span class="line"><span>: memref&lt;4x4xf32, strided&lt;[16, 2], offset: 9&gt;&gt; to</span></span>
<span class="line"><span>  memref&lt;2x2xf32, strided&lt;[32, 4], offset: 27&gt;&gt;</span></span></code></pre></div><p>The underlying memory of <code>%arg0</code> consists of a linear sequence of integers from 1 to 64. Its memref has the following 8x8 elements:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[[1,  2,  3,  4,  5,  6,  7,  8],</span></span>
<span class="line"><span>[9,  10, 11, 12, 13, 14, 15, 16],</span></span>
<span class="line"><span>[17, 18, 19, 20, 21, 22, 23, 24],</span></span>
<span class="line"><span>[25, 26, 27, 28, 29, 30, 31, 32],</span></span>
<span class="line"><span>[33, 34, 35, 36, 37, 38, 39, 40],</span></span>
<span class="line"><span>[41, 42, 43, 44, 45, 46, 47, 48],</span></span>
<span class="line"><span>[49, 50, 51, 52, 53, 54, 55, 56],</span></span>
<span class="line"><span>[57, 58, 59, 60, 61, 62, 63, 64]]</span></span></code></pre></div><p>Following the first <code>subview</code>, the strided memref elements of <code>%result1</code> are:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[[10, 12, 14, 16],</span></span>
<span class="line"><span>[26, 28, 30, 32],</span></span>
<span class="line"><span>[42, 44, 46, 48],</span></span>
<span class="line"><span>[58, 60, 62, 64]]</span></span></code></pre></div><p>Note: The offset and strides are relative to the strided memref of <code>%arg0</code> (compare to the corresponding <code>reinterpret_cast</code> example).</p><p>The second <code>subview</code> results in the following strided memref for <code>%result2</code>:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[[28, 32],</span></span>
<span class="line"><span>[60, 64]]</span></span></code></pre></div><p>Unlike the <code>reinterpret_cast</code>, the values are relative to the strided memref of the input (<code>%result1</code> in this case) and not its underlying memory.</p><p>Example 2:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Subview of static memref with strided layout at static offsets, sizes</span></span>
<span class="line"><span>// and strides.</span></span>
<span class="line"><span>%1 = memref.subview %0[4, 2][8, 2][3, 2]</span></span>
<span class="line"><span>    : memref&lt;64x4xf32, strided&lt;[7, 9], offset: 91&gt;&gt; to</span></span>
<span class="line"><span>      memref&lt;8x2xf32, strided&lt;[21, 18], offset: 137&gt;&gt;</span></span></code></pre></div><p>Example 3:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Subview of static memref with identity layout at dynamic offsets, sizes</span></span>
<span class="line"><span>// and strides.</span></span>
<span class="line"><span>%1 = memref.subview %0[%off0, %off1][%sz0, %sz1][%str0, %str1]</span></span>
<span class="line"><span>    : memref&lt;64x4xf32&gt; to memref&lt;?x?xf32, strided&lt;[?, ?], offset: ?&gt;&gt;</span></span></code></pre></div><p>Example 4:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Subview of dynamic memref with strided layout at dynamic offsets and</span></span>
<span class="line"><span>// strides, but static sizes.</span></span>
<span class="line"><span>%1 = memref.subview %0[%off0, %off1][4, 4][%str0, %str1]</span></span>
<span class="line"><span>    : memref&lt;?x?xf32, strided&lt;[?, ?], offset: ?&gt;&gt; to</span></span>
<span class="line"><span>      memref&lt;4x4xf32, strided&lt;[?, ?], offset: ?&gt;&gt;</span></span></code></pre></div><p>Example 5:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Rank-reducing subviews.</span></span>
<span class="line"><span>%1 = memref.subview %0[0, 0, 0][1, 16, 4][1, 1, 1]</span></span>
<span class="line"><span>    : memref&lt;8x16x4xf32&gt; to memref&lt;16x4xf32&gt;</span></span>
<span class="line"><span>%3 = memref.subview %2[3, 4, 2][1, 6, 3][1, 1, 1]</span></span>
<span class="line"><span>    : memref&lt;8x16x4xf32&gt; to memref&lt;6x3xf32, strided&lt;[4, 1], offset: 210&gt;&gt;</span></span></code></pre></div><p>Example 6:</p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Identity subview. The subview is the full source memref.</span></span>
<span class="line"><span>%1 = memref.subview %0[0, 0, 0] [8, 16, 4] [1, 1, 1]</span></span>
<span class="line"><span>    : memref&lt;8x16x4xf32&gt; to memref&lt;8x16x4xf32&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L1635-L1779" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.transpose-Tuple{Reactant.MLIR.IR.Value}" href="#Reactant.MLIR.Dialects.memref.transpose-Tuple{Reactant.MLIR.IR.Value}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.transpose</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>transpose</code></p><p>The <code>transpose</code> op produces a strided memref whose sizes and strides are a permutation of the original <code>in</code> memref. This is purely a metadata transformation.</p><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>%1 = memref.transpose %0 (i, j) -&gt; (j, i) : memref&lt;?x?xf32&gt; to memref&lt;?x?xf32, affine_map&lt;(d0, d1)[s0] -&gt; (d1 * s0 + d0)&gt;&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L1540-L1552" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block"><summary><a id="Reactant.MLIR.Dialects.memref.view-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}" href="#Reactant.MLIR.Dialects.memref.view-Tuple{Reactant.MLIR.IR.Value, Reactant.MLIR.IR.Value, Vector{Reactant.MLIR.IR.Value}}"><span class="jlbinding">Reactant.MLIR.Dialects.memref.view</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><p><code>view</code></p><p>The &quot;view&quot; operation extracts an N-D contiguous memref with empty layout map with arbitrary element type from a 1-D contiguous memref with empty layout map of i8 element type. The ViewOp supports the following arguments:</p><ul><li><p>A single dynamic byte-shift operand must be specified which represents a a shift of the base 1-D memref pointer from which to create the resulting contiguous memref view with identity layout.</p></li><li><p>A dynamic size operand that must be specified for each dynamic dimension in the resulting view memref type.</p></li></ul><p>The &quot;view&quot; operation gives a structured indexing form to a flat 1-D buffer. Unlike &quot;subview&quot; it can perform a type change. The type change behavior requires the op to have special semantics because, e.g. a byte shift of 3 cannot be represented as an offset on f64. For now, a &quot;view&quot; op:</p><ol><li><p>Only takes a contiguous source memref with 0 offset and empty layout.</p></li><li><p>Must specify a byte_shift operand (in the future, a special integer attribute may be added to support the folded case).</p></li><li><p>Returns a contiguous memref with 0 offset and empty layout.</p></li></ol><p><strong>Example</strong></p><div class="language-mlir vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mlir</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Allocate a flat 1D/i8 memref.</span></span>
<span class="line"><span>%0 = memref.alloc() : memref&lt;2048xi8&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ViewOp with dynamic offset and static sizes.</span></span>
<span class="line"><span>%1 = memref.view %0[%offset_1024][] : memref&lt;2048xi8&gt; to memref&lt;64x4xf32&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ViewOp with dynamic offset and two dynamic size.</span></span>
<span class="line"><span>%2 = memref.view %0[%offset_1024][%size0, %size1] :</span></span>
<span class="line"><span>  memref&lt;2048xi8&gt; to memref&lt;?x4x?xf32&gt;</span></span></code></pre></div><span class="VPBadge info source-link"><!--[--><a href="https://github.com/EnzymeAD/Reactant.jl/blob/296ddeb6000fa6cb254c115f8a60c3400ae72f5b/src/mlir/Dialects/MemRef.jl#L1572-L1609" target="_blank" rel="noreferrer">source</a><!--]--></span></details></div></div></main><footer class="VPDocFooter" data-v-83890dd9 data-v-4f9813fa><!--[--><!--]--><div class="edit-info" data-v-4f9813fa><div class="edit-link" data-v-4f9813fa><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/EnzymeAD/Reactant.jl/edit/main/docs/src/api/dialects/memref.md" target="_blank" rel="noreferrer" data-v-4f9813fa><!--[--><span class="vpi-square-pen edit-link-icon" data-v-4f9813fa></span> Edit this page on GitHub<!--]--></a></div><!----></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-4f9813fa><span class="visually-hidden" id="doc-footer-aria-label" data-v-4f9813fa>Pager</span><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link prev" href="/Reactant.jl/previews/PR1260/api/dialects/mpi" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Previous page</span><span class="title" data-v-4f9813fa>MPI</span><!--]--></a></div><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link next" href="/Reactant.jl/previews/PR1260/api/dialects/nvvm" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Next page</span><span class="title" data-v-4f9813fa>NVVM</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-a9a9e638 data-v-c970a860><div class="container" data-v-c970a860><p class="message" data-v-c970a860>Made with <a href="https://documenter.juliadocs.org/stable/" target="_blank"><strong>Documenter.jl</strong></a>, <a href="https://vitepress.dev" target="_blank"><strong>VitePress</strong></a> and <a href="https://luxdl.github.io/DocumenterVitepress.jl/stable" target="_blank"><strong>DocumenterVitepress.jl</strong></a><br>Released under the MIT License. Powered by the <a href="https://www.julialang.org">Julia Programming Language</a>.<br></p><p class="copyright" data-v-c970a860>© Copyright 2025 Reactant Development Team.</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"api_api.md\":\"DHfJIIHP\",\"api_config.md\":\"BBM5dHYn\",\"api_dialects_affine.md\":\"Ba9rKDmD\",\"api_dialects_arith.md\":\"BXQiPcB9\",\"api_dialects_builtin.md\":\"BhhUNErm\",\"api_dialects_chlo.md\":\"H_ars6_P\",\"api_dialects_enzyme.md\":\"CedvGmXu\",\"api_dialects_enzymexla.md\":\"CIm_9aAQ\",\"api_dialects_func.md\":\"lZqwdiyc\",\"api_dialects_gpu.md\":\"BO5qo_az\",\"api_dialects_llvm.md\":\"KLWP_Mqr\",\"api_dialects_memref.md\":\"DHzkTljZ\",\"api_dialects_mpi.md\":\"DPRSfg8u\",\"api_dialects_nvvm.md\":\"DHekB4lW\",\"api_dialects_shardy.md\":\"B4LLjP2x\",\"api_dialects_sparsetensor.md\":\"CZaMEQ86\",\"api_dialects_stablehlo.md\":\"CwXvtClA\",\"api_dialects_tpu.md\":\"CepmU57P\",\"api_dialects_triton.md\":\"C8Cu69NZ\",\"api_dialects_vhlo.md\":\"BsP9VZ3L\",\"api_internal.md\":\"BzG-KX07\",\"api_mlirc.md\":\"BKHPR92o\",\"api_ops.md\":\"Cp8Ywit3\",\"api_sharding.md\":\"Bt3ZkzhP\",\"api_xla.md\":\"DSzIAI1D\",\"index.md\":\"DadpO8oU\",\"introduction_configuration.md\":\"Ds8M0vxi\",\"introduction_index.md\":\"BPrKESxg\",\"tutorials_index.md\":\"DW6Itj-G\",\"tutorials_local-build.md\":\"QLjzVswV\",\"tutorials_multihost.md\":\"B0T_K79s\",\"tutorials_profiling.md\":\"BIWvBEHl\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Reactant.jl\",\"description\":\"Documentation for Reactant.jl\",\"base\":\"/Reactant.jl/previews/PR1260/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"outline\":\"deep\",\"logo\":{\"light\":\"/logo.svg\",\"dark\":\"/logo.svg\"},\"search\":{\"provider\":\"local\",\"options\":{\"detailedView\":true}},\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Getting Started\",\"items\":[{\"text\":\"Introduction\",\"link\":\"/introduction\"},{\"text\":\"Configuration\",\"link\":\"/introduction/configuration\"}]},{\"text\":\"Benchmarks\",\"link\":\"https://enzymead.github.io/Reactant.jl/benchmarks/\"},{\"text\":\"Tutorials\",\"items\":[{\"text\":\"Overview\",\"link\":\"/tutorials/\"},{\"text\":\"Profiling\",\"link\":\"/tutorials/profiling\"},{\"text\":\"Distributed\",\"link\":\"/tutorials/multihost\"},{\"text\":\"Local build\",\"link\":\"/tutorials/local-build\"}]},{\"text\":\"API\",\"items\":[{\"text\":\"Core Reactant API\",\"link\":\"/api/api\"},{\"text\":\"Sharding\",\"link\":\"/api/sharding\"},{\"text\":\"Ops\",\"link\":\"/api/ops\"},{\"text\":\"Configuration\",\"link\":\"/api/config\"},{\"text\":\"MLIR Dialects\",\"items\":[{\"text\":\"ArithOps\",\"link\":\"/api/dialects/arith\"},{\"text\":\"Affine\",\"link\":\"/api/dialects/affine\"},{\"text\":\"Builtin\",\"link\":\"/api/dialects/builtin\"},{\"text\":\"Chlo\",\"link\":\"/api/dialects/chlo\"},{\"text\":\"Enzyme\",\"link\":\"/api/dialects/enzyme\"},{\"text\":\"EnzymeXLA\",\"link\":\"/api/dialects/enzymexla\"},{\"text\":\"Func\",\"link\":\"/api/dialects/func\"},{\"text\":\"GPU\",\"link\":\"/api/dialects/gpu\"},{\"text\":\"LLVM\",\"link\":\"/api/dialects/llvm\"},{\"text\":\"MPI\",\"link\":\"/api/dialects/mpi\"},{\"text\":\"MemRef\",\"link\":\"/api/dialects/memref\"},{\"text\":\"NVVM\",\"link\":\"/api/dialects/nvvm\"},{\"text\":\"Shardy\",\"link\":\"/api/dialects/shardy\"},{\"text\":\"SparseTensor\",\"link\":\"/api/dialects/sparsetensor\"},{\"text\":\"StableHLO\",\"link\":\"/api/dialects/stablehlo\"},{\"text\":\"Triton\",\"link\":\"/api/dialects/triton\"},{\"text\":\"TPU\",\"link\":\"/api/dialects/tpu\"},{\"text\":\"VHLO\",\"link\":\"/api/dialects/vhlo\"}]},{\"text\":\"Low-Level API\",\"items\":[{\"text\":\"MLIR API\",\"link\":\"/api/mlirc\"},{\"text\":\"XLA\",\"link\":\"/api/xla\"}]},{\"text\":\"Internal API\",\"link\":\"/api/internal\"}]},{\"component\":\"VersionPicker\"}],\"sidebar\":{\"/introduction/\":[{\"text\":\"Getting Started\",\"collapsed\":false,\"items\":[{\"text\":\"Introduction\",\"link\":\"/introduction\"},{\"text\":\"Configuration\",\"link\":\"/introduction/configuration\"}]}],\"/tutorials/\":[{\"text\":\"Tutorials\",\"collapsed\":false,\"items\":[{\"text\":\"Overview\",\"link\":\"/tutorials/\"},{\"text\":\"Profiling\",\"link\":\"/tutorials/profiling\"},{\"text\":\"Distributed\",\"link\":\"/tutorials/multihost\"},{\"text\":\"Local build\",\"link\":\"/tutorials/local-build\"}]}],\"/api/\":[{\"text\":\"API Reference\",\"collapsed\":false,\"items\":[{\"text\":\"Reactant API\",\"link\":\"/api/api\"},{\"text\":\"Sharding\",\"link\":\"/api/sharding\"},{\"text\":\"Ops\",\"link\":\"/api/ops\"},{\"text\":\"Configuration\",\"link\":\"/api/config\"},{\"text\":\"MLIR Dialects\",\"collapsed\":false,\"items\":[{\"text\":\"ArithOps\",\"link\":\"/api/dialects/arith\"},{\"text\":\"Affine\",\"link\":\"/api/dialects/affine\"},{\"text\":\"Builtin\",\"link\":\"/api/dialects/builtin\"},{\"text\":\"Chlo\",\"link\":\"/api/dialects/chlo\"},{\"text\":\"Enzyme\",\"link\":\"/api/dialects/enzyme\"},{\"text\":\"EnzymeXLA\",\"link\":\"/api/dialects/enzymexla\"},{\"text\":\"Func\",\"link\":\"/api/dialects/func\"},{\"text\":\"GPU\",\"link\":\"/api/dialects/gpu\"},{\"text\":\"LLVM\",\"link\":\"/api/dialects/llvm\"},{\"text\":\"MPI\",\"link\":\"/api/dialects/mpi\"},{\"text\":\"MemRef\",\"link\":\"/api/dialects/memref\"},{\"text\":\"NVVM\",\"link\":\"/api/dialects/nvvm\"},{\"text\":\"Shardy\",\"link\":\"/api/dialects/shardy\"},{\"text\":\"SparseTensor\",\"link\":\"/api/dialects/sparsetensor\"},{\"text\":\"StableHLO\",\"link\":\"/api/dialects/stablehlo\"},{\"text\":\"Triton\",\"link\":\"/api/dialects/triton\"},{\"text\":\"TPU\",\"link\":\"/api/dialects/tpu\"},{\"text\":\"VHLO\",\"link\":\"/api/dialects/vhlo\"}]},{\"text\":\"Low-Level API\",\"collapsed\":false,\"items\":[{\"text\":\"MLIR API\",\"link\":\"/api/mlirc\"},{\"text\":\"XLA\",\"link\":\"/api/xla\"}]},{\"text\":\"Internal API\",\"link\":\"/api/internal\"}]}]},\"editLink\":{\"pattern\":\"https://github.com/EnzymeAD/Reactant.jl/edit/main/docs/src/:path\",\"text\":\"Edit this page on GitHub\"},\"socialLinks\":[{\"icon\":\"slack\",\"link\":\"https://julialang.org/slack/\"}],\"footer\":{\"message\":\"Made with <a href=\\\"https://documenter.juliadocs.org/stable/\\\" target=\\\"_blank\\\"><strong>Documenter.jl</strong></a>, <a href=\\\"https://vitepress.dev\\\" target=\\\"_blank\\\"><strong>VitePress</strong></a> and <a href=\\\"https://luxdl.github.io/DocumenterVitepress.jl/stable\\\" target=\\\"_blank\\\"><strong>DocumenterVitepress.jl</strong></a><br>Released under the MIT License. Powered by the <a href=\\\"https://www.julialang.org\\\">Julia Programming Language</a>.<br>\",\"copyright\":\"© Copyright 2025 Reactant Development Team.\"},\"lastUpdated\":{\"text\":\"Updated at\",\"formatOptions\":{\"dateStyle\":\"full\",\"timeStyle\":\"medium\"}}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>